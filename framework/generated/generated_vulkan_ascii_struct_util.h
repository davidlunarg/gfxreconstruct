/*
** Copyright (c) 2018-2019 Valve Corporation
** Copyright (c) 2018-2019 LunarG, Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#ifndef  GFXRECON_GENERATED_VULKAN_ASCII_STRUCT_UTIL_H
#define  GFXRECON_GENERATED_VULKAN_ASCII_STRUCT_UTIL_H

#include "generated/generated_vulkan_ascii_enum_util.h"
#include "format/platform_types.h"
#include "util/ascii_utils.h"
#include "util/defines.h"
#include "vulkan/vulkan.h"
#include <inttypes.h>
#include <string>

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

void StructureToString(FILE* outputFile, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRectLayerKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPresentRegionKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPresentRegionsKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImagelessFramebufferFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFramebufferAttachmentImageInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFramebufferAttachmentsCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassAttachmentBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageFormatListCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevice8BitStorageFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkConformanceVersionKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDriverPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFloatControlsPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassDescriptionDepthStencilResolveKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthStencilResolvePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceProtectedCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAttachmentReferenceStencilLayoutKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAttachmentDescriptionStencilLayoutKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDedicatedAllocationImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDedicatedAllocationBufferCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkTextureLODGatherFormatPropertiesAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkValidationFlagsEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageViewASTCDecodeModeEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkViewportSwizzleNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSamplerReductionModeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkWriteDescriptorSetInlineUniformBlockEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineCoverageToColorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineCoverageModulationStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceQueueGlobalPriorityCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineCompilerControlCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkVertexInputBindingDivisorDescriptionEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineVertexInputDivisorStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPresentFrameTokenGGP &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkMemoryPriorityAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkImageStencilUsageCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkValidationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);

template <typename T>
void ArrayOfStructsToString(FILE*        outputFile,
                            int          indent,
                            const int    pointer_count,
                            const char*  base_type_name,
                            T*           array,
                            const char*  array_name,
                            const size_t array_length,
                            bool         is_union,
                            uint64_t     base_addr)
{
    assert(outputFile != nullptr);
    if (array_length == 0 || array == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n");
    for (uint64_t j = 0; j < array_length; j++)
    {
        std::string name_and_index;
        char tmp_string[100];
        IndentSpaces(outputFile, indent);
        name_and_index += array_name;
        snprintf(tmp_string, sizeof(tmp_string), "%s[%" PRIu64 "]: ", array_name, j);
        fprintf(outputFile, "%-32s", tmp_string);
        OutputString(outputFile, base_type_name);
        OutputString(outputFile, " = ");
        AddrToString(outputFile, base_addr + j * sizeof(T));
        if (is_union)
        {
            OutputString(outputFile, " (Union)");
        }
        OutputString(outputFile, ":");
        if (pointer_count > 1)
        {
            fprintf(stderr, "ERROR: ArrayOfStructsToString cannot handle arrays of arrays\n");
        }
        else
        {
            StructureToString(outputFile, array[j], indent + 1, base_addr + j * sizeof(T));
        }
        if (j < array_length - 1)
        {
            OutputString(outputFile, "\n");
        }
    }
}

void PnextStructToString(FILE* outputFile, int indent, void *pNext)
{
    assert(outputFile != nullptr);
    switch (static_cast<Decoded_VkApplicationInfo*>(pNext)->decoded_value->sType)
    {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupProperties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevice16BitStorageFeatures*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkMemoryDedicatedRequirements*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkMemoryDedicatedAllocateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkMemoryAllocateFlagsInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupRenderPassBeginInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupCommandBufferBeginInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupSubmitInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupBindSparseInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkBindBufferMemoryDeviceGroupInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkBindImageMemoryDeviceGroupInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupDeviceCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFeatures2*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePointClippingProperties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassInputAttachmentAspectCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImageViewUsageCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassMultiviewCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewFeatures*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewProperties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVariablePointersFeatures*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryFeatures*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryProperties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkProtectedSubmitInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSamplerYcbcrConversionInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkBindImagePlaneMemoryInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImagePlaneMemoryRequirementsInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSamplerYcbcrConversionImageFormatProperties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceExternalImageFormatInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExternalImageFormatProperties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceIDProperties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExternalMemoryBufferCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryAllocateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportFenceCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportSemaphoreCreateInfo*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance3Properties*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImageSwapchainCreateInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkBindImageMemorySwapchainInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupPresentInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupSwapchainCreateInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDisplayPresentInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryFdInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportSemaphoreWin32HandleInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkD3D12FenceSubmitInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPresentRegionsKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceImagelessFramebufferFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkFramebufferAttachmentsCreateInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassAttachmentBeginInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSharedPresentSurfaceCapabilitiesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportFenceWin32HandleInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImageFormatListCreateInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevice8BitStorageFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDriverPropertiesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFloatControlsPropertiesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSubpassDescriptionDepthStencilResolveKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDepthStencilResolvePropertiesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSemaphoreTypeCreateInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkTimelineSemaphoreSubmitInfoKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceProtectedCapabilitiesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkAttachmentReferenceStencilLayoutKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkAttachmentDescriptionStencilLayoutKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDebugReportCallbackCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDedicatedAllocationImageCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDedicatedAllocationBufferCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkTextureLODGatherFormatPropertiesAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryAllocateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkValidationFlagsEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImageViewASTCDecodeModeEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportWScalingStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSwapchainCounterCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPresentTimesInfoGOOGLE*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDebugUtilsMessengerCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkAndroidHardwareBufferUsageANDROID*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImportAndroidHardwareBufferInfoANDROID*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkExternalFormatANDROID*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSamplerReductionModeCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkWriteDescriptorSetInlineUniformBlockEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSampleLocationsInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassSampleLocationsBeginInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCoverageToColorStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCoverageModulationStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDrmFormatModifierPropertiesListEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImageDrmFormatModifierListCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkShaderModuleValidationCacheCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkWriteDescriptorSetAccelerationStructureNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPropertiesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceQueueGlobalPriorityCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryHostPointerInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCompilerControlCreateInfoAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineVertexInputDivisorStateCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPresentFrameTokenGGP*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCreationFeedbackCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkQueueFamilyCheckpointPropertiesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkMemoryPriorityAllocateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkBufferDeviceAddressCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkImageStencilUsageCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkValidationFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCoverageReductionStateCreateInfoNV*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
            StructureToString(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(pNext)) , indent, reinterpret_cast<uint64_t>(pNext));
            break;
        default:
            OutputString(outputFile, "Unknown pNext struct");
            break;
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkApplicationInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pApplicationName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pApplicationName:               "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pApplicationName); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t applicationVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "applicationVersion:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->applicationVersion); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pEngineName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pEngineName:                    "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pEngineName); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t engineVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "engineVersion:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->engineVersion); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t apiVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "apiVersion:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->apiVersion); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkInstanceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkInstanceCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkInstanceCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkApplicationInfo* pApplicationInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pApplicationInfo:               "); //HRW
    OutputString(outputFile, "const VkApplicationInfo* = "); //TEQ
    if (pstruct->pApplicationInfo == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pApplicationInfo->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pApplicationInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkInstanceCreateInfo, pApplicationInfo)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t enabledLayerCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "enabledLayerCount:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->enabledLayerCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* const* ppEnabledLayerNames
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ppEnabledLayerNames:            "); //HRW
    OutputString(outputFile, "const char* const* = "); //TEQ
    if (pstruct->ppEnabledLayerNames == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.ppEnabledLayerNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(outputFile, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pstruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t enabledExtensionCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "enabledExtensionCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->enabledExtensionCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* const* ppEnabledExtensionNames
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ppEnabledExtensionNames:        "); //HRW
    OutputString(outputFile, "const char* const* = "); //TEQ
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.ppEnabledExtensionNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(outputFile, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pstruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAllocationCallbacks *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: void* pUserData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pUserData:                      "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pUserData); // PWR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: PFN_vkAllocationFunction pfnAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pfnAllocation:                  "); //HRW
    OutputString(outputFile, "PFN_vkAllocationFunction = "); //TEQ
    AddrToString(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnAllocation)); // WRX
    OutputString(outputFile, "\n"); // GDS

    // struct member: PFN_vkReallocationFunction pfnReallocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pfnReallocation:                "); //HRW
    OutputString(outputFile, "PFN_vkReallocationFunction = "); //TEQ
    AddrToString(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnReallocation)); // WRX
    OutputString(outputFile, "\n"); // GDS

    // struct member: PFN_vkFreeFunction pfnFree
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pfnFree:                        "); //HRW
    OutputString(outputFile, "PFN_vkFreeFunction = "); //TEQ
    AddrToString(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnFree)); // WRX
    OutputString(outputFile, "\n"); // GDS

    // struct member: PFN_vkInternalAllocationNotification pfnInternalAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pfnInternalAllocation:          "); //HRW
    OutputString(outputFile, "PFN_vkInternalAllocationNotification = "); //TEQ
    AddrToString(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnInternalAllocation)); // WRX
    OutputString(outputFile, "\n"); // GDS

    // struct member: PFN_vkInternalFreeNotification pfnInternalFree
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pfnInternalFree:                "); //HRW
    OutputString(outputFile, "PFN_vkInternalFreeNotification = "); //TEQ
    AddrToString(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnInternalFree)); // WRX
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkBool32 robustBufferAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "robustBufferAccess:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->robustBufferAccess); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fullDrawIndexUint32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fullDrawIndexUint32:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fullDrawIndexUint32); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 imageCubeArray
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageCubeArray:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->imageCubeArray); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 independentBlend
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "independentBlend:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->independentBlend); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 geometryShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "geometryShader:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->geometryShader); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 tessellationShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tessellationShader:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->tessellationShader); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sampleRateShading
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleRateShading:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sampleRateShading); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 dualSrcBlend
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dualSrcBlend:                   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->dualSrcBlend); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 logicOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "logicOp:                        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->logicOp); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 multiDrawIndirect
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "multiDrawIndirect:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->multiDrawIndirect); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 drawIndirectFirstInstance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drawIndirectFirstInstance:      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->drawIndirectFirstInstance); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthClamp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthClamp:                     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthClamp); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthBiasClamp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthBiasClamp:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthBiasClamp); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fillModeNonSolid
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fillModeNonSolid:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fillModeNonSolid); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthBounds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthBounds:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthBounds); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 wideLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "wideLines:                      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->wideLines); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 largePoints
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "largePoints:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->largePoints); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 alphaToOne
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "alphaToOne:                     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->alphaToOne); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 multiViewport
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "multiViewport:                  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->multiViewport); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 samplerAnisotropy
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "samplerAnisotropy:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->samplerAnisotropy); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 textureCompressionETC2
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "textureCompressionETC2:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->textureCompressionETC2); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 textureCompressionASTC_LDR
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "textureCompressionASTC_LDR:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->textureCompressionASTC_LDR); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 textureCompressionBC
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "textureCompressionBC:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->textureCompressionBC); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 occlusionQueryPrecise
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "occlusionQueryPrecise:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->occlusionQueryPrecise); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 pipelineStatisticsQuery
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineStatisticsQuery:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->pipelineStatisticsQuery); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 vertexPipelineStoresAndAtomics
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexPipelineStoresAndAtomics: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vertexPipelineStoresAndAtomics); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentStoresAndAtomics
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentStoresAndAtomics:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentStoresAndAtomics); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderTessellationAndGeometryPointSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderTessellationAndGeometryPointSize: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderTessellationAndGeometryPointSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderImageGatherExtended
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderImageGatherExtended:      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderImageGatherExtended); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageImageExtendedFormats
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageImageExtendedFormats: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageImageExtendedFormats); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageImageMultisample
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageImageMultisample:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageImageMultisample); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageImageReadWithoutFormat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageImageReadWithoutFormat: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageImageReadWithoutFormat); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageImageWriteWithoutFormat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageImageWriteWithoutFormat: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageImageWriteWithoutFormat); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderUniformBufferArrayDynamicIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderUniformBufferArrayDynamicIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderUniformBufferArrayDynamicIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSampledImageArrayDynamicIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSampledImageArrayDynamicIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSampledImageArrayDynamicIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageBufferArrayDynamicIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageBufferArrayDynamicIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageBufferArrayDynamicIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageImageArrayDynamicIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageImageArrayDynamicIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageImageArrayDynamicIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderClipDistance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderClipDistance:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderClipDistance); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderCullDistance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderCullDistance:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderCullDistance); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderFloat64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderFloat64:                  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderFloat64); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderInt64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderInt64:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderInt64); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderInt16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderInt16:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderInt16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderResourceResidency
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderResourceResidency:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderResourceResidency); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderResourceMinLod
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderResourceMinLod:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderResourceMinLod); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseBinding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseBinding:                  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseBinding); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidencyBuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidencyBuffer:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidencyBuffer); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidencyImage2D
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidencyImage2D:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidencyImage2D); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidencyImage3D
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidencyImage3D:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidencyImage3D); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidency2Samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidency2Samples:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidency2Samples); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidency4Samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidency4Samples:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidency4Samples); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidency8Samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidency8Samples:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidency8Samples); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidency16Samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidency16Samples:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidency16Samples); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sparseResidencyAliased
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseResidencyAliased:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseResidencyAliased); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 variableMultisampleRate
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "variableMultisampleRate:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->variableMultisampleRate); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 inheritedQueries
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "inheritedQueries:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->inheritedQueries); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkFormatFeatureFlags linearTilingFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "linearTilingFeatures:           "); //HRW
    OutputString(outputFile, "VkFormatFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->linearTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormatFeatureFlags optimalTilingFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "optimalTilingFeatures:          "); //HRW
    OutputString(outputFile, "VkFormatFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->optimalTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormatFeatureFlags bufferFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferFeatures:                 "); //HRW
    OutputString(outputFile, "VkFormatFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->bufferFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExtent3D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t width
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "width:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->width); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t height
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "height:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->height); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t depth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depth:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->depth); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkExtent3D maxExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxExtent:                      "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxExtent, indent+1,  base_addr + offsetof(VkImageFormatProperties, maxExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMipLevels
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMipLevels:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMipLevels); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxArrayLayers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxArrayLayers:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxArrayLayers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags sampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleCounts:                   "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->sampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize maxResourceSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxResourceSize:                "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->maxResourceSize); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceLimits *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t maxImageDimension1D
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageDimension1D:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageDimension1D); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageDimension2D
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageDimension2D:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageDimension2D); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageDimension3D
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageDimension3D:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageDimension3D); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageDimensionCube
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageDimensionCube:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageDimensionCube); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageArrayLayers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageArrayLayers:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageArrayLayers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTexelBufferElements
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTexelBufferElements:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTexelBufferElements); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxUniformBufferRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxUniformBufferRange:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxUniformBufferRange); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxStorageBufferRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxStorageBufferRange:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxStorageBufferRange); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPushConstantsSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPushConstantsSize:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPushConstantsSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMemoryAllocationCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMemoryAllocationCount:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMemoryAllocationCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSamplerAllocationCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSamplerAllocationCount:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSamplerAllocationCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize bufferImageGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferImageGranularity:         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->bufferImageGranularity); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize sparseAddressSpaceSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseAddressSpaceSize:         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sparseAddressSpaceSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxBoundDescriptorSets
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxBoundDescriptorSets:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxBoundDescriptorSets); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorSamplers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorSamplers:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorSamplers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUniformBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUniformBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUniformBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorStorageBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorStorageBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorStorageBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorSampledImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorSampledImages: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorSampledImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorStorageImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorStorageImages: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorStorageImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorInputAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorInputAttachments: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorInputAttachments); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageResources
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageResources:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageResources); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetSamplers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetSamplers:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetSamplers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUniformBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUniformBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUniformBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUniformBuffersDynamic
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUniformBuffersDynamic: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUniformBuffersDynamic); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetStorageBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetStorageBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetStorageBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetStorageBuffersDynamic
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetStorageBuffersDynamic: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetStorageBuffersDynamic); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetSampledImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetSampledImages:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetSampledImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetStorageImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetStorageImages:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetStorageImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetInputAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetInputAttachments: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetInputAttachments); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVertexInputAttributes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVertexInputAttributes:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVertexInputAttributes); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVertexInputBindings
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVertexInputBindings:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVertexInputBindings); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVertexInputAttributeOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVertexInputAttributeOffset:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVertexInputAttributeOffset); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVertexInputBindingStride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVertexInputBindingStride:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVertexInputBindingStride); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVertexOutputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVertexOutputComponents:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVertexOutputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationGenerationLevel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationGenerationLevel: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationGenerationLevel); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationPatchSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationPatchSize:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationPatchSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationControlPerVertexInputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationControlPerVertexInputComponents: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationControlPerVertexInputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationControlPerVertexOutputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationControlPerVertexOutputComponents: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationControlPerVertexOutputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationControlPerPatchOutputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationControlPerPatchOutputComponents: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationControlPerPatchOutputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationControlTotalOutputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationControlTotalOutputComponents: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationControlTotalOutputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationEvaluationInputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationEvaluationInputComponents: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationEvaluationInputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTessellationEvaluationOutputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTessellationEvaluationOutputComponents: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTessellationEvaluationOutputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxGeometryShaderInvocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxGeometryShaderInvocations:   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxGeometryShaderInvocations); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxGeometryInputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxGeometryInputComponents:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxGeometryInputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxGeometryOutputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxGeometryOutputComponents:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxGeometryOutputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxGeometryOutputVertices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxGeometryOutputVertices:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxGeometryOutputVertices); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxGeometryTotalOutputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxGeometryTotalOutputComponents: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxGeometryTotalOutputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxFragmentInputComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFragmentInputComponents:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxFragmentInputComponents); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxFragmentOutputAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFragmentOutputAttachments:   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxFragmentOutputAttachments); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxFragmentDualSrcAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFragmentDualSrcAttachments:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxFragmentDualSrcAttachments); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxFragmentCombinedOutputResources
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFragmentCombinedOutputResources: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxFragmentCombinedOutputResources); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxComputeSharedMemorySize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxComputeSharedMemorySize:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxComputeSharedMemorySize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxComputeWorkGroupCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxComputeWorkGroupCount:       "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "3"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.maxComputeWorkGroupCount.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_maxComputeWorkGroupCount = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxComputeWorkGroupCount), "maxComputeWorkGroupCount", 3, vinfo_maxComputeWorkGroupCount); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxComputeWorkGroupInvocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxComputeWorkGroupInvocations: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxComputeWorkGroupInvocations); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxComputeWorkGroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxComputeWorkGroupSize:        "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "3"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.maxComputeWorkGroupSize.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_maxComputeWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxComputeWorkGroupSize), "maxComputeWorkGroupSize", 3, vinfo_maxComputeWorkGroupSize); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subPixelPrecisionBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subPixelPrecisionBits:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subPixelPrecisionBits); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subTexelPrecisionBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subTexelPrecisionBits:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subTexelPrecisionBits); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t mipmapPrecisionBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mipmapPrecisionBits:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->mipmapPrecisionBits); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDrawIndexedIndexValue
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDrawIndexedIndexValue:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDrawIndexedIndexValue); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDrawIndirectCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDrawIndirectCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDrawIndirectCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxSamplerLodBias
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSamplerLodBias:              "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxSamplerLodBias); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxSamplerAnisotropy
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSamplerAnisotropy:           "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxSamplerAnisotropy); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxViewports
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxViewports:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxViewports); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxViewportDimensions
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxViewportDimensions:          "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "2"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.maxViewportDimensions.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_maxViewportDimensions = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxViewportDimensions), "maxViewportDimensions", 2, vinfo_maxViewportDimensions); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: float viewportBoundsRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewportBoundsRange:            "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "2"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.viewportBoundsRange.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_viewportBoundsRange = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->viewportBoundsRange), "viewportBoundsRange", 2, vinfo_viewportBoundsRange); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewportSubPixelBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewportSubPixelBits:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewportSubPixelBits); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t minMemoryMapAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minMemoryMapAlignment:          "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minMemoryMapAlignment); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize minTexelBufferOffsetAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minTexelBufferOffsetAlignment:  "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->minTexelBufferOffsetAlignment); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize minUniformBufferOffsetAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minUniformBufferOffsetAlignment: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->minUniformBufferOffsetAlignment); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize minStorageBufferOffsetAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minStorageBufferOffsetAlignment: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->minStorageBufferOffsetAlignment); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t minTexelOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minTexelOffset:                 "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->minTexelOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTexelOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTexelOffset:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTexelOffset); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t minTexelGatherOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minTexelGatherOffset:           "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->minTexelGatherOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTexelGatherOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTexelGatherOffset:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTexelGatherOffset); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: float minInterpolationOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minInterpolationOffset:         "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->minInterpolationOffset); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxInterpolationOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxInterpolationOffset:         "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxInterpolationOffset); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subPixelInterpolationOffsetBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subPixelInterpolationOffsetBits: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subPixelInterpolationOffsetBits); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxFramebufferWidth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFramebufferWidth:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxFramebufferWidth); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxFramebufferHeight
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFramebufferHeight:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxFramebufferHeight); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxFramebufferLayers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFramebufferLayers:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxFramebufferLayers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags framebufferColorSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "framebufferColorSampleCounts:   "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->framebufferColorSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags framebufferDepthSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "framebufferDepthSampleCounts:   "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->framebufferDepthSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags framebufferStencilSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "framebufferStencilSampleCounts: "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->framebufferStencilSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags framebufferNoAttachmentsSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "framebufferNoAttachmentsSampleCounts: "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->framebufferNoAttachmentsSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxColorAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxColorAttachments:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxColorAttachments); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags sampledImageColorSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampledImageColorSampleCounts:  "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->sampledImageColorSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags sampledImageIntegerSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampledImageIntegerSampleCounts: "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->sampledImageIntegerSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags sampledImageDepthSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampledImageDepthSampleCounts:  "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->sampledImageDepthSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags sampledImageStencilSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampledImageStencilSampleCounts: "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->sampledImageStencilSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags storageImageSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storageImageSampleCounts:       "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->storageImageSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSampleMaskWords
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSampleMaskWords:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSampleMaskWords); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 timestampComputeAndGraphics
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "timestampComputeAndGraphics:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->timestampComputeAndGraphics); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: float timestampPeriod
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "timestampPeriod:                "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->timestampPeriod); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxClipDistances
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxClipDistances:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxClipDistances); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxCullDistances
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxCullDistances:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxCullDistances); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxCombinedClipAndCullDistances
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxCombinedClipAndCullDistances: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxCombinedClipAndCullDistances); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t discreteQueuePriorities
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "discreteQueuePriorities:        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->discreteQueuePriorities); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: float pointSizeRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pointSizeRange:                 "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "2"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.pointSizeRange.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_pointSizeRange = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->pointSizeRange), "pointSizeRange", 2, vinfo_pointSizeRange); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: float lineWidthRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "lineWidthRange:                 "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "2"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.lineWidthRange.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_lineWidthRange = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->lineWidthRange), "lineWidthRange", 2, vinfo_lineWidthRange); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: float pointSizeGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pointSizeGranularity:           "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->pointSizeGranularity); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float lineWidthGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "lineWidthGranularity:           "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->lineWidthGranularity); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 strictLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "strictLines:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->strictLines); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 standardSampleLocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "standardSampleLocations:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->standardSampleLocations); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize optimalBufferCopyOffsetAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "optimalBufferCopyOffsetAlignment: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->optimalBufferCopyOffsetAlignment); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize optimalBufferCopyRowPitchAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "optimalBufferCopyRowPitchAlignment: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->optimalBufferCopyRowPitchAlignment); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize nonCoherentAtomSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "nonCoherentAtomSize:            "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->nonCoherentAtomSize); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSparseProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkBool32 residencyStandard2DBlockShape
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "residencyStandard2DBlockShape:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->residencyStandard2DBlockShape); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 residencyStandard2DMultisampleBlockShape
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "residencyStandard2DMultisampleBlockShape: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->residencyStandard2DMultisampleBlockShape); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 residencyStandard3DBlockShape
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "residencyStandard3DBlockShape:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->residencyStandard3DBlockShape); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 residencyAlignedMipSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "residencyAlignedMipSize:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->residencyAlignedMipSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 residencyNonResidentStrict
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "residencyNonResidentStrict:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->residencyNonResidentStrict); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t apiVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "apiVersion:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->apiVersion); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t driverVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "driverVersion:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->driverVersion); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t vendorID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vendorID:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vendorID); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceID:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceID); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPhysicalDeviceType deviceType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceType:                     "); //HRW
    OutputString(outputFile, "VkPhysicalDeviceType = "); //TEQ
    EnumToStringVkPhysicalDeviceType(outputFile, pstruct->deviceType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->deviceType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: char deviceName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceName:                     "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_deviceName = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->deviceName), "deviceName", VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, vinfo_deviceName); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint8_t pipelineCacheUUID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineCacheUUID:              "); //HRW
    OutputString(outputFile, "uint8_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "VK_UUID_SIZE"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.pipelineCacheUUID.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_pipelineCacheUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(outputFile, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->pipelineCacheUUID), "pipelineCacheUUID", VK_UUID_SIZE, vinfo_pipelineCacheUUID); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPhysicalDeviceLimits limits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "limits:                         "); //HRW
    OutputString(outputFile, "VkPhysicalDeviceLimits = "); //TEQ
    StructureToString(outputFile, *pstruct_in.limits, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties, limits)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPhysicalDeviceSparseProperties sparseProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sparseProperties:               "); //HRW
    OutputString(outputFile, "VkPhysicalDeviceSparseProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.sparseProperties, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties, sparseProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueueFamilyProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkQueueFlags queueFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFlags:                     "); //HRW
    OutputString(outputFile, "VkQueueFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->queueFlags, EnumToStringVkQueueFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t timestampValidBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "timestampValidBits:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->timestampValidBits); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent3D minImageTransferGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minImageTransferGranularity:    "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minImageTransferGranularity, indent+1,  base_addr + offsetof(VkQueueFamilyProperties, minImageTransferGranularity)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryType *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkMemoryPropertyFlags propertyFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "propertyFlags:                  "); //HRW
    OutputString(outputFile, "VkMemoryPropertyFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->propertyFlags, EnumToStringVkMemoryPropertyFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t heapIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "heapIndex:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->heapIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryHeap *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMemoryHeapFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkMemoryHeapFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkMemoryHeapFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t memoryTypeCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypeCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMemoryType memoryTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypes:                    "); //HRW
    OutputString(outputFile, "VkMemoryType"); //JUQ
    OutputString(outputFile, "[");
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeCount); // DFW
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.memoryTypes->GetAddress()); // IYY
    ArrayOfStructsToString<Decoded_VkMemoryType>(outputFile, indent+1, 0, "VkMemoryType", pstruct_in.memoryTypes->GetMetaStructPointer(), "memoryTypes", pstruct->memoryTypeCount , false, pstruct_in.memoryTypes->GetAddress()); // EPB
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryHeapCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryHeapCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryHeapCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMemoryHeap memoryHeaps
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryHeaps:                    "); //HRW
    OutputString(outputFile, "VkMemoryHeap"); //JUQ
    OutputString(outputFile, "[");
    UnsignedDecimalToString(outputFile, pstruct->memoryHeapCount); // DFW
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.memoryHeaps->GetAddress()); // IYY
    ArrayOfStructsToString<Decoded_VkMemoryHeap>(outputFile, indent+1, 0, "VkMemoryHeap", pstruct_in.memoryHeaps->GetMetaStructPointer(), "memoryHeaps", pstruct->memoryHeapCount , false, pstruct_in.memoryHeaps->GetAddress()); // EPB
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceQueueCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceQueueCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDeviceQueueCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkDeviceQueueCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueFamilyIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyIndex:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueFamilyIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const float* pQueuePriorities
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pQueuePriorities:               "); //HRW
    OutputString(outputFile, "const float* = "); //TEQ
    if (pstruct->pQueuePriorities == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pQueuePriorities.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueuePriorities = {false, false, false, nullptr};
        ArrayToString<const float*>(outputFile, indent, 1, "const float*", reinterpret_cast<const float*>(pstruct_in.pQueuePriorities.GetPointer()), "pQueuePriorities", pstruct->queueCount,  vinfo_pQueuePriorities);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDeviceCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueCreateInfoCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueCreateInfoCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueCreateInfoCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDeviceQueueCreateInfo* pQueueCreateInfos
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pQueueCreateInfos:              "); //HRW
    OutputString(outputFile, "const VkDeviceQueueCreateInfo* = "); //TEQ
    if (pstruct->pQueueCreateInfos == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pQueueCreateInfos->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDeviceQueueCreateInfo>(outputFile, indent+1, 1, "VkDeviceQueueCreateInfo", pstruct_in.pQueueCreateInfos->GetMetaStructPointer(), "pQueueCreateInfos", pstruct->queueCreateInfoCount, false, pstruct_in.pQueueCreateInfos->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t enabledLayerCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "enabledLayerCount:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->enabledLayerCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* const* ppEnabledLayerNames
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ppEnabledLayerNames:            "); //HRW
    OutputString(outputFile, "const char* const* = "); //TEQ
    if (pstruct->ppEnabledLayerNames == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.ppEnabledLayerNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(outputFile, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pstruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t enabledExtensionCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "enabledExtensionCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->enabledExtensionCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* const* ppEnabledExtensionNames
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ppEnabledExtensionNames:        "); //HRW
    OutputString(outputFile, "const char* const* = "); //TEQ
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.ppEnabledExtensionNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(outputFile, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pstruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPhysicalDeviceFeatures* pEnabledFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pEnabledFeatures:               "); //HRW
    OutputString(outputFile, "const VkPhysicalDeviceFeatures* = "); //TEQ
    if (pstruct->pEnabledFeatures == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pEnabledFeatures->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pEnabledFeatures->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkDeviceCreateInfo, pEnabledFeatures)); // GLN
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExtensionProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: char extensionName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extensionName:                  "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_extensionName = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->extensionName), "extensionName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_extensionName); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t specVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "specVersion:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->specVersion); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkLayerProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: char layerName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layerName:                      "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_layerName = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->layerName), "layerName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_layerName); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t specVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "specVersion:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->specVersion); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t implementationVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "implementationVersion:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->implementationVersion); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: char description
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "description:                    "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
}

void StructureToString(FILE* outputFile, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubmitInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "waitSemaphoreCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSemaphore* pWaitSemaphores
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pWaitSemaphores:                "); //HRW
    OutputString(outputFile, "const VkSemaphore* = "); //TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(outputFile, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineStageFlags* pWaitDstStageMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pWaitDstStageMask:              "); //HRW
    OutputString(outputFile, "const VkPipelineStageFlags* = "); //TEQ
    if (pstruct->pWaitDstStageMask == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pWaitDstStageMask.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitDstStageMask = {false, false, true, EnumToStringVkPipelineStageFlagBits};
        ArrayToString<const VkPipelineStageFlags*>(outputFile, indent, 1, "const VkPipelineStageFlags*", reinterpret_cast<const VkPipelineStageFlags*>(pstruct_in.pWaitDstStageMask.GetPointer()), "pWaitDstStageMask", pstruct->waitSemaphoreCount,  vinfo_pWaitDstStageMask);  // CCR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t commandBufferCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "commandBufferCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->commandBufferCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkCommandBuffer* pCommandBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCommandBuffers:                "); //HRW
    OutputString(outputFile, "const VkCommandBuffer* = "); //TEQ
    if (pstruct->pCommandBuffers == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCommandBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<const VkCommandBuffer*>(outputFile, indent, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pstruct_in.pCommandBuffers.GetPointer()), "pCommandBuffers", pstruct->commandBufferCount,  vinfo_pCommandBuffers);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t signalSemaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "signalSemaphoreCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->signalSemaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSemaphore* pSignalSemaphores
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSignalSemaphores:              "); //HRW
    OutputString(outputFile, "const VkSemaphore* = "); //TEQ
    if (pstruct->pSignalSemaphores == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSignalSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(outputFile, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize allocationSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "allocationSize:                 "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->allocationSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryTypeIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypeIndex:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMappedMemoryRange *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryRequirements *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize alignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "alignment:                      "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->alignment); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypeBits:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeBits); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectMask:                     "); //HRW
    OutputString(outputFile, "VkImageAspectFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent3D imageGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageGranularity:               "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageGranularity, indent+1,  base_addr + offsetof(VkSparseImageFormatProperties, imageGranularity)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSparseImageFormatFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSparseImageFormatFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSparseImageFormatFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryRequirements *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkSparseImageFormatProperties formatProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "formatProperties:               "); //HRW
    OutputString(outputFile, "VkSparseImageFormatProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.formatProperties, indent+1,  base_addr + offsetof(VkSparseImageMemoryRequirements, formatProperties)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t imageMipTailFirstLod
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageMipTailFirstLod:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->imageMipTailFirstLod); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize imageMipTailSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageMipTailSize:               "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->imageMipTailSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize imageMipTailOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageMipTailOffset:             "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->imageMipTailOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize imageMipTailStride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageMipTailStride:             "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->imageMipTailStride); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseMemoryBind *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDeviceSize resourceOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "resourceOffset:                 "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->resourceOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryOffset:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->memoryOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSparseMemoryBindFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSparseMemoryBindFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSparseMemoryBindFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseBufferMemoryBindInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bindCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bindCount:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bindCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSparseMemoryBind* pBinds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pBinds:                         "); //HRW
    OutputString(outputFile, "const VkSparseMemoryBind* = "); //TEQ
    if (pstruct->pBinds == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseMemoryBind>(outputFile, indent+1, 1, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageOpaqueMemoryBindInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bindCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bindCount:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bindCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSparseMemoryBind* pBinds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pBinds:                         "); //HRW
    OutputString(outputFile, "const VkSparseMemoryBind* = "); //TEQ
    if (pstruct->pBinds == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseMemoryBind>(outputFile, indent+1, 1, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSubresource *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectMask:                     "); //HRW
    OutputString(outputFile, "VkImageAspectFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t mipLevel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mipLevel:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->mipLevel); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t arrayLayer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "arrayLayer:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->arrayLayer); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkOffset3D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: int32_t x
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "x:                              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->x); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t y
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "y:                              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->y); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t z
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "z:                              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->z); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryBind *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageSubresource subresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subresource:                    "); //HRW
    OutputString(outputFile, "VkImageSubresource = "); //TEQ
    StructureToString(outputFile, *pstruct_in.subresource, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, subresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkOffset3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.offset, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, offset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extent:                         "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, extent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryOffset:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->memoryOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSparseMemoryBindFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSparseMemoryBindFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSparseMemoryBindFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryBindInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bindCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bindCount:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bindCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSparseImageMemoryBind* pBinds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pBinds:                         "); //HRW
    OutputString(outputFile, "const VkSparseImageMemoryBind* = "); //TEQ
    if (pstruct->pBinds == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryBind>(outputFile, indent+1, 1, "VkSparseImageMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindSparseInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "waitSemaphoreCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSemaphore* pWaitSemaphores
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pWaitSemaphores:                "); //HRW
    OutputString(outputFile, "const VkSemaphore* = "); //TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(outputFile, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bufferBindCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferBindCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bufferBindCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSparseBufferMemoryBindInfo* pBufferBinds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pBufferBinds:                   "); //HRW
    OutputString(outputFile, "const VkSparseBufferMemoryBindInfo* = "); //TEQ
    if (pstruct->pBufferBinds == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pBufferBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseBufferMemoryBindInfo>(outputFile, indent+1, 1, "VkSparseBufferMemoryBindInfo", pstruct_in.pBufferBinds->GetMetaStructPointer(), "pBufferBinds", pstruct->bufferBindCount, false, pstruct_in.pBufferBinds->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t imageOpaqueBindCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageOpaqueBindCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->imageOpaqueBindCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pImageOpaqueBinds:              "); //HRW
    OutputString(outputFile, "const VkSparseImageOpaqueMemoryBindInfo* = "); //TEQ
    if (pstruct->pImageOpaqueBinds == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pImageOpaqueBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(outputFile, indent+1, 1, "VkSparseImageOpaqueMemoryBindInfo", pstruct_in.pImageOpaqueBinds->GetMetaStructPointer(), "pImageOpaqueBinds", pstruct->imageOpaqueBindCount, false, pstruct_in.pImageOpaqueBinds->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t imageBindCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageBindCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->imageBindCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSparseImageMemoryBindInfo* pImageBinds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pImageBinds:                    "); //HRW
    OutputString(outputFile, "const VkSparseImageMemoryBindInfo* = "); //TEQ
    if (pstruct->pImageBinds == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pImageBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryBindInfo>(outputFile, indent+1, 1, "VkSparseImageMemoryBindInfo", pstruct_in.pImageBinds->GetMetaStructPointer(), "pImageBinds", pstruct->imageBindCount, false, pstruct_in.pImageBinds->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t signalSemaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "signalSemaphoreCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->signalSemaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSemaphore* pSignalSemaphores
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSignalSemaphores:              "); //HRW
    OutputString(outputFile, "const VkSemaphore* = "); //TEQ
    if (pstruct->pSignalSemaphores == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSignalSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(outputFile, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFenceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFenceCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkFenceCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkFenceCreateFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphoreCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSemaphoreCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkEventCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkEventCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkEventCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueryPoolCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueryPoolCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkQueryPoolCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueryType queryType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queryType:                      "); //HRW
    OutputString(outputFile, "VkQueryType = "); //TEQ
    EnumToStringVkQueryType(outputFile, pstruct->queryType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->queryType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queryCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queryCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queryCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueryPipelineStatisticFlags pipelineStatistics
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineStatistics:             "); //HRW
    OutputString(outputFile, "VkQueryPipelineStatisticFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->pipelineStatistics, EnumToStringVkQueryPipelineStatisticFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBufferCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkBufferCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkBufferCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBufferUsageFlags usage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "usage:                          "); //HRW
    OutputString(outputFile, "VkBufferUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->usage, EnumToStringVkBufferUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSharingMode sharingMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sharingMode:                    "); //HRW
    OutputString(outputFile, "VkSharingMode = "); //TEQ
    EnumToStringVkSharingMode(outputFile, pstruct->sharingMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sharingMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyIndexCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pQueueFamilyIndices:            "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferViewCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBufferViewCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkBufferViewCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize range
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "range:                          "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->range); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkImageCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkImageCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageType imageType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageType:                      "); //HRW
    OutputString(outputFile, "VkImageType = "); //TEQ
    EnumToStringVkImageType(outputFile, pstruct->imageType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->imageType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extent:                         "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageCreateInfo, extent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t mipLevels
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mipLevels:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->mipLevels); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t arrayLayers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "arrayLayers:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->arrayLayers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "samples:                        "); //HRW
    OutputString(outputFile, "VkSampleCountFlagBits = "); //TEQ
    EnumToStringVkSampleCountFlagBits(outputFile, pstruct->samples); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->samples);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageTiling tiling
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tiling:                         "); //HRW
    OutputString(outputFile, "VkImageTiling = "); //TEQ
    EnumToStringVkImageTiling(outputFile, pstruct->tiling); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->tiling);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "usage:                          "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSharingMode sharingMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sharingMode:                    "); //HRW
    OutputString(outputFile, "VkSharingMode = "); //TEQ
    EnumToStringVkSharingMode(outputFile, pstruct->sharingMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sharingMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyIndexCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pQueueFamilyIndices:            "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout initialLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "initialLayout:                  "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->initialLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->initialLayout);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubresourceLayout *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize rowPitch
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rowPitch:                       "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->rowPitch); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize arrayPitch
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "arrayPitch:                     "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->arrayPitch); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize depthPitch
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthPitch:                     "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthPitch); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr)
{
    const VkComponentMapping *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkComponentSwizzle r
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "r:                              "); //HRW
    OutputString(outputFile, "VkComponentSwizzle = "); //TEQ
    EnumToStringVkComponentSwizzle(outputFile, pstruct->r); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->r);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentSwizzle g
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "g:                              "); //HRW
    OutputString(outputFile, "VkComponentSwizzle = "); //TEQ
    EnumToStringVkComponentSwizzle(outputFile, pstruct->g); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->g);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentSwizzle b
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "b:                              "); //HRW
    OutputString(outputFile, "VkComponentSwizzle = "); //TEQ
    EnumToStringVkComponentSwizzle(outputFile, pstruct->b); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->b);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentSwizzle a
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "a:                              "); //HRW
    OutputString(outputFile, "VkComponentSwizzle = "); //TEQ
    EnumToStringVkComponentSwizzle(outputFile, pstruct->a); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->a);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSubresourceRange *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectMask:                     "); //HRW
    OutputString(outputFile, "VkImageAspectFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t baseMipLevel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "baseMipLevel:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->baseMipLevel); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t levelCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "levelCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->levelCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t baseArrayLayer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "baseArrayLayer:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->baseArrayLayer); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t layerCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layerCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->layerCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageViewCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkImageViewCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkImageViewCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageViewType viewType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewType:                       "); //HRW
    OutputString(outputFile, "VkImageViewType = "); //TEQ
    EnumToStringVkImageViewType(outputFile, pstruct->viewType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->viewType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentMapping components
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "components:                     "); //HRW
    OutputString(outputFile, "VkComponentMapping = "); //TEQ
    StructureToString(outputFile, *pstruct_in.components, indent+1,  base_addr + offsetof(VkImageViewCreateInfo, components)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageSubresourceRange subresourceRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subresourceRange:               "); //HRW
    OutputString(outputFile, "VkImageSubresourceRange = "); //TEQ
    StructureToString(outputFile, *pstruct_in.subresourceRange, indent+1,  base_addr + offsetof(VkImageViewCreateInfo, subresourceRange)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderModuleCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderModuleCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkShaderModuleCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkShaderModuleCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t codeSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "codeSize:                       "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->codeSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pCode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCode:                          "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pCode == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCode.GetAddress()); // WUX
        if (kPrintShaderCode)
        {
            ScalarValueToStringStruct vinfo_pCode = {false, false, false, nullptr};
            ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCode.GetPointer()), "pCode", pstruct->codeSize / 4, vinfo_pCode);  // CCY
        }
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCacheCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCacheCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCacheCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t initialDataSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "initialDataSize:                "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->initialDataSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pInitialData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pInitialData:                   "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pInitialData == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pInitialData.GetAddress()); // AHW
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSpecializationMapEntry *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t constantID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "constantID:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->constantID); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->offset); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->size); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSpecializationInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t mapEntryCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mapEntryCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->mapEntryCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSpecializationMapEntry* pMapEntries
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pMapEntries:                    "); //HRW
    OutputString(outputFile, "const VkSpecializationMapEntry* = "); //TEQ
    if (pstruct->pMapEntries == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pMapEntries->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSpecializationMapEntry>(outputFile, indent+1, 1, "VkSpecializationMapEntry", pstruct_in.pMapEntries->GetMetaStructPointer(), "pMapEntries", pstruct->mapEntryCount, false, pstruct_in.pMapEntries->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t dataSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dataSize:                       "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dataSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pData:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pData == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pData.GetAddress()); // AHW
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineShaderStageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineShaderStageCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineShaderStageCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkPipelineShaderStageCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderStageFlagBits stage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stage:                          "); //HRW
    OutputString(outputFile, "VkShaderStageFlagBits = "); //TEQ
    EnumToStringVkShaderStageFlagBits(outputFile, pstruct->stage); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stage);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderModule module
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "module:                         "); //HRW
    OutputString(outputFile, "VkShaderModule = "); //TEQ
    AddrToString(outputFile, pstruct_in.module); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pName:                          "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pName); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSpecializationInfo* pSpecializationInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSpecializationInfo:            "); //HRW
    OutputString(outputFile, "const VkSpecializationInfo* = "); //TEQ
    if (pstruct->pSpecializationInfo == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSpecializationInfo->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pSpecializationInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkPipelineShaderStageCreateInfo, pSpecializationInfo)); // GLN
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkVertexInputBindingDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t binding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "binding:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->binding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t stride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stride:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->stride); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkVertexInputRate inputRate
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "inputRate:                      "); //HRW
    OutputString(outputFile, "VkVertexInputRate = "); //TEQ
    EnumToStringVkVertexInputRate(outputFile, pstruct->inputRate); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->inputRate);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkVertexInputAttributeDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t location
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "location:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->location); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t binding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "binding:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->binding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->offset); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineVertexInputStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineVertexInputStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineVertexInputStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t vertexBindingDescriptionCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexBindingDescriptionCount:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vertexBindingDescriptionCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkVertexInputBindingDescription* pVertexBindingDescriptions
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pVertexBindingDescriptions:     "); //HRW
    OutputString(outputFile, "const VkVertexInputBindingDescription* = "); //TEQ
    if (pstruct->pVertexBindingDescriptions == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pVertexBindingDescriptions->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkVertexInputBindingDescription>(outputFile, indent+1, 1, "VkVertexInputBindingDescription", pstruct_in.pVertexBindingDescriptions->GetMetaStructPointer(), "pVertexBindingDescriptions", pstruct->vertexBindingDescriptionCount, false, pstruct_in.pVertexBindingDescriptions->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t vertexAttributeDescriptionCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexAttributeDescriptionCount: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vertexAttributeDescriptionCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkVertexInputAttributeDescription* pVertexAttributeDescriptions
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pVertexAttributeDescriptions:   "); //HRW
    OutputString(outputFile, "const VkVertexInputAttributeDescription* = "); //TEQ
    if (pstruct->pVertexAttributeDescriptions == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pVertexAttributeDescriptions->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkVertexInputAttributeDescription>(outputFile, indent+1, 1, "VkVertexInputAttributeDescription", pstruct_in.pVertexAttributeDescriptions->GetMetaStructPointer(), "pVertexAttributeDescriptions", pstruct->vertexAttributeDescriptionCount, false, pstruct_in.pVertexAttributeDescriptions->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineInputAssemblyStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineInputAssemblyStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineInputAssemblyStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPrimitiveTopology topology
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "topology:                       "); //HRW
    OutputString(outputFile, "VkPrimitiveTopology = "); //TEQ
    EnumToStringVkPrimitiveTopology(outputFile, pstruct->topology); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->topology);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 primitiveRestartEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "primitiveRestartEnable:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->primitiveRestartEnable); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineTessellationStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineTessellationStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineTessellationStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t patchControlPoints
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "patchControlPoints:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->patchControlPoints); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViewport *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: float x
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "x:                              "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->x); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float y
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "y:                              "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->y); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float width
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "width:                          "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->width); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float height
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "height:                         "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->height); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float minDepth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minDepth:                       "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->minDepth); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxDepth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDepth:                       "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxDepth); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkOffset2D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: int32_t x
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "x:                              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->x); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t y
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "y:                              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->y); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExtent2D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t width
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "width:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->width); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t height
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "height:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->height); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRect2D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkOffset2D offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkOffset2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.offset, indent+1,  base_addr + offsetof(VkRect2D, offset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D extent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extent:                         "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkRect2D, extent)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineViewportStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineViewportStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewportCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewportCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewportCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkViewport* pViewports
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewports:                     "); //HRW
    OutputString(outputFile, "const VkViewport* = "); //TEQ
    if (pstruct->pViewports == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewports->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkViewport>(outputFile, indent+1, 1, "VkViewport", pstruct_in.pViewports->GetMetaStructPointer(), "pViewports", pstruct->viewportCount, false, pstruct_in.pViewports->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t scissorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "scissorCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->scissorCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkRect2D* pScissors
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pScissors:                      "); //HRW
    OutputString(outputFile, "const VkRect2D* = "); //TEQ
    if (pstruct->pScissors == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pScissors->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(outputFile, indent+1, 1, "VkRect2D", pstruct_in.pScissors->GetMetaStructPointer(), "pScissors", pstruct->scissorCount, false, pstruct_in.pScissors->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineRasterizationStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineRasterizationStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthClampEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthClampEnable:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthClampEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 rasterizerDiscardEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rasterizerDiscardEnable:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->rasterizerDiscardEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPolygonMode polygonMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "polygonMode:                    "); //HRW
    OutputString(outputFile, "VkPolygonMode = "); //TEQ
    EnumToStringVkPolygonMode(outputFile, pstruct->polygonMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->polygonMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCullModeFlags cullMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "cullMode:                       "); //HRW
    OutputString(outputFile, "VkCullModeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->cullMode, EnumToStringVkCullModeFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFrontFace frontFace
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "frontFace:                      "); //HRW
    OutputString(outputFile, "VkFrontFace = "); //TEQ
    EnumToStringVkFrontFace(outputFile, pstruct->frontFace); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->frontFace);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthBiasEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthBiasEnable:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthBiasEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: float depthBiasConstantFactor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthBiasConstantFactor:        "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->depthBiasConstantFactor); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float depthBiasClamp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthBiasClamp:                 "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->depthBiasClamp); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float depthBiasSlopeFactor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthBiasSlopeFactor:           "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->depthBiasSlopeFactor); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float lineWidth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "lineWidth:                      "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->lineWidth); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineMultisampleStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineMultisampleStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineMultisampleStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlagBits rasterizationSamples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rasterizationSamples:           "); //HRW
    OutputString(outputFile, "VkSampleCountFlagBits = "); //TEQ
    EnumToStringVkSampleCountFlagBits(outputFile, pstruct->rasterizationSamples); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->rasterizationSamples);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sampleShadingEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleShadingEnable:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sampleShadingEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: float minSampleShading
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minSampleShading:               "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->minSampleShading); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSampleMask* pSampleMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSampleMask:                    "); //HRW
    OutputString(outputFile, "const VkSampleMask* = "); //TEQ
    if (pstruct->pSampleMask == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSampleMask.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSampleMask = {false, false, false, nullptr};
        ArrayToString<const VkSampleMask*>(outputFile, indent, 1, "const VkSampleMask*", reinterpret_cast<const VkSampleMask*>(pstruct_in.pSampleMask.GetPointer()), "pSampleMask", pstruct->rasterizationSamples,  vinfo_pSampleMask);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 alphaToCoverageEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "alphaToCoverageEnable:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->alphaToCoverageEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 alphaToOneEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "alphaToOneEnable:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->alphaToOneEnable); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr)
{
    const VkStencilOpState *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStencilOp failOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "failOp:                         "); //HRW
    OutputString(outputFile, "VkStencilOp = "); //TEQ
    EnumToStringVkStencilOp(outputFile, pstruct->failOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->failOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkStencilOp passOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "passOp:                         "); //HRW
    OutputString(outputFile, "VkStencilOp = "); //TEQ
    EnumToStringVkStencilOp(outputFile, pstruct->passOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->passOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkStencilOp depthFailOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthFailOp:                    "); //HRW
    OutputString(outputFile, "VkStencilOp = "); //TEQ
    EnumToStringVkStencilOp(outputFile, pstruct->depthFailOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->depthFailOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCompareOp compareOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compareOp:                      "); //HRW
    OutputString(outputFile, "VkCompareOp = "); //TEQ
    EnumToStringVkCompareOp(outputFile, pstruct->compareOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->compareOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t compareMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compareMask:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->compareMask); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t writeMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "writeMask:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->writeMask); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t reference
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "reference:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->reference); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineDepthStencilStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineDepthStencilStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineDepthStencilStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthTestEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthTestEnable:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthTestEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthWriteEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthWriteEnable:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthWriteEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCompareOp depthCompareOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthCompareOp:                 "); //HRW
    OutputString(outputFile, "VkCompareOp = "); //TEQ
    EnumToStringVkCompareOp(outputFile, pstruct->depthCompareOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->depthCompareOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthBoundsTestEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthBoundsTestEnable:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthBoundsTestEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 stencilTestEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilTestEnable:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->stencilTestEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkStencilOpState front
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "front:                          "); //HRW
    OutputString(outputFile, "VkStencilOpState = "); //TEQ
    StructureToString(outputFile, *pstruct_in.front, indent+1,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, front)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkStencilOpState back
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "back:                           "); //HRW
    OutputString(outputFile, "VkStencilOpState = "); //TEQ
    StructureToString(outputFile, *pstruct_in.back, indent+1,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, back)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float minDepthBounds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minDepthBounds:                 "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->minDepthBounds); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxDepthBounds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDepthBounds:                 "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxDepthBounds); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineColorBlendAttachmentState *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkBool32 blendEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "blendEnable:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->blendEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBlendFactor srcColorBlendFactor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcColorBlendFactor:            "); //HRW
    OutputString(outputFile, "VkBlendFactor = "); //TEQ
    EnumToStringVkBlendFactor(outputFile, pstruct->srcColorBlendFactor); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->srcColorBlendFactor);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBlendFactor dstColorBlendFactor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstColorBlendFactor:            "); //HRW
    OutputString(outputFile, "VkBlendFactor = "); //TEQ
    EnumToStringVkBlendFactor(outputFile, pstruct->dstColorBlendFactor); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->dstColorBlendFactor);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBlendOp colorBlendOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "colorBlendOp:                   "); //HRW
    OutputString(outputFile, "VkBlendOp = "); //TEQ
    EnumToStringVkBlendOp(outputFile, pstruct->colorBlendOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->colorBlendOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBlendFactor srcAlphaBlendFactor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcAlphaBlendFactor:            "); //HRW
    OutputString(outputFile, "VkBlendFactor = "); //TEQ
    EnumToStringVkBlendFactor(outputFile, pstruct->srcAlphaBlendFactor); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->srcAlphaBlendFactor);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBlendFactor dstAlphaBlendFactor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstAlphaBlendFactor:            "); //HRW
    OutputString(outputFile, "VkBlendFactor = "); //TEQ
    EnumToStringVkBlendFactor(outputFile, pstruct->dstAlphaBlendFactor); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->dstAlphaBlendFactor);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBlendOp alphaBlendOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "alphaBlendOp:                   "); //HRW
    OutputString(outputFile, "VkBlendOp = "); //TEQ
    EnumToStringVkBlendOp(outputFile, pstruct->alphaBlendOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->alphaBlendOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkColorComponentFlags colorWriteMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "colorWriteMask:                 "); //HRW
    OutputString(outputFile, "VkColorComponentFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->colorWriteMask, EnumToStringVkColorComponentFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineColorBlendStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineColorBlendStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineColorBlendStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 logicOpEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "logicOpEnable:                  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->logicOpEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkLogicOp logicOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "logicOp:                        "); //HRW
    OutputString(outputFile, "VkLogicOp = "); //TEQ
    EnumToStringVkLogicOp(outputFile, pstruct->logicOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->logicOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineColorBlendAttachmentState* pAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttachments:                   "); //HRW
    OutputString(outputFile, "const VkPipelineColorBlendAttachmentState* = "); //TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPipelineColorBlendAttachmentState>(outputFile, indent+1, 1, "VkPipelineColorBlendAttachmentState", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: float blendConstants
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "blendConstants:                 "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "4"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.blendConstants.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_blendConstants = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->blendConstants), "blendConstants", 4, vinfo_blendConstants); // JPA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineDynamicStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineDynamicStateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineDynamicStateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dynamicStateCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dynamicStateCount:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dynamicStateCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDynamicState* pDynamicStates
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDynamicStates:                 "); //HRW
    OutputString(outputFile, "const VkDynamicState* = "); //TEQ
    if (pstruct->pDynamicStates == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDynamicStates.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDynamicStates = {false, true, false, EnumToStringVkDynamicState};
        ArrayToString<const VkDynamicState*>(outputFile, indent, 1, "const VkDynamicState*", reinterpret_cast<const VkDynamicState*>(pstruct_in.pDynamicStates.GetPointer()), "pDynamicStates", pstruct->dynamicStateCount,  vinfo_pDynamicStates);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGraphicsPipelineCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t stageCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stageCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->stageCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineShaderStageCreateInfo* pStages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pStages:                        "); //HRW
    OutputString(outputFile, "const VkPipelineShaderStageCreateInfo* = "); //TEQ
    if (pstruct->pStages == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pStages->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(outputFile, indent+1, 1, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineVertexInputStateCreateInfo* pVertexInputState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pVertexInputState:              "); //HRW
    OutputString(outputFile, "const VkPipelineVertexInputStateCreateInfo* = "); //TEQ
    if (pstruct->pVertexInputState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pVertexInputState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pVertexInputState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pVertexInputState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pInputAssemblyState:            "); //HRW
    OutputString(outputFile, "const VkPipelineInputAssemblyStateCreateInfo* = "); //TEQ
    if (pstruct->pInputAssemblyState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pInputAssemblyState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pInputAssemblyState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pInputAssemblyState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineTessellationStateCreateInfo* pTessellationState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pTessellationState:             "); //HRW
    OutputString(outputFile, "const VkPipelineTessellationStateCreateInfo* = "); //TEQ
    if (pstruct->pTessellationState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pTessellationState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pTessellationState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pTessellationState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineViewportStateCreateInfo* pViewportState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewportState:                 "); //HRW
    OutputString(outputFile, "const VkPipelineViewportStateCreateInfo* = "); //TEQ
    if (pstruct->pViewportState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewportState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pViewportState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pViewportState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineRasterizationStateCreateInfo* pRasterizationState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pRasterizationState:            "); //HRW
    OutputString(outputFile, "const VkPipelineRasterizationStateCreateInfo* = "); //TEQ
    if (pstruct->pRasterizationState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pRasterizationState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pRasterizationState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pRasterizationState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineMultisampleStateCreateInfo* pMultisampleState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pMultisampleState:              "); //HRW
    OutputString(outputFile, "const VkPipelineMultisampleStateCreateInfo* = "); //TEQ
    if (pstruct->pMultisampleState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pMultisampleState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pMultisampleState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pMultisampleState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineDepthStencilStateCreateInfo* pDepthStencilState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDepthStencilState:             "); //HRW
    OutputString(outputFile, "const VkPipelineDepthStencilStateCreateInfo* = "); //TEQ
    if (pstruct->pDepthStencilState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDepthStencilState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pDepthStencilState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDepthStencilState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineColorBlendStateCreateInfo* pColorBlendState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pColorBlendState:               "); //HRW
    OutputString(outputFile, "const VkPipelineColorBlendStateCreateInfo* = "); //TEQ
    if (pstruct->pColorBlendState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pColorBlendState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pColorBlendState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pColorBlendState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineDynamicStateCreateInfo* pDynamicState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDynamicState:                  "); //HRW
    OutputString(outputFile, "const VkPipelineDynamicStateCreateInfo* = "); //TEQ
    if (pstruct->pDynamicState == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDynamicState->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pDynamicState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDynamicState)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineLayout layout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layout:                         "); //HRW
    OutputString(outputFile, "VkPipelineLayout = "); //TEQ
    AddrToString(outputFile, pstruct_in.layout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "renderPass:                     "); //HRW
    OutputString(outputFile, "VkRenderPass = "); //TEQ
    AddrToString(outputFile, pstruct_in.renderPass); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subpass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subpass:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subpass); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipeline basePipelineHandle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "basePipelineHandle:             "); //HRW
    OutputString(outputFile, "VkPipeline = "); //TEQ
    AddrToString(outputFile, pstruct_in.basePipelineHandle); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t basePipelineIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "basePipelineIndex:              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->basePipelineIndex); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkComputePipelineCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineShaderStageCreateInfo stage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stage:                          "); //HRW
    OutputString(outputFile, "VkPipelineShaderStageCreateInfo = "); //TEQ
    StructureToString(outputFile, *pstruct_in.stage, indent+1,  base_addr + offsetof(VkComputePipelineCreateInfo, stage)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineLayout layout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layout:                         "); //HRW
    OutputString(outputFile, "VkPipelineLayout = "); //TEQ
    AddrToString(outputFile, pstruct_in.layout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipeline basePipelineHandle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "basePipelineHandle:             "); //HRW
    OutputString(outputFile, "VkPipeline = "); //TEQ
    AddrToString(outputFile, pstruct_in.basePipelineHandle); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t basePipelineIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "basePipelineIndex:              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->basePipelineIndex); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPushConstantRange *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkShaderStageFlags stageFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stageFlags:                     "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->offset); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->size); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineLayoutCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineLayoutCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineLayoutCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t setLayoutCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "setLayoutCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->setLayoutCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorSetLayout* pSetLayouts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSetLayouts:                    "); //HRW
    OutputString(outputFile, "const VkDescriptorSetLayout* = "); //TEQ
    if (pstruct->pSetLayouts == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSetLayouts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSetLayout*>(outputFile, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pstruct_in.pSetLayouts.GetPointer()), "pSetLayouts", pstruct->setLayoutCount,  vinfo_pSetLayouts);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t pushConstantRangeCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pushConstantRangeCount:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pushConstantRangeCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPushConstantRange* pPushConstantRanges
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPushConstantRanges:            "); //HRW
    OutputString(outputFile, "const VkPushConstantRange* = "); //TEQ
    if (pstruct->pPushConstantRanges == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPushConstantRanges->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPushConstantRange>(outputFile, indent+1, 1, "VkPushConstantRange", pstruct_in.pPushConstantRanges->GetMetaStructPointer(), "pPushConstantRanges", pstruct->pushConstantRangeCount, false, pstruct_in.pPushConstantRanges->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSamplerCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSamplerCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFilter magFilter
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "magFilter:                      "); //HRW
    OutputString(outputFile, "VkFilter = "); //TEQ
    EnumToStringVkFilter(outputFile, pstruct->magFilter); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->magFilter);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFilter minFilter
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minFilter:                      "); //HRW
    OutputString(outputFile, "VkFilter = "); //TEQ
    EnumToStringVkFilter(outputFile, pstruct->minFilter); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->minFilter);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerMipmapMode mipmapMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mipmapMode:                     "); //HRW
    OutputString(outputFile, "VkSamplerMipmapMode = "); //TEQ
    EnumToStringVkSamplerMipmapMode(outputFile, pstruct->mipmapMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->mipmapMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerAddressMode addressModeU
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "addressModeU:                   "); //HRW
    OutputString(outputFile, "VkSamplerAddressMode = "); //TEQ
    EnumToStringVkSamplerAddressMode(outputFile, pstruct->addressModeU); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->addressModeU);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerAddressMode addressModeV
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "addressModeV:                   "); //HRW
    OutputString(outputFile, "VkSamplerAddressMode = "); //TEQ
    EnumToStringVkSamplerAddressMode(outputFile, pstruct->addressModeV); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->addressModeV);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerAddressMode addressModeW
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "addressModeW:                   "); //HRW
    OutputString(outputFile, "VkSamplerAddressMode = "); //TEQ
    EnumToStringVkSamplerAddressMode(outputFile, pstruct->addressModeW); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->addressModeW);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: float mipLodBias
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mipLodBias:                     "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->mipLodBias); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 anisotropyEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "anisotropyEnable:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->anisotropyEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxAnisotropy
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxAnisotropy:                  "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxAnisotropy); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 compareEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compareEnable:                  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->compareEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCompareOp compareOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compareOp:                      "); //HRW
    OutputString(outputFile, "VkCompareOp = "); //TEQ
    EnumToStringVkCompareOp(outputFile, pstruct->compareOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->compareOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: float minLod
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minLod:                         "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->minLod); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxLod
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxLod:                         "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxLod); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBorderColor borderColor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "borderColor:                    "); //HRW
    OutputString(outputFile, "VkBorderColor = "); //TEQ
    EnumToStringVkBorderColor(outputFile, pstruct->borderColor); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->borderColor);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 unnormalizedCoordinates
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "unnormalizedCoordinates:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->unnormalizedCoordinates); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutBinding *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t binding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "binding:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->binding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorType:                 "); //HRW
    OutputString(outputFile, "VkDescriptorType = "); //TEQ
    EnumToStringVkDescriptorType(outputFile, pstruct->descriptorType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->descriptorType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderStageFlags stageFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stageFlags:                     "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSampler* pImmutableSamplers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pImmutableSamplers:             "); //HRW
    OutputString(outputFile, "const VkSampler* = "); //TEQ
    if (pstruct->pImmutableSamplers == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pImmutableSamplers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pImmutableSamplers = {true, false, false, nullptr};
        ArrayToString<const VkSampler*>(outputFile, indent, 1, "const VkSampler*", reinterpret_cast<const VkSampler*>(pstruct_in.pImmutableSamplers.GetPointer()), "pImmutableSamplers", pstruct->descriptorCount,  vinfo_pImmutableSamplers);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorSetLayoutCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDescriptorSetLayoutCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkDescriptorSetLayoutCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bindingCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bindingCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bindingCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorSetLayoutBinding* pBindings
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pBindings:                      "); //HRW
    OutputString(outputFile, "const VkDescriptorSetLayoutBinding* = "); //TEQ
    if (pstruct->pBindings == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pBindings->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorSetLayoutBinding>(outputFile, indent+1, 1, "VkDescriptorSetLayoutBinding", pstruct_in.pBindings->GetMetaStructPointer(), "pBindings", pstruct->bindingCount, false, pstruct_in.pBindings->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorPoolSize *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDescriptorType type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkDescriptorType = "); //TEQ
    EnumToStringVkDescriptorType(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorPoolCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorPoolCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDescriptorPoolCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkDescriptorPoolCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSets
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSets:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSets); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t poolSizeCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "poolSizeCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->poolSizeCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorPoolSize* pPoolSizes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPoolSizes:                     "); //HRW
    OutputString(outputFile, "const VkDescriptorPoolSize* = "); //TEQ
    if (pstruct->pPoolSizes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPoolSizes->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorPoolSize>(outputFile, indent+1, 1, "VkDescriptorPoolSize", pstruct_in.pPoolSizes->GetMetaStructPointer(), "pPoolSizes", pstruct->poolSizeCount, false, pstruct_in.pPoolSizes->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorPool descriptorPool
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorPool:                 "); //HRW
    OutputString(outputFile, "VkDescriptorPool = "); //TEQ
    AddrToString(outputFile, pstruct_in.descriptorPool); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorSetCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorSetCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorSetCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorSetLayout* pSetLayouts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSetLayouts:                    "); //HRW
    OutputString(outputFile, "const VkDescriptorSetLayout* = "); //TEQ
    if (pstruct->pSetLayouts == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSetLayouts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSetLayout*>(outputFile, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pstruct_in.pSetLayouts.GetPointer()), "pSetLayouts", pstruct->descriptorSetCount,  vinfo_pSetLayouts);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorImageInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkSampler sampler
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampler:                        "); //HRW
    OutputString(outputFile, "VkSampler = "); //TEQ
    AddrToString(outputFile, pstruct_in.sampler); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageView imageView
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageView:                      "); //HRW
    OutputString(outputFile, "VkImageView = "); //TEQ
    AddrToString(outputFile, pstruct_in.imageView); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout imageLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageLayout:                    "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->imageLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->imageLayout);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorBufferInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize range
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "range:                          "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->range); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWriteDescriptorSet *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorSet dstSet
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstSet:                         "); //HRW
    OutputString(outputFile, "VkDescriptorSet = "); //TEQ
    AddrToString(outputFile, pstruct_in.dstSet); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstBinding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstBinding:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstBinding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstArrayElement
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstArrayElement:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstArrayElement); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorType:                 "); //HRW
    OutputString(outputFile, "VkDescriptorType = "); //TEQ
    EnumToStringVkDescriptorType(outputFile, pstruct->descriptorType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->descriptorType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorImageInfo* pImageInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pImageInfo:                     "); //HRW
    OutputString(outputFile, "const VkDescriptorImageInfo* = "); //TEQ
    if (pstruct->pImageInfo == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pImageInfo->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorImageInfo>(outputFile, indent+1, 1, "VkDescriptorImageInfo", pstruct_in.pImageInfo->GetMetaStructPointer(), "pImageInfo", pstruct->descriptorCount, false, pstruct_in.pImageInfo->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorBufferInfo* pBufferInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pBufferInfo:                    "); //HRW
    OutputString(outputFile, "const VkDescriptorBufferInfo* = "); //TEQ
    if (pstruct->pBufferInfo == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pBufferInfo->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorBufferInfo>(outputFile, indent+1, 1, "VkDescriptorBufferInfo", pstruct_in.pBufferInfo->GetMetaStructPointer(), "pBufferInfo", pstruct->descriptorCount, false, pstruct_in.pBufferInfo->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkBufferView* pTexelBufferView
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pTexelBufferView:               "); //HRW
    OutputString(outputFile, "const VkBufferView* = "); //TEQ
    if (pstruct->pTexelBufferView == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pTexelBufferView.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pTexelBufferView = {true, false, false, nullptr};
        ArrayToString<const VkBufferView*>(outputFile, indent, 1, "const VkBufferView*", reinterpret_cast<const VkBufferView*>(pstruct_in.pTexelBufferView.GetPointer()), "pTexelBufferView", pstruct->descriptorCount,  vinfo_pTexelBufferView);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCopyDescriptorSet *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorSet srcSet
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcSet:                         "); //HRW
    OutputString(outputFile, "VkDescriptorSet = "); //TEQ
    AddrToString(outputFile, pstruct_in.srcSet); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t srcBinding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcBinding:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->srcBinding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t srcArrayElement
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcArrayElement:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->srcArrayElement); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorSet dstSet
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstSet:                         "); //HRW
    OutputString(outputFile, "VkDescriptorSet = "); //TEQ
    AddrToString(outputFile, pstruct_in.dstSet); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstBinding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstBinding:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstBinding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstArrayElement
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstArrayElement:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstArrayElement); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFramebufferCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkFramebufferCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkFramebufferCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "renderPass:                     "); //HRW
    OutputString(outputFile, "VkRenderPass = "); //TEQ
    AddrToString(outputFile, pstruct_in.renderPass); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkImageView* pAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttachments:                   "); //HRW
    OutputString(outputFile, "const VkImageView* = "); //TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAttachments.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAttachments = {true, false, false, nullptr};
        ArrayToString<const VkImageView*>(outputFile, indent, 1, "const VkImageView*", reinterpret_cast<const VkImageView*>(pstruct_in.pAttachments.GetPointer()), "pAttachments", pstruct->attachmentCount,  vinfo_pAttachments);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t width
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "width:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->width); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t height
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "height:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->height); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t layers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layers:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->layers); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkAttachmentDescriptionFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkAttachmentDescriptionFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkAttachmentDescriptionFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "samples:                        "); //HRW
    OutputString(outputFile, "VkSampleCountFlagBits = "); //TEQ
    EnumToStringVkSampleCountFlagBits(outputFile, pstruct->samples); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->samples);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentLoadOp loadOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "loadOp:                         "); //HRW
    OutputString(outputFile, "VkAttachmentLoadOp = "); //TEQ
    EnumToStringVkAttachmentLoadOp(outputFile, pstruct->loadOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->loadOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentStoreOp storeOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storeOp:                        "); //HRW
    OutputString(outputFile, "VkAttachmentStoreOp = "); //TEQ
    EnumToStringVkAttachmentStoreOp(outputFile, pstruct->storeOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->storeOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentLoadOp stencilLoadOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilLoadOp:                  "); //HRW
    OutputString(outputFile, "VkAttachmentLoadOp = "); //TEQ
    EnumToStringVkAttachmentLoadOp(outputFile, pstruct->stencilLoadOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilLoadOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentStoreOp stencilStoreOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilStoreOp:                 "); //HRW
    OutputString(outputFile, "VkAttachmentStoreOp = "); //TEQ
    EnumToStringVkAttachmentStoreOp(outputFile, pstruct->stencilStoreOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilStoreOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout initialLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "initialLayout:                  "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->initialLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->initialLayout);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout finalLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "finalLayout:                    "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->finalLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->finalLayout);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentReference *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t attachment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachment:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachment); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout layout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layout:                         "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->layout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->layout);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkSubpassDescriptionFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSubpassDescriptionFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSubpassDescriptionFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineBindPoint:              "); //HRW
    OutputString(outputFile, "VkPipelineBindPoint = "); //TEQ
    EnumToStringVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->pipelineBindPoint);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t inputAttachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "inputAttachmentCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->inputAttachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference* pInputAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pInputAttachments:              "); //HRW
    OutputString(outputFile, "const VkAttachmentReference* = "); //TEQ
    if (pstruct->pInputAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pInputAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(outputFile, indent+1, 1, "VkAttachmentReference", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t colorAttachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "colorAttachmentCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->colorAttachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference* pColorAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pColorAttachments:              "); //HRW
    OutputString(outputFile, "const VkAttachmentReference* = "); //TEQ
    if (pstruct->pColorAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pColorAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(outputFile, indent+1, 1, "VkAttachmentReference", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference* pResolveAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pResolveAttachments:            "); //HRW
    OutputString(outputFile, "const VkAttachmentReference* = "); //TEQ
    if (pstruct->pResolveAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pResolveAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(outputFile, indent+1, 1, "VkAttachmentReference", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference* pDepthStencilAttachment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDepthStencilAttachment:        "); //HRW
    OutputString(outputFile, "const VkAttachmentReference* = "); //TEQ
    if (pstruct->pDepthStencilAttachment == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDepthStencilAttachment->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkSubpassDescription, pDepthStencilAttachment)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t preserveAttachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "preserveAttachmentCount:        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->preserveAttachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pPreserveAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPreserveAttachments:           "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pPreserveAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPreserveAttachments.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pstruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDependency *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t srcSubpass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcSubpass:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->srcSubpass); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstSubpass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstSubpass:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstSubpass); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineStageFlags srcStageMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcStageMask:                   "); //HRW
    OutputString(outputFile, "VkPipelineStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineStageFlags dstStageMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstStageMask:                   "); //HRW
    OutputString(outputFile, "VkPipelineStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDependencyFlags dependencyFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dependencyFlags:                "); //HRW
    OutputString(outputFile, "VkDependencyFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dependencyFlags, EnumToStringVkDependencyFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRenderPassCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkRenderPassCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkRenderPassCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentDescription* pAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttachments:                   "); //HRW
    OutputString(outputFile, "const VkAttachmentDescription* = "); //TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentDescription>(outputFile, indent+1, 1, "VkAttachmentDescription", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subpassCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subpassCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subpassCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSubpassDescription* pSubpasses
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSubpasses:                     "); //HRW
    OutputString(outputFile, "const VkSubpassDescription* = "); //TEQ
    if (pstruct->pSubpasses == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSubpasses->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDescription>(outputFile, indent+1, 1, "VkSubpassDescription", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dependencyCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dependencyCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dependencyCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSubpassDependency* pDependencies
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDependencies:                  "); //HRW
    OutputString(outputFile, "const VkSubpassDependency* = "); //TEQ
    if (pstruct->pDependencies == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDependencies->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDependency>(outputFile, indent+1, 1, "VkSubpassDependency", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandPoolCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCommandPoolCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkCommandPoolCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkCommandPoolCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueFamilyIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyIndex:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueFamilyIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCommandPool commandPool
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "commandPool:                    "); //HRW
    OutputString(outputFile, "VkCommandPool = "); //TEQ
    AddrToString(outputFile, pstruct_in.commandPool); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCommandBufferLevel level
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "level:                          "); //HRW
    OutputString(outputFile, "VkCommandBufferLevel = "); //TEQ
    EnumToStringVkCommandBufferLevel(outputFile, pstruct->level); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->level);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t commandBufferCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "commandBufferCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->commandBufferCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferInheritanceInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "renderPass:                     "); //HRW
    OutputString(outputFile, "VkRenderPass = "); //TEQ
    AddrToString(outputFile, pstruct_in.renderPass); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subpass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subpass:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subpass); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFramebuffer framebuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "framebuffer:                    "); //HRW
    OutputString(outputFile, "VkFramebuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.framebuffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 occlusionQueryEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "occlusionQueryEnable:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->occlusionQueryEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueryControlFlags queryFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queryFlags:                     "); //HRW
    OutputString(outputFile, "VkQueryControlFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->queryFlags, EnumToStringVkQueryControlFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueryPipelineStatisticFlags pipelineStatistics
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineStatistics:             "); //HRW
    OutputString(outputFile, "VkQueryPipelineStatisticFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->pipelineStatistics, EnumToStringVkQueryPipelineStatisticFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCommandBufferUsageFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkCommandBufferUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkCommandBufferUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkCommandBufferInheritanceInfo* pInheritanceInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pInheritanceInfo:               "); //HRW
    OutputString(outputFile, "const VkCommandBufferInheritanceInfo* = "); //TEQ
    if (pstruct->pInheritanceInfo == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pInheritanceInfo->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pInheritanceInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkCommandBufferBeginInfo, pInheritanceInfo)); // GLN
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferCopy *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDeviceSize srcOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcOffset:                      "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->srcOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize dstOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstOffset:                      "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->dstOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSubresourceLayers *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectMask:                     "); //HRW
    OutputString(outputFile, "VkImageAspectFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t mipLevel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mipLevel:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->mipLevel); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t baseArrayLayer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "baseArrayLayer:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->baseArrayLayer); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t layerCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layerCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->layerCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageCopy *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageSubresourceLayers srcSubresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcSubresource:                 "); //HRW
    OutputString(outputFile, "VkImageSubresourceLayers = "); //TEQ
    StructureToString(outputFile, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageCopy, srcSubresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D srcOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcOffset:                      "); //HRW
    OutputString(outputFile, "VkOffset3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.srcOffset, indent+1,  base_addr + offsetof(VkImageCopy, srcOffset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageSubresourceLayers dstSubresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstSubresource:                 "); //HRW
    OutputString(outputFile, "VkImageSubresourceLayers = "); //TEQ
    StructureToString(outputFile, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageCopy, dstSubresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D dstOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstOffset:                      "); //HRW
    OutputString(outputFile, "VkOffset3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.dstOffset, indent+1,  base_addr + offsetof(VkImageCopy, dstOffset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extent:                         "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageCopy, extent)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageBlit *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageSubresourceLayers srcSubresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcSubresource:                 "); //HRW
    OutputString(outputFile, "VkImageSubresourceLayers = "); //TEQ
    StructureToString(outputFile, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageBlit, srcSubresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D srcOffsets
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcOffsets:                     "); //HRW
    OutputString(outputFile, "VkOffset3D"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "2"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.srcOffsets->GetAddress()); // IYY
    ArrayOfStructsToString<Decoded_VkOffset3D>(outputFile, indent+1, 0, "VkOffset3D", pstruct_in.srcOffsets->GetMetaStructPointer(), "srcOffsets", 2 , false, pstruct_in.srcOffsets->GetAddress()); // EPB
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageSubresourceLayers dstSubresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstSubresource:                 "); //HRW
    OutputString(outputFile, "VkImageSubresourceLayers = "); //TEQ
    StructureToString(outputFile, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageBlit, dstSubresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D dstOffsets
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstOffsets:                     "); //HRW
    OutputString(outputFile, "VkOffset3D"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "2"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.dstOffsets->GetAddress()); // IYY
    ArrayOfStructsToString<Decoded_VkOffset3D>(outputFile, indent+1, 0, "VkOffset3D", pstruct_in.dstOffsets->GetMetaStructPointer(), "dstOffsets", 2 , false, pstruct_in.dstOffsets->GetAddress()); // EPB
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferImageCopy *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDeviceSize bufferOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferOffset:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->bufferOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bufferRowLength
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferRowLength:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bufferRowLength); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bufferImageHeight
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferImageHeight:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bufferImageHeight); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageSubresourceLayers imageSubresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageSubresource:               "); //HRW
    OutputString(outputFile, "VkImageSubresourceLayers = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageSubresource, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageSubresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D imageOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageOffset:                    "); //HRW
    OutputString(outputFile, "VkOffset3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageOffset, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageOffset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent3D imageExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageExtent:                    "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageExtent)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearColorValue *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: float float32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "float32:                        "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "4"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.uint32.GetAddress()); // IYX
    ScalarValueToStringStruct vinfo_float32 = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->float32), "float32", 4, vinfo_float32); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t int32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "int32:                          "); //HRW
    OutputString(outputFile, "int32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "4"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.uint32.GetAddress()); // IYX
    ScalarValueToStringStruct vinfo_int32 = {false, false, false, nullptr};
    ArrayToString<int32_t*>(outputFile, indent, 0, "int32_t", const_cast<int32_t*>(pstruct->int32), "int32", 4, vinfo_int32); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t uint32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "uint32:                         "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "4"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.uint32.GetAddress()); // IYX
    ScalarValueToStringStruct vinfo_uint32 = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->uint32), "uint32", 4, vinfo_uint32); // JPA
}

void StructureToString(FILE* outputFile, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearDepthStencilValue *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: float depth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depth:                          "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->depth); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t stencil
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencil:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->stencil); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearValue *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkClearColorValue color
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "color:                          "); //HRW
    OutputString(outputFile, "VkClearColorValue = "); //TEQ
    OutputString(outputFile, "(Union):"); // RGT
    StructureToString(outputFile, reinterpret_cast<const Decoded_VkClearColorValue&>(*pstruct_in.color) , indent+1,  base_addr + offsetof(VkClearValue, color)); // RLN
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkClearDepthStencilValue depthStencil
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthStencil:                   "); //HRW
    OutputString(outputFile, "VkClearDepthStencilValue = "); //TEQ
    StructureToString(outputFile, reinterpret_cast<const Decoded_VkClearDepthStencilValue&>(*pstruct_in.color) , indent+1,  base_addr + offsetof(VkClearValue, depthStencil)); // RLN
}

void StructureToString(FILE* outputFile, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearAttachment *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectMask:                     "); //HRW
    OutputString(outputFile, "VkImageAspectFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t colorAttachment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "colorAttachment:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->colorAttachment); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkClearValue clearValue
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "clearValue:                     "); //HRW
    OutputString(outputFile, "VkClearValue = "); //TEQ
    OutputString(outputFile, "(Union):"); // RGT
    StructureToString(outputFile, *pstruct_in.clearValue, indent+1,  base_addr + offsetof(VkClearAttachment, clearValue)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearRect *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkRect2D rect
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rect:                           "); //HRW
    OutputString(outputFile, "VkRect2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.rect, indent+1,  base_addr + offsetof(VkClearRect, rect)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t baseArrayLayer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "baseArrayLayer:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->baseArrayLayer); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t layerCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layerCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->layerCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageResolve *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageSubresourceLayers srcSubresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcSubresource:                 "); //HRW
    OutputString(outputFile, "VkImageSubresourceLayers = "); //TEQ
    StructureToString(outputFile, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageResolve, srcSubresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D srcOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcOffset:                      "); //HRW
    OutputString(outputFile, "VkOffset3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.srcOffset, indent+1,  base_addr + offsetof(VkImageResolve, srcOffset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageSubresourceLayers dstSubresource
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstSubresource:                 "); //HRW
    OutputString(outputFile, "VkImageSubresourceLayers = "); //TEQ
    StructureToString(outputFile, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageResolve, dstSubresource)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset3D dstOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstOffset:                      "); //HRW
    OutputString(outputFile, "VkOffset3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.dstOffset, indent+1,  base_addr + offsetof(VkImageResolve, dstOffset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extent:                         "); //HRW
    OutputString(outputFile, "VkExtent3D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageResolve, extent)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryBarrier *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferMemoryBarrier *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t srcQueueFamilyIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcQueueFamilyIndex:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->srcQueueFamilyIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstQueueFamilyIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstQueueFamilyIndex:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstQueueFamilyIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "size:                           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->size); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageMemoryBarrier *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout oldLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "oldLayout:                      "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->oldLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->oldLayout);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout newLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "newLayout:                      "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->newLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->newLayout);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t srcQueueFamilyIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcQueueFamilyIndex:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->srcQueueFamilyIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstQueueFamilyIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstQueueFamilyIndex:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstQueueFamilyIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageSubresourceRange subresourceRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subresourceRange:               "); //HRW
    OutputString(outputFile, "VkImageSubresourceRange = "); //TEQ
    StructureToString(outputFile, *pstruct_in.subresourceRange, indent+1,  base_addr + offsetof(VkImageMemoryBarrier, subresourceRange)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "renderPass:                     "); //HRW
    OutputString(outputFile, "VkRenderPass = "); //TEQ
    AddrToString(outputFile, pstruct_in.renderPass); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFramebuffer framebuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "framebuffer:                    "); //HRW
    OutputString(outputFile, "VkFramebuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.framebuffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRect2D renderArea
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "renderArea:                     "); //HRW
    OutputString(outputFile, "VkRect2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.renderArea, indent+1,  base_addr + offsetof(VkRenderPassBeginInfo, renderArea)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t clearValueCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "clearValueCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->clearValueCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkClearValue* pClearValues
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pClearValues:                   "); //HRW
    OutputString(outputFile, "const VkClearValue* = "); //TEQ
    if (pstruct->pClearValues == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pClearValues->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkClearValue>(outputFile, indent+1, 1, "VkClearValue", pstruct_in.pClearValues->GetMetaStructPointer(), "pClearValues", pstruct->clearValueCount, true, pstruct_in.pClearValues->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDispatchIndirectCommand *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t x
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "x:                              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->x); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t y
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "y:                              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->y); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t z
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "z:                              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->z); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrawIndexedIndirectCommand *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t indexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indexCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->indexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t instanceCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "instanceCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->instanceCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t firstIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "firstIndex:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->firstIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t vertexOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexOffset:                   "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vertexOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t firstInstance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "firstInstance:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->firstInstance); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrawIndirectCommand *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t vertexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexCount:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vertexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t instanceCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "instanceCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->instanceCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t firstVertex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "firstVertex:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->firstVertex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t firstInstance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "firstInstance:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->firstInstance); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSubgroupProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subgroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subgroupSize:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subgroupSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderStageFlags supportedStages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedStages:                "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedStages, EnumToStringVkShaderStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSubgroupFeatureFlags supportedOperations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedOperations:            "); //HRW
    OutputString(outputFile, "VkSubgroupFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedOperations, EnumToStringVkSubgroupFeatureFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 quadOperationsInAllStages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "quadOperationsInAllStages:      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->quadOperationsInAllStages); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindBufferMemoryInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryOffset:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->memoryOffset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImageMemoryInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryOffset:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->memoryOffset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevice16BitStorageFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 storageBuffer16BitAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storageBuffer16BitAccess:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->storageBuffer16BitAccess); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 uniformAndStorageBuffer16BitAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "uniformAndStorageBuffer16BitAccess: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->uniformAndStorageBuffer16BitAccess); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 storagePushConstant16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storagePushConstant16:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->storagePushConstant16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 storageInputOutput16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storageInputOutput16:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->storageInputOutput16); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryDedicatedRequirements *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 prefersDedicatedAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "prefersDedicatedAllocation:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->prefersDedicatedAllocation); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 requiresDedicatedAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "requiresDedicatedAllocation:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->requiresDedicatedAllocation); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryDedicatedAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryAllocateFlagsInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMemoryAllocateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkMemoryAllocateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkMemoryAllocateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceMask:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceMask); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupRenderPassBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceMask:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceMask); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceRenderAreaCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceRenderAreaCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceRenderAreaCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkRect2D* pDeviceRenderAreas
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDeviceRenderAreas:             "); //HRW
    OutputString(outputFile, "const VkRect2D* = "); //TEQ
    if (pstruct->pDeviceRenderAreas == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDeviceRenderAreas->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(outputFile, indent+1, 1, "VkRect2D", pstruct_in.pDeviceRenderAreas->GetMetaStructPointer(), "pDeviceRenderAreas", pstruct->deviceRenderAreaCount, false, pstruct_in.pDeviceRenderAreas->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupCommandBufferBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceMask:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceMask); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupSubmitInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "waitSemaphoreCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pWaitSemaphoreDeviceIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pWaitSemaphoreDeviceIndices:    "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pWaitSemaphoreDeviceIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pWaitSemaphoreDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphoreDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pWaitSemaphoreDeviceIndices.GetPointer()), "pWaitSemaphoreDeviceIndices", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphoreDeviceIndices);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t commandBufferCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "commandBufferCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->commandBufferCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pCommandBufferDeviceMasks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCommandBufferDeviceMasks:      "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pCommandBufferDeviceMasks == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCommandBufferDeviceMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCommandBufferDeviceMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCommandBufferDeviceMasks.GetPointer()), "pCommandBufferDeviceMasks", pstruct->commandBufferCount,  vinfo_pCommandBufferDeviceMasks);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t signalSemaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "signalSemaphoreCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->signalSemaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pSignalSemaphoreDeviceIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSignalSemaphoreDeviceIndices:  "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pSignalSemaphoreDeviceIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSignalSemaphoreDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphoreDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pSignalSemaphoreDeviceIndices.GetPointer()), "pSignalSemaphoreDeviceIndices", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphoreDeviceIndices);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupBindSparseInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t resourceDeviceIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "resourceDeviceIndex:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->resourceDeviceIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryDeviceIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryDeviceIndex:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryDeviceIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindBufferMemoryDeviceGroupInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceIndexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceIndexCount:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceIndexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pDeviceIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDeviceIndices:                 "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImageMemoryDeviceGroupInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceIndexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceIndexCount:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceIndexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pDeviceIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDeviceIndices:                 "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t splitInstanceBindRegionCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "splitInstanceBindRegionCount:   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->splitInstanceBindRegionCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkRect2D* pSplitInstanceBindRegions
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSplitInstanceBindRegions:      "); //HRW
    OutputString(outputFile, "const VkRect2D* = "); //TEQ
    if (pstruct->pSplitInstanceBindRegions == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSplitInstanceBindRegions->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(outputFile, indent+1, 1, "VkRect2D", pstruct_in.pSplitInstanceBindRegions->GetMetaStructPointer(), "pSplitInstanceBindRegions", pstruct->splitInstanceBindRegionCount, false, pstruct_in.pSplitInstanceBindRegions->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceGroupProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t physicalDeviceCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "physicalDeviceCount:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->physicalDeviceCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPhysicalDevice physicalDevices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "physicalDevices:                "); //HRW
    OutputString(outputFile, "VkPhysicalDevice"); //JUQ
    OutputString(outputFile, "[");
    UnsignedDecimalToString(outputFile, pstruct->physicalDeviceCount); // DFW
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.physicalDevices.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_physicalDevices = {true, false, false, nullptr};
    ArrayToString<VkPhysicalDevice*>(outputFile, indent, 0, "VkPhysicalDevice", const_cast<VkPhysicalDevice*>(pstruct->physicalDevices), "physicalDevices", pstruct->physicalDeviceCount, vinfo_physicalDevices); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 subsetAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subsetAllocation:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->subsetAllocation); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupDeviceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t physicalDeviceCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "physicalDeviceCount:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->physicalDeviceCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPhysicalDevice* pPhysicalDevices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPhysicalDevices:               "); //HRW
    OutputString(outputFile, "const VkPhysicalDevice* = "); //TEQ
    if (pstruct->pPhysicalDevices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPhysicalDevices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPhysicalDevices = {true, false, false, nullptr};
        ArrayToString<const VkPhysicalDevice*>(outputFile, indent, 1, "const VkPhysicalDevice*", reinterpret_cast<const VkPhysicalDevice*>(pstruct_in.pPhysicalDevices.GetPointer()), "pPhysicalDevices", pstruct->physicalDeviceCount,  vinfo_pPhysicalDevices);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferMemoryRequirementsInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageMemoryRequirementsInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSparseMemoryRequirementsInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryRequirements2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMemoryRequirements memoryRequirements
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryRequirements:             "); //HRW
    OutputString(outputFile, "VkMemoryRequirements = "); //TEQ
    StructureToString(outputFile, *pstruct_in.memoryRequirements, indent+1,  base_addr + offsetof(VkMemoryRequirements2, memoryRequirements)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryRequirements2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSparseImageMemoryRequirements memoryRequirements
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryRequirements:             "); //HRW
    OutputString(outputFile, "VkSparseImageMemoryRequirements = "); //TEQ
    StructureToString(outputFile, *pstruct_in.memoryRequirements, indent+1,  base_addr + offsetof(VkSparseImageMemoryRequirements2, memoryRequirements)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFeatures2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPhysicalDeviceFeatures features
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "features:                       "); //HRW
    OutputString(outputFile, "VkPhysicalDeviceFeatures = "); //TEQ
    StructureToString(outputFile, *pstruct_in.features, indent+1,  base_addr + offsetof(VkPhysicalDeviceFeatures2, features)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPhysicalDeviceProperties properties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "properties:                     "); //HRW
    OutputString(outputFile, "VkPhysicalDeviceProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.properties, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties2, properties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFormatProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormatProperties formatProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "formatProperties:               "); //HRW
    OutputString(outputFile, "VkFormatProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.formatProperties, indent+1,  base_addr + offsetof(VkFormatProperties2, formatProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageFormatProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageFormatProperties imageFormatProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageFormatProperties:          "); //HRW
    OutputString(outputFile, "VkImageFormatProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageFormatProperties, indent+1,  base_addr + offsetof(VkImageFormatProperties2, imageFormatProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImageFormatInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageType type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkImageType = "); //TEQ
    EnumToStringVkImageType(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageTiling tiling
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tiling:                         "); //HRW
    OutputString(outputFile, "VkImageTiling = "); //TEQ
    EnumToStringVkImageTiling(outputFile, pstruct->tiling); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->tiling);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "usage:                          "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkImageCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkImageCreateFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueueFamilyProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueueFamilyProperties queueFamilyProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyProperties:          "); //HRW
    OutputString(outputFile, "VkQueueFamilyProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.queueFamilyProperties, indent+1,  base_addr + offsetof(VkQueueFamilyProperties2, queueFamilyProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPhysicalDeviceMemoryProperties memoryProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryProperties:               "); //HRW
    OutputString(outputFile, "VkPhysicalDeviceMemoryProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.memoryProperties, indent+1,  base_addr + offsetof(VkPhysicalDeviceMemoryProperties2, memoryProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageFormatProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSparseImageFormatProperties properties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "properties:                     "); //HRW
    OutputString(outputFile, "VkSparseImageFormatProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.properties, indent+1,  base_addr + offsetof(VkSparseImageFormatProperties2, properties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSparseImageFormatInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageType type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkImageType = "); //TEQ
    EnumToStringVkImageType(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "samples:                        "); //HRW
    OutputString(outputFile, "VkSampleCountFlagBits = "); //TEQ
    EnumToStringVkSampleCountFlagBits(outputFile, pstruct->samples); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->samples);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "usage:                          "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageTiling tiling
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tiling:                         "); //HRW
    OutputString(outputFile, "VkImageTiling = "); //TEQ
    EnumToStringVkImageTiling(outputFile, pstruct->tiling); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->tiling);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePointClippingProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPointClippingBehavior pointClippingBehavior
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pointClippingBehavior:          "); //HRW
    OutputString(outputFile, "VkPointClippingBehavior = "); //TEQ
    EnumToStringVkPointClippingBehavior(outputFile, pstruct->pointClippingBehavior); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->pointClippingBehavior);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr)
{
    const VkInputAttachmentAspectReference *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t subpass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subpass:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subpass); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t inputAttachmentIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "inputAttachmentIndex:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->inputAttachmentIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectMask:                     "); //HRW
    OutputString(outputFile, "VkImageAspectFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassInputAttachmentAspectCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t aspectReferenceCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectReferenceCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->aspectReferenceCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkInputAttachmentAspectReference* pAspectReferences
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAspectReferences:              "); //HRW
    OutputString(outputFile, "const VkInputAttachmentAspectReference* = "); //TEQ
    if (pstruct->pAspectReferences == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAspectReferences->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkInputAttachmentAspectReference>(outputFile, indent+1, 1, "VkInputAttachmentAspectReference", pstruct_in.pAspectReferences->GetMetaStructPointer(), "pAspectReferences", pstruct->aspectReferenceCount, false, pstruct_in.pAspectReferences->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewUsageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "usage:                          "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineTessellationDomainOriginStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkTessellationDomainOrigin domainOrigin
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "domainOrigin:                   "); //HRW
    OutputString(outputFile, "VkTessellationDomainOrigin = "); //TEQ
    EnumToStringVkTessellationDomainOrigin(outputFile, pstruct->domainOrigin); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->domainOrigin);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassMultiviewCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subpassCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subpassCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subpassCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pViewMasks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewMasks:                     "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pViewMasks == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pViewMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pViewMasks.GetPointer()), "pViewMasks", pstruct->subpassCount,  vinfo_pViewMasks);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dependencyCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dependencyCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dependencyCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const int32_t* pViewOffsets
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewOffsets:                   "); //HRW
    OutputString(outputFile, "const int32_t* = "); //TEQ
    if (pstruct->pViewOffsets == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewOffsets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pViewOffsets = {false, false, false, nullptr};
        ArrayToString<const int32_t*>(outputFile, indent, 1, "const int32_t*", reinterpret_cast<const int32_t*>(pstruct_in.pViewOffsets.GetPointer()), "pViewOffsets", pstruct->dependencyCount,  vinfo_pViewOffsets);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t correlationMaskCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "correlationMaskCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->correlationMaskCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pCorrelationMasks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCorrelationMasks:              "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pCorrelationMasks == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCorrelationMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCorrelationMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCorrelationMasks.GetPointer()), "pCorrelationMasks", pstruct->correlationMaskCount,  vinfo_pCorrelationMasks);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMultiviewFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 multiview
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "multiview:                      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->multiview); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 multiviewGeometryShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "multiviewGeometryShader:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->multiviewGeometryShader); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 multiviewTessellationShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "multiviewTessellationShader:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->multiviewTessellationShader); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMultiviewProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMultiviewViewCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMultiviewViewCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMultiviewViewCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMultiviewInstanceIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMultiviewInstanceIndex:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMultiviewInstanceIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVariablePointersFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 variablePointersStorageBuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "variablePointersStorageBuffer:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->variablePointersStorageBuffer); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 variablePointers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "variablePointers:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->variablePointers); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProtectedMemoryFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 protectedMemory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "protectedMemory:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->protectedMemory); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProtectedMemoryProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 protectedNoFault
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "protectedNoFault:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->protectedNoFault); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceQueueInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceQueueCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDeviceQueueCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkDeviceQueueCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueFamilyIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyIndex:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueFamilyIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueIndex:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkProtectedSubmitInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 protectedSubmit
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "protectedSubmit:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->protectedSubmit); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerYcbcrConversionCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerYcbcrModelConversion ycbcrModel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ycbcrModel:                     "); //HRW
    OutputString(outputFile, "VkSamplerYcbcrModelConversion = "); //TEQ
    EnumToStringVkSamplerYcbcrModelConversion(outputFile, pstruct->ycbcrModel); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->ycbcrModel);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerYcbcrRange ycbcrRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ycbcrRange:                     "); //HRW
    OutputString(outputFile, "VkSamplerYcbcrRange = "); //TEQ
    EnumToStringVkSamplerYcbcrRange(outputFile, pstruct->ycbcrRange); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->ycbcrRange);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentMapping components
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "components:                     "); //HRW
    OutputString(outputFile, "VkComponentMapping = "); //TEQ
    StructureToString(outputFile, *pstruct_in.components, indent+1,  base_addr + offsetof(VkSamplerYcbcrConversionCreateInfo, components)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkChromaLocation xChromaOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "xChromaOffset:                  "); //HRW
    OutputString(outputFile, "VkChromaLocation = "); //TEQ
    EnumToStringVkChromaLocation(outputFile, pstruct->xChromaOffset); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->xChromaOffset);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkChromaLocation yChromaOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "yChromaOffset:                  "); //HRW
    OutputString(outputFile, "VkChromaLocation = "); //TEQ
    EnumToStringVkChromaLocation(outputFile, pstruct->yChromaOffset); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->yChromaOffset);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFilter chromaFilter
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "chromaFilter:                   "); //HRW
    OutputString(outputFile, "VkFilter = "); //TEQ
    EnumToStringVkFilter(outputFile, pstruct->chromaFilter); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->chromaFilter);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 forceExplicitReconstruction
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "forceExplicitReconstruction:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->forceExplicitReconstruction); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerYcbcrConversionInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerYcbcrConversion conversion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "conversion:                     "); //HRW
    OutputString(outputFile, "VkSamplerYcbcrConversion = "); //TEQ
    AddrToString(outputFile, pstruct_in.conversion); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImagePlaneMemoryInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageAspectFlagBits planeAspect
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "planeAspect:                    "); //HRW
    OutputString(outputFile, "VkImageAspectFlagBits = "); //TEQ
    EnumToStringVkImageAspectFlagBits(outputFile, pstruct->planeAspect); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->planeAspect);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImagePlaneMemoryRequirementsInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageAspectFlagBits planeAspect
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "planeAspect:                    "); //HRW
    OutputString(outputFile, "VkImageAspectFlagBits = "); //TEQ
    EnumToStringVkImageAspectFlagBits(outputFile, pstruct->planeAspect); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->planeAspect);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 samplerYcbcrConversion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "samplerYcbcrConversion:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->samplerYcbcrConversion); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerYcbcrConversionImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t combinedImageSamplerDescriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "combinedImageSamplerDescriptorCount: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->combinedImageSamplerDescriptorCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorUpdateTemplateEntry *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t dstBinding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstBinding:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstBinding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstArrayElement
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstArrayElement:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstArrayElement); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorType:                 "); //HRW
    OutputString(outputFile, "VkDescriptorType = "); //TEQ
    EnumToStringVkDescriptorType(outputFile, pstruct->descriptorType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->descriptorType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->offset); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t stride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stride:                         "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->stride); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorUpdateTemplateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorUpdateTemplateCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDescriptorUpdateTemplateCreateFlags = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorUpdateEntryCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorUpdateEntryCount:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorUpdateEntryCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDescriptorUpdateEntries:       "); //HRW
    OutputString(outputFile, "const VkDescriptorUpdateTemplateEntry* = "); //TEQ
    if (pstruct->pDescriptorUpdateEntries == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDescriptorUpdateEntries->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorUpdateTemplateEntry>(outputFile, indent+1, 1, "VkDescriptorUpdateTemplateEntry", pstruct_in.pDescriptorUpdateEntries->GetMetaStructPointer(), "pDescriptorUpdateEntries", pstruct->descriptorUpdateEntryCount, false, pstruct_in.pDescriptorUpdateEntries->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorUpdateTemplateType templateType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "templateType:                   "); //HRW
    OutputString(outputFile, "VkDescriptorUpdateTemplateType = "); //TEQ
    EnumToStringVkDescriptorUpdateTemplateType(outputFile, pstruct->templateType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->templateType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorSetLayout descriptorSetLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorSetLayout:            "); //HRW
    OutputString(outputFile, "VkDescriptorSetLayout = "); //TEQ
    AddrToString(outputFile, pstruct_in.descriptorSetLayout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineBindPoint:              "); //HRW
    OutputString(outputFile, "VkPipelineBindPoint = "); //TEQ
    EnumToStringVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->pipelineBindPoint);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineLayout pipelineLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineLayout:                 "); //HRW
    OutputString(outputFile, "VkPipelineLayout = "); //TEQ
    AddrToString(outputFile, pstruct_in.pipelineLayout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t set
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "set:                            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->set); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkExternalMemoryFeatureFlags externalMemoryFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalMemoryFeatures:         "); //HRW
    OutputString(outputFile, "VkExternalMemoryFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->externalMemoryFeatures, EnumToStringVkExternalMemoryFeatureFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "exportFromImportedHandleTypes:  "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlags compatibleHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compatibleHandleTypes:          "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->compatibleHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalImageFormatInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryProperties externalMemoryProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalMemoryProperties:       "); //HRW
    OutputString(outputFile, "VkExternalMemoryProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.externalMemoryProperties, indent+1,  base_addr + offsetof(VkExternalImageFormatProperties, externalMemoryProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalBufferInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBufferCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkBufferCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkBufferCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBufferUsageFlags usage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "usage:                          "); //HRW
    OutputString(outputFile, "VkBufferUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->usage, EnumToStringVkBufferUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalBufferProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryProperties externalMemoryProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalMemoryProperties:       "); //HRW
    OutputString(outputFile, "VkExternalMemoryProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.externalMemoryProperties, indent+1,  base_addr + offsetof(VkExternalBufferProperties, externalMemoryProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceIDProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint8_t deviceUUID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceUUID:                     "); //HRW
    OutputString(outputFile, "uint8_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "VK_UUID_SIZE"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.deviceUUID.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_deviceUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(outputFile, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->deviceUUID), "deviceUUID", VK_UUID_SIZE, vinfo_deviceUUID); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint8_t driverUUID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "driverUUID:                     "); //HRW
    OutputString(outputFile, "uint8_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "VK_UUID_SIZE"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.driverUUID.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_driverUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(outputFile, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->driverUUID), "driverUUID", VK_UUID_SIZE, vinfo_driverUUID); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint8_t deviceLUID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceLUID:                     "); //HRW
    OutputString(outputFile, "uint8_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "VK_LUID_SIZE"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.deviceLUID.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_deviceLUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(outputFile, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->deviceLUID), "deviceLUID", VK_LUID_SIZE, vinfo_deviceLUID); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceNodeMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceNodeMask:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceNodeMask); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 deviceLUIDValid
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceLUIDValid:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->deviceLUIDValid); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryImageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleTypes:                    "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryBufferCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleTypes:                    "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleTypes:                    "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalFenceInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalFenceProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "exportFromImportedHandleTypes:  "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlags compatibleHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compatibleHandleTypes:          "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->compatibleHandleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceFeatureFlags externalFenceFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalFenceFeatures:          "); //HRW
    OutputString(outputFile, "VkExternalFenceFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->externalFenceFeatures, EnumToStringVkExternalFenceFeatureFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportFenceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlags handleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleTypes:                    "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->handleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportSemaphoreCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlags handleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleTypes:                    "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->handleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalSemaphoreInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalSemaphoreProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "exportFromImportedHandleTypes:  "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compatibleHandleTypes:          "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->compatibleHandleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalSemaphoreFeatures:      "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->externalSemaphoreFeatures, EnumToStringVkExternalSemaphoreFeatureFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMaintenance3Properties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerSetDescriptors
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerSetDescriptors:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerSetDescriptors); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize maxMemoryAllocationSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMemoryAllocationSize:        "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->maxMemoryAllocationSize); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutSupport *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 supported
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supported:                      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->supported); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderDrawParametersFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDrawParameters
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDrawParameters:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDrawParameters); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t minImageCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minImageCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minImageCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D currentExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "currentExtent:                  "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.currentExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, currentExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D minImageExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minImageExtent:                 "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, minImageExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D maxImageExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageExtent:                 "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, maxImageExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageArrayLayers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageArrayLayers:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageArrayLayers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedTransforms:            "); //HRW
    OutputString(outputFile, "VkSurfaceTransformFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR currentTransform
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "currentTransform:               "); //HRW
    OutputString(outputFile, "VkSurfaceTransformFlagBitsKHR = "); //TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(outputFile, pstruct->currentTransform); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->currentTransform);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCompositeAlphaFlagsKHR supportedCompositeAlpha
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedCompositeAlpha:        "); //HRW
    OutputString(outputFile, "VkCompositeAlphaFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedCompositeAlpha, EnumToStringVkCompositeAlphaFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags supportedUsageFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedUsageFlags:            "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFormatKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkColorSpaceKHR colorSpace
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "colorSpace:                     "); //HRW
    OutputString(outputFile, "VkColorSpaceKHR = "); //TEQ
    EnumToStringVkColorSpaceKHR(outputFile, pstruct->colorSpace); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->colorSpace);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSwapchainCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSwapchainCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSwapchainCreateFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSwapchainCreateFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceKHR surface
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "surface:                        "); //HRW
    OutputString(outputFile, "VkSurfaceKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.surface); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minImageCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minImageCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minImageCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat imageFormat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageFormat:                    "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->imageFormat); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->imageFormat);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkColorSpaceKHR imageColorSpace
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageColorSpace:                "); //HRW
    OutputString(outputFile, "VkColorSpaceKHR = "); //TEQ
    EnumToStringVkColorSpaceKHR(outputFile, pstruct->imageColorSpace); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->imageColorSpace);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D imageExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageExtent:                    "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkSwapchainCreateInfoKHR, imageExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t imageArrayLayers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageArrayLayers:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->imageArrayLayers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags imageUsage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageUsage:                     "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->imageUsage, EnumToStringVkImageUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSharingMode imageSharingMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageSharingMode:               "); //HRW
    OutputString(outputFile, "VkSharingMode = "); //TEQ
    EnumToStringVkSharingMode(outputFile, pstruct->imageSharingMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->imageSharingMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyIndexCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pQueueFamilyIndices:            "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR preTransform
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "preTransform:                   "); //HRW
    OutputString(outputFile, "VkSurfaceTransformFlagBitsKHR = "); //TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(outputFile, pstruct->preTransform); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->preTransform);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCompositeAlphaFlagBitsKHR compositeAlpha
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compositeAlpha:                 "); //HRW
    OutputString(outputFile, "VkCompositeAlphaFlagBitsKHR = "); //TEQ
    EnumToStringVkCompositeAlphaFlagBitsKHR(outputFile, pstruct->compositeAlpha); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->compositeAlpha);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPresentModeKHR presentMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "presentMode:                    "); //HRW
    OutputString(outputFile, "VkPresentModeKHR = "); //TEQ
    EnumToStringVkPresentModeKHR(outputFile, pstruct->presentMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->presentMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 clipped
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "clipped:                        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->clipped); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSwapchainKHR oldSwapchain
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "oldSwapchain:                   "); //HRW
    OutputString(outputFile, "VkSwapchainKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.oldSwapchain); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "waitSemaphoreCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSemaphore* pWaitSemaphores
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pWaitSemaphores:                "); //HRW
    OutputString(outputFile, "const VkSemaphore* = "); //TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(outputFile, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t swapchainCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "swapchainCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->swapchainCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSwapchainKHR* pSwapchains
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSwapchains:                    "); //HRW
    OutputString(outputFile, "const VkSwapchainKHR* = "); //TEQ
    if (pstruct->pSwapchains == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSwapchains.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        ArrayToString<const VkSwapchainKHR*>(outputFile, indent, 1, "const VkSwapchainKHR*", reinterpret_cast<const VkSwapchainKHR*>(pstruct_in.pSwapchains.GetPointer()), "pSwapchains", pstruct->swapchainCount,  vinfo_pSwapchains);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pImageIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pImageIndices:                  "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pImageIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pImageIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pImageIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pImageIndices.GetPointer()), "pImageIndices", pstruct->swapchainCount,  vinfo_pImageIndices);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkResult* pResults
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pResults:                       "); //HRW
    OutputString(outputFile, "VkResult* = "); //TEQ
    if (pstruct->pResults == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pResults.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pResults = {false, true, false, EnumToStringVkResult};
        ArrayToString<VkResult*>(outputFile, indent, 1, "VkResult*", reinterpret_cast<VkResult*>(pstruct_in.pResults.GetPointer()), "pResults", pstruct->swapchainCount,  vinfo_pResults);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSwapchainCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSwapchainKHR swapchain
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "swapchain:                      "); //HRW
    OutputString(outputFile, "VkSwapchainKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.swapchain); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImageMemorySwapchainInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSwapchainKHR swapchain
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "swapchain:                      "); //HRW
    OutputString(outputFile, "VkSwapchainKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.swapchain); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t imageIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageIndex:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->imageIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAcquireNextImageInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSwapchainKHR swapchain
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "swapchain:                      "); //HRW
    OutputString(outputFile, "VkSwapchainKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.swapchain); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t timeout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "timeout:                        "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->timeout); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphore:                      "); //HRW
    OutputString(outputFile, "VkSemaphore = "); //TEQ
    AddrToString(outputFile, pstruct_in.semaphore); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFence fence
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fence:                          "); //HRW
    OutputString(outputFile, "VkFence = "); //TEQ
    AddrToString(outputFile, pstruct_in.fence); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceMask:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceMask); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupPresentCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t presentMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "presentMask:                    "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "VK_MAX_DEVICE_GROUP_SIZE"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.presentMask.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_presentMask = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->presentMask), "presentMask", VK_MAX_DEVICE_GROUP_SIZE, vinfo_presentMask); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceGroupPresentModeFlagsKHR modes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "modes:                          "); //HRW
    OutputString(outputFile, "VkDeviceGroupPresentModeFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->modes, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupPresentInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t swapchainCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "swapchainCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->swapchainCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pDeviceMasks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDeviceMasks:                   "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pDeviceMasks == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDeviceMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceMasks.GetPointer()), "pDeviceMasks", pstruct->swapchainCount,  vinfo_pDeviceMasks);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceGroupPresentModeFlagBitsKHR mode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mode:                           "); //HRW
    OutputString(outputFile, "VkDeviceGroupPresentModeFlagBitsKHR = "); //TEQ
    EnumToStringVkDeviceGroupPresentModeFlagBitsKHR(outputFile, pstruct->mode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->mode);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupSwapchainCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceGroupPresentModeFlagsKHR modes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "modes:                          "); //HRW
    OutputString(outputFile, "VkDeviceGroupPresentModeFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->modes, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDisplayKHR display
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "display:                        "); //HRW
    OutputString(outputFile, "VkDisplayKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.display); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* displayName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayName:                    "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->displayName); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D physicalDimensions
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "physicalDimensions:             "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.physicalDimensions, indent+1,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalDimensions)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D physicalResolution
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "physicalResolution:             "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.physicalResolution, indent+1,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalResolution)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedTransforms:            "); //HRW
    OutputString(outputFile, "VkSurfaceTransformFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 planeReorderPossible
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "planeReorderPossible:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->planeReorderPossible); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 persistentContent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "persistentContent:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->persistentContent); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModeParametersKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkExtent2D visibleRegion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "visibleRegion:                  "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.visibleRegion, indent+1,  base_addr + offsetof(VkDisplayModeParametersKHR, visibleRegion)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t refreshRate
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "refreshRate:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->refreshRate); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDisplayModeKHR displayMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayMode:                    "); //HRW
    OutputString(outputFile, "VkDisplayModeKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.displayMode); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayModeParametersKHR parameters
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "parameters:                     "); //HRW
    OutputString(outputFile, "VkDisplayModeParametersKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.parameters, indent+1,  base_addr + offsetof(VkDisplayModePropertiesKHR, parameters)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModeCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayModeCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDisplayModeCreateFlagsKHR = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayModeParametersKHR parameters
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "parameters:                     "); //HRW
    OutputString(outputFile, "VkDisplayModeParametersKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.parameters, indent+1,  base_addr + offsetof(VkDisplayModeCreateInfoKHR, parameters)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDisplayPlaneAlphaFlagsKHR supportedAlpha
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedAlpha:                 "); //HRW
    OutputString(outputFile, "VkDisplayPlaneAlphaFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedAlpha, EnumToStringVkDisplayPlaneAlphaFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset2D minSrcPosition
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minSrcPosition:                 "); //HRW
    OutputString(outputFile, "VkOffset2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minSrcPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcPosition)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset2D maxSrcPosition
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSrcPosition:                 "); //HRW
    OutputString(outputFile, "VkOffset2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxSrcPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcPosition)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D minSrcExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minSrcExtent:                   "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minSrcExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D maxSrcExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSrcExtent:                   "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxSrcExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset2D minDstPosition
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minDstPosition:                 "); //HRW
    OutputString(outputFile, "VkOffset2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minDstPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstPosition)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkOffset2D maxDstPosition
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDstPosition:                 "); //HRW
    OutputString(outputFile, "VkOffset2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxDstPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstPosition)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D minDstExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minDstExtent:                   "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minDstExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D maxDstExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDstExtent:                   "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxDstExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstExtent)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlanePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkDisplayKHR currentDisplay
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "currentDisplay:                 "); //HRW
    OutputString(outputFile, "VkDisplayKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.currentDisplay); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t currentStackIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "currentStackIndex:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->currentStackIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplaySurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplaySurfaceCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDisplaySurfaceCreateFlagsKHR = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayModeKHR displayMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayMode:                    "); //HRW
    OutputString(outputFile, "VkDisplayModeKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.displayMode); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t planeIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "planeIndex:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->planeIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t planeStackIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "planeStackIndex:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->planeStackIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR transform
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transform:                      "); //HRW
    OutputString(outputFile, "VkSurfaceTransformFlagBitsKHR = "); //TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(outputFile, pstruct->transform); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->transform);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: float globalAlpha
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "globalAlpha:                    "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->globalAlpha); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayPlaneAlphaFlagBitsKHR alphaMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "alphaMode:                      "); //HRW
    OutputString(outputFile, "VkDisplayPlaneAlphaFlagBitsKHR = "); //TEQ
    EnumToStringVkDisplayPlaneAlphaFlagBitsKHR(outputFile, pstruct->alphaMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->alphaMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D imageExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageExtent:                    "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkDisplaySurfaceCreateInfoKHR, imageExtent)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPresentInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRect2D srcRect
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcRect:                        "); //HRW
    OutputString(outputFile, "VkRect2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.srcRect, indent+1,  base_addr + offsetof(VkDisplayPresentInfoKHR, srcRect)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRect2D dstRect
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstRect:                        "); //HRW
    OutputString(outputFile, "VkRect2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.dstRect, indent+1,  base_addr + offsetof(VkDisplayPresentInfoKHR, dstRect)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 persistent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "persistent:                     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->persistent); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkXlibSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkXlibSurfaceCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkXlibSurfaceCreateFlagsKHR = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* dpy
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dpy:                            "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    AddrToString(outputFile, pstruct_in.dpy); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t window
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "window:                         "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->window); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkXcbSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkXcbSurfaceCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkXcbSurfaceCreateFlagsKHR = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* connection
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "connection:                     "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->connection == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.connection); // PWR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t window
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "window:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->window); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWaylandSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkWaylandSurfaceCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkWaylandSurfaceCreateFlagsKHR = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: struct void* display
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "display:                        "); //HRW
    OutputString(outputFile, "struct void* = "); //TEQ
    if (pstruct->display == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.display); // PWR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: struct void* surface
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "surface:                        "); //HRW
    OutputString(outputFile, "struct void* = "); //TEQ
    if (pstruct->surface == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.surface); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAndroidSurfaceCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkAndroidSurfaceCreateFlagsKHR = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: struct void* window
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "window:                         "); //HRW
    OutputString(outputFile, "struct void* = "); //TEQ
    if (pstruct->window == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.window); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWin32SurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkWin32SurfaceCreateFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkWin32SurfaceCreateFlagsKHR = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* hinstance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "hinstance:                      "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->hinstance == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.hinstance); // PWR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* hwnd
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "hwnd:                           "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->hwnd == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.hwnd); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* handle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handle:                         "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.handle); // PWR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const wchar_t* name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "const wchar_t* = "); //TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        WideStringToQuotedString(outputFile, pstruct->name); // RHP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttributes:                    "); //HRW
    OutputString(outputFile, "const SECURITY_ATTRIBUTES* = "); //TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dwAccess:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dwAccess); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const wchar_t* name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "const wchar_t* = "); //TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        WideStringToQuotedString(outputFile, pstruct->name); // RHP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryWin32HandlePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypeBits:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeBits); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryGetWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: int fd
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fd:                             "); //HRW
    OutputString(outputFile, "int = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fd); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryFdPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypeBits:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeBits); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryGetFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWin32KeyedMutexAcquireReleaseInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t acquireCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "acquireCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->acquireCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDeviceMemory* pAcquireSyncs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAcquireSyncs:                  "); //HRW
    OutputString(outputFile, "const VkDeviceMemory* = "); //TEQ
    if (pstruct->pAcquireSyncs == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAcquireSyncs.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAcquireSyncs = {true, false, false, nullptr};
        ArrayToString<const VkDeviceMemory*>(outputFile, indent, 1, "const VkDeviceMemory*", reinterpret_cast<const VkDeviceMemory*>(pstruct_in.pAcquireSyncs.GetPointer()), "pAcquireSyncs", pstruct->acquireCount,  vinfo_pAcquireSyncs);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pAcquireKeys
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAcquireKeys:                   "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pAcquireKeys == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAcquireKeys.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAcquireKeys = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pAcquireKeys.GetPointer()), "pAcquireKeys", pstruct->acquireCount,  vinfo_pAcquireKeys);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pAcquireTimeouts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAcquireTimeouts:               "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pAcquireTimeouts == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAcquireTimeouts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAcquireTimeouts = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pAcquireTimeouts.GetPointer()), "pAcquireTimeouts", pstruct->acquireCount,  vinfo_pAcquireTimeouts);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t releaseCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "releaseCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->releaseCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDeviceMemory* pReleaseSyncs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pReleaseSyncs:                  "); //HRW
    OutputString(outputFile, "const VkDeviceMemory* = "); //TEQ
    if (pstruct->pReleaseSyncs == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pReleaseSyncs.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pReleaseSyncs = {true, false, false, nullptr};
        ArrayToString<const VkDeviceMemory*>(outputFile, indent, 1, "const VkDeviceMemory*", reinterpret_cast<const VkDeviceMemory*>(pstruct_in.pReleaseSyncs.GetPointer()), "pReleaseSyncs", pstruct->releaseCount,  vinfo_pReleaseSyncs);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pReleaseKeys
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pReleaseKeys:                   "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pReleaseKeys == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pReleaseKeys.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pReleaseKeys = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pReleaseKeys.GetPointer()), "pReleaseKeys", pstruct->releaseCount,  vinfo_pReleaseKeys);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportSemaphoreWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphore:                      "); //HRW
    OutputString(outputFile, "VkSemaphore = "); //TEQ
    AddrToString(outputFile, pstruct_in.semaphore); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphoreImportFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSemaphoreImportFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSemaphoreImportFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* handle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handle:                         "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.handle); // PWR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const wchar_t* name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "const wchar_t* = "); //TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        WideStringToQuotedString(outputFile, pstruct->name); // RHP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportSemaphoreWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttributes:                    "); //HRW
    OutputString(outputFile, "const SECURITY_ATTRIBUTES* = "); //TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dwAccess:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dwAccess); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const wchar_t* name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "const wchar_t* = "); //TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        WideStringToQuotedString(outputFile, pstruct->name); // RHP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkD3D12FenceSubmitInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t waitSemaphoreValuesCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "waitSemaphoreValuesCount:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->waitSemaphoreValuesCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pWaitSemaphoreValues
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pWaitSemaphoreValues:           "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pWaitSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pstruct->waitSemaphoreValuesCount,  vinfo_pWaitSemaphoreValues);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t signalSemaphoreValuesCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "signalSemaphoreValuesCount:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->signalSemaphoreValuesCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pSignalSemaphoreValues
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSignalSemaphoreValues:         "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSignalSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pstruct->signalSemaphoreValuesCount,  vinfo_pSignalSemaphoreValues);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreGetWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphore:                      "); //HRW
    OutputString(outputFile, "VkSemaphore = "); //TEQ
    AddrToString(outputFile, pstruct_in.semaphore); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportSemaphoreFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphore:                      "); //HRW
    OutputString(outputFile, "VkSemaphore = "); //TEQ
    AddrToString(outputFile, pstruct_in.semaphore); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphoreImportFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSemaphoreImportFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSemaphoreImportFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: int fd
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fd:                             "); //HRW
    OutputString(outputFile, "int = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fd); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreGetFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphore:                      "); //HRW
    OutputString(outputFile, "VkSemaphore = "); //TEQ
    AddrToString(outputFile, pstruct_in.semaphore); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalSemaphoreHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePushDescriptorPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPushDescriptors
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPushDescriptors:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPushDescriptors); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderFloat16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderFloat16:                  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderFloat16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderInt8
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderInt8:                     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderInt8); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkRectLayerKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRectLayerKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkOffset2D offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkOffset2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.offset, indent+1,  base_addr + offsetof(VkRectLayerKHR, offset)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D extent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extent:                         "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkRectLayerKHR, extent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t layer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layer:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->layer); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPresentRegionKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentRegionKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t rectangleCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rectangleCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->rectangleCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkRectLayerKHR* pRectangles
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pRectangles:                    "); //HRW
    OutputString(outputFile, "const VkRectLayerKHR* = "); //TEQ
    if (pstruct->pRectangles == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pRectangles->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRectLayerKHR>(outputFile, indent+1, 1, "VkRectLayerKHR", pstruct_in.pRectangles->GetMetaStructPointer(), "pRectangles", pstruct->rectangleCount, false, pstruct_in.pRectangles->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPresentRegionsKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentRegionsKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t swapchainCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "swapchainCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->swapchainCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPresentRegionKHR* pRegions
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pRegions:                       "); //HRW
    OutputString(outputFile, "const VkPresentRegionKHR* = "); //TEQ
    if (pstruct->pRegions == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pRegions->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPresentRegionKHR>(outputFile, indent+1, 1, "VkPresentRegionKHR", pstruct_in.pRegions->GetMetaStructPointer(), "pRegions", pstruct->swapchainCount, false, pstruct_in.pRegions->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImagelessFramebufferFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImagelessFramebufferFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 imagelessFramebuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imagelessFramebuffer:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->imagelessFramebuffer); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkFramebufferAttachmentImageInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferAttachmentImageInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkImageCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkImageCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "usage:                          "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t width
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "width:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->width); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t height
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "height:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->height); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t layerCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layerCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->layerCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewFormatCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewFormatCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewFormatCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkFormat* pViewFormats
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewFormats:                   "); //HRW
    OutputString(outputFile, "const VkFormat* = "); //TEQ
    if (pstruct->pViewFormats == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewFormats.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pViewFormats = {false, true, false, EnumToStringVkFormat};
        ArrayToString<const VkFormat*>(outputFile, indent, 1, "const VkFormat*", reinterpret_cast<const VkFormat*>(pstruct_in.pViewFormats.GetPointer()), "pViewFormats", pstruct->viewFormatCount,  vinfo_pViewFormats);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkFramebufferAttachmentsCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferAttachmentsCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachmentImageInfoCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentImageInfoCount:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentImageInfoCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkFramebufferAttachmentImageInfoKHR* pAttachmentImageInfos
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttachmentImageInfos:          "); //HRW
    OutputString(outputFile, "const VkFramebufferAttachmentImageInfoKHR* = "); //TEQ
    if (pstruct->pAttachmentImageInfos == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAttachmentImageInfos->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkFramebufferAttachmentImageInfoKHR>(outputFile, indent+1, 1, "VkFramebufferAttachmentImageInfoKHR", pstruct_in.pAttachmentImageInfos->GetMetaStructPointer(), "pAttachmentImageInfos", pstruct->attachmentImageInfoCount, false, pstruct_in.pAttachmentImageInfos->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassAttachmentBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassAttachmentBeginInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkImageView* pAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttachments:                   "); //HRW
    OutputString(outputFile, "const VkImageView* = "); //TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAttachments.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAttachments = {true, false, false, nullptr};
        ArrayToString<const VkImageView*>(outputFile, indent, 1, "const VkImageView*", reinterpret_cast<const VkImageView*>(pstruct_in.pAttachments.GetPointer()), "pAttachments", pstruct->attachmentCount,  vinfo_pAttachments);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentDescription2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentDescriptionFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkAttachmentDescriptionFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkAttachmentDescriptionFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "samples:                        "); //HRW
    OutputString(outputFile, "VkSampleCountFlagBits = "); //TEQ
    EnumToStringVkSampleCountFlagBits(outputFile, pstruct->samples); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->samples);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentLoadOp loadOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "loadOp:                         "); //HRW
    OutputString(outputFile, "VkAttachmentLoadOp = "); //TEQ
    EnumToStringVkAttachmentLoadOp(outputFile, pstruct->loadOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->loadOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentStoreOp storeOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storeOp:                        "); //HRW
    OutputString(outputFile, "VkAttachmentStoreOp = "); //TEQ
    EnumToStringVkAttachmentStoreOp(outputFile, pstruct->storeOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->storeOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentLoadOp stencilLoadOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilLoadOp:                  "); //HRW
    OutputString(outputFile, "VkAttachmentLoadOp = "); //TEQ
    EnumToStringVkAttachmentLoadOp(outputFile, pstruct->stencilLoadOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilLoadOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentStoreOp stencilStoreOp
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilStoreOp:                 "); //HRW
    OutputString(outputFile, "VkAttachmentStoreOp = "); //TEQ
    EnumToStringVkAttachmentStoreOp(outputFile, pstruct->stencilStoreOp); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilStoreOp);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout initialLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "initialLayout:                  "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->initialLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->initialLayout);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout finalLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "finalLayout:                    "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->finalLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->finalLayout);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentReference2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachment:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachment); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout layout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layout:                         "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->layout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->layout);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aspectMask:                     "); //HRW
    OutputString(outputFile, "VkImageAspectFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDescription2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSubpassDescriptionFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSubpassDescriptionFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSubpassDescriptionFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineBindPoint:              "); //HRW
    OutputString(outputFile, "VkPipelineBindPoint = "); //TEQ
    EnumToStringVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->pipelineBindPoint);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewMask:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewMask); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t inputAttachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "inputAttachmentCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->inputAttachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference2KHR* pInputAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pInputAttachments:              "); //HRW
    OutputString(outputFile, "const VkAttachmentReference2KHR* = "); //TEQ
    if (pstruct->pInputAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pInputAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(outputFile, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t colorAttachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "colorAttachmentCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->colorAttachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference2KHR* pColorAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pColorAttachments:              "); //HRW
    OutputString(outputFile, "const VkAttachmentReference2KHR* = "); //TEQ
    if (pstruct->pColorAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pColorAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(outputFile, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference2KHR* pResolveAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pResolveAttachments:            "); //HRW
    OutputString(outputFile, "const VkAttachmentReference2KHR* = "); //TEQ
    if (pstruct->pResolveAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pResolveAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(outputFile, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference2KHR* pDepthStencilAttachment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDepthStencilAttachment:        "); //HRW
    OutputString(outputFile, "const VkAttachmentReference2KHR* = "); //TEQ
    if (pstruct->pDepthStencilAttachment == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDepthStencilAttachment->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkSubpassDescription2KHR, pDepthStencilAttachment)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t preserveAttachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "preserveAttachmentCount:        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->preserveAttachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pPreserveAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPreserveAttachments:           "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pPreserveAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPreserveAttachments.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pstruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDependency2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t srcSubpass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcSubpass:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->srcSubpass); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dstSubpass
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstSubpass:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dstSubpass); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineStageFlags srcStageMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcStageMask:                   "); //HRW
    OutputString(outputFile, "VkPipelineStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineStageFlags dstStageMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstStageMask:                   "); //HRW
    OutputString(outputFile, "VkPipelineStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstAccessMask:                  "); //HRW
    OutputString(outputFile, "VkAccessFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDependencyFlags dependencyFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dependencyFlags:                "); //HRW
    OutputString(outputFile, "VkDependencyFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->dependencyFlags, EnumToStringVkDependencyFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t viewOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewOffset:                     "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->viewOffset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassCreateInfo2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRenderPassCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkRenderPassCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkRenderPassCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentDescription2KHR* pAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttachments:                   "); //HRW
    OutputString(outputFile, "const VkAttachmentDescription2KHR* = "); //TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentDescription2KHR>(outputFile, indent+1, 1, "VkAttachmentDescription2KHR", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subpassCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subpassCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subpassCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSubpassDescription2KHR* pSubpasses
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSubpasses:                     "); //HRW
    OutputString(outputFile, "const VkSubpassDescription2KHR* = "); //TEQ
    if (pstruct->pSubpasses == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSubpasses->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDescription2KHR>(outputFile, indent+1, 1, "VkSubpassDescription2KHR", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dependencyCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dependencyCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dependencyCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSubpassDependency2KHR* pDependencies
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDependencies:                  "); //HRW
    OutputString(outputFile, "const VkSubpassDependency2KHR* = "); //TEQ
    if (pstruct->pDependencies == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDependencies->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDependency2KHR>(outputFile, indent+1, 1, "VkSubpassDependency2KHR", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t correlatedViewMaskCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "correlatedViewMaskCount:        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->correlatedViewMaskCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pCorrelatedViewMasks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCorrelatedViewMasks:           "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pCorrelatedViewMasks == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCorrelatedViewMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCorrelatedViewMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCorrelatedViewMasks.GetPointer()), "pCorrelatedViewMasks", pstruct->correlatedViewMaskCount,  vinfo_pCorrelatedViewMasks);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassBeginInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSubpassContents contents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "contents:                       "); //HRW
    OutputString(outputFile, "VkSubpassContents = "); //TEQ
    EnumToStringVkSubpassContents(outputFile, pstruct->contents); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->contents);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassEndInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSharedPresentSurfaceCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags sharedPresentSupportedUsageFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sharedPresentSupportedUsageFlags: "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->sharedPresentSupportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportFenceWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFence fence
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fence:                          "); //HRW
    OutputString(outputFile, "VkFence = "); //TEQ
    AddrToString(outputFile, pstruct_in.fence); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFenceImportFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkFenceImportFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkFenceImportFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* handle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handle:                         "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.handle); // PWR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const wchar_t* name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "const wchar_t* = "); //TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        WideStringToQuotedString(outputFile, pstruct->name); // RHP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportFenceWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttributes:                    "); //HRW
    OutputString(outputFile, "const SECURITY_ATTRIBUTES* = "); //TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dwAccess:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dwAccess); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const wchar_t* name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "const wchar_t* = "); //TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        WideStringToQuotedString(outputFile, pstruct->name); // RHP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFenceGetWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFence fence
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fence:                          "); //HRW
    OutputString(outputFile, "VkFence = "); //TEQ
    AddrToString(outputFile, pstruct_in.fence); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportFenceFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFence fence
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fence:                          "); //HRW
    OutputString(outputFile, "VkFence = "); //TEQ
    AddrToString(outputFile, pstruct_in.fence); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFenceImportFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkFenceImportFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkFenceImportFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: int fd
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fd:                             "); //HRW
    OutputString(outputFile, "int = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fd); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFenceGetFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFence fence
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fence:                          "); //HRW
    OutputString(outputFile, "VkFence = "); //TEQ
    AddrToString(outputFile, pstruct_in.fence); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalFenceHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSurfaceInfo2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceKHR surface
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "surface:                        "); //HRW
    OutputString(outputFile, "VkSurfaceKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.surface); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilities2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceCapabilitiesKHR surfaceCapabilities
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "surfaceCapabilities:            "); //HRW
    OutputString(outputFile, "VkSurfaceCapabilitiesKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.surfaceCapabilities, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2KHR, surfaceCapabilities)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFormat2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceFormatKHR surfaceFormat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "surfaceFormat:                  "); //HRW
    OutputString(outputFile, "VkSurfaceFormatKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.surfaceFormat, indent+1,  base_addr + offsetof(VkSurfaceFormat2KHR, surfaceFormat)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayProperties2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayPropertiesKHR displayProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayProperties:              "); //HRW
    OutputString(outputFile, "VkDisplayPropertiesKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.displayProperties, indent+1,  base_addr + offsetof(VkDisplayProperties2KHR, displayProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneProperties2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayPlanePropertiesKHR displayPlaneProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayPlaneProperties:         "); //HRW
    OutputString(outputFile, "VkDisplayPlanePropertiesKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.displayPlaneProperties, indent+1,  base_addr + offsetof(VkDisplayPlaneProperties2KHR, displayPlaneProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModeProperties2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayModePropertiesKHR displayModeProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayModeProperties:          "); //HRW
    OutputString(outputFile, "VkDisplayModePropertiesKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.displayModeProperties, indent+1,  base_addr + offsetof(VkDisplayModeProperties2KHR, displayModeProperties)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneInfo2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayModeKHR mode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "mode:                           "); //HRW
    OutputString(outputFile, "VkDisplayModeKHR = "); //TEQ
    AddrToString(outputFile, pstruct_in.mode); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t planeIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "planeIndex:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->planeIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneCapabilities2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayPlaneCapabilitiesKHR capabilities
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "capabilities:                   "); //HRW
    OutputString(outputFile, "VkDisplayPlaneCapabilitiesKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.capabilities, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilities2KHR, capabilities)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkImageFormatListCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageFormatListCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewFormatCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewFormatCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewFormatCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkFormat* pViewFormats
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewFormats:                   "); //HRW
    OutputString(outputFile, "const VkFormat* = "); //TEQ
    if (pstruct->pViewFormats == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewFormats.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pViewFormats = {false, true, false, EnumToStringVkFormat};
        ArrayToString<const VkFormat*>(outputFile, indent, 1, "const VkFormat*", reinterpret_cast<const VkFormat*>(pstruct_in.pViewFormats.GetPointer()), "pViewFormats", pstruct->viewFormatCount,  vinfo_pViewFormats);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSubgroupExtendedTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSubgroupExtendedTypes:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSubgroupExtendedTypes); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevice8BitStorageFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevice8BitStorageFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 storageBuffer8BitAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storageBuffer8BitAccess:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->storageBuffer8BitAccess); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 uniformAndStorageBuffer8BitAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "uniformAndStorageBuffer8BitAccess: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->uniformAndStorageBuffer8BitAccess); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 storagePushConstant8
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storagePushConstant8:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->storagePushConstant8); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderBufferInt64Atomics
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderBufferInt64Atomics:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderBufferInt64Atomics); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSharedInt64Atomics
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSharedInt64Atomics:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSharedInt64Atomics); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderClockFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSubgroupClock
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSubgroupClock:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSubgroupClock); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDeviceClock
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDeviceClock:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDeviceClock); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkConformanceVersionKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkConformanceVersionKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint8_t major
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "major:                          "); //HRW
    OutputString(outputFile, "uint8_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->major); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint8_t minor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minor:                          "); //HRW
    OutputString(outputFile, "uint8_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minor); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint8_t subminor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subminor:                       "); //HRW
    OutputString(outputFile, "uint8_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subminor); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint8_t patch
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "patch:                          "); //HRW
    OutputString(outputFile, "uint8_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->patch); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDriverPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDriverPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDriverIdKHR driverID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "driverID:                       "); //HRW
    OutputString(outputFile, "VkDriverIdKHR = "); //TEQ
    EnumToStringVkDriverIdKHR(outputFile, pstruct->driverID); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->driverID);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: char driverName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "driverName:                     "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_driverName = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->driverName), "driverName", VK_MAX_DRIVER_NAME_SIZE_KHR, vinfo_driverName); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: char driverInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "driverInfo:                     "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_driverInfo = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->driverInfo), "driverInfo", VK_MAX_DRIVER_INFO_SIZE_KHR, vinfo_driverInfo); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkConformanceVersionKHR conformanceVersion
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "conformanceVersion:             "); //HRW
    OutputString(outputFile, "VkConformanceVersionKHR = "); //TEQ
    StructureToString(outputFile, *pstruct_in.conformanceVersion, indent+1,  base_addr + offsetof(VkPhysicalDeviceDriverPropertiesKHR, conformanceVersion)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFloatControlsPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFloatControlsPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderFloatControlsIndependenceKHR denormBehaviorIndependence
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "denormBehaviorIndependence:     "); //HRW
    OutputString(outputFile, "VkShaderFloatControlsIndependenceKHR = "); //TEQ
    EnumToStringVkShaderFloatControlsIndependenceKHR(outputFile, pstruct->denormBehaviorIndependence); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->denormBehaviorIndependence);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderFloatControlsIndependenceKHR roundingModeIndependence
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "roundingModeIndependence:       "); //HRW
    OutputString(outputFile, "VkShaderFloatControlsIndependenceKHR = "); //TEQ
    EnumToStringVkShaderFloatControlsIndependenceKHR(outputFile, pstruct->roundingModeIndependence); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->roundingModeIndependence);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSignedZeroInfNanPreserveFloat16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSignedZeroInfNanPreserveFloat16: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSignedZeroInfNanPreserveFloat16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSignedZeroInfNanPreserveFloat32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSignedZeroInfNanPreserveFloat32: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSignedZeroInfNanPreserveFloat32); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSignedZeroInfNanPreserveFloat64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSignedZeroInfNanPreserveFloat64: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSignedZeroInfNanPreserveFloat64); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDenormPreserveFloat16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDenormPreserveFloat16:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDenormPreserveFloat16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDenormPreserveFloat32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDenormPreserveFloat32:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDenormPreserveFloat32); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDenormPreserveFloat64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDenormPreserveFloat64:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDenormPreserveFloat64); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDenormFlushToZeroFloat16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDenormFlushToZeroFloat16: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDenormFlushToZeroFloat16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDenormFlushToZeroFloat32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDenormFlushToZeroFloat32: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDenormFlushToZeroFloat32); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDenormFlushToZeroFloat64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDenormFlushToZeroFloat64: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDenormFlushToZeroFloat64); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderRoundingModeRTEFloat16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderRoundingModeRTEFloat16:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderRoundingModeRTEFloat16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderRoundingModeRTEFloat32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderRoundingModeRTEFloat32:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderRoundingModeRTEFloat32); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderRoundingModeRTEFloat64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderRoundingModeRTEFloat64:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderRoundingModeRTEFloat64); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderRoundingModeRTZFloat16
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderRoundingModeRTZFloat16:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderRoundingModeRTZFloat16); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderRoundingModeRTZFloat32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderRoundingModeRTZFloat32:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderRoundingModeRTZFloat32); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderRoundingModeRTZFloat64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderRoundingModeRTZFloat64:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderRoundingModeRTZFloat64); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassDescriptionDepthStencilResolveKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDescriptionDepthStencilResolveKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkResolveModeFlagBitsKHR depthResolveMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthResolveMode:               "); //HRW
    OutputString(outputFile, "VkResolveModeFlagBitsKHR = "); //TEQ
    EnumToStringVkResolveModeFlagBitsKHR(outputFile, pstruct->depthResolveMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->depthResolveMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkResolveModeFlagBitsKHR stencilResolveMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilResolveMode:             "); //HRW
    OutputString(outputFile, "VkResolveModeFlagBitsKHR = "); //TEQ
    EnumToStringVkResolveModeFlagBitsKHR(outputFile, pstruct->stencilResolveMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilResolveMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentReference2KHR* pDepthStencilResolveAttachment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDepthStencilResolveAttachment: "); //HRW
    OutputString(outputFile, "const VkAttachmentReference2KHR* = "); //TEQ
    if (pstruct->pDepthStencilResolveAttachment == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDepthStencilResolveAttachment->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pDepthStencilResolveAttachment->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkSubpassDescriptionDepthStencilResolveKHR, pDepthStencilResolveAttachment)); // GLN
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthStencilResolvePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDepthStencilResolvePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkResolveModeFlagsKHR supportedDepthResolveModes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedDepthResolveModes:     "); //HRW
    OutputString(outputFile, "VkResolveModeFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedDepthResolveModes, EnumToStringVkResolveModeFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkResolveModeFlagsKHR supportedStencilResolveModes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedStencilResolveModes:   "); //HRW
    OutputString(outputFile, "VkResolveModeFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedStencilResolveModes, EnumToStringVkResolveModeFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 independentResolveNone
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "independentResolveNone:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->independentResolveNone); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 independentResolve
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "independentResolve:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->independentResolve); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 timelineSemaphore
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "timelineSemaphore:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->timelineSemaphore); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t maxTimelineSemaphoreValueDifference
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTimelineSemaphoreValueDifference: "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTimelineSemaphoreValueDifference); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreTypeCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphoreTypeKHR semaphoreType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphoreType:                  "); //HRW
    OutputString(outputFile, "VkSemaphoreTypeKHR = "); //TEQ
    EnumToStringVkSemaphoreTypeKHR(outputFile, pstruct->semaphoreType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->semaphoreType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t initialValue
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "initialValue:                   "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->initialValue); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkTimelineSemaphoreSubmitInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t waitSemaphoreValueCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "waitSemaphoreValueCount:        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->waitSemaphoreValueCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pWaitSemaphoreValues
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pWaitSemaphoreValues:           "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pWaitSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pstruct->waitSemaphoreValueCount,  vinfo_pWaitSemaphoreValues);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t signalSemaphoreValueCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "signalSemaphoreValueCount:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->signalSemaphoreValueCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pSignalSemaphoreValues
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSignalSemaphoreValues:         "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSignalSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pstruct->signalSemaphoreValueCount,  vinfo_pSignalSemaphoreValues);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreWaitInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphoreWaitFlagsKHR flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkSemaphoreWaitFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkSemaphoreWaitFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t semaphoreCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphoreCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->semaphoreCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSemaphore* pSemaphores
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSemaphores:                    "); //HRW
    OutputString(outputFile, "const VkSemaphore* = "); //TEQ
    if (pstruct->pSemaphores == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(outputFile, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSemaphores.GetPointer()), "pSemaphores", pstruct->semaphoreCount,  vinfo_pSemaphores);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pValues
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pValues:                        "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pValues == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pValues.GetPointer()), "pValues", pstruct->semaphoreCount,  vinfo_pValues);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreSignalInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "semaphore:                      "); //HRW
    OutputString(outputFile, "VkSemaphore = "); //TEQ
    AddrToString(outputFile, pstruct_in.semaphore); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t value
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "value:                          "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->value); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 vulkanMemoryModel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vulkanMemoryModel:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vulkanMemoryModel); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 vulkanMemoryModelDeviceScope
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vulkanMemoryModelDeviceScope:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vulkanMemoryModelDeviceScope); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 vulkanMemoryModelAvailabilityVisibilityChains
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vulkanMemoryModelAvailabilityVisibilityChains: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vulkanMemoryModelAvailabilityVisibilityChains); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceProtectedCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceProtectedCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 supportsProtected
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportsProtected:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->supportsProtected); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 separateDepthStencilLayouts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "separateDepthStencilLayouts:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->separateDepthStencilLayouts); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkAttachmentReferenceStencilLayoutKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentReferenceStencilLayoutKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout stencilLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilLayout:                  "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->stencilLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilLayout);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkAttachmentDescriptionStencilLayoutKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentDescriptionStencilLayoutKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout stencilInitialLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilInitialLayout:           "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->stencilInitialLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilInitialLayout);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageLayout stencilFinalLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilFinalLayout:             "); //HRW
    OutputString(outputFile, "VkImageLayout = "); //TEQ
    EnumToStringVkImageLayout(outputFile, pstruct->stencilFinalLayout); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stencilFinalLayout);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 uniformBufferStandardLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "uniformBufferStandardLayout:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->uniformBufferStandardLayout); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 pipelineExecutableInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineExecutableInfo:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->pipelineExecutableInfo); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipeline pipeline
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipeline:                       "); //HRW
    OutputString(outputFile, "VkPipeline = "); //TEQ
    AddrToString(outputFile, pstruct_in.pipeline); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutablePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderStageFlags stages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stages:                         "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->stages, EnumToStringVkShaderStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: char name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: char description
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "description:                    "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t subgroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subgroupSize:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subgroupSize); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipeline pipeline
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipeline:                       "); //HRW
    OutputString(outputFile, "VkPipeline = "); //TEQ
    AddrToString(outputFile, pstruct_in.pipeline); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t executableIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "executableIndex:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->executableIndex); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableStatisticValueKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkBool32 b32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "b32:                            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->b32); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: int64_t i64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "i64:                            "); //HRW
    OutputString(outputFile, "int64_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->i64); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t u64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "u64:                            "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->u64); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: double f64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "f64:                            "); //HRW
    OutputString(outputFile, "double = "); //TEQ
    DoubleToString(outputFile, pstruct->f64); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableStatisticKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: char name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: char description
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "description:                    "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineExecutableStatisticFormatKHR format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkPipelineExecutableStatisticFormatKHR = "); //TEQ
    EnumToStringVkPipelineExecutableStatisticFormatKHR(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineExecutableStatisticValueKHR value
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "value:                          "); //HRW
    OutputString(outputFile, "VkPipelineExecutableStatisticValueKHR = "); //TEQ
    OutputString(outputFile, "(Union):"); // RGT
    StructureToString(outputFile, *pstruct_in.value, indent+1,  base_addr + offsetof(VkPipelineExecutableStatisticKHR, value)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableInternalRepresentationKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: char name
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "name:                           "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: char description
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "description:                    "); //HRW
    OutputString(outputFile, "char = "); //TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(outputFile, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 isText
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "isText:                         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->isText); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t dataSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dataSize:                       "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dataSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pData:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pData == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pData.GetAddress()); // AHW
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugReportCallbackCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDebugReportFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDebugReportFlagsEXT = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkDebugReportFlagBitsEXT); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: PFN_vkDebugReportCallbackEXT pfnCallback
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pfnCallback:                    "); //HRW
    OutputString(outputFile, "PFN_vkDebugReportCallbackEXT = "); //TEQ
    AddrToString(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnCallback)); // WRX
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pUserData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pUserData:                      "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pUserData); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationStateRasterizationOrderAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRasterizationOrderAMD rasterizationOrder
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rasterizationOrder:             "); //HRW
    OutputString(outputFile, "VkRasterizationOrderAMD = "); //TEQ
    EnumToStringVkRasterizationOrderAMD(outputFile, pstruct->rasterizationOrder); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->rasterizationOrder);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugMarkerObjectNameInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDebugReportObjectTypeEXT objectType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectType:                     "); //HRW
    OutputString(outputFile, "VkDebugReportObjectTypeEXT = "); //TEQ
    EnumToStringVkDebugReportObjectTypeEXT(outputFile, pstruct->objectType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->objectType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t object
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "object:                         "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->object); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pObjectName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pObjectName:                    "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pObjectName); // TGI
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugMarkerObjectTagInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDebugReportObjectTypeEXT objectType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectType:                     "); //HRW
    OutputString(outputFile, "VkDebugReportObjectTypeEXT = "); //TEQ
    EnumToStringVkDebugReportObjectTypeEXT(outputFile, pstruct->objectType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->objectType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t object
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "object:                         "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->object); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t tagName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tagName:                        "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->tagName); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t tagSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tagSize:                        "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->tagSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pTag
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pTag:                           "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pTag == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pTag.GetAddress()); // AHW
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugMarkerMarkerInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pMarkerName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pMarkerName:                    "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pMarkerName); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: float color
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "color:                          "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "4"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.color.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_color = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->color), "color", 4, vinfo_color); // JPA
}

void StructureToString(FILE* outputFile, const Decoded_VkDedicatedAllocationImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDedicatedAllocationImageCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 dedicatedAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dedicatedAllocation:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->dedicatedAllocation); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDedicatedAllocationBufferCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDedicatedAllocationBufferCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 dedicatedAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dedicatedAllocation:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->dedicatedAllocation); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDedicatedAllocationMemoryAllocateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImage image
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "image:                          "); //HRW
    OutputString(outputFile, "VkImage = "); //TEQ
    AddrToString(outputFile, pstruct_in.image); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 transformFeedback
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transformFeedback:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->transformFeedback); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 geometryStreams
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "geometryStreams:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->geometryStreams); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTransformFeedbackStreams
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTransformFeedbackStreams:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTransformFeedbackStreams); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTransformFeedbackBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTransformFeedbackBuffers:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTransformFeedbackBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize maxTransformFeedbackBufferSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTransformFeedbackBufferSize: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->maxTransformFeedbackBufferSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTransformFeedbackStreamDataSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTransformFeedbackStreamDataSize: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTransformFeedbackStreamDataSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTransformFeedbackBufferDataSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTransformFeedbackBufferDataSize: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTransformFeedbackBufferDataSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTransformFeedbackBufferDataStride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTransformFeedbackBufferDataStride: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTransformFeedbackBufferDataStride); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 transformFeedbackQueries
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transformFeedbackQueries:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->transformFeedbackQueries); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 transformFeedbackStreamsLinesTriangles
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transformFeedbackStreamsLinesTriangles: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->transformFeedbackStreamsLinesTriangles); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 transformFeedbackRasterizationStreamSelect
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transformFeedbackRasterizationStreamSelect: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->transformFeedbackRasterizationStreamSelect); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 transformFeedbackDraw
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transformFeedbackDraw:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->transformFeedbackDraw); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationStateStreamCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineRasterizationStateStreamCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineRasterizationStateStreamCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t rasterizationStream
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rasterizationStream:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->rasterizationStream); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewHandleInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageView imageView
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageView:                      "); //HRW
    OutputString(outputFile, "VkImageView = "); //TEQ
    AddrToString(outputFile, pstruct_in.imageView); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorType:                 "); //HRW
    OutputString(outputFile, "VkDescriptorType = "); //TEQ
    EnumToStringVkDescriptorType(outputFile, pstruct->descriptorType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->descriptorType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampler sampler
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampler:                        "); //HRW
    OutputString(outputFile, "VkSampler = "); //TEQ
    AddrToString(outputFile, pstruct_in.sampler); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkTextureLODGatherFormatPropertiesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkTextureLODGatherFormatPropertiesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 supportsTextureGatherLODBiasAMD
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportsTextureGatherLODBiasAMD: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->supportsTextureGatherLODBiasAMD); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderResourceUsageAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t numUsedVgprs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "numUsedVgprs:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->numUsedVgprs); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t numUsedSgprs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "numUsedSgprs:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->numUsedSgprs); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t ldsSizePerLocalWorkGroup
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ldsSizePerLocalWorkGroup:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->ldsSizePerLocalWorkGroup); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t ldsUsageSizeInBytes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ldsUsageSizeInBytes:            "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->ldsUsageSizeInBytes); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t scratchMemUsageInBytes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "scratchMemUsageInBytes:         "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->scratchMemUsageInBytes); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderStatisticsInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkShaderStageFlags shaderStageMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStageMask:                "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->shaderStageMask, EnumToStringVkShaderStageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderResourceUsageAMD resourceUsage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "resourceUsage:                  "); //HRW
    OutputString(outputFile, "VkShaderResourceUsageAMD = "); //TEQ
    StructureToString(outputFile, *pstruct_in.resourceUsage, indent+1,  base_addr + offsetof(VkShaderStatisticsInfoAMD, resourceUsage)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t numPhysicalVgprs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "numPhysicalVgprs:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->numPhysicalVgprs); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t numPhysicalSgprs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "numPhysicalSgprs:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->numPhysicalSgprs); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t numAvailableVgprs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "numAvailableVgprs:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->numAvailableVgprs); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t numAvailableSgprs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "numAvailableSgprs:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->numAvailableSgprs); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t computeWorkGroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "computeWorkGroupSize:           "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "3"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.computeWorkGroupSize.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_computeWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->computeWorkGroupSize), "computeWorkGroupSize", 3, vinfo_computeWorkGroupSize); // JPA
}

void StructureToString(FILE* outputFile, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr)
{
    const VkStreamDescriptorSurfaceCreateInfoGGP *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkStreamDescriptorSurfaceCreateFlagsGGP flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkStreamDescriptorSurfaceCreateFlagsGGP = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t streamDescriptor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "streamDescriptor:               "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->streamDescriptor); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCornerSampledImageFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 cornerSampledImage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "cornerSampledImage:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->cornerSampledImage); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalImageFormatPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkImageFormatProperties imageFormatProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageFormatProperties:          "); //HRW
    OutputString(outputFile, "VkImageFormatProperties = "); //TEQ
    StructureToString(outputFile, *pstruct_in.imageFormatProperties, indent+1,  base_addr + offsetof(VkExternalImageFormatPropertiesNV, imageFormatProperties)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryFeatureFlagsNV externalMemoryFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalMemoryFeatures:         "); //HRW
    OutputString(outputFile, "VkExternalMemoryFeatureFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->externalMemoryFeatures, EnumToStringVkExternalMemoryFeatureFlagBitsNV); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "exportFromImportedHandleTypes:  "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compatibleHandleTypes:          "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->compatibleHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryImageCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV handleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleTypes:                    "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryAllocateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV handleTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleTypes:                    "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryWin32HandleInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->handleType, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* handle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handle:                         "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.handle); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryWin32HandleInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttributes:                    "); //HRW
    OutputString(outputFile, "const SECURITY_ATTRIBUTES* = "); //TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dwAccess:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dwAccess); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWin32KeyedMutexAcquireReleaseInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t acquireCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "acquireCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->acquireCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDeviceMemory* pAcquireSyncs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAcquireSyncs:                  "); //HRW
    OutputString(outputFile, "const VkDeviceMemory* = "); //TEQ
    if (pstruct->pAcquireSyncs == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAcquireSyncs.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAcquireSyncs = {true, false, false, nullptr};
        ArrayToString<const VkDeviceMemory*>(outputFile, indent, 1, "const VkDeviceMemory*", reinterpret_cast<const VkDeviceMemory*>(pstruct_in.pAcquireSyncs.GetPointer()), "pAcquireSyncs", pstruct->acquireCount,  vinfo_pAcquireSyncs);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pAcquireKeys
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAcquireKeys:                   "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pAcquireKeys == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAcquireKeys.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAcquireKeys = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pAcquireKeys.GetPointer()), "pAcquireKeys", pstruct->acquireCount,  vinfo_pAcquireKeys);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pAcquireTimeoutMilliseconds
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAcquireTimeoutMilliseconds:    "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pAcquireTimeoutMilliseconds == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAcquireTimeoutMilliseconds.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAcquireTimeoutMilliseconds = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pAcquireTimeoutMilliseconds.GetPointer()), "pAcquireTimeoutMilliseconds", pstruct->acquireCount,  vinfo_pAcquireTimeoutMilliseconds);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t releaseCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "releaseCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->releaseCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDeviceMemory* pReleaseSyncs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pReleaseSyncs:                  "); //HRW
    OutputString(outputFile, "const VkDeviceMemory* = "); //TEQ
    if (pstruct->pReleaseSyncs == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pReleaseSyncs.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pReleaseSyncs = {true, false, false, nullptr};
        ArrayToString<const VkDeviceMemory*>(outputFile, indent, 1, "const VkDeviceMemory*", reinterpret_cast<const VkDeviceMemory*>(pstruct_in.pReleaseSyncs.GetPointer()), "pReleaseSyncs", pstruct->releaseCount,  vinfo_pReleaseSyncs);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pReleaseKeys
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pReleaseKeys:                   "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pReleaseKeys == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pReleaseKeys.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pReleaseKeys = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pReleaseKeys.GetPointer()), "pReleaseKeys", pstruct->releaseCount,  vinfo_pReleaseKeys);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkValidationFlagsEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkValidationFlagsEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t disabledValidationCheckCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "disabledValidationCheckCount:   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->disabledValidationCheckCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkValidationCheckEXT* pDisabledValidationChecks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDisabledValidationChecks:      "); //HRW
    OutputString(outputFile, "const VkValidationCheckEXT* = "); //TEQ
    if (pstruct->pDisabledValidationChecks == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDisabledValidationChecks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDisabledValidationChecks = {false, true, false, EnumToStringVkValidationCheckEXT};
        ArrayToString<const VkValidationCheckEXT*>(outputFile, indent, 1, "const VkValidationCheckEXT*", reinterpret_cast<const VkValidationCheckEXT*>(pstruct_in.pDisabledValidationChecks.GetPointer()), "pDisabledValidationChecks", pstruct->disabledValidationCheckCount,  vinfo_pDisabledValidationChecks);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViSurfaceCreateInfoNN *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkViSurfaceCreateFlagsNN flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkViSurfaceCreateFlagsNN = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* window
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "window:                         "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->window == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.window); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 textureCompressionASTC_HDR
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "textureCompressionASTC_HDR:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->textureCompressionASTC_HDR); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkImageViewASTCDecodeModeEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewASTCDecodeModeEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat decodeMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "decodeMode:                     "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->decodeMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->decodeMode);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceASTCDecodeFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 decodeModeSharedExponent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "decodeModeSharedExponent:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->decodeModeSharedExponent); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkConditionalRenderingBeginInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkConditionalRenderingFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkConditionalRenderingFlagsEXT = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkConditionalRenderingFlagBitsEXT); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 conditionalRendering
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "conditionalRendering:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->conditionalRendering); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 inheritedConditionalRendering
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "inheritedConditionalRendering:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->inheritedConditionalRendering); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 conditionalRenderingEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "conditionalRenderingEnable:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->conditionalRenderingEnable); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGeneratedCommandsFeaturesNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 computeBindingPointSupport
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "computeBindingPointSupport:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->computeBindingPointSupport); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGeneratedCommandsLimitsNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxIndirectCommandsLayoutTokenCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxIndirectCommandsLayoutTokenCount: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxIndirectCommandsLayoutTokenCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxObjectEntryCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxObjectEntryCounts:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxObjectEntryCounts); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minSequenceCountBufferOffsetAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minSequenceCountBufferOffsetAlignment: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minSequenceCountBufferOffsetAlignment); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minSequenceIndexBufferOffsetAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minSequenceIndexBufferOffsetAlignment: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minSequenceIndexBufferOffsetAlignment); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minCommandsTokenBufferOffsetAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minCommandsTokenBufferOffsetAlignment: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minCommandsTokenBufferOffsetAlignment); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIndirectCommandsTokenNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkIndirectCommandsTokenTypeNVX tokenType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tokenType:                      "); //HRW
    OutputString(outputFile, "VkIndirectCommandsTokenTypeNVX = "); //TEQ
    EnumToStringVkIndirectCommandsTokenTypeNVX(outputFile, pstruct->tokenType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->tokenType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIndirectCommandsLayoutTokenNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkIndirectCommandsTokenTypeNVX tokenType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tokenType:                      "); //HRW
    OutputString(outputFile, "VkIndirectCommandsTokenTypeNVX = "); //TEQ
    EnumToStringVkIndirectCommandsTokenTypeNVX(outputFile, pstruct->tokenType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->tokenType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bindingUnit
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bindingUnit:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bindingUnit); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dynamicCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dynamicCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dynamicCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t divisor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "divisor:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->divisor); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIndirectCommandsLayoutCreateInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineBindPoint:              "); //HRW
    OutputString(outputFile, "VkPipelineBindPoint = "); //TEQ
    EnumToStringVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->pipelineBindPoint);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkIndirectCommandsLayoutUsageFlagsNVX flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkIndirectCommandsLayoutUsageFlagsNVX = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkIndirectCommandsLayoutUsageFlagBitsNVX); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t tokenCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tokenCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->tokenCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkIndirectCommandsLayoutTokenNVX* pTokens
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pTokens:                        "); //HRW
    OutputString(outputFile, "const VkIndirectCommandsLayoutTokenNVX* = "); //TEQ
    if (pstruct->pTokens == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pTokens->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(outputFile, indent+1, 1, "VkIndirectCommandsLayoutTokenNVX", pstruct_in.pTokens->GetMetaStructPointer(), "pTokens", pstruct->tokenCount, false, pstruct_in.pTokens->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCmdProcessCommandsInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectTableNVX objectTable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectTable:                    "); //HRW
    OutputString(outputFile, "VkObjectTableNVX = "); //TEQ
    AddrToString(outputFile, pstruct_in.objectTable); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkIndirectCommandsLayoutNVX indirectCommandsLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indirectCommandsLayout:         "); //HRW
    OutputString(outputFile, "VkIndirectCommandsLayoutNVX = "); //TEQ
    AddrToString(outputFile, pstruct_in.indirectCommandsLayout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t indirectCommandsTokenCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indirectCommandsTokenCount:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->indirectCommandsTokenCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkIndirectCommandsTokenNVX* pIndirectCommandsTokens
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pIndirectCommandsTokens:        "); //HRW
    OutputString(outputFile, "const VkIndirectCommandsTokenNVX* = "); //TEQ
    if (pstruct->pIndirectCommandsTokens == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pIndirectCommandsTokens->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkIndirectCommandsTokenNVX>(outputFile, indent+1, 1, "VkIndirectCommandsTokenNVX", pstruct_in.pIndirectCommandsTokens->GetMetaStructPointer(), "pIndirectCommandsTokens", pstruct->indirectCommandsTokenCount, false, pstruct_in.pIndirectCommandsTokens->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSequencesCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSequencesCount:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSequencesCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCommandBuffer targetCommandBuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "targetCommandBuffer:            "); //HRW
    OutputString(outputFile, "VkCommandBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.targetCommandBuffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer sequencesCountBuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sequencesCountBuffer:           "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.sequencesCountBuffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize sequencesCountOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sequencesCountOffset:           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sequencesCountOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer sequencesIndexBuffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sequencesIndexBuffer:           "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.sequencesIndexBuffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize sequencesIndexOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sequencesIndexOffset:           "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sequencesIndexOffset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCmdReserveSpaceForCommandsInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectTableNVX objectTable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectTable:                    "); //HRW
    OutputString(outputFile, "VkObjectTableNVX = "); //TEQ
    AddrToString(outputFile, pstruct_in.objectTable); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkIndirectCommandsLayoutNVX indirectCommandsLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indirectCommandsLayout:         "); //HRW
    OutputString(outputFile, "VkIndirectCommandsLayoutNVX = "); //TEQ
    AddrToString(outputFile, pstruct_in.indirectCommandsLayout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSequencesCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSequencesCount:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSequencesCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableCreateInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t objectCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectCount:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->objectCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkObjectEntryTypeNVX* pObjectEntryTypes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pObjectEntryTypes:              "); //HRW
    OutputString(outputFile, "const VkObjectEntryTypeNVX* = "); //TEQ
    if (pstruct->pObjectEntryTypes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pObjectEntryTypes.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectEntryTypes = {false, true, false, EnumToStringVkObjectEntryTypeNVX};
        ArrayToString<const VkObjectEntryTypeNVX*>(outputFile, indent, 1, "const VkObjectEntryTypeNVX*", reinterpret_cast<const VkObjectEntryTypeNVX*>(pstruct_in.pObjectEntryTypes.GetPointer()), "pObjectEntryTypes", pstruct->objectCount,  vinfo_pObjectEntryTypes);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pObjectEntryCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pObjectEntryCounts:             "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pObjectEntryCounts == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pObjectEntryCounts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectEntryCounts = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pObjectEntryCounts.GetPointer()), "pObjectEntryCounts", pstruct->objectCount,  vinfo_pObjectEntryCounts);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkObjectEntryUsageFlagsNVX* pObjectEntryUsageFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pObjectEntryUsageFlags:         "); //HRW
    OutputString(outputFile, "const VkObjectEntryUsageFlagsNVX* = "); //TEQ
    if (pstruct->pObjectEntryUsageFlags == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pObjectEntryUsageFlags.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectEntryUsageFlags = {false, false, true, EnumToStringVkObjectEntryUsageFlagBitsNVX};
        ArrayToString<const VkObjectEntryUsageFlagsNVX*>(outputFile, indent, 1, "const VkObjectEntryUsageFlagsNVX*", reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(pstruct_in.pObjectEntryUsageFlags.GetPointer()), "pObjectEntryUsageFlags", pstruct->objectCount,  vinfo_pObjectEntryUsageFlags);  // CCR
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxUniformBuffersPerDescriptor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxUniformBuffersPerDescriptor: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxUniformBuffersPerDescriptor); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxStorageBuffersPerDescriptor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxStorageBuffersPerDescriptor: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxStorageBuffersPerDescriptor); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxStorageImagesPerDescriptor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxStorageImagesPerDescriptor:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxStorageImagesPerDescriptor); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSampledImagesPerDescriptor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSampledImagesPerDescriptor:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSampledImagesPerDescriptor); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPipelineLayouts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPipelineLayouts:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPipelineLayouts); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkObjectEntryTypeNVX = "); //TEQ
    EnumToStringVkObjectEntryTypeNVX(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkObjectEntryUsageFlagsNVX = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTablePipelineEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkObjectEntryTypeNVX = "); //TEQ
    EnumToStringVkObjectEntryTypeNVX(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkObjectEntryUsageFlagsNVX = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipeline pipeline
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipeline:                       "); //HRW
    OutputString(outputFile, "VkPipeline = "); //TEQ
    AddrToString(outputFile, pstruct_in.pipeline); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableDescriptorSetEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkObjectEntryTypeNVX = "); //TEQ
    EnumToStringVkObjectEntryTypeNVX(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkObjectEntryUsageFlagsNVX = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineLayout pipelineLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineLayout:                 "); //HRW
    OutputString(outputFile, "VkPipelineLayout = "); //TEQ
    AddrToString(outputFile, pstruct_in.pipelineLayout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDescriptorSet descriptorSet
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorSet:                  "); //HRW
    OutputString(outputFile, "VkDescriptorSet = "); //TEQ
    AddrToString(outputFile, pstruct_in.descriptorSet); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableVertexBufferEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkObjectEntryTypeNVX = "); //TEQ
    EnumToStringVkObjectEntryTypeNVX(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkObjectEntryUsageFlagsNVX = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableIndexBufferEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkObjectEntryTypeNVX = "); //TEQ
    EnumToStringVkObjectEntryTypeNVX(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkObjectEntryUsageFlagsNVX = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkIndexType indexType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indexType:                      "); //HRW
    OutputString(outputFile, "VkIndexType = "); //TEQ
    EnumToStringVkIndexType(outputFile, pstruct->indexType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->indexType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTablePushConstantEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkObjectEntryTypeNVX = "); //TEQ
    EnumToStringVkObjectEntryTypeNVX(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkObjectEntryUsageFlagsNVX = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineLayout pipelineLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineLayout:                 "); //HRW
    OutputString(outputFile, "VkPipelineLayout = "); //TEQ
    AddrToString(outputFile, pstruct_in.pipelineLayout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderStageFlags stageFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stageFlags:                     "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViewportWScalingNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: float xcoeff
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "xcoeff:                         "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->xcoeff); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float ycoeff
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ycoeff:                         "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->ycoeff); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportWScalingStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 viewportWScalingEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewportWScalingEnable:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->viewportWScalingEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewportCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewportCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewportCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkViewportWScalingNV* pViewportWScalings
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewportWScalings:             "); //HRW
    OutputString(outputFile, "const VkViewportWScalingNV* = "); //TEQ
    if (pstruct->pViewportWScalings == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewportWScalings->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkViewportWScalingNV>(outputFile, indent+1, 1, "VkViewportWScalingNV", pstruct_in.pViewportWScalings->GetMetaStructPointer(), "pViewportWScalings", pstruct->viewportCount, false, pstruct_in.pViewportWScalings->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilities2EXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minImageCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minImageCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minImageCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D currentExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "currentExtent:                  "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.currentExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, currentExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D minImageExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minImageExtent:                 "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, minImageExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D maxImageExtent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageExtent:                 "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, maxImageExtent)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxImageArrayLayers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxImageArrayLayers:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxImageArrayLayers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedTransforms:            "); //HRW
    OutputString(outputFile, "VkSurfaceTransformFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR currentTransform
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "currentTransform:               "); //HRW
    OutputString(outputFile, "VkSurfaceTransformFlagBitsKHR = "); //TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(outputFile, pstruct->currentTransform); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->currentTransform);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCompositeAlphaFlagsKHR supportedCompositeAlpha
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedCompositeAlpha:        "); //HRW
    OutputString(outputFile, "VkCompositeAlphaFlagsKHR = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedCompositeAlpha, EnumToStringVkCompositeAlphaFlagBitsKHR); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags supportedUsageFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedUsageFlags:            "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceCounterFlagsEXT supportedSurfaceCounters
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "supportedSurfaceCounters:       "); //HRW
    OutputString(outputFile, "VkSurfaceCounterFlagsEXT = "); //TEQ
    FlagsToString(outputFile, pstruct->supportedSurfaceCounters, EnumToStringVkSurfaceCounterFlagBitsEXT); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPowerInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayPowerStateEXT powerState
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "powerState:                     "); //HRW
    OutputString(outputFile, "VkDisplayPowerStateEXT = "); //TEQ
    EnumToStringVkDisplayPowerStateEXT(outputFile, pstruct->powerState); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->powerState);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceEventInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceEventTypeEXT deviceEvent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceEvent:                    "); //HRW
    OutputString(outputFile, "VkDeviceEventTypeEXT = "); //TEQ
    EnumToStringVkDeviceEventTypeEXT(outputFile, pstruct->deviceEvent); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->deviceEvent);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayEventInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDisplayEventTypeEXT displayEvent
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayEvent:                   "); //HRW
    OutputString(outputFile, "VkDisplayEventTypeEXT = "); //TEQ
    EnumToStringVkDisplayEventTypeEXT(outputFile, pstruct->displayEvent); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->displayEvent);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSwapchainCounterCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSurfaceCounterFlagsEXT surfaceCounters
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "surfaceCounters:                "); //HRW
    OutputString(outputFile, "VkSurfaceCounterFlagsEXT = "); //TEQ
    FlagsToString(outputFile, pstruct->surfaceCounters, EnumToStringVkSurfaceCounterFlagBitsEXT); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRefreshCycleDurationGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint64_t refreshDuration
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "refreshDuration:                "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->refreshDuration); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPastPresentationTimingGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t presentID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "presentID:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->presentID); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t desiredPresentTime
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "desiredPresentTime:             "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->desiredPresentTime); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t actualPresentTime
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "actualPresentTime:              "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->actualPresentTime); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t earliestPresentTime
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "earliestPresentTime:            "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->earliestPresentTime); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t presentMargin
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "presentMargin:                  "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->presentMargin); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentTimeGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t presentID
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "presentID:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->presentID); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t desiredPresentTime
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "desiredPresentTime:             "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->desiredPresentTime); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentTimesInfoGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t swapchainCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "swapchainCount:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->swapchainCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPresentTimeGOOGLE* pTimes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pTimes:                         "); //HRW
    OutputString(outputFile, "const VkPresentTimeGOOGLE* = "); //TEQ
    if (pstruct->pTimes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pTimes->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPresentTimeGOOGLE>(outputFile, indent+1, 1, "VkPresentTimeGOOGLE", pstruct_in.pTimes->GetMetaStructPointer(), "pTimes", pstruct->swapchainCount, false, pstruct_in.pTimes->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 perViewPositionAllComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "perViewPositionAllComponents:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->perViewPositionAllComponents); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkViewportSwizzleNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViewportSwizzleNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkViewportCoordinateSwizzleNV x
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "x:                              "); //HRW
    OutputString(outputFile, "VkViewportCoordinateSwizzleNV = "); //TEQ
    EnumToStringVkViewportCoordinateSwizzleNV(outputFile, pstruct->x); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->x);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkViewportCoordinateSwizzleNV y
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "y:                              "); //HRW
    OutputString(outputFile, "VkViewportCoordinateSwizzleNV = "); //TEQ
    EnumToStringVkViewportCoordinateSwizzleNV(outputFile, pstruct->y); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->y);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkViewportCoordinateSwizzleNV z
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "z:                              "); //HRW
    OutputString(outputFile, "VkViewportCoordinateSwizzleNV = "); //TEQ
    EnumToStringVkViewportCoordinateSwizzleNV(outputFile, pstruct->z); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->z);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkViewportCoordinateSwizzleNV w
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "w:                              "); //HRW
    OutputString(outputFile, "VkViewportCoordinateSwizzleNV = "); //TEQ
    EnumToStringVkViewportCoordinateSwizzleNV(outputFile, pstruct->w); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->w);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportSwizzleStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineViewportSwizzleStateCreateFlagsNV flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineViewportSwizzleStateCreateFlagsNV = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewportCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewportCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewportCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkViewportSwizzleNV* pViewportSwizzles
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pViewportSwizzles:              "); //HRW
    OutputString(outputFile, "const VkViewportSwizzleNV* = "); //TEQ
    if (pstruct->pViewportSwizzles == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pViewportSwizzles->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkViewportSwizzleNV>(outputFile, indent+1, 1, "VkViewportSwizzleNV", pstruct_in.pViewportSwizzles->GetMetaStructPointer(), "pViewportSwizzles", pstruct->viewportCount, false, pstruct_in.pViewportSwizzles->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDiscardRectangles
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDiscardRectangles:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDiscardRectangles); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineDiscardRectangleStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineDiscardRectangleStateCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineDiscardRectangleStateCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDiscardRectangleModeEXT discardRectangleMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "discardRectangleMode:           "); //HRW
    OutputString(outputFile, "VkDiscardRectangleModeEXT = "); //TEQ
    EnumToStringVkDiscardRectangleModeEXT(outputFile, pstruct->discardRectangleMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->discardRectangleMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t discardRectangleCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "discardRectangleCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->discardRectangleCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkRect2D* pDiscardRectangles
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDiscardRectangles:             "); //HRW
    OutputString(outputFile, "const VkRect2D* = "); //TEQ
    if (pstruct->pDiscardRectangles == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDiscardRectangles->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(outputFile, indent+1, 1, "VkRect2D", pstruct_in.pDiscardRectangles->GetMetaStructPointer(), "pDiscardRectangles", pstruct->discardRectangleCount, false, pstruct_in.pDiscardRectangles->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: float primitiveOverestimationSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "primitiveOverestimationSize:    "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->primitiveOverestimationSize); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxExtraPrimitiveOverestimationSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxExtraPrimitiveOverestimationSize: "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxExtraPrimitiveOverestimationSize); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float extraPrimitiveOverestimationSizeGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extraPrimitiveOverestimationSizeGranularity: "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->extraPrimitiveOverestimationSizeGranularity); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 primitiveUnderestimation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "primitiveUnderestimation:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->primitiveUnderestimation); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 conservativePointAndLineRasterization
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "conservativePointAndLineRasterization: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->conservativePointAndLineRasterization); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 degenerateTrianglesRasterized
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "degenerateTrianglesRasterized:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->degenerateTrianglesRasterized); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 degenerateLinesRasterized
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "degenerateLinesRasterized:      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->degenerateLinesRasterized); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fullyCoveredFragmentShaderInputVariable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fullyCoveredFragmentShaderInputVariable: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fullyCoveredFragmentShaderInputVariable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 conservativeRasterizationPostDepthCoverage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "conservativeRasterizationPostDepthCoverage: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->conservativeRasterizationPostDepthCoverage); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationConservativeStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineRasterizationConservativeStateCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineRasterizationConservativeStateCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkConservativeRasterizationModeEXT conservativeRasterizationMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "conservativeRasterizationMode:  "); //HRW
    OutputString(outputFile, "VkConservativeRasterizationModeEXT = "); //TEQ
    EnumToStringVkConservativeRasterizationModeEXT(outputFile, pstruct->conservativeRasterizationMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->conservativeRasterizationMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: float extraPrimitiveOverestimationSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "extraPrimitiveOverestimationSize: "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->extraPrimitiveOverestimationSize); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthClipEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthClipEnable:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthClipEnable); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineRasterizationDepthClipStateCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 depthClipEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthClipEnable:                "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->depthClipEnable); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkXYColorEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: float x
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "x:                              "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->x); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float y
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "y:                              "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->y); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkHdrMetadataEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkXYColorEXT displayPrimaryRed
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayPrimaryRed:              "); //HRW
    OutputString(outputFile, "VkXYColorEXT = "); //TEQ
    StructureToString(outputFile, *pstruct_in.displayPrimaryRed, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryRed)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkXYColorEXT displayPrimaryGreen
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayPrimaryGreen:            "); //HRW
    OutputString(outputFile, "VkXYColorEXT = "); //TEQ
    StructureToString(outputFile, *pstruct_in.displayPrimaryGreen, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryGreen)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkXYColorEXT displayPrimaryBlue
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "displayPrimaryBlue:             "); //HRW
    OutputString(outputFile, "VkXYColorEXT = "); //TEQ
    StructureToString(outputFile, *pstruct_in.displayPrimaryBlue, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryBlue)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkXYColorEXT whitePoint
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "whitePoint:                     "); //HRW
    OutputString(outputFile, "VkXYColorEXT = "); //TEQ
    StructureToString(outputFile, *pstruct_in.whitePoint, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, whitePoint)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxLuminance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxLuminance:                   "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxLuminance); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float minLuminance
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minLuminance:                   "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->minLuminance); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxContentLightLevel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxContentLightLevel:           "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxContentLightLevel); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float maxFrameAverageLightLevel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFrameAverageLightLevel:      "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->maxFrameAverageLightLevel); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIOSSurfaceCreateInfoMVK *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkIOSSurfaceCreateFlagsMVK flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkIOSSurfaceCreateFlagsMVK = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pView
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pView:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pView == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pView); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMacOSSurfaceCreateInfoMVK *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMacOSSurfaceCreateFlagsMVK flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkMacOSSurfaceCreateFlagsMVK = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pView
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pView:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pView == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pView); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsObjectNameInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectType objectType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectType:                     "); //HRW
    OutputString(outputFile, "VkObjectType = "); //TEQ
    EnumToStringVkObjectType(outputFile, pstruct->objectType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->objectType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t objectHandle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectHandle:                   "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->objectHandle); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pObjectName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pObjectName:                    "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pObjectName); // TGI
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsObjectTagInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkObjectType objectType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectType:                     "); //HRW
    OutputString(outputFile, "VkObjectType = "); //TEQ
    EnumToStringVkObjectType(outputFile, pstruct->objectType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->objectType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t objectHandle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectHandle:                   "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->objectHandle); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t tagName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tagName:                        "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->tagName); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t tagSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "tagSize:                        "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->tagSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pTag
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pTag:                           "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pTag == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pTag.GetAddress()); // AHW
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsLabelEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pLabelName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pLabelName:                     "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pLabelName); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: float color
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "color:                          "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "4"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.color.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_color = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->color), "color", 4, vinfo_color); // JPA
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsMessengerCallbackDataEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDebugUtilsMessengerCallbackDataFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDebugUtilsMessengerCallbackDataFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pMessageIdName
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pMessageIdName:                 "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pMessageIdName); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t messageIdNumber
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "messageIdNumber:                "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->messageIdNumber); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* pMessage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pMessage:                       "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->pMessage); // TGI
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueLabelCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueLabelCount:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueLabelCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDebugUtilsLabelEXT* pQueueLabels
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pQueueLabels:                   "); //HRW
    OutputString(outputFile, "const VkDebugUtilsLabelEXT* = "); //TEQ
    if (pstruct->pQueueLabels == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pQueueLabels->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(outputFile, indent+1, 1, "VkDebugUtilsLabelEXT", pstruct_in.pQueueLabels->GetMetaStructPointer(), "pQueueLabels", pstruct->queueLabelCount, false, pstruct_in.pQueueLabels->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t cmdBufLabelCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "cmdBufLabelCount:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->cmdBufLabelCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDebugUtilsLabelEXT* pCmdBufLabels
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCmdBufLabels:                  "); //HRW
    OutputString(outputFile, "const VkDebugUtilsLabelEXT* = "); //TEQ
    if (pstruct->pCmdBufLabels == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCmdBufLabels->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(outputFile, indent+1, 1, "VkDebugUtilsLabelEXT", pstruct_in.pCmdBufLabels->GetMetaStructPointer(), "pCmdBufLabels", pstruct->cmdBufLabelCount, false, pstruct_in.pCmdBufLabels->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t objectCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "objectCount:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->objectCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDebugUtilsObjectNameInfoEXT* pObjects
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pObjects:                       "); //HRW
    OutputString(outputFile, "const VkDebugUtilsObjectNameInfoEXT* = "); //TEQ
    if (pstruct->pObjects == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pObjects->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(outputFile, indent+1, 1, "VkDebugUtilsObjectNameInfoEXT", pstruct_in.pObjects->GetMetaStructPointer(), "pObjects", pstruct->objectCount, false, pstruct_in.pObjects->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsMessengerCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDebugUtilsMessengerCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkDebugUtilsMessengerCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDebugUtilsMessageSeverityFlagsEXT messageSeverity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "messageSeverity:                "); //HRW
    OutputString(outputFile, "VkDebugUtilsMessageSeverityFlagsEXT = "); //TEQ
    FlagsToString(outputFile, pstruct->messageSeverity, EnumToStringVkDebugUtilsMessageSeverityFlagBitsEXT); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDebugUtilsMessageTypeFlagsEXT messageType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "messageType:                    "); //HRW
    OutputString(outputFile, "VkDebugUtilsMessageTypeFlagsEXT = "); //TEQ
    FlagsToString(outputFile, pstruct->messageType, EnumToStringVkDebugUtilsMessageTypeFlagBitsEXT); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pfnUserCallback:                "); //HRW
    OutputString(outputFile, "PFN_vkDebugUtilsMessengerCallbackEXT = "); //TEQ
    AddrToString(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnUserCallback)); // WRX
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pUserData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pUserData:                      "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pUserData); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidHardwareBufferUsageANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t androidHardwareBufferUsage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "androidHardwareBufferUsage:     "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->androidHardwareBufferUsage); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidHardwareBufferPropertiesANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize allocationSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "allocationSize:                 "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->allocationSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypeBits:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeBits); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidHardwareBufferFormatPropertiesANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat format
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "format:                         "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->format); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->format);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t externalFormat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalFormat:                 "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->externalFormat); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormatFeatureFlags formatFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "formatFeatures:                 "); //HRW
    OutputString(outputFile, "VkFormatFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->formatFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentMapping samplerYcbcrConversionComponents
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "samplerYcbcrConversionComponents: "); //HRW
    OutputString(outputFile, "VkComponentMapping = "); //TEQ
    StructureToString(outputFile, *pstruct_in.samplerYcbcrConversionComponents, indent+1,  base_addr + offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerYcbcrModelConversion suggestedYcbcrModel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "suggestedYcbcrModel:            "); //HRW
    OutputString(outputFile, "VkSamplerYcbcrModelConversion = "); //TEQ
    EnumToStringVkSamplerYcbcrModelConversion(outputFile, pstruct->suggestedYcbcrModel); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->suggestedYcbcrModel);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerYcbcrRange suggestedYcbcrRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "suggestedYcbcrRange:            "); //HRW
    OutputString(outputFile, "VkSamplerYcbcrRange = "); //TEQ
    EnumToStringVkSamplerYcbcrRange(outputFile, pstruct->suggestedYcbcrRange); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->suggestedYcbcrRange);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkChromaLocation suggestedXChromaOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "suggestedXChromaOffset:         "); //HRW
    OutputString(outputFile, "VkChromaLocation = "); //TEQ
    EnumToStringVkChromaLocation(outputFile, pstruct->suggestedXChromaOffset); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->suggestedXChromaOffset);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkChromaLocation suggestedYChromaOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "suggestedYChromaOffset:         "); //HRW
    OutputString(outputFile, "VkChromaLocation = "); //TEQ
    EnumToStringVkChromaLocation(outputFile, pstruct->suggestedYChromaOffset); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->suggestedYChromaOffset);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportAndroidHardwareBufferInfoANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: struct void* buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "struct void* = "); //TEQ
    if (pstruct->buffer == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.buffer); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryGetAndroidHardwareBufferInfoANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalFormatANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t externalFormat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "externalFormat:                 "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->externalFormat); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkSamplerReductionModeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerReductionModeCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSamplerReductionModeEXT reductionMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "reductionMode:                  "); //HRW
    OutputString(outputFile, "VkSamplerReductionModeEXT = "); //TEQ
    EnumToStringVkSamplerReductionModeEXT(outputFile, pstruct->reductionMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->reductionMode);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 filterMinmaxSingleComponentFormats
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "filterMinmaxSingleComponentFormats: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->filterMinmaxSingleComponentFormats); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 filterMinmaxImageComponentMapping
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "filterMinmaxImageComponentMapping: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->filterMinmaxImageComponentMapping); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceInlineUniformBlockFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 inlineUniformBlock
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "inlineUniformBlock:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->inlineUniformBlock); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingInlineUniformBlockUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingInlineUniformBlockUpdateAfterBind); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceInlineUniformBlockPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxInlineUniformBlockSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxInlineUniformBlockSize:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxInlineUniformBlockSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorInlineUniformBlocks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorInlineUniformBlocks: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorInlineUniformBlocks); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetInlineUniformBlocks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetInlineUniformBlocks: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetInlineUniformBlocks); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindInlineUniformBlocks: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindInlineUniformBlocks); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkWriteDescriptorSetInlineUniformBlockEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWriteDescriptorSetInlineUniformBlockEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t dataSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dataSize:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->dataSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pData:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pData == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pData.GetAddress()); // AHW
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorPoolInlineUniformBlockCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxInlineUniformBlockBindings
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxInlineUniformBlockBindings:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxInlineUniformBlockBindings); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSampleLocationEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: float x
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "x:                              "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->x); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float y
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "y:                              "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->y); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSampleLocationsInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlagBits sampleLocationsPerPixel
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationsPerPixel:        "); //HRW
    OutputString(outputFile, "VkSampleCountFlagBits = "); //TEQ
    EnumToStringVkSampleCountFlagBits(outputFile, pstruct->sampleLocationsPerPixel); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sampleLocationsPerPixel);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D sampleLocationGridSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationGridSize:         "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.sampleLocationGridSize, indent+1,  base_addr + offsetof(VkSampleLocationsInfoEXT, sampleLocationGridSize)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t sampleLocationsCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationsCount:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->sampleLocationsCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSampleLocationEXT* pSampleLocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSampleLocations:               "); //HRW
    OutputString(outputFile, "const VkSampleLocationEXT* = "); //TEQ
    if (pstruct->pSampleLocations == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSampleLocationEXT>(outputFile, indent+1, 1, "VkSampleLocationEXT", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationsCount, false, pstruct_in.pSampleLocations->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentSampleLocationsEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t attachmentIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentIndex:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationsInfo:            "); //HRW
    OutputString(outputFile, "VkSampleLocationsInfoEXT = "); //TEQ
    StructureToString(outputFile, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkAttachmentSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassSampleLocationsEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t subpassIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subpassIndex:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->subpassIndex); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationsInfo:            "); //HRW
    OutputString(outputFile, "VkSampleLocationsInfoEXT = "); //TEQ
    StructureToString(outputFile, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkSubpassSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassSampleLocationsBeginInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t attachmentInitialSampleLocationsCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "attachmentInitialSampleLocationsCount: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->attachmentInitialSampleLocationsCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAttachmentInitialSampleLocations: "); //HRW
    OutputString(outputFile, "const VkAttachmentSampleLocationsEXT* = "); //TEQ
    if (pstruct->pAttachmentInitialSampleLocations == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAttachmentInitialSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentSampleLocationsEXT>(outputFile, indent+1, 1, "VkAttachmentSampleLocationsEXT", pstruct_in.pAttachmentInitialSampleLocations->GetMetaStructPointer(), "pAttachmentInitialSampleLocations", pstruct->attachmentInitialSampleLocationsCount, false, pstruct_in.pAttachmentInitialSampleLocations->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t postSubpassSampleLocationsCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "postSubpassSampleLocationsCount: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->postSubpassSampleLocationsCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPostSubpassSampleLocations:    "); //HRW
    OutputString(outputFile, "const VkSubpassSampleLocationsEXT* = "); //TEQ
    if (pstruct->pPostSubpassSampleLocations == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPostSubpassSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassSampleLocationsEXT>(outputFile, indent+1, 1, "VkSubpassSampleLocationsEXT", pstruct_in.pPostSubpassSampleLocations->GetMetaStructPointer(), "pPostSubpassSampleLocations", pstruct->postSubpassSampleLocationsCount, false, pstruct_in.pPostSubpassSampleLocations->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineSampleLocationsStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 sampleLocationsEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationsEnable:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->sampleLocationsEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationsInfo:            "); //HRW
    OutputString(outputFile, "VkSampleLocationsInfoEXT = "); //TEQ
    StructureToString(outputFile, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSampleLocationsPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags sampleLocationSampleCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationSampleCounts:     "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->sampleLocationSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D maxSampleLocationGridSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSampleLocationGridSize:      "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxSampleLocationGridSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: float sampleLocationCoordinateRange
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationCoordinateRange:  "); //HRW
    OutputString(outputFile, "float"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "2"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.sampleLocationCoordinateRange.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_sampleLocationCoordinateRange = {false, false, false, nullptr};
    ArrayToString<float*>(outputFile, indent, 0, "float", const_cast<float*>(pstruct->sampleLocationCoordinateRange), "sampleLocationCoordinateRange", 2, vinfo_sampleLocationCoordinateRange); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t sampleLocationSubPixelBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationSubPixelBits:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->sampleLocationSubPixelBits); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 variableSampleLocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "variableSampleLocations:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->variableSampleLocations); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMultisamplePropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D maxSampleLocationGridSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSampleLocationGridSize:      "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxSampleLocationGridSize, indent+1,  base_addr + offsetof(VkMultisamplePropertiesEXT, maxSampleLocationGridSize)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 advancedBlendCoherentOperations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "advancedBlendCoherentOperations: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->advancedBlendCoherentOperations); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t advancedBlendMaxColorAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "advancedBlendMaxColorAttachments: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->advancedBlendMaxColorAttachments); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 advancedBlendIndependentBlend
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "advancedBlendIndependentBlend:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->advancedBlendIndependentBlend); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 advancedBlendNonPremultipliedSrcColor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "advancedBlendNonPremultipliedSrcColor: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->advancedBlendNonPremultipliedSrcColor); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 advancedBlendNonPremultipliedDstColor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "advancedBlendNonPremultipliedDstColor: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->advancedBlendNonPremultipliedDstColor); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 advancedBlendCorrelatedOverlap
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "advancedBlendCorrelatedOverlap: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->advancedBlendCorrelatedOverlap); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 advancedBlendAllOperations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "advancedBlendAllOperations:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->advancedBlendAllOperations); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 srcPremultiplied
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "srcPremultiplied:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->srcPremultiplied); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 dstPremultiplied
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dstPremultiplied:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->dstPremultiplied); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBlendOverlapEXT blendOverlap
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "blendOverlap:                   "); //HRW
    OutputString(outputFile, "VkBlendOverlapEXT = "); //TEQ
    EnumToStringVkBlendOverlapEXT(outputFile, pstruct->blendOverlap); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->blendOverlap);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineCoverageToColorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCoverageToColorStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCoverageToColorStateCreateFlagsNV flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCoverageToColorStateCreateFlagsNV = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 coverageToColorEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageToColorEnable:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->coverageToColorEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t coverageToColorLocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageToColorLocation:        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->coverageToColorLocation); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineCoverageModulationStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCoverageModulationStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCoverageModulationStateCreateFlagsNV flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCoverageModulationStateCreateFlagsNV = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCoverageModulationModeNV coverageModulationMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageModulationMode:         "); //HRW
    OutputString(outputFile, "VkCoverageModulationModeNV = "); //TEQ
    EnumToStringVkCoverageModulationModeNV(outputFile, pstruct->coverageModulationMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->coverageModulationMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 coverageModulationTableEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageModulationTableEnable:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->coverageModulationTableEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t coverageModulationTableCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageModulationTableCount:   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->coverageModulationTableCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const float* pCoverageModulationTable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCoverageModulationTable:       "); //HRW
    OutputString(outputFile, "const float* = "); //TEQ
    if (pstruct->pCoverageModulationTable == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCoverageModulationTable.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCoverageModulationTable = {false, false, false, nullptr};
        ArrayToString<const float*>(outputFile, indent, 1, "const float*", reinterpret_cast<const float*>(pstruct_in.pCoverageModulationTable.GetPointer()), "pCoverageModulationTable", pstruct->coverageModulationTableCount,  vinfo_pCoverageModulationTable);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shaderSMCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSMCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shaderSMCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shaderWarpsPerSM
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderWarpsPerSM:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shaderWarpsPerSM); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSMBuiltins
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSMBuiltins:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSMBuiltins); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrmFormatModifierPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifier:              "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifier); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t drmFormatModifierPlaneCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifierPlaneCount:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifierPlaneCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormatFeatureFlags drmFormatModifierTilingFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifierTilingFeatures: "); //HRW
    OutputString(outputFile, "VkFormatFeatureFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->drmFormatModifierTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrmFormatModifierPropertiesListEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t drmFormatModifierCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifierCount:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifierCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDrmFormatModifierProperties:   "); //HRW
    OutputString(outputFile, "VkDrmFormatModifierPropertiesEXT* = "); //TEQ
    if (pstruct->pDrmFormatModifierProperties == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDrmFormatModifierProperties->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDrmFormatModifierPropertiesEXT>(outputFile, indent+1, 1, "VkDrmFormatModifierPropertiesEXT", pstruct_in.pDrmFormatModifierProperties->GetMetaStructPointer(), "pDrmFormatModifierProperties", pstruct->drmFormatModifierCount, false, pstruct_in.pDrmFormatModifierProperties->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifier:              "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifier); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSharingMode sharingMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sharingMode:                    "); //HRW
    OutputString(outputFile, "VkSharingMode = "); //TEQ
    EnumToStringVkSharingMode(outputFile, pstruct->sharingMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sharingMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "queueFamilyIndexCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pQueueFamilyIndices:            "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageDrmFormatModifierListCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t drmFormatModifierCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifierCount:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifierCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint64_t* pDrmFormatModifiers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDrmFormatModifiers:            "); //HRW
    OutputString(outputFile, "const uint64_t* = "); //TEQ
    if (pstruct->pDrmFormatModifiers == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDrmFormatModifiers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDrmFormatModifiers = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(outputFile, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pDrmFormatModifiers.GetPointer()), "pDrmFormatModifiers", pstruct->drmFormatModifierCount,  vinfo_pDrmFormatModifiers);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageDrmFormatModifierExplicitCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifier:              "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifier); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t drmFormatModifierPlaneCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifierPlaneCount:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifierPlaneCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkSubresourceLayout* pPlaneLayouts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPlaneLayouts:                  "); //HRW
    OutputString(outputFile, "const VkSubresourceLayout* = "); //TEQ
    if (pstruct->pPlaneLayouts == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPlaneLayouts->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubresourceLayout>(outputFile, indent+1, 1, "VkSubresourceLayout", pstruct_in.pPlaneLayouts->GetMetaStructPointer(), "pPlaneLayouts", pstruct->drmFormatModifierPlaneCount, false, pstruct_in.pPlaneLayouts->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageDrmFormatModifierPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "drmFormatModifier:              "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->drmFormatModifier); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkValidationCacheCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkValidationCacheCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkValidationCacheCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: size_t initialDataSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "initialDataSize:                "); //HRW
    OutputString(outputFile, "size_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->initialDataSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pInitialData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pInitialData:                   "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pInitialData == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pInitialData.GetAddress()); // AHW
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderModuleValidationCacheCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkValidationCacheEXT validationCache
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "validationCache:                "); //HRW
    OutputString(outputFile, "VkValidationCacheEXT = "); //TEQ
    AddrToString(outputFile, pstruct_in.validationCache); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t bindingCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bindingCount:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->bindingCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkDescriptorBindingFlagsEXT* pBindingFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pBindingFlags:                  "); //HRW
    OutputString(outputFile, "const VkDescriptorBindingFlagsEXT* = "); //TEQ
    if (pstruct->pBindingFlags == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pBindingFlags.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pBindingFlags = {false, false, true, EnumToStringVkDescriptorBindingFlagBitsEXT};
        ArrayToString<const VkDescriptorBindingFlagsEXT*>(outputFile, indent, 1, "const VkDescriptorBindingFlagsEXT*", reinterpret_cast<const VkDescriptorBindingFlagsEXT*>(pstruct_in.pBindingFlags.GetPointer()), "pBindingFlags", pstruct->bindingCount,  vinfo_pBindingFlags);  // CCR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderInputAttachmentArrayDynamicIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderInputAttachmentArrayDynamicIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderInputAttachmentArrayDynamicIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderUniformTexelBufferArrayDynamicIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderUniformTexelBufferArrayDynamicIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderUniformTexelBufferArrayDynamicIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageTexelBufferArrayDynamicIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageTexelBufferArrayDynamicIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageTexelBufferArrayDynamicIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderUniformBufferArrayNonUniformIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderUniformBufferArrayNonUniformIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderUniformBufferArrayNonUniformIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSampledImageArrayNonUniformIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSampledImageArrayNonUniformIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSampledImageArrayNonUniformIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageBufferArrayNonUniformIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageBufferArrayNonUniformIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageBufferArrayNonUniformIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageImageArrayNonUniformIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageImageArrayNonUniformIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageImageArrayNonUniformIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderInputAttachmentArrayNonUniformIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderInputAttachmentArrayNonUniformIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderInputAttachmentArrayNonUniformIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderUniformTexelBufferArrayNonUniformIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderUniformTexelBufferArrayNonUniformIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageTexelBufferArrayNonUniformIndexing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageTexelBufferArrayNonUniformIndexing); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingUniformBufferUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingUniformBufferUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingUniformBufferUpdateAfterBind); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingSampledImageUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingSampledImageUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingSampledImageUpdateAfterBind); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingStorageImageUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingStorageImageUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingStorageImageUpdateAfterBind); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingStorageBufferUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingStorageBufferUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingStorageBufferUpdateAfterBind); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingUniformTexelBufferUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingUniformTexelBufferUpdateAfterBind); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingStorageTexelBufferUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingStorageTexelBufferUpdateAfterBind); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingUpdateUnusedWhilePending
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingUpdateUnusedWhilePending: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingUpdateUnusedWhilePending); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingPartiallyBound
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingPartiallyBound: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingPartiallyBound); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 descriptorBindingVariableDescriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorBindingVariableDescriptorCount: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->descriptorBindingVariableDescriptorCount); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 runtimeDescriptorArray
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "runtimeDescriptorArray:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->runtimeDescriptorArray); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxUpdateAfterBindDescriptorsInAllPools
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxUpdateAfterBindDescriptorsInAllPools: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxUpdateAfterBindDescriptorsInAllPools); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderUniformBufferArrayNonUniformIndexingNative
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderUniformBufferArrayNonUniformIndexingNative: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderUniformBufferArrayNonUniformIndexingNative); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderSampledImageArrayNonUniformIndexingNative
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderSampledImageArrayNonUniformIndexingNative: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderSampledImageArrayNonUniformIndexingNative); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageBufferArrayNonUniformIndexingNative
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageBufferArrayNonUniformIndexingNative: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageBufferArrayNonUniformIndexingNative); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderStorageImageArrayNonUniformIndexingNative
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderStorageImageArrayNonUniformIndexingNative: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderStorageImageArrayNonUniformIndexingNative); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderInputAttachmentArrayNonUniformIndexingNative: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderInputAttachmentArrayNonUniformIndexingNative); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 robustBufferAccessUpdateAfterBind
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "robustBufferAccessUpdateAfterBind: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->robustBufferAccessUpdateAfterBind); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 quadDivergentImplicitLod
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "quadDivergentImplicitLod:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->quadDivergentImplicitLod); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindSamplers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUpdateAfterBindSamplers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindSamplers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUpdateAfterBindUniformBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindUniformBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUpdateAfterBindStorageBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindStorageBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUpdateAfterBindSampledImages: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindSampledImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUpdateAfterBindStorageImages: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindStorageImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageDescriptorUpdateAfterBindInputAttachments: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindInputAttachments); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxPerStageUpdateAfterBindResources
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxPerStageUpdateAfterBindResources: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxPerStageUpdateAfterBindResources); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindSamplers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindSamplers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindSamplers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindUniformBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindUniformBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindStorageBuffers: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindStorageBuffers); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindSampledImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindSampledImages: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindSampledImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindStorageImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindStorageImages: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindStorageImages); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindInputAttachments
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetUpdateAfterBindInputAttachments: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetUpdateAfterBindInputAttachments); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t descriptorSetCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "descriptorSetCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->descriptorSetCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pDescriptorCounts
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDescriptorCounts:              "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pDescriptorCounts == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDescriptorCounts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDescriptorCounts = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDescriptorCounts.GetPointer()), "pDescriptorCounts", pstruct->descriptorSetCount,  vinfo_pDescriptorCounts);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVariableDescriptorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVariableDescriptorCount:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVariableDescriptorCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShadingRatePaletteNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t shadingRatePaletteEntryCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRatePaletteEntryCount:   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shadingRatePaletteEntryCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkShadingRatePaletteEntryNV* pShadingRatePaletteEntries
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pShadingRatePaletteEntries:     "); //HRW
    OutputString(outputFile, "const VkShadingRatePaletteEntryNV* = "); //TEQ
    if (pstruct->pShadingRatePaletteEntries == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pShadingRatePaletteEntries.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pShadingRatePaletteEntries = {false, true, false, EnumToStringVkShadingRatePaletteEntryNV};
        ArrayToString<const VkShadingRatePaletteEntryNV*>(outputFile, indent, 1, "const VkShadingRatePaletteEntryNV*", reinterpret_cast<const VkShadingRatePaletteEntryNV*>(pstruct_in.pShadingRatePaletteEntries.GetPointer()), "pShadingRatePaletteEntries", pstruct->shadingRatePaletteEntryCount,  vinfo_pShadingRatePaletteEntries);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportShadingRateImageStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shadingRateImageEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRateImageEnable:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shadingRateImageEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t viewportCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "viewportCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->viewportCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkShadingRatePaletteNV* pShadingRatePalettes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pShadingRatePalettes:           "); //HRW
    OutputString(outputFile, "const VkShadingRatePaletteNV* = "); //TEQ
    if (pstruct->pShadingRatePalettes == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pShadingRatePalettes->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkShadingRatePaletteNV>(outputFile, indent+1, 1, "VkShadingRatePaletteNV", pstruct_in.pShadingRatePalettes->GetMetaStructPointer(), "pShadingRatePalettes", pstruct->viewportCount, false, pstruct_in.pShadingRatePalettes->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShadingRateImageFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shadingRateImage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRateImage:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shadingRateImage); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shadingRateCoarseSampleOrder
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRateCoarseSampleOrder:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shadingRateCoarseSampleOrder); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShadingRateImagePropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D shadingRateTexelSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRateTexelSize:           "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.shadingRateTexelSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shadingRatePaletteSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRatePaletteSize:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shadingRatePaletteSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shadingRateMaxCoarseSamples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRateMaxCoarseSamples:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shadingRateMaxCoarseSamples); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCoarseSampleLocationNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t pixelX
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pixelX:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pixelX); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t pixelY
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pixelY:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pixelY); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t sample
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sample:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->sample); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCoarseSampleOrderCustomNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkShadingRatePaletteEntryNV shadingRate
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shadingRate:                    "); //HRW
    OutputString(outputFile, "VkShadingRatePaletteEntryNV = "); //TEQ
    EnumToStringVkShadingRatePaletteEntryNV(outputFile, pstruct->shadingRate); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->shadingRate);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t sampleCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleCount:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->sampleCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t sampleLocationCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleLocationCount:            "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->sampleLocationCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkCoarseSampleLocationNV* pSampleLocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pSampleLocations:               "); //HRW
    OutputString(outputFile, "const VkCoarseSampleLocationNV* = "); //TEQ
    if (pstruct->pSampleLocations == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkCoarseSampleLocationNV>(outputFile, indent+1, 1, "VkCoarseSampleLocationNV", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationCount, false, pstruct_in.pSampleLocations->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCoarseSampleOrderTypeNV sampleOrderType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sampleOrderType:                "); //HRW
    OutputString(outputFile, "VkCoarseSampleOrderTypeNV = "); //TEQ
    EnumToStringVkCoarseSampleOrderTypeNV(outputFile, pstruct->sampleOrderType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sampleOrderType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t customSampleOrderCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "customSampleOrderCount:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->customSampleOrderCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkCoarseSampleOrderCustomNV* pCustomSampleOrders
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCustomSampleOrders:            "); //HRW
    OutputString(outputFile, "const VkCoarseSampleOrderCustomNV* = "); //TEQ
    if (pstruct->pCustomSampleOrders == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCustomSampleOrders->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkCoarseSampleOrderCustomNV>(outputFile, indent+1, 1, "VkCoarseSampleOrderCustomNV", pstruct_in.pCustomSampleOrders->GetMetaStructPointer(), "pCustomSampleOrders", pstruct->customSampleOrderCount, false, pstruct_in.pCustomSampleOrders->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRayTracingShaderGroupCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkRayTracingShaderGroupTypeNV type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkRayTracingShaderGroupTypeNV = "); //TEQ
    EnumToStringVkRayTracingShaderGroupTypeNV(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t generalShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "generalShader:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->generalShader); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t closestHitShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "closestHitShader:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->closestHitShader); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t anyHitShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "anyHitShader:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->anyHitShader); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t intersectionShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "intersectionShader:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->intersectionShader); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRayTracingPipelineCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCreateFlags flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCreateFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t stageCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stageCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->stageCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkPipelineShaderStageCreateInfo* pStages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pStages:                        "); //HRW
    OutputString(outputFile, "const VkPipelineShaderStageCreateInfo* = "); //TEQ
    if (pstruct->pStages == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pStages->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(outputFile, indent+1, 1, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t groupCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "groupCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->groupCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkRayTracingShaderGroupCreateInfoNV* pGroups
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pGroups:                        "); //HRW
    OutputString(outputFile, "const VkRayTracingShaderGroupCreateInfoNV* = "); //TEQ
    if (pstruct->pGroups == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pGroups->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(outputFile, indent+1, 1, "VkRayTracingShaderGroupCreateInfoNV", pstruct_in.pGroups->GetMetaStructPointer(), "pGroups", pstruct->groupCount, false, pstruct_in.pGroups->GetAddress());  // CCP
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxRecursionDepth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxRecursionDepth:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxRecursionDepth); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineLayout layout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "layout:                         "); //HRW
    OutputString(outputFile, "VkPipelineLayout = "); //TEQ
    AddrToString(outputFile, pstruct_in.layout); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipeline basePipelineHandle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "basePipelineHandle:             "); //HRW
    OutputString(outputFile, "VkPipeline = "); //TEQ
    AddrToString(outputFile, pstruct_in.basePipelineHandle); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: int32_t basePipelineIndex
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "basePipelineIndex:              "); //HRW
    OutputString(outputFile, "int32_t = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->basePipelineIndex); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryTrianglesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer vertexData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexData:                     "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.vertexData); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize vertexOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexOffset:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vertexOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t vertexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexCount:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vertexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize vertexStride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexStride:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vertexStride); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFormat vertexFormat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexFormat:                   "); //HRW
    OutputString(outputFile, "VkFormat = "); //TEQ
    EnumToStringVkFormat(outputFile, pstruct->vertexFormat); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->vertexFormat);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer indexData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indexData:                      "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.indexData); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize indexOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indexOffset:                    "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->indexOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t indexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indexCount:                     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->indexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkIndexType indexType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indexType:                      "); //HRW
    OutputString(outputFile, "VkIndexType = "); //TEQ
    EnumToStringVkIndexType(outputFile, pstruct->indexType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->indexType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer transformData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transformData:                  "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.transformData); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize transformOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "transformOffset:                "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->transformOffset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryAABBNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer aabbData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aabbData:                       "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.aabbData); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t numAABBs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "numAABBs:                       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->numAABBs); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t stride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stride:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->stride); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "offset:                         "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->offset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryDataNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkGeometryTrianglesNV triangles
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "triangles:                      "); //HRW
    OutputString(outputFile, "VkGeometryTrianglesNV = "); //TEQ
    StructureToString(outputFile, *pstruct_in.triangles, indent+1,  base_addr + offsetof(VkGeometryDataNV, triangles)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkGeometryAABBNV aabbs
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "aabbs:                          "); //HRW
    OutputString(outputFile, "VkGeometryAABBNV = "); //TEQ
    StructureToString(outputFile, *pstruct_in.aabbs, indent+1,  base_addr + offsetof(VkGeometryDataNV, aabbs)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkGeometryTypeNV geometryType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "geometryType:                   "); //HRW
    OutputString(outputFile, "VkGeometryTypeNV = "); //TEQ
    EnumToStringVkGeometryTypeNV(outputFile, pstruct->geometryType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->geometryType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkGeometryDataNV geometry
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "geometry:                       "); //HRW
    OutputString(outputFile, "VkGeometryDataNV = "); //TEQ
    StructureToString(outputFile, *pstruct_in.geometry, indent+1,  base_addr + offsetof(VkGeometryNV, geometry)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkGeometryFlagsNV flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkGeometryFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkGeometryFlagBitsNV); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAccelerationStructureInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccelerationStructureTypeNV type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkAccelerationStructureTypeNV = "); //TEQ
    EnumToStringVkAccelerationStructureTypeNV(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuildAccelerationStructureFlagsNV flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkBuildAccelerationStructureFlagsNV = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkBuildAccelerationStructureFlagBitsNV); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t instanceCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "instanceCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->instanceCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t geometryCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "geometryCount:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->geometryCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkGeometryNV* pGeometries
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pGeometries:                    "); //HRW
    OutputString(outputFile, "const VkGeometryNV* = "); //TEQ
    if (pstruct->pGeometries == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pGeometries->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkGeometryNV>(outputFile, indent+1, 1, "VkGeometryNV", pstruct_in.pGeometries->GetMetaStructPointer(), "pGeometries", pstruct->geometryCount, false, pstruct_in.pGeometries->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAccelerationStructureCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize compactedSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compactedSize:                  "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->compactedSize); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccelerationStructureInfoNV info
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "info:                           "); //HRW
    OutputString(outputFile, "VkAccelerationStructureInfoNV = "); //TEQ
    StructureToString(outputFile, *pstruct_in.info, indent+1,  base_addr + offsetof(VkAccelerationStructureCreateInfoNV, info)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindAccelerationStructureMemoryInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccelerationStructureNV accelerationStructure
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "accelerationStructure:          "); //HRW
    OutputString(outputFile, "VkAccelerationStructureNV = "); //TEQ
    AddrToString(outputFile, pstruct_in.accelerationStructure); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memory:                         "); //HRW
    OutputString(outputFile, "VkDeviceMemory = "); //TEQ
    AddrToString(outputFile, pstruct_in.memory); // PAQ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryOffset:                   "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->memoryOffset); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t deviceIndexCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceIndexCount:               "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceIndexCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const uint32_t* pDeviceIndices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDeviceIndices:                 "); //HRW
    OutputString(outputFile, "const uint32_t* = "); //TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(outputFile, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWriteDescriptorSetAccelerationStructureNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t accelerationStructureCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "accelerationStructureCount:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->accelerationStructureCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkAccelerationStructureNV* pAccelerationStructures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pAccelerationStructures:        "); //HRW
    OutputString(outputFile, "const VkAccelerationStructureNV* = "); //TEQ
    if (pstruct->pAccelerationStructures == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pAccelerationStructures.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAccelerationStructures = {true, false, false, nullptr};
        ArrayToString<const VkAccelerationStructureNV*>(outputFile, indent, 1, "const VkAccelerationStructureNV*", reinterpret_cast<const VkAccelerationStructureNV*>(pstruct_in.pAccelerationStructures.GetPointer()), "pAccelerationStructures", pstruct->accelerationStructureCount,  vinfo_pAccelerationStructures);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAccelerationStructureMemoryRequirementsInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccelerationStructureMemoryRequirementsTypeNV type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkAccelerationStructureMemoryRequirementsTypeNV = "); //TEQ
    EnumToStringVkAccelerationStructureMemoryRequirementsTypeNV(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAccelerationStructureNV accelerationStructure
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "accelerationStructure:          "); //HRW
    OutputString(outputFile, "VkAccelerationStructureNV = "); //TEQ
    AddrToString(outputFile, pstruct_in.accelerationStructure); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceRayTracingPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shaderGroupHandleSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderGroupHandleSize:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shaderGroupHandleSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxRecursionDepth
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxRecursionDepth:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxRecursionDepth); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxShaderGroupStride
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxShaderGroupStride:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxShaderGroupStride); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shaderGroupBaseAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderGroupBaseAlignment:       "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shaderGroupBaseAlignment); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t maxGeometryCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxGeometryCount:               "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxGeometryCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t maxInstanceCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxInstanceCount:               "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxInstanceCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t maxTriangleCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTriangleCount:               "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTriangleCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDescriptorSetAccelerationStructures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDescriptorSetAccelerationStructures: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDescriptorSetAccelerationStructures); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 representativeFragmentTest
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "representativeFragmentTest:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->representativeFragmentTest); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 representativeFragmentTestEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "representativeFragmentTestEnable: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->representativeFragmentTestEnable); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImageViewImageFormatInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageViewType imageViewType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageViewType:                  "); //HRW
    OutputString(outputFile, "VkImageViewType = "); //TEQ
    EnumToStringVkImageViewType(outputFile, pstruct->imageViewType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->imageViewType);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFilterCubicImageViewImageFormatPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 filterCubic
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "filterCubic:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->filterCubic); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 filterCubicMinmax
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "filterCubicMinmax:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->filterCubicMinmax); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceQueueGlobalPriorityCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceQueueGlobalPriorityCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueueGlobalPriorityEXT globalPriority
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "globalPriority:                 "); //HRW
    OutputString(outputFile, "VkQueueGlobalPriorityEXT = "); //TEQ
    EnumToStringVkQueueGlobalPriorityEXT(outputFile, pstruct->globalPriority); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->globalPriority);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryHostPointerInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "handleType:                     "); //HRW
    OutputString(outputFile, "VkExternalMemoryHandleTypeFlagBits = "); //TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(outputFile, pstruct->handleType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->handleType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pHostPointer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pHostPointer:                   "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pHostPointer == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pHostPointer); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryHostPointerPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryTypeBits:                 "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->memoryTypeBits); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize minImportedHostPointerAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minImportedHostPointerAlignment: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->minImportedHostPointerAlignment); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineCompilerControlCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCompilerControlCreateInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCompilerControlFlagsAMD compilerControlFlags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "compilerControlFlags:           "); //HRW
    OutputString(outputFile, "VkPipelineCompilerControlFlagsAMD = "); //TEQ
    FlagsToString(outputFile, pstruct->compilerControlFlags, EnumToStringVkPipelineCompilerControlFlagBitsAMD); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCalibratedTimestampInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkTimeDomainEXT timeDomain
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "timeDomain:                     "); //HRW
    OutputString(outputFile, "VkTimeDomainEXT = "); //TEQ
    EnumToStringVkTimeDomainEXT(outputFile, pstruct->timeDomain); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->timeDomain);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderCorePropertiesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shaderEngineCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderEngineCount:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shaderEngineCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t shaderArraysPerEngineCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderArraysPerEngineCount:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->shaderArraysPerEngineCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t computeUnitsPerShaderArray
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "computeUnitsPerShaderArray:     "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->computeUnitsPerShaderArray); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t simdPerComputeUnit
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "simdPerComputeUnit:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->simdPerComputeUnit); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t wavefrontsPerSimd
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "wavefrontsPerSimd:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->wavefrontsPerSimd); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t wavefrontSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "wavefrontSize:                  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->wavefrontSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t sgprsPerSimd
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sgprsPerSimd:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->sgprsPerSimd); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minSgprAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minSgprAllocation:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minSgprAllocation); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSgprAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSgprAllocation:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSgprAllocation); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t sgprAllocationGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sgprAllocationGranularity:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->sgprAllocationGranularity); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t vgprsPerSimd
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vgprsPerSimd:                   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vgprsPerSimd); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minVgprAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minVgprAllocation:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minVgprAllocation); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVgprAllocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVgprAllocation:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVgprAllocation); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t vgprAllocationGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vgprAllocationGranularity:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vgprAllocationGranularity); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceMemoryOverallocationCreateInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMemoryOverallocationBehaviorAMD overallocationBehavior
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "overallocationBehavior:         "); //HRW
    OutputString(outputFile, "VkMemoryOverallocationBehaviorAMD = "); //TEQ
    EnumToStringVkMemoryOverallocationBehaviorAMD(outputFile, pstruct->overallocationBehavior); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->overallocationBehavior);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxVertexAttribDivisor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxVertexAttribDivisor:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxVertexAttribDivisor); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkVertexInputBindingDivisorDescriptionEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkVertexInputBindingDivisorDescriptionEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t binding
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "binding:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->binding); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t divisor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "divisor:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->divisor); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineVertexInputDivisorStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineVertexInputDivisorStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t vertexBindingDivisorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexBindingDivisorCount:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->vertexBindingDivisorCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkVertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pVertexBindingDivisors:         "); //HRW
    OutputString(outputFile, "const VkVertexInputBindingDivisorDescriptionEXT* = "); //TEQ
    if (pstruct->pVertexBindingDivisors == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pVertexBindingDivisors->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkVertexInputBindingDivisorDescriptionEXT>(outputFile, indent+1, 1, "VkVertexInputBindingDivisorDescriptionEXT", pstruct_in.pVertexBindingDivisors->GetMetaStructPointer(), "pVertexBindingDivisors", pstruct->vertexBindingDivisorCount, false, pstruct_in.pVertexBindingDivisors->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 vertexAttributeInstanceRateDivisor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexAttributeInstanceRateDivisor: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vertexAttributeInstanceRateDivisor); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 vertexAttributeInstanceRateZeroDivisor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "vertexAttributeInstanceRateZeroDivisor: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->vertexAttributeInstanceRateZeroDivisor); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPresentFrameTokenGGP &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentFrameTokenGGP *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t frameToken
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "frameToken:                     "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->frameToken); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCreationFeedbackEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkPipelineCreationFeedbackFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCreationFeedbackFlagsEXT = "); //TEQ
    FlagsToString(outputFile, pstruct->flags, EnumToStringVkPipelineCreationFeedbackFlagBitsEXT); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t duration
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "duration:                       "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->duration); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCreationFeedbackCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCreationFeedbackEXT* pPipelineCreationFeedback
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPipelineCreationFeedback:      "); //HRW
    OutputString(outputFile, "VkPipelineCreationFeedbackEXT* = "); //TEQ
    if (pstruct->pPipelineCreationFeedback == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPipelineCreationFeedback->GetAddress()); // JHJ
        OutputString(outputFile, ":");
        StructureToString(outputFile, *pstruct_in.pPipelineCreationFeedback->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkPipelineCreationFeedbackCreateInfoEXT, pPipelineCreationFeedback)); // GLN
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t pipelineStageCreationFeedbackCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pipelineStageCreationFeedbackCount: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pipelineStageCreationFeedbackCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCreationFeedbackEXT* pPipelineStageCreationFeedbacks
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pPipelineStageCreationFeedbacks: "); //HRW
    OutputString(outputFile, "VkPipelineCreationFeedbackEXT* = "); //TEQ
    if (pstruct->pPipelineStageCreationFeedbacks == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pPipelineStageCreationFeedbacks->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPipelineCreationFeedbackEXT>(outputFile, indent+1, 1, "VkPipelineCreationFeedbackEXT", pstruct_in.pPipelineStageCreationFeedbacks->GetMetaStructPointer(), "pPipelineStageCreationFeedbacks", pstruct->pipelineStageCreationFeedbackCount, false, pstruct_in.pPipelineStageCreationFeedbacks->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 computeDerivativeGroupQuads
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "computeDerivativeGroupQuads:    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->computeDerivativeGroupQuads); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 computeDerivativeGroupLinear
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "computeDerivativeGroupLinear:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->computeDerivativeGroupLinear); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMeshShaderFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 taskShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "taskShader:                     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->taskShader); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 meshShader
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "meshShader:                     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->meshShader); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMeshShaderPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxDrawMeshTasksCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxDrawMeshTasksCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxDrawMeshTasksCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTaskWorkGroupInvocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTaskWorkGroupInvocations:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTaskWorkGroupInvocations); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTaskWorkGroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTaskWorkGroupSize:           "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "3"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.maxTaskWorkGroupSize.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_maxTaskWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxTaskWorkGroupSize), "maxTaskWorkGroupSize", 3, vinfo_maxTaskWorkGroupSize); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTaskTotalMemorySize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTaskTotalMemorySize:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTaskTotalMemorySize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxTaskOutputCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxTaskOutputCount:             "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxTaskOutputCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMeshWorkGroupInvocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMeshWorkGroupInvocations:    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMeshWorkGroupInvocations); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMeshWorkGroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMeshWorkGroupSize:           "); //HRW
    OutputString(outputFile, "uint32_t"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "3"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.maxMeshWorkGroupSize.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_maxMeshWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(outputFile, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxMeshWorkGroupSize), "maxMeshWorkGroupSize", 3, vinfo_maxMeshWorkGroupSize); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMeshTotalMemorySize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMeshTotalMemorySize:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMeshTotalMemorySize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMeshOutputVertices
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMeshOutputVertices:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMeshOutputVertices); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMeshOutputPrimitives
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMeshOutputPrimitives:        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMeshOutputPrimitives); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxMeshMultiviewViewCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxMeshMultiviewViewCount:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxMeshMultiviewViewCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t meshOutputPerVertexGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "meshOutputPerVertexGranularity: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->meshOutputPerVertexGranularity); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t meshOutputPerPrimitiveGranularity
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "meshOutputPerPrimitiveGranularity: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->meshOutputPerPrimitiveGranularity); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrawMeshTasksIndirectCommandNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t taskCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "taskCount:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->taskCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t firstTask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "firstTask:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->firstTask); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentShaderBarycentric
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentShaderBarycentric:      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentShaderBarycentric); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 imageFootprint
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imageFootprint:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->imageFootprint); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t exclusiveScissorCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "exclusiveScissorCount:          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->exclusiveScissorCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkRect2D* pExclusiveScissors
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pExclusiveScissors:             "); //HRW
    OutputString(outputFile, "const VkRect2D* = "); //TEQ
    if (pstruct->pExclusiveScissors == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pExclusiveScissors->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(outputFile, indent+1, 1, "VkRect2D", pstruct_in.pExclusiveScissors->GetMetaStructPointer(), "pExclusiveScissors", pstruct->exclusiveScissorCount, false, pstruct_in.pExclusiveScissors->GetAddress());  // CCP
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExclusiveScissorFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 exclusiveScissor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "exclusiveScissor:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->exclusiveScissor); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueueFamilyCheckpointPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineStageFlags checkpointExecutionStageMask
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "checkpointExecutionStageMask:   "); //HRW
    OutputString(outputFile, "VkPipelineStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->checkpointExecutionStageMask, EnumToStringVkPipelineStageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCheckpointDataNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineStageFlagBits stage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stage:                          "); //HRW
    OutputString(outputFile, "VkPipelineStageFlagBits = "); //TEQ
    EnumToStringVkPipelineStageFlagBits(outputFile, pstruct->stage); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->stage);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pCheckpointMarker
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pCheckpointMarker:              "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pCheckpointMarker == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pCheckpointMarker); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderIntegerFunctions2
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderIntegerFunctions2:        "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderIntegerFunctions2); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceValueDataINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: uint32_t value32
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "value32:                        "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->value32); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t value64
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "value64:                        "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->value64); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: float valueFloat
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "valueFloat:                     "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->valueFloat); // PEZ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 valueBool
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "valueBool:                      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->valueBool); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: const char* valueString
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "valueString:                    "); //HRW
    OutputString(outputFile, "const char* = "); //TEQ
    StringToQuotedString(outputFile, pstruct->valueString); // TGI
}

void StructureToString(FILE* outputFile, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceValueINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkPerformanceValueTypeINTEL type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkPerformanceValueTypeINTEL = "); //TEQ
    EnumToStringVkPerformanceValueTypeINTEL(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPerformanceValueDataINTEL data
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "data:                           "); //HRW
    OutputString(outputFile, "VkPerformanceValueDataINTEL = "); //TEQ
    OutputString(outputFile, "(Union):"); // RGT
    StructureToString(outputFile, *pstruct_in.data, indent+1,  base_addr + offsetof(VkPerformanceValueINTEL, data)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkInitializePerformanceApiInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pUserData
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pUserData:                      "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pUserData); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueryPoolCreateInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkQueryPoolSamplingModeINTEL performanceCountersSampling
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "performanceCountersSampling:    "); //HRW
    OutputString(outputFile, "VkQueryPoolSamplingModeINTEL = "); //TEQ
    EnumToStringVkQueryPoolSamplingModeINTEL(outputFile, pstruct->performanceCountersSampling); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->performanceCountersSampling);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceMarkerInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t marker
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "marker:                         "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->marker); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceStreamMarkerInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t marker
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "marker:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->marker); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceOverrideInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPerformanceOverrideTypeINTEL type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkPerformanceOverrideTypeINTEL = "); //TEQ
    EnumToStringVkPerformanceOverrideTypeINTEL(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 enable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "enable:                         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->enable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint64_t parameter
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "parameter:                      "); //HRW
    OutputString(outputFile, "uint64_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->parameter); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceConfigurationAcquireInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPerformanceConfigurationTypeINTEL type
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "type:                           "); //HRW
    OutputString(outputFile, "VkPerformanceConfigurationTypeINTEL = "); //TEQ
    EnumToStringVkPerformanceConfigurationTypeINTEL(outputFile, pstruct->type); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->type);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePCIBusInfoPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t pciDomain
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pciDomain:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pciDomain); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t pciBus
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pciBus:                         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pciBus); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t pciDevice
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pciDevice:                      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pciDevice); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t pciFunction
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pciFunction:                    "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->pciFunction); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 localDimmingSupport
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "localDimmingSupport:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->localDimmingSupport); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSwapchainDisplayNativeHdrCreateInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 localDimmingEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "localDimmingEnable:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->localDimmingEnable); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImagePipeSurfaceCreateInfoFUCHSIA *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImagePipeSurfaceCreateFlagsFUCHSIA flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkImagePipeSurfaceCreateFlagsFUCHSIA = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t imagePipeHandle
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "imagePipeHandle:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->imagePipeHandle); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMetalSurfaceCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkMetalSurfaceCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkMetalSurfaceCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pLayer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pLayer:                         "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pLayer == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pLayer); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentDensityMap
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentDensityMap:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentDensityMap); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentDensityMapDynamic
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentDensityMapDynamic:      "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentDensityMapDynamic); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentDensityMapNonSubsampledImages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentDensityMapNonSubsampledImages: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentDensityMapNonSubsampledImages); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D minFragmentDensityTexelSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minFragmentDensityTexelSize:    "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.minFragmentDensityTexelSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, minFragmentDensityTexelSize)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkExtent2D maxFragmentDensityTexelSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxFragmentDensityTexelSize:    "); //HRW
    OutputString(outputFile, "VkExtent2D = "); //TEQ
    StructureToString(outputFile, *pstruct_in.maxFragmentDensityTexelSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, maxFragmentDensityTexelSize)); // AZJ
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentDensityInvocations
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentDensityInvocations:     "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentDensityInvocations); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassFragmentDensityMapCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkAttachmentReference fragmentDensityMapAttachment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentDensityMapAttachment:   "); //HRW
    OutputString(outputFile, "VkAttachmentReference = "); //TEQ
    StructureToString(outputFile, *pstruct_in.fragmentDensityMapAttachment, indent+1,  base_addr + offsetof(VkRenderPassFragmentDensityMapCreateInfoEXT, fragmentDensityMapAttachment)); // AZJ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 scalarBlockLayout
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "scalarBlockLayout:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->scalarBlockLayout); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 subgroupSizeControl
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "subgroupSizeControl:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->subgroupSizeControl); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 computeFullSubgroups
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "computeFullSubgroups:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->computeFullSubgroups); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t minSubgroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "minSubgroupSize:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->minSubgroupSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxSubgroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxSubgroupSize:                "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxSubgroupSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t maxComputeWorkgroupSubgroups
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "maxComputeWorkgroupSubgroups:   "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->maxComputeWorkgroupSubgroups); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderStageFlags requiredSubgroupSizeStages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "requiredSubgroupSizeStages:     "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->requiredSubgroupSizeStages, EnumToStringVkShaderStageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t requiredSubgroupSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "requiredSubgroupSize:           "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->requiredSubgroupSize); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderCoreProperties2AMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderCorePropertiesFlagsAMD shaderCoreFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderCoreFeatures:             "); //HRW
    OutputString(outputFile, "VkShaderCorePropertiesFlagsAMD = "); //TEQ
    FlagsToString(outputFile, pstruct->shaderCoreFeatures, EnumToStringVkShaderCorePropertiesFlagBitsAMD); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t activeComputeUnitCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "activeComputeUnitCount:         "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->activeComputeUnitCount); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 deviceCoherentMemory
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceCoherentMemory:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->deviceCoherentMemory); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize heapBudget
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "heapBudget:                     "); //HRW
    OutputString(outputFile, "VkDeviceSize"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "VK_MAX_MEMORY_HEAPS"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.heapBudget.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_heapBudget = {false, false, false, nullptr};
    ArrayToString<VkDeviceSize*>(outputFile, indent, 0, "VkDeviceSize", const_cast<VkDeviceSize*>(pstruct->heapBudget), "heapBudget", VK_MAX_MEMORY_HEAPS, vinfo_heapBudget); // JPA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize heapUsage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "heapUsage:                      "); //HRW
    OutputString(outputFile, "VkDeviceSize"); //JUQ
    OutputString(outputFile, "[");
    OutputString(outputFile, "VK_MAX_MEMORY_HEAPS"); //DFX
    OutputString(outputFile, "] = ");
    AddrToString(outputFile, pstruct_in.heapUsage.GetAddress()); // IYZ
    ScalarValueToStringStruct vinfo_heapUsage = {false, false, false, nullptr};
    ArrayToString<VkDeviceSize*>(outputFile, indent, 0, "VkDeviceSize", const_cast<VkDeviceSize*>(pstruct->heapUsage), "heapUsage", VK_MAX_MEMORY_HEAPS, vinfo_heapUsage); // JPA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 memoryPriority
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "memoryPriority:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->memoryPriority); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkMemoryPriorityAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryPriorityAllocateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: float priority
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "priority:                       "); //HRW
    OutputString(outputFile, "float = "); //TEQ
    DoubleToString(outputFile, pstruct->priority); // PEZ
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 dedicatedAllocationImageAliasing
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "dedicatedAllocationImageAliasing: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->dedicatedAllocationImageAliasing); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 bufferDeviceAddress
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferDeviceAddress:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->bufferDeviceAddress); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 bufferDeviceAddressCaptureReplay
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferDeviceAddressCaptureReplay: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->bufferDeviceAddressCaptureReplay); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 bufferDeviceAddressMultiDevice
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bufferDeviceAddressMultiDevice: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->bufferDeviceAddressMultiDevice); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferDeviceAddressInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "buffer:                         "); //HRW
    OutputString(outputFile, "VkBuffer = "); //TEQ
    AddrToString(outputFile, pstruct_in.buffer); // PAQ
}

void StructureToString(FILE* outputFile, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferDeviceAddressCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceAddress deviceAddress
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "deviceAddress:                  "); //HRW
    OutputString(outputFile, "VkDeviceAddress = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->deviceAddress); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkImageStencilUsageCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageStencilUsageCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkImageUsageFlags stencilUsage
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stencilUsage:                   "); //HRW
    OutputString(outputFile, "VkImageUsageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->stencilUsage, EnumToStringVkImageUsageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkValidationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkValidationFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t enabledValidationFeatureCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "enabledValidationFeatureCount:  "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->enabledValidationFeatureCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkValidationFeatureEnableEXT* pEnabledValidationFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pEnabledValidationFeatures:     "); //HRW
    OutputString(outputFile, "const VkValidationFeatureEnableEXT* = "); //TEQ
    if (pstruct->pEnabledValidationFeatures == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pEnabledValidationFeatures.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pEnabledValidationFeatures = {false, true, false, EnumToStringVkValidationFeatureEnableEXT};
        ArrayToString<const VkValidationFeatureEnableEXT*>(outputFile, indent, 1, "const VkValidationFeatureEnableEXT*", reinterpret_cast<const VkValidationFeatureEnableEXT*>(pstruct_in.pEnabledValidationFeatures.GetPointer()), "pEnabledValidationFeatures", pstruct->enabledValidationFeatureCount,  vinfo_pEnabledValidationFeatures);  // CXC
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t disabledValidationFeatureCount
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "disabledValidationFeatureCount: "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->disabledValidationFeatureCount); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: const VkValidationFeatureDisableEXT* pDisabledValidationFeatures
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pDisabledValidationFeatures:    "); //HRW
    OutputString(outputFile, "const VkValidationFeatureDisableEXT* = "); //TEQ
    if (pstruct->pDisabledValidationFeatures == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.pDisabledValidationFeatures.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDisabledValidationFeatures = {false, true, false, EnumToStringVkValidationFeatureDisableEXT};
        ArrayToString<const VkValidationFeatureDisableEXT*>(outputFile, indent, 1, "const VkValidationFeatureDisableEXT*", reinterpret_cast<const VkValidationFeatureDisableEXT*>(pstruct_in.pDisabledValidationFeatures.GetPointer()), "pDisabledValidationFeatures", pstruct->disabledValidationFeatureCount,  vinfo_pDisabledValidationFeatures);  // CXC
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCooperativeMatrixPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t MSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "MSize:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->MSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t NSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "NSize:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->NSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t KSize
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "KSize:                          "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->KSize); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentTypeNV AType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "AType:                          "); //HRW
    OutputString(outputFile, "VkComponentTypeNV = "); //TEQ
    EnumToStringVkComponentTypeNV(outputFile, pstruct->AType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->AType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentTypeNV BType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "BType:                          "); //HRW
    OutputString(outputFile, "VkComponentTypeNV = "); //TEQ
    EnumToStringVkComponentTypeNV(outputFile, pstruct->BType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->BType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentTypeNV CType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "CType:                          "); //HRW
    OutputString(outputFile, "VkComponentTypeNV = "); //TEQ
    EnumToStringVkComponentTypeNV(outputFile, pstruct->CType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->CType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkComponentTypeNV DType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "DType:                          "); //HRW
    OutputString(outputFile, "VkComponentTypeNV = "); //TEQ
    EnumToStringVkComponentTypeNV(outputFile, pstruct->DType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->DType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkScopeNV scope
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "scope:                          "); //HRW
    OutputString(outputFile, "VkScopeNV = "); //TEQ
    EnumToStringVkScopeNV(outputFile, pstruct->scope); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->scope);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 cooperativeMatrix
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "cooperativeMatrix:              "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->cooperativeMatrix); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 cooperativeMatrixRobustBufferAccess
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "cooperativeMatrixRobustBufferAccess: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->cooperativeMatrixRobustBufferAccess); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkShaderStageFlags cooperativeMatrixSupportedStages
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "cooperativeMatrixSupportedStages: "); //HRW
    OutputString(outputFile, "VkShaderStageFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->cooperativeMatrixSupportedStages, EnumToStringVkShaderStageFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 coverageReductionMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageReductionMode:          "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->coverageReductionMode); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCoverageReductionStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkPipelineCoverageReductionStateCreateFlagsNV flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkPipelineCoverageReductionStateCreateFlagsNV = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCoverageReductionModeNV coverageReductionMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageReductionMode:          "); //HRW
    OutputString(outputFile, "VkCoverageReductionModeNV = "); //TEQ
    EnumToStringVkCoverageReductionModeNV(outputFile, pstruct->coverageReductionMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->coverageReductionMode);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferMixedSamplesCombinationNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkCoverageReductionModeNV coverageReductionMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "coverageReductionMode:          "); //HRW
    OutputString(outputFile, "VkCoverageReductionModeNV = "); //TEQ
    EnumToStringVkCoverageReductionModeNV(outputFile, pstruct->coverageReductionMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->coverageReductionMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlagBits rasterizationSamples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rasterizationSamples:           "); //HRW
    OutputString(outputFile, "VkSampleCountFlagBits = "); //TEQ
    EnumToStringVkSampleCountFlagBits(outputFile, pstruct->rasterizationSamples); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->rasterizationSamples);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags depthStencilSamples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "depthStencilSamples:            "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->depthStencilSamples, EnumToStringVkSampleCountFlagBits); // URW
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkSampleCountFlags colorSamples
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "colorSamples:                   "); //HRW
    OutputString(outputFile, "VkSampleCountFlags = "); //TEQ
    FlagsToString(outputFile, pstruct->colorSamples, EnumToStringVkSampleCountFlagBits); // URW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentShaderSampleInterlock
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentShaderSampleInterlock:  "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentShaderSampleInterlock); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentShaderPixelInterlock
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentShaderPixelInterlock:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentShaderPixelInterlock); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fragmentShaderShadingRateInterlock
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fragmentShaderShadingRateInterlock: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fragmentShaderShadingRateInterlock); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 ycbcrImageArrays
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "ycbcrImageArrays:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->ycbcrImageArrays); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFullScreenExclusiveInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkFullScreenExclusiveEXT fullScreenExclusive
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fullScreenExclusive:            "); //HRW
    OutputString(outputFile, "VkFullScreenExclusiveEXT = "); //TEQ
    EnumToStringVkFullScreenExclusiveEXT(outputFile, pstruct->fullScreenExclusive); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->fullScreenExclusive);
    OutputString(outputFile, ")");
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 fullScreenExclusiveSupported
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "fullScreenExclusiveSupported:   "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->fullScreenExclusiveSupported); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFullScreenExclusiveWin32InfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* hmonitor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "hmonitor:                       "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->hmonitor == nullptr) // WWX
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        AddrToString(outputFile, pstruct_in.hmonitor); // PWR
    }
}

void StructureToString(FILE* outputFile, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkHeadlessSurfaceCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkHeadlessSurfaceCreateFlagsEXT flags
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "flags:                          "); //HRW
    OutputString(outputFile, "VkHeadlessSurfaceCreateFlagsEXT = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->flags); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceLineRasterizationFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 rectangularLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "rectangularLines:               "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->rectangularLines); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 bresenhamLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "bresenhamLines:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->bresenhamLines); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 smoothLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "smoothLines:                    "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->smoothLines); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 stippledRectangularLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stippledRectangularLines:       "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->stippledRectangularLines); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 stippledBresenhamLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stippledBresenhamLines:         "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->stippledBresenhamLines); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 stippledSmoothLines
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stippledSmoothLines:            "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->stippledSmoothLines); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceLineRasterizationPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t lineSubPixelPrecisionBits
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "lineSubPixelPrecisionBits:      "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->lineSubPixelPrecisionBits); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationLineStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: const void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "const void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkLineRasterizationModeEXT lineRasterizationMode
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "lineRasterizationMode:          "); //HRW
    OutputString(outputFile, "VkLineRasterizationModeEXT = "); //TEQ
    EnumToStringVkLineRasterizationModeEXT(outputFile, pstruct->lineRasterizationMode); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->lineRasterizationMode);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 stippledLineEnable
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "stippledLineEnable:             "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->stippledLineEnable); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint32_t lineStippleFactor
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "lineStippleFactor:              "); //HRW
    OutputString(outputFile, "uint32_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->lineStippleFactor); // UYW
    OutputString(outputFile, "\n"); // GDS

    // struct member: uint16_t lineStipplePattern
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "lineStipplePattern:             "); //HRW
    OutputString(outputFile, "uint16_t = "); //TEQ
    UnsignedDecimalToString(outputFile, pstruct->lineStipplePattern); // UYW
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceHostQueryResetFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 hostQueryReset
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "hostQueryReset:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->hostQueryReset); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 indexTypeUint8
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "indexTypeUint8:                 "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->indexTypeUint8); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 shaderDemoteToHelperInvocation
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "shaderDemoteToHelperInvocation: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->shaderDemoteToHelperInvocation); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 texelBufferAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "texelBufferAlignment:           "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->texelBufferAlignment); //EQA
}

void StructureToString(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputString(outputFile, "\n"); // UUR

    // struct member: VkStructureType sType
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "sType:                          "); //HRW
    OutputString(outputFile, "VkStructureType = "); //TEQ
    EnumToStringVkStructureType(outputFile, pstruct->sType); // VSA
    OutputString(outputFile, " (");
    UnsignedDecimalToString(outputFile, pstruct->sType);
    OutputString(outputFile, ")");
    OutputString(outputFile, "\n"); // GDS

    // struct member: void* pNext
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "pNext:                          "); //HRW
    OutputString(outputFile, "void* = "); //TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputString(outputFile, "NULL");
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        void *pNextLocal = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PNX
        ScalarValueToString(outputFile, &pNextLocal, vinfo_pNext);
        if (pNextLocal)
        {
            PnextStructToString(outputFile, indent+1, reinterpret_cast<void*>(pstruct_in.pNext->GetMetaStructPointer())); //POX 
        }
    }
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize storageTexelBufferOffsetAlignmentBytes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storageTexelBufferOffsetAlignmentBytes: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->storageTexelBufferOffsetAlignmentBytes); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 storageTexelBufferOffsetSingleTexelAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "storageTexelBufferOffsetSingleTexelAlignment: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->storageTexelBufferOffsetSingleTexelAlignment); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkDeviceSize uniformTexelBufferOffsetAlignmentBytes
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "uniformTexelBufferOffsetAlignmentBytes: "); //HRW
    OutputString(outputFile, "VkDeviceSize = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->uniformTexelBufferOffsetAlignmentBytes); //EQA
    OutputString(outputFile, "\n"); // GDS

    // struct member: VkBool32 uniformTexelBufferOffsetSingleTexelAlignment
    IndentSpaces(outputFile, indent);
    OutputString(outputFile, "uniformTexelBufferOffsetSingleTexelAlignment: "); //HRW
    OutputString(outputFile, "VkBool32 = "); //TEQ
    SignedDecimalToString(outputFile, pstruct->uniformTexelBufferOffsetSingleTexelAlignment); //EQA
}

GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)

#endif
