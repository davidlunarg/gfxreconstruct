/*
** Copyright (c) 2018-2019 Valve Corporation
** Copyright (c) 2018-2019 LunarG, Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "generated/generated_vulkan_ascii_consumer.h"
#include "generated/generated_vulkan_ascii_enum_util.h"
#include "format/platform_types.h"
#include "util/defines.h"
#include "vulkan/vulkan.h"
#include <functional>
#include <inttypes.h>
#include <string>

extern int  kIndentSize;
extern bool kNoAddr;
extern bool kPrintShaderCode;

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

typedef std::function<void(std::string *, uint32_t)> EnumToStringFuncPtr;

typedef struct ScalarValueToStringStruct {
   bool is_handle_or_addr;
   bool is_enum;
   bool is_flags;
   EnumToStringFuncPtr enum_to_string_func;
} ScalarValueToStringStruct;

void SignedDecimalToString(std::string* out, int64_t n)
{
    char tmp[30];
    assert(out != nullptr);
    snprintf(tmp, sizeof(tmp), "%" PRId64, n);
    snprintf(tmp, sizeof(tmp), "%" PRId64, n);
    *out += tmp;
}

void UnsignedDecimalToString(std::string* out, uint64_t n)
{
    char tmp[30];
    assert(out != nullptr);
    snprintf(tmp, sizeof(tmp), "%" PRIu64, n);
    *out += tmp;
}

void DoubleToString(std::string* out, double d)
{
    char tmp[30];
    snprintf(tmp, sizeof(tmp), "%g", d);
    *out += tmp;
}

void AddrToString(std::string* out, uint64_t a)
{
    assert(out != nullptr);
    if (kNoAddr)
    {
        *out += "address";
    }
    else
    {
        char tmp[30];
        snprintf(tmp, sizeof(tmp), "0x%" PRIx64, a);
        *out += tmp;
    }
}

void IndentSpaces(std::string* out, int indent)
{
    assert(out != nullptr);
    out->insert(out->end(), indent * kIndentSize, ' ');
}

void FlagsToString(std::string* out, VkFlags flags, EnumToStringFuncPtr enum_to_string_func)
{
    VkFlags m = 1;
    assert(out != nullptr);
    UnsignedDecimalToString(out, flags);
    if (flags != 0)
    {
        *out += " (";
        while (flags)
        {
            if (m & flags)
            {
                enum_to_string_func(out, (m & flags));
                flags = flags & ~m;
                if (flags & ~m)
                {
                    *out += " | ";
                }
            }
            else
            {
                flags &= ~m;
            }
            m <<= 1;
        }
        *out += ")";
    }
    return;
}


template <typename T>
void ScalarValueToString(std::string* out, T value, const ScalarValueToStringStruct &vinfo)
{
    assert(out != nullptr);
    assert((vinfo.is_handle_or_addr + vinfo.is_enum  + vinfo.is_flags) <= 1);
    assert(vinfo.is_enum ? vinfo.enum_to_string_func != nullptr : true);
    assert(vinfo.is_flags ? vinfo.enum_to_string_func != nullptr : true);
    if (vinfo.is_handle_or_addr)
    {
        uint64_t v = *((uint64_t*)value);
        AddrToString(out, v);
    }
    else if (vinfo.is_flags)
    {
        uint32_t v = *((uint32_t*)value);
        FlagsToString(out, v, vinfo.enum_to_string_func);
    }
    else if (vinfo.is_enum)
    {
        uint32_t v = *((uint32_t*)value);
        vinfo.enum_to_string_func(out, v);
    }
    else if (std::is_same<T, float*>::value || std::is_same<T, const float*>::value)
    {
        double v = *((float*)value);
        DoubleToString(out, v);
    }
    else if (std::is_same<T, double*>::value || std::is_same<T, const double*>::value)
    {
        DoubleToString(out, *((double*)value));
    }
    else if (std::is_same<T, int32_t*>::value || std::is_same<T, const int32_t*>::value)
    {
        int32_t v = *((int32_t*)value);
        SignedDecimalToString(out, v);
    }
    else if (std::is_same<T, uint32_t*>::value || std::is_same<T, const uint32_t*>::value)
    {
        uint32_t v = *((uint32_t*)value);
        UnsignedDecimalToString(out, v);
    }
    else if (std::is_same<T, int64_t*>::value || std::is_same<T, const int64_t*>::value)
    {
        int64_t v = *((int64_t*)value);
        SignedDecimalToString(out, v);
    }
    else if (std::is_same<T, unsigned int*>::value || std::is_same<T, const unsigned int*>::value)
    {
        unsigned int v = *((unsigned int*)value);
        UnsignedDecimalToString(out, v);
    }
    else if (std::is_same<T, unsigned char*>::value || std::is_same<T, const unsigned char*>::value)
    {
        unsigned char v = *((unsigned char*)value);
        UnsignedDecimalToString(out, v);
    }
    else
    {
        uint64_t v = *((uint64_t*)value);
        UnsignedDecimalToString(out, v);
    }
}
void StringToQuotedString(std::string* out, const char* s)
{
    assert(out != nullptr);
    if (s != nullptr)
    {
        *out += "\"";
        *out += s;
        *out += "\"";
    }
    else
    {
        *out += "NULL";
    }
}

void PadString(std::string* s, size_t len)
{
    assert(s != nullptr);
    if (s->length() < len)
    {
        s->insert(s->end(), len - s->length(), ' ');
    }
}

template <typename T>
void StructureToString(std::string* out, const T& pstruct_in, int indent, uint64_t base_addr);

template <typename T>
void ArrayToString(std::string*                    out,
                   int                             indent,
                   const int                       pointer_count,
                   const char*                     full_type_name,
                   T                               array,
                   const char*                     array_name,
                   const size_t                    array_length,
                   const ScalarValueToStringStruct &vinfo)
{
    assert(out != nullptr);
    assert((vinfo.is_handle_or_addr + vinfo.is_enum  + vinfo.is_flags) <= 1);
    assert(vinfo.is_enum ? vinfo.enum_to_string_func != nullptr : true);
    assert(vinfo.is_flags ? vinfo.enum_to_string_func != nullptr : true);
    if (array_length == 0 || array == nullptr)
    {
        return;
    }
    if (pointer_count <= 1 &&
        (std::is_same<T, const char>::value || std::is_same<T, const char>::value || std::is_same<T, char>::value ||
         std::is_same<T, const char*>::value || std::is_same<T, char*>::value))
    {
        StringToQuotedString(out, *((const char**)&array));
    }
    else
    {
        std::string full_type_name_str = full_type_name;
        if (*full_type_name_str.rbegin() == '*')
        {
            full_type_name_str.pop_back();
        }
        *out += "\n";
        for (uint64_t j = 0; j < array_length; j++)
        {
            IndentSpaces(out, indent + 1);
            std::string name_and_index;
            name_and_index += array_name;
            name_and_index += "[";
            UnsignedDecimalToString(&name_and_index, j);
            name_and_index += "]: ";
            PadString(&name_and_index, 32);
            *out += name_and_index;
            *out += full_type_name_str;
            *out += " = ";
            if (pointer_count > 1)
            {
                if (pointer_count == 2 && strstr(full_type_name, "char"))
                {
                    StringToQuotedString(out, ((const char**)array)[j]);
                }
                else
                {
                    fprintf(stderr, "ERROR: ArrayToString arrays of non-strings not implemented\n");
                }
            }
            else
            {
                ScalarValueToString<T>(out, &array[j], vinfo);
            }
            if (j < array_length - 1)
            {
                *out += "\n";
            }
        }
    }
}

template <typename T>
void ArrayOfStructsToString(std::string* out,
                            int          indent,
                            const int    pointer_count,
                            const char*  base_type_name,
                            T*           array,
                            const char*  array_name,
                            const size_t array_length,
                            bool         is_union,
                            uint64_t     base_addr)
{
    assert(out != nullptr);
    if (array_length == 0 || array == nullptr)
    {
        return;
    }
    *out += "\n";
    for (uint64_t j = 0; j < array_length; j++)
    {
        IndentSpaces(out, indent);
        std::string name_and_index;
        name_and_index += array_name;
        name_and_index += "[";
        UnsignedDecimalToString(&name_and_index, j);
        name_and_index += "]: ";
        PadString(&name_and_index, 32);
        *out += name_and_index;
        *out += base_type_name;
        *out += " = ";
        AddrToString(out, base_addr + j * sizeof(T)); // UEW
        if (is_union)
        {
            *out += " (Union)";
        }
        *out += ":";
        if (pointer_count > 1)
        {
            fprintf(stderr, "ERROR: ArrayOfStructsToString cannot handle arrays of arrays\n");
        }
        else
        {
            StructureToString<T>(out, array[j], indent + 1, base_addr + j * sizeof(T)); // YQS
        }
        if (j < array_length - 1)
        {
            *out += "\n"; // AZC
        }
    }
}


template <> void StructureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(std::string* out, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDependency>(std::string* out, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFenceCreateInfo>(std::string* out, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(std::string* out, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryAllocateInfo>(std::string* out, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGraphicsPipelineCreateInfo>(std::string* out, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassCreateInfo>(std::string* out, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentDescription>(std::string* out, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExtensionProperties>(std::string* out, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageFormatProperties>(std::string* out, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkLayerProperties>(std::string* out, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkViewport>(std::string* out, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPushConstantRange>(std::string* out, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkComputePipelineCreateInfo>(std::string* out, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetLayoutBinding>(std::string* out, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSparseProperties>(std::string* out, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrawIndirectCommand>(std::string* out, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFramebufferCreateInfo>(std::string* out, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassBeginInfo>(std::string* out, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportStateCreateInfo>(std::string* out, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(std::string* out, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferCopy>(std::string* out, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubresourceLayout>(std::string* out, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSubresource>(std::string* out, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueueFamilyProperties>(std::string* out, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferBeginInfo>(std::string* out, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferImageCopy>(std::string* out, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferViewCreateInfo>(std::string* out, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProperties>(std::string* out, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(std::string* out, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(std::string* out, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRect2D>(std::string* out, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkStencilOpState>(std::string* out, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageViewCreateInfo>(std::string* out, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageCreateInfo>(std::string* out, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentReference>(std::string* out, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferMemoryBarrier>(std::string* out, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryRequirements>(std::string* out, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryType>(std::string* out, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFormatProperties>(std::string* out, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferAllocateInfo>(std::string* out, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkEventCreateInfo>(std::string* out, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryRequirements>(std::string* out, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDescription>(std::string* out, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCopyDescriptorSet>(std::string* out, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSubresourceLayers>(std::string* out, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubmitInfo>(std::string* out, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageResolve>(std::string* out, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineLayoutCreateInfo>(std::string* out, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceQueueCreateInfo>(std::string* out, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(std::string* out, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkShaderModuleCreateInfo>(std::string* out, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageCopy>(std::string* out, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseBufferMemoryBindInfo>(std::string* out, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferCreateInfo>(std::string* out, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkOffset2D>(std::string* out, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkComponentMapping>(std::string* out, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkInstanceCreateInfo>(std::string* out, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseMemoryBind>(std::string* out, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineDynamicStateCreateInfo>(std::string* out, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineCacheCreateInfo>(std::string* out, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkVertexInputAttributeDescription>(std::string* out, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSpecializationInfo>(std::string* out, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueryPoolCreateInfo>(std::string* out, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkOffset3D>(std::string* out, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExtent3D>(std::string* out, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandPoolCreateInfo>(std::string* out, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageMemoryBarrier>(std::string* out, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorBufferInfo>(std::string* out, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearColorValue>(std::string* out, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineColorBlendAttachmentState>(std::string* out, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDispatchIndirectCommand>(std::string* out, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearDepthStencilValue>(std::string* out, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetAllocateInfo>(std::string* out, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrawIndexedIndirectCommand>(std::string* out, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferInheritanceInfo>(std::string* out, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorPoolSize>(std::string* out, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageFormatProperties>(std::string* out, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryBarrier>(std::string* out, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExtent2D>(std::string* out, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineTessellationStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceLimits>(std::string* out, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageBlit>(std::string* out, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkWriteDescriptorSet>(std::string* out, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkApplicationInfo>(std::string* out, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSpecializationMapEntry>(std::string* out, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindSparseInfo>(std::string* out, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearValue>(std::string* out, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryBind>(std::string* out, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkVertexInputBindingDescription>(std::string* out, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerCreateInfo>(std::string* out, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreCreateInfo>(std::string* out, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearAttachment>(std::string* out, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(std::string* out, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorPoolCreateInfo>(std::string* out, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorImageInfo>(std::string* out, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAllocationCallbacks>(std::string* out, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceFeatures>(std::string* out, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryHeap>(std::string* out, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineShaderStageCreateInfo>(std::string* out, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMappedMemoryRange>(std::string* out, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearRect>(std::string* out, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSubresourceRange>(std::string* out, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(std::string* out, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineDepthStencilStateCreateInfo *pstruct = (const VkPipelineDepthStencilStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineDepthStencilStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineDepthStencilStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkBool32 depthTestEnable
    IndentSpaces(out, indent);
    *out += "depthTestEnable:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthTestEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 depthWriteEnable
    IndentSpaces(out, indent);
    *out += "depthWriteEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthWriteEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkCompareOp depthCompareOp
    IndentSpaces(out, indent);
    *out += "depthCompareOp:                 ";
    *out += "VkCompareOp = "; // TEQ
    EnumToStringVkCompareOp(out, pstruct->depthCompareOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->depthCompareOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 depthBoundsTestEnable
    IndentSpaces(out, indent);
    *out += "depthBoundsTestEnable:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBoundsTestEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 stencilTestEnable
    IndentSpaces(out, indent);
    *out += "stencilTestEnable:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stencilTestEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkStencilOpState front
    IndentSpaces(out, indent);
    *out += "front:                          ";
    *out += "VkStencilOpState = "; // TEQ
    StructureToString<Decoded_VkStencilOpState>(out, *pstruct_in.front, indent+1,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, front)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkStencilOpState back
    IndentSpaces(out, indent);
    *out += "back:                           ";
    *out += "VkStencilOpState = "; // TEQ
    StructureToString<Decoded_VkStencilOpState>(out, *pstruct_in.back, indent+1,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, back)); // AZJ
    *out += "\n"; // GDS

    // struct member: float minDepthBounds
    IndentSpaces(out, indent);
    *out += "minDepthBounds:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minDepthBounds); // PEZ
    *out += "\n"; // GDS

    // struct member: float maxDepthBounds
    IndentSpaces(out, indent);
    *out += "maxDepthBounds:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxDepthBounds); // PEZ
}

template <>
void StructureToString<Decoded_VkSubpassDependency>(std::string* out, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDependency *pstruct = (const VkSubpassDependency *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t srcSubpass
    IndentSpaces(out, indent);
    *out += "srcSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcSubpass); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dstSubpass
    IndentSpaces(out, indent);
    *out += "dstSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstSubpass); // UYW
    *out += "\n"; // GDS

    // struct member: VkPipelineStageFlags srcStageMask
    IndentSpaces(out, indent);
    *out += "srcStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkPipelineStageFlags dstStageMask
    IndentSpaces(out, indent);
    *out += "dstStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkDependencyFlags dependencyFlags
    IndentSpaces(out, indent);
    *out += "dependencyFlags:                ";
    *out += "VkDependencyFlags = "; // TEQ
    FlagsToString(out, pstruct->dependencyFlags, EnumToStringVkDependencyFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkFenceCreateInfo>(std::string* out, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFenceCreateInfo *pstruct = (const VkFenceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFenceCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFenceCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFenceCreateFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(std::string* out, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineVertexInputStateCreateInfo *pstruct = (const VkPipelineVertexInputStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineVertexInputStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineVertexInputStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t vertexBindingDescriptionCount
    IndentSpaces(out, indent);
    *out += "vertexBindingDescriptionCount:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexBindingDescriptionCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkVertexInputBindingDescription* pVertexBindingDescriptions
    IndentSpaces(out, indent);
    *out += "pVertexBindingDescriptions:     ";
    *out += "const VkVertexInputBindingDescription* = "; // TEQ
    if (pstruct->pVertexBindingDescriptions == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pVertexBindingDescriptions->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkVertexInputBindingDescription>(out, indent+1, 1, "VkVertexInputBindingDescription", pstruct_in.pVertexBindingDescriptions->GetMetaStructPointer(), "pVertexBindingDescriptions", pstruct->vertexBindingDescriptionCount, false, pstruct_in.pVertexBindingDescriptions->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t vertexAttributeDescriptionCount
    IndentSpaces(out, indent);
    *out += "vertexAttributeDescriptionCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexAttributeDescriptionCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkVertexInputAttributeDescription* pVertexAttributeDescriptions
    IndentSpaces(out, indent);
    *out += "pVertexAttributeDescriptions:   ";
    *out += "const VkVertexInputAttributeDescription* = "; // TEQ
    if (pstruct->pVertexAttributeDescriptions == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pVertexAttributeDescriptions->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkVertexInputAttributeDescription>(out, indent+1, 1, "VkVertexInputAttributeDescription", pstruct_in.pVertexAttributeDescriptions->GetMetaStructPointer(), "pVertexAttributeDescriptions", pstruct->vertexAttributeDescriptionCount, false, pstruct_in.pVertexAttributeDescriptions->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkMemoryAllocateInfo>(std::string* out, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryAllocateInfo *pstruct = (const VkMemoryAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceSize allocationSize
    IndentSpaces(out, indent);
    *out += "allocationSize:                 ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->allocationSize); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t memoryTypeIndex
    IndentSpaces(out, indent);
    *out += "memoryTypeIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeIndex); // UYW
}

template <>
void StructureToString<Decoded_VkGraphicsPipelineCreateInfo>(std::string* out, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGraphicsPipelineCreateInfo *pstruct = (const VkGraphicsPipelineCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t stageCount
    IndentSpaces(out, indent);
    *out += "stageCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stageCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkPipelineShaderStageCreateInfo* pStages
    IndentSpaces(out, indent);
    *out += "pStages:                        ";
    *out += "const VkPipelineShaderStageCreateInfo* = "; // TEQ
    if (pstruct->pStages == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pStages->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(out, indent+1, 1, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineVertexInputStateCreateInfo* pVertexInputState
    IndentSpaces(out, indent);
    *out += "pVertexInputState:              ";
    *out += "const VkPipelineVertexInputStateCreateInfo* = "; // TEQ
    if (pstruct->pVertexInputState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pVertexInputState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(out, *pstruct_in.pVertexInputState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pVertexInputState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState
    IndentSpaces(out, indent);
    *out += "pInputAssemblyState:            ";
    *out += "const VkPipelineInputAssemblyStateCreateInfo* = "; // TEQ
    if (pstruct->pInputAssemblyState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInputAssemblyState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(out, *pstruct_in.pInputAssemblyState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pInputAssemblyState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineTessellationStateCreateInfo* pTessellationState
    IndentSpaces(out, indent);
    *out += "pTessellationState:             ";
    *out += "const VkPipelineTessellationStateCreateInfo* = "; // TEQ
    if (pstruct->pTessellationState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTessellationState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineTessellationStateCreateInfo>(out, *pstruct_in.pTessellationState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pTessellationState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineViewportStateCreateInfo* pViewportState
    IndentSpaces(out, indent);
    *out += "pViewportState:                 ";
    *out += "const VkPipelineViewportStateCreateInfo* = "; // TEQ
    if (pstruct->pViewportState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewportState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineViewportStateCreateInfo>(out, *pstruct_in.pViewportState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pViewportState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineRasterizationStateCreateInfo* pRasterizationState
    IndentSpaces(out, indent);
    *out += "pRasterizationState:            ";
    *out += "const VkPipelineRasterizationStateCreateInfo* = "; // TEQ
    if (pstruct->pRasterizationState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pRasterizationState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(out, *pstruct_in.pRasterizationState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pRasterizationState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineMultisampleStateCreateInfo* pMultisampleState
    IndentSpaces(out, indent);
    *out += "pMultisampleState:              ";
    *out += "const VkPipelineMultisampleStateCreateInfo* = "; // TEQ
    if (pstruct->pMultisampleState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pMultisampleState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(out, *pstruct_in.pMultisampleState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pMultisampleState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineDepthStencilStateCreateInfo* pDepthStencilState
    IndentSpaces(out, indent);
    *out += "pDepthStencilState:             ";
    *out += "const VkPipelineDepthStencilStateCreateInfo* = "; // TEQ
    if (pstruct->pDepthStencilState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDepthStencilState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(out, *pstruct_in.pDepthStencilState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDepthStencilState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineColorBlendStateCreateInfo* pColorBlendState
    IndentSpaces(out, indent);
    *out += "pColorBlendState:               ";
    *out += "const VkPipelineColorBlendStateCreateInfo* = "; // TEQ
    if (pstruct->pColorBlendState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pColorBlendState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(out, *pstruct_in.pColorBlendState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pColorBlendState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineDynamicStateCreateInfo* pDynamicState
    IndentSpaces(out, indent);
    *out += "pDynamicState:                  ";
    *out += "const VkPipelineDynamicStateCreateInfo* = "; // TEQ
    if (pstruct->pDynamicState == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDynamicState->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPipelineDynamicStateCreateInfo>(out, *pstruct_in.pDynamicState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDynamicState)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.layout); // PAQ
    *out += "\n"; // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t subpass
    IndentSpaces(out, indent);
    *out += "subpass:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpass); // UYW
    *out += "\n"; // GDS

    // struct member: VkPipeline basePipelineHandle
    IndentSpaces(out, indent);
    *out += "basePipelineHandle:             ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.basePipelineHandle); // PAQ
    *out += "\n"; // GDS

    // struct member: int32_t basePipelineIndex
    IndentSpaces(out, indent);
    *out += "basePipelineIndex:              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->basePipelineIndex); //EQA
}

template <>
void StructureToString<Decoded_VkRenderPassCreateInfo>(std::string* out, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassCreateInfo *pstruct = (const VkRenderPassCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkRenderPassCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkRenderPassCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkRenderPassCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAttachmentDescription* pAttachments
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkAttachmentDescription* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentDescription>(out, indent+1, 1, "VkAttachmentDescription", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t subpassCount
    IndentSpaces(out, indent);
    *out += "subpassCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSubpassDescription* pSubpasses
    IndentSpaces(out, indent);
    *out += "pSubpasses:                     ";
    *out += "const VkSubpassDescription* = "; // TEQ
    if (pstruct->pSubpasses == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSubpasses->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDescription>(out, indent+1, 1, "VkSubpassDescription", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t dependencyCount
    IndentSpaces(out, indent);
    *out += "dependencyCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dependencyCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSubpassDependency* pDependencies
    IndentSpaces(out, indent);
    *out += "pDependencies:                  ";
    *out += "const VkSubpassDependency* = "; // TEQ
    if (pstruct->pDependencies == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDependencies->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDependency>(out, indent+1, 1, "VkSubpassDependency", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkAttachmentDescription>(std::string* out, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentDescription *pstruct = (const VkAttachmentDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkAttachmentDescriptionFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkAttachmentDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkAttachmentDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentLoadOp loadOp
    IndentSpaces(out, indent);
    *out += "loadOp:                         ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->loadOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->loadOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentStoreOp storeOp
    IndentSpaces(out, indent);
    *out += "storeOp:                        ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->storeOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->storeOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentLoadOp stencilLoadOp
    IndentSpaces(out, indent);
    *out += "stencilLoadOp:                  ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->stencilLoadOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilLoadOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentStoreOp stencilStoreOp
    IndentSpaces(out, indent);
    *out += "stencilStoreOp:                 ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->stencilStoreOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilStoreOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageLayout initialLayout
    IndentSpaces(out, indent);
    *out += "initialLayout:                  ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->initialLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->initialLayout);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageLayout finalLayout
    IndentSpaces(out, indent);
    *out += "finalLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->finalLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->finalLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExtensionProperties>(std::string* out, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExtensionProperties *pstruct = (const VkExtensionProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: char extensionName
    IndentSpaces(out, indent);
    *out += "extensionName:                  ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_extensionName = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->extensionName), "extensionName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_extensionName); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t specVersion
    IndentSpaces(out, indent);
    *out += "specVersion:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->specVersion); // UYW
}

template <>
void StructureToString<Decoded_VkSparseImageFormatProperties>(std::string* out, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageFormatProperties *pstruct = (const VkSparseImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExtent3D imageGranularity
    IndentSpaces(out, indent);
    *out += "imageGranularity:               ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.imageGranularity, indent+1,  base_addr + offsetof(VkSparseImageFormatProperties, imageGranularity)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkSparseImageFormatFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSparseImageFormatFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSparseImageFormatFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkLayerProperties>(std::string* out, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkLayerProperties *pstruct = (const VkLayerProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: char layerName
    IndentSpaces(out, indent);
    *out += "layerName:                      ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_layerName = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->layerName), "layerName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_layerName); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t specVersion
    IndentSpaces(out, indent);
    *out += "specVersion:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->specVersion); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t implementationVersion
    IndentSpaces(out, indent);
    *out += "implementationVersion:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->implementationVersion); // UYW
    *out += "\n"; // GDS

    // struct member: char description
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
}

template <>
void StructureToString<Decoded_VkViewport>(std::string* out, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkViewport *pstruct = (const VkViewport *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: float x
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->x); // PEZ
    *out += "\n"; // GDS

    // struct member: float y
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->y); // PEZ
    *out += "\n"; // GDS

    // struct member: float width
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->width); // PEZ
    *out += "\n"; // GDS

    // struct member: float height
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->height); // PEZ
    *out += "\n"; // GDS

    // struct member: float minDepth
    IndentSpaces(out, indent);
    *out += "minDepth:                       ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minDepth); // PEZ
    *out += "\n"; // GDS

    // struct member: float maxDepth
    IndentSpaces(out, indent);
    *out += "maxDepth:                       ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxDepth); // PEZ
}

template <>
void StructureToString<Decoded_VkPushConstantRange>(std::string* out, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPushConstantRange *pstruct = (const VkPushConstantRange *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkShaderStageFlags stageFlags
    IndentSpaces(out, indent);
    *out += "stageFlags:                     ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->size); // UYW
}

template <>
void StructureToString<Decoded_VkComputePipelineCreateInfo>(std::string* out, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkComputePipelineCreateInfo *pstruct = (const VkComputePipelineCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkPipelineShaderStageCreateInfo stage
    IndentSpaces(out, indent);
    *out += "stage:                          ";
    *out += "VkPipelineShaderStageCreateInfo = "; // TEQ
    StructureToString<Decoded_VkPipelineShaderStageCreateInfo>(out, *pstruct_in.stage, indent+1,  base_addr + offsetof(VkComputePipelineCreateInfo, stage)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkPipelineLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.layout); // PAQ
    *out += "\n"; // GDS

    // struct member: VkPipeline basePipelineHandle
    IndentSpaces(out, indent);
    *out += "basePipelineHandle:             ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.basePipelineHandle); // PAQ
    *out += "\n"; // GDS

    // struct member: int32_t basePipelineIndex
    IndentSpaces(out, indent);
    *out += "basePipelineIndex:              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->basePipelineIndex); //EQA
}

template <>
void StructureToString<Decoded_VkDescriptorSetLayoutBinding>(std::string* out, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetLayoutBinding *pstruct = (const VkDescriptorSetLayoutBinding *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t binding
    IndentSpaces(out, indent);
    *out += "binding:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->binding); // UYW
    *out += "\n"; // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkShaderStageFlags stageFlags
    IndentSpaces(out, indent);
    *out += "stageFlags:                     ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: const VkSampler* pImmutableSamplers
    IndentSpaces(out, indent);
    *out += "pImmutableSamplers:             ";
    *out += "const VkSampler* = "; // TEQ
    if (pstruct->pImmutableSamplers == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImmutableSamplers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pImmutableSamplers = {true, false, false, nullptr};
        ArrayToString<const VkSampler*>(out, indent, 1, "const VkSampler*", reinterpret_cast<const VkSampler*>(pstruct_in.pImmutableSamplers.GetPointer()), "pImmutableSamplers", pstruct->descriptorCount,  vinfo_pImmutableSamplers);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSparseProperties>(std::string* out, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSparseProperties *pstruct = (const VkPhysicalDeviceSparseProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkBool32 residencyStandard2DBlockShape
    IndentSpaces(out, indent);
    *out += "residencyStandard2DBlockShape:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyStandard2DBlockShape); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 residencyStandard2DMultisampleBlockShape
    IndentSpaces(out, indent);
    *out += "residencyStandard2DMultisampleBlockShape: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyStandard2DMultisampleBlockShape); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 residencyStandard3DBlockShape
    IndentSpaces(out, indent);
    *out += "residencyStandard3DBlockShape:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyStandard3DBlockShape); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 residencyAlignedMipSize
    IndentSpaces(out, indent);
    *out += "residencyAlignedMipSize:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyAlignedMipSize); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 residencyNonResidentStrict
    IndentSpaces(out, indent);
    *out += "residencyNonResidentStrict:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyNonResidentStrict); //EQA
}

template <>
void StructureToString<Decoded_VkDrawIndirectCommand>(std::string* out, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrawIndirectCommand *pstruct = (const VkDrawIndirectCommand *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t vertexCount
    IndentSpaces(out, indent);
    *out += "vertexCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t instanceCount
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->instanceCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t firstVertex
    IndentSpaces(out, indent);
    *out += "firstVertex:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstVertex); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t firstInstance
    IndentSpaces(out, indent);
    *out += "firstInstance:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstInstance); // UYW
}

template <>
void StructureToString<Decoded_VkFramebufferCreateInfo>(std::string* out, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFramebufferCreateInfo *pstruct = (const VkFramebufferCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFramebufferCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFramebufferCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFramebufferCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkImageView* pAttachments
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkImageView* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAttachments = {true, false, false, nullptr};
        ArrayToString<const VkImageView*>(out, indent, 1, "const VkImageView*", reinterpret_cast<const VkImageView*>(pstruct_in.pAttachments.GetPointer()), "pAttachments", pstruct->attachmentCount,  vinfo_pAttachments);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t width
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->width); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t height
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->height); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t layers
    IndentSpaces(out, indent);
    *out += "layers:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layers); // UYW
}

template <>
void StructureToString<Decoded_VkRenderPassBeginInfo>(std::string* out, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassBeginInfo *pstruct = (const VkRenderPassBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // struct member: VkFramebuffer framebuffer
    IndentSpaces(out, indent);
    *out += "framebuffer:                    ";
    *out += "VkFramebuffer = "; // TEQ
    AddrToString(out, pstruct_in.framebuffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkRect2D renderArea
    IndentSpaces(out, indent);
    *out += "renderArea:                     ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.renderArea, indent+1,  base_addr + offsetof(VkRenderPassBeginInfo, renderArea)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t clearValueCount
    IndentSpaces(out, indent);
    *out += "clearValueCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->clearValueCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkClearValue* pClearValues
    IndentSpaces(out, indent);
    *out += "pClearValues:                   ";
    *out += "const VkClearValue* = "; // TEQ
    if (pstruct->pClearValues == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pClearValues->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkClearValue>(out, indent+1, 1, "VkClearValue", pstruct_in.pClearValues->GetMetaStructPointer(), "pClearValues", pstruct->clearValueCount, true, pstruct_in.pClearValues->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPipelineViewportStateCreateInfo>(std::string* out, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportStateCreateInfo *pstruct = (const VkPipelineViewportStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineViewportStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineViewportStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t viewportCount
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkViewport* pViewports
    IndentSpaces(out, indent);
    *out += "pViewports:                     ";
    *out += "const VkViewport* = "; // TEQ
    if (pstruct->pViewports == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewports->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkViewport>(out, indent+1, 1, "VkViewport", pstruct_in.pViewports->GetMetaStructPointer(), "pViewports", pstruct->viewportCount, false, pstruct_in.pViewports->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t scissorCount
    IndentSpaces(out, indent);
    *out += "scissorCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->scissorCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkRect2D* pScissors
    IndentSpaces(out, indent);
    *out += "pScissors:                      ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pScissors == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pScissors->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pScissors->GetMetaStructPointer(), "pScissors", pstruct->scissorCount, false, pstruct_in.pScissors->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(std::string* out, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineMultisampleStateCreateInfo *pstruct = (const VkPipelineMultisampleStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineMultisampleStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineMultisampleStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlagBits rasterizationSamples
    IndentSpaces(out, indent);
    *out += "rasterizationSamples:           ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->rasterizationSamples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->rasterizationSamples);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 sampleShadingEnable
    IndentSpaces(out, indent);
    *out += "sampleShadingEnable:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sampleShadingEnable); //EQA
    *out += "\n"; // GDS

    // struct member: float minSampleShading
    IndentSpaces(out, indent);
    *out += "minSampleShading:               ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minSampleShading); // PEZ
    *out += "\n"; // GDS

    // struct member: const VkSampleMask* pSampleMask
    IndentSpaces(out, indent);
    *out += "pSampleMask:                    ";
    *out += "const VkSampleMask* = "; // TEQ
    if (pstruct->pSampleMask == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSampleMask.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSampleMask = {false, false, false, nullptr};
        ArrayToString<const VkSampleMask*>(out, indent, 1, "const VkSampleMask*", reinterpret_cast<const VkSampleMask*>(pstruct_in.pSampleMask.GetPointer()), "pSampleMask", pstruct->rasterizationSamples,  vinfo_pSampleMask);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 alphaToCoverageEnable
    IndentSpaces(out, indent);
    *out += "alphaToCoverageEnable:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->alphaToCoverageEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 alphaToOneEnable
    IndentSpaces(out, indent);
    *out += "alphaToOneEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->alphaToOneEnable); //EQA
}

template <>
void StructureToString<Decoded_VkBufferCopy>(std::string* out, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferCopy *pstruct = (const VkBufferCopy *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDeviceSize srcOffset
    IndentSpaces(out, indent);
    *out += "srcOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->srcOffset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize dstOffset
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->dstOffset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
}

template <>
void StructureToString<Decoded_VkSubresourceLayout>(std::string* out, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubresourceLayout *pstruct = (const VkSubresourceLayout *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize rowPitch
    IndentSpaces(out, indent);
    *out += "rowPitch:                       ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->rowPitch); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize arrayPitch
    IndentSpaces(out, indent);
    *out += "arrayPitch:                     ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->arrayPitch); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize depthPitch
    IndentSpaces(out, indent);
    *out += "depthPitch:                     ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->depthPitch); //EQA
}

template <>
void StructureToString<Decoded_VkImageSubresource>(std::string* out, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSubresource *pstruct = (const VkImageSubresource *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t mipLevel
    IndentSpaces(out, indent);
    *out += "mipLevel:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipLevel); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t arrayLayer
    IndentSpaces(out, indent);
    *out += "arrayLayer:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->arrayLayer); // UYW
}

template <>
void StructureToString<Decoded_VkQueueFamilyProperties>(std::string* out, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueueFamilyProperties *pstruct = (const VkQueueFamilyProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkQueueFlags queueFlags
    IndentSpaces(out, indent);
    *out += "queueFlags:                     ";
    *out += "VkQueueFlags = "; // TEQ
    FlagsToString(out, pstruct->queueFlags, EnumToStringVkQueueFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t queueCount
    IndentSpaces(out, indent);
    *out += "queueCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t timestampValidBits
    IndentSpaces(out, indent);
    *out += "timestampValidBits:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->timestampValidBits); // UYW
    *out += "\n"; // GDS

    // struct member: VkExtent3D minImageTransferGranularity
    IndentSpaces(out, indent);
    *out += "minImageTransferGranularity:    ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.minImageTransferGranularity, indent+1,  base_addr + offsetof(VkQueueFamilyProperties, minImageTransferGranularity)); // AZJ
}

template <>
void StructureToString<Decoded_VkCommandBufferBeginInfo>(std::string* out, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferBeginInfo *pstruct = (const VkCommandBufferBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkCommandBufferUsageFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandBufferUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkCommandBufferUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: const VkCommandBufferInheritanceInfo* pInheritanceInfo
    IndentSpaces(out, indent);
    *out += "pInheritanceInfo:               ";
    *out += "const VkCommandBufferInheritanceInfo* = "; // TEQ
    if (pstruct->pInheritanceInfo == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInheritanceInfo->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkCommandBufferInheritanceInfo>(out, *pstruct_in.pInheritanceInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkCommandBufferBeginInfo, pInheritanceInfo)); // GLN
    }
}

template <>
void StructureToString<Decoded_VkBufferImageCopy>(std::string* out, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferImageCopy *pstruct = (const VkBufferImageCopy *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDeviceSize bufferOffset
    IndentSpaces(out, indent);
    *out += "bufferOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferOffset); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t bufferRowLength
    IndentSpaces(out, indent);
    *out += "bufferRowLength:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bufferRowLength); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t bufferImageHeight
    IndentSpaces(out, indent);
    *out += "bufferImageHeight:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bufferImageHeight); // UYW
    *out += "\n"; // GDS

    // struct member: VkImageSubresourceLayers imageSubresource
    IndentSpaces(out, indent);
    *out += "imageSubresource:               ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.imageSubresource, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageSubresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D imageOffset
    IndentSpaces(out, indent);
    *out += "imageOffset:                    ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.imageOffset, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageOffset)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent3D imageExtent
    IndentSpaces(out, indent);
    *out += "imageExtent:                    ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageExtent)); // AZJ
}

template <>
void StructureToString<Decoded_VkBufferViewCreateInfo>(std::string* out, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferViewCreateInfo *pstruct = (const VkBufferViewCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBufferViewCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBufferViewCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize range
    IndentSpaces(out, indent);
    *out += "range:                          ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->range); //EQA
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProperties>(std::string* out, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProperties *pstruct = (const VkPhysicalDeviceProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t apiVersion
    IndentSpaces(out, indent);
    *out += "apiVersion:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->apiVersion); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t driverVersion
    IndentSpaces(out, indent);
    *out += "driverVersion:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->driverVersion); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t vendorID
    IndentSpaces(out, indent);
    *out += "vendorID:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vendorID); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t deviceID
    IndentSpaces(out, indent);
    *out += "deviceID:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceID); // UYW
    *out += "\n"; // GDS

    // struct member: VkPhysicalDeviceType deviceType
    IndentSpaces(out, indent);
    *out += "deviceType:                     ";
    *out += "VkPhysicalDeviceType = "; // TEQ
    EnumToStringVkPhysicalDeviceType(out, pstruct->deviceType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->deviceType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: char deviceName
    IndentSpaces(out, indent);
    *out += "deviceName:                     ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_deviceName = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->deviceName), "deviceName", VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, vinfo_deviceName); // JPA
    *out += "\n"; // GDS

    // struct member: uint8_t pipelineCacheUUID
    IndentSpaces(out, indent);
    *out += "pipelineCacheUUID:              ";
    *out += "uint8_t[";
    *out += "VK_UUID_SIZE"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceProperties, pipelineCacheUUID)); // IYY
    ScalarValueToStringStruct vinfo_pipelineCacheUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->pipelineCacheUUID), "pipelineCacheUUID", VK_UUID_SIZE, vinfo_pipelineCacheUUID); // JPA
    *out += "\n"; // GDS

    // struct member: VkPhysicalDeviceLimits limits
    IndentSpaces(out, indent);
    *out += "limits:                         ";
    *out += "VkPhysicalDeviceLimits = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceLimits>(out, *pstruct_in.limits, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties, limits)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkPhysicalDeviceSparseProperties sparseProperties
    IndentSpaces(out, indent);
    *out += "sparseProperties:               ";
    *out += "VkPhysicalDeviceSparseProperties = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceSparseProperties>(out, *pstruct_in.sparseProperties, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties, sparseProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(std::string* out, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineColorBlendStateCreateInfo *pstruct = (const VkPipelineColorBlendStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineColorBlendStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineColorBlendStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkBool32 logicOpEnable
    IndentSpaces(out, indent);
    *out += "logicOpEnable:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->logicOpEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkLogicOp logicOp
    IndentSpaces(out, indent);
    *out += "logicOp:                        ";
    *out += "VkLogicOp = "; // TEQ
    EnumToStringVkLogicOp(out, pstruct->logicOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->logicOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkPipelineColorBlendAttachmentState* pAttachments
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkPipelineColorBlendAttachmentState* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPipelineColorBlendAttachmentState>(out, indent+1, 1, "VkPipelineColorBlendAttachmentState", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: float blendConstants
    IndentSpaces(out, indent);
    *out += "blendConstants:                 ";
    *out += "float[";
    *out += "4"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPipelineColorBlendStateCreateInfo, blendConstants)); // IYY
    ScalarValueToStringStruct vinfo_blendConstants = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->blendConstants), "blendConstants", 4, vinfo_blendConstants); // JPA
}

template <>
void StructureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(std::string* out, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineRasterizationStateCreateInfo *pstruct = (const VkPipelineRasterizationStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineRasterizationStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineRasterizationStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkBool32 depthClampEnable
    IndentSpaces(out, indent);
    *out += "depthClampEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthClampEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 rasterizerDiscardEnable
    IndentSpaces(out, indent);
    *out += "rasterizerDiscardEnable:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->rasterizerDiscardEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkPolygonMode polygonMode
    IndentSpaces(out, indent);
    *out += "polygonMode:                    ";
    *out += "VkPolygonMode = "; // TEQ
    EnumToStringVkPolygonMode(out, pstruct->polygonMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->polygonMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkCullModeFlags cullMode
    IndentSpaces(out, indent);
    *out += "cullMode:                       ";
    *out += "VkCullModeFlags = "; // TEQ
    FlagsToString(out, pstruct->cullMode, EnumToStringVkCullModeFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkFrontFace frontFace
    IndentSpaces(out, indent);
    *out += "frontFace:                      ";
    *out += "VkFrontFace = "; // TEQ
    EnumToStringVkFrontFace(out, pstruct->frontFace); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->frontFace);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 depthBiasEnable
    IndentSpaces(out, indent);
    *out += "depthBiasEnable:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBiasEnable); //EQA
    *out += "\n"; // GDS

    // struct member: float depthBiasConstantFactor
    IndentSpaces(out, indent);
    *out += "depthBiasConstantFactor:        ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depthBiasConstantFactor); // PEZ
    *out += "\n"; // GDS

    // struct member: float depthBiasClamp
    IndentSpaces(out, indent);
    *out += "depthBiasClamp:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depthBiasClamp); // PEZ
    *out += "\n"; // GDS

    // struct member: float depthBiasSlopeFactor
    IndentSpaces(out, indent);
    *out += "depthBiasSlopeFactor:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depthBiasSlopeFactor); // PEZ
    *out += "\n"; // GDS

    // struct member: float lineWidth
    IndentSpaces(out, indent);
    *out += "lineWidth:                      ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->lineWidth); // PEZ
}

template <>
void StructureToString<Decoded_VkRect2D>(std::string* out, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRect2D *pstruct = (const VkRect2D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkOffset2D offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.offset, indent+1,  base_addr + offsetof(VkRect2D, offset)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D extent
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkRect2D, extent)); // AZJ
}

template <>
void StructureToString<Decoded_VkStencilOpState>(std::string* out, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkStencilOpState *pstruct = (const VkStencilOpState *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStencilOp failOp
    IndentSpaces(out, indent);
    *out += "failOp:                         ";
    *out += "VkStencilOp = "; // TEQ
    EnumToStringVkStencilOp(out, pstruct->failOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->failOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkStencilOp passOp
    IndentSpaces(out, indent);
    *out += "passOp:                         ";
    *out += "VkStencilOp = "; // TEQ
    EnumToStringVkStencilOp(out, pstruct->passOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->passOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkStencilOp depthFailOp
    IndentSpaces(out, indent);
    *out += "depthFailOp:                    ";
    *out += "VkStencilOp = "; // TEQ
    EnumToStringVkStencilOp(out, pstruct->depthFailOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->depthFailOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkCompareOp compareOp
    IndentSpaces(out, indent);
    *out += "compareOp:                      ";
    *out += "VkCompareOp = "; // TEQ
    EnumToStringVkCompareOp(out, pstruct->compareOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->compareOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t compareMask
    IndentSpaces(out, indent);
    *out += "compareMask:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->compareMask); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t writeMask
    IndentSpaces(out, indent);
    *out += "writeMask:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->writeMask); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t reference
    IndentSpaces(out, indent);
    *out += "reference:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->reference); // UYW
}

template <>
void StructureToString<Decoded_VkImageViewCreateInfo>(std::string* out, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageViewCreateInfo *pstruct = (const VkImageViewCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageViewCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageViewCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkImageViewCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // struct member: VkImageViewType viewType
    IndentSpaces(out, indent);
    *out += "viewType:                       ";
    *out += "VkImageViewType = "; // TEQ
    EnumToStringVkImageViewType(out, pstruct->viewType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->viewType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentMapping components
    IndentSpaces(out, indent);
    *out += "components:                     ";
    *out += "VkComponentMapping = "; // TEQ
    StructureToString<Decoded_VkComponentMapping>(out, *pstruct_in.components, indent+1,  base_addr + offsetof(VkImageViewCreateInfo, components)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkImageSubresourceRange subresourceRange
    IndentSpaces(out, indent);
    *out += "subresourceRange:               ";
    *out += "VkImageSubresourceRange = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceRange>(out, *pstruct_in.subresourceRange, indent+1,  base_addr + offsetof(VkImageViewCreateInfo, subresourceRange)); // AZJ
}

template <>
void StructureToString<Decoded_VkImageCreateInfo>(std::string* out, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageCreateInfo *pstruct = (const VkImageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkImageCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkImageType imageType
    IndentSpaces(out, indent);
    *out += "imageType:                      ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, pstruct->imageType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageCreateInfo, extent)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t mipLevels
    IndentSpaces(out, indent);
    *out += "mipLevels:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipLevels); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t arrayLayers
    IndentSpaces(out, indent);
    *out += "arrayLayers:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->arrayLayers); // UYW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageTiling tiling
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, pstruct->tiling); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tiling);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSharingMode sharingMode
    IndentSpaces(out, indent);
    *out += "sharingMode:                    ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->sharingMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: VkImageLayout initialLayout
    IndentSpaces(out, indent);
    *out += "initialLayout:                  ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->initialLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->initialLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkAttachmentReference>(std::string* out, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentReference *pstruct = (const VkAttachmentReference *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t attachment
    IndentSpaces(out, indent);
    *out += "attachment:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachment); // UYW
    *out += "\n"; // GDS

    // struct member: VkImageLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->layout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->layout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkBufferMemoryBarrier>(std::string* out, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferMemoryBarrier *pstruct = (const VkBufferMemoryBarrier *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t srcQueueFamilyIndex
    IndentSpaces(out, indent);
    *out += "srcQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcQueueFamilyIndex); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dstQueueFamilyIndex
    IndentSpaces(out, indent);
    *out += "dstQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstQueueFamilyIndex); // UYW
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
}

template <>
void StructureToString<Decoded_VkMemoryRequirements>(std::string* out, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryRequirements *pstruct = (const VkMemoryRequirements *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize alignment
    IndentSpaces(out, indent);
    *out += "alignment:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->alignment); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits); // UYW
}

template <>
void StructureToString<Decoded_VkMemoryType>(std::string* out, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryType *pstruct = (const VkMemoryType *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkMemoryPropertyFlags propertyFlags
    IndentSpaces(out, indent);
    *out += "propertyFlags:                  ";
    *out += "VkMemoryPropertyFlags = "; // TEQ
    FlagsToString(out, pstruct->propertyFlags, EnumToStringVkMemoryPropertyFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t heapIndex
    IndentSpaces(out, indent);
    *out += "heapIndex:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->heapIndex); // UYW
}

template <>
void StructureToString<Decoded_VkFormatProperties>(std::string* out, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFormatProperties *pstruct = (const VkFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkFormatFeatureFlags linearTilingFeatures
    IndentSpaces(out, indent);
    *out += "linearTilingFeatures:           ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->linearTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkFormatFeatureFlags optimalTilingFeatures
    IndentSpaces(out, indent);
    *out += "optimalTilingFeatures:          ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->optimalTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkFormatFeatureFlags bufferFeatures
    IndentSpaces(out, indent);
    *out += "bufferFeatures:                 ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->bufferFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkCommandBufferAllocateInfo>(std::string* out, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferAllocateInfo *pstruct = (const VkCommandBufferAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkCommandPool commandPool
    IndentSpaces(out, indent);
    *out += "commandPool:                    ";
    *out += "VkCommandPool = "; // TEQ
    AddrToString(out, pstruct_in.commandPool); // PAQ
    *out += "\n"; // GDS

    // struct member: VkCommandBufferLevel level
    IndentSpaces(out, indent);
    *out += "level:                          ";
    *out += "VkCommandBufferLevel = "; // TEQ
    EnumToStringVkCommandBufferLevel(out, pstruct->level); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->level);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t commandBufferCount
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->commandBufferCount); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMemoryProperties *pstruct = (const VkPhysicalDeviceMemoryProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t memoryTypeCount
    IndentSpaces(out, indent);
    *out += "memoryTypeCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkMemoryType memoryTypes
    IndentSpaces(out, indent);
    *out += "memoryTypes:                    ";
    *out += "VkMemoryType[";
    UnsignedDecimalToString(out, pstruct->memoryTypeCount); // DFW
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMemoryProperties, memoryTypes)); // IYY
    ArrayOfStructsToString<Decoded_VkMemoryType>(out, indent+1, 0, "VkMemoryType", pstruct_in.memoryTypes->GetMetaStructPointer(), "memoryTypes", pstruct->memoryTypeCount , false, pstruct_in.memoryTypes->GetAddress()); // EPB
    *out += "\n"; // GDS

    // struct member: uint32_t memoryHeapCount
    IndentSpaces(out, indent);
    *out += "memoryHeapCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryHeapCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkMemoryHeap memoryHeaps
    IndentSpaces(out, indent);
    *out += "memoryHeaps:                    ";
    *out += "VkMemoryHeap[";
    UnsignedDecimalToString(out, pstruct->memoryHeapCount); // DFW
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMemoryProperties, memoryHeaps)); // IYY
    ArrayOfStructsToString<Decoded_VkMemoryHeap>(out, indent+1, 0, "VkMemoryHeap", pstruct_in.memoryHeaps->GetMetaStructPointer(), "memoryHeaps", pstruct->memoryHeapCount , false, pstruct_in.memoryHeaps->GetAddress()); // EPB
}

template <>
void StructureToString<Decoded_VkEventCreateInfo>(std::string* out, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkEventCreateInfo *pstruct = (const VkEventCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkEventCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkEventCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryRequirements>(std::string* out, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryRequirements *pstruct = (const VkSparseImageMemoryRequirements *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkSparseImageFormatProperties formatProperties
    IndentSpaces(out, indent);
    *out += "formatProperties:               ";
    *out += "VkSparseImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkSparseImageFormatProperties>(out, *pstruct_in.formatProperties, indent+1,  base_addr + offsetof(VkSparseImageMemoryRequirements, formatProperties)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t imageMipTailFirstLod
    IndentSpaces(out, indent);
    *out += "imageMipTailFirstLod:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageMipTailFirstLod); // UYW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize imageMipTailSize
    IndentSpaces(out, indent);
    *out += "imageMipTailSize:               ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->imageMipTailSize); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize imageMipTailOffset
    IndentSpaces(out, indent);
    *out += "imageMipTailOffset:             ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->imageMipTailOffset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize imageMipTailStride
    IndentSpaces(out, indent);
    *out += "imageMipTailStride:             ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->imageMipTailStride); //EQA
}

template <>
void StructureToString<Decoded_VkSubpassDescription>(std::string* out, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDescription *pstruct = (const VkSubpassDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkSubpassDescriptionFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSubpassDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSubpassDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t inputAttachmentCount
    IndentSpaces(out, indent);
    *out += "inputAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->inputAttachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference* pInputAttachments
    IndentSpaces(out, indent);
    *out += "pInputAttachments:              ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pInputAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInputAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(out, indent+1, 1, "VkAttachmentReference", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t colorAttachmentCount
    IndentSpaces(out, indent);
    *out += "colorAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->colorAttachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference* pColorAttachments
    IndentSpaces(out, indent);
    *out += "pColorAttachments:              ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pColorAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pColorAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(out, indent+1, 1, "VkAttachmentReference", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference* pResolveAttachments
    IndentSpaces(out, indent);
    *out += "pResolveAttachments:            ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pResolveAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pResolveAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(out, indent+1, 1, "VkAttachmentReference", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference* pDepthStencilAttachment
    IndentSpaces(out, indent);
    *out += "pDepthStencilAttachment:        ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pDepthStencilAttachment == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDepthStencilAttachment->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkAttachmentReference>(out, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkSubpassDescription, pDepthStencilAttachment)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: uint32_t preserveAttachmentCount
    IndentSpaces(out, indent);
    *out += "preserveAttachmentCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->preserveAttachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pPreserveAttachments
    IndentSpaces(out, indent);
    *out += "pPreserveAttachments:           ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pPreserveAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPreserveAttachments.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pstruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkCopyDescriptorSet>(std::string* out, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCopyDescriptorSet *pstruct = (const VkCopyDescriptorSet *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDescriptorSet srcSet
    IndentSpaces(out, indent);
    *out += "srcSet:                         ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.srcSet); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t srcBinding
    IndentSpaces(out, indent);
    *out += "srcBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcBinding); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t srcArrayElement
    IndentSpaces(out, indent);
    *out += "srcArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcArrayElement); // UYW
    *out += "\n"; // GDS

    // struct member: VkDescriptorSet dstSet
    IndentSpaces(out, indent);
    *out += "dstSet:                         ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.dstSet); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t dstBinding
    IndentSpaces(out, indent);
    *out += "dstBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstBinding); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dstArrayElement
    IndentSpaces(out, indent);
    *out += "dstArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstArrayElement); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount); // UYW
}

template <>
void StructureToString<Decoded_VkImageSubresourceLayers>(std::string* out, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSubresourceLayers *pstruct = (const VkImageSubresourceLayers *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t mipLevel
    IndentSpaces(out, indent);
    *out += "mipLevel:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipLevel); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t baseArrayLayer
    IndentSpaces(out, indent);
    *out += "baseArrayLayer:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseArrayLayer); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t layerCount
    IndentSpaces(out, indent);
    *out += "layerCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layerCount); // UYW
}

template <>
void StructureToString<Decoded_VkSubmitInfo>(std::string* out, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubmitInfo *pstruct = (const VkSubmitInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSemaphore* pWaitSemaphores
    IndentSpaces(out, indent);
    *out += "pWaitSemaphores:                ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: const VkPipelineStageFlags* pWaitDstStageMask
    IndentSpaces(out, indent);
    *out += "pWaitDstStageMask:              ";
    *out += "const VkPipelineStageFlags* = "; // TEQ
    if (pstruct->pWaitDstStageMask == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitDstStageMask.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitDstStageMask = {false, false, true, EnumToStringVkPipelineStageFlagBits};
        ArrayToString<const VkPipelineStageFlags*>(out, indent, 1, "const VkPipelineStageFlags*", reinterpret_cast<const VkPipelineStageFlags*>(pstruct_in.pWaitDstStageMask.GetPointer()), "pWaitDstStageMask", pstruct->waitSemaphoreCount,  vinfo_pWaitDstStageMask);  // CCR
    }
    *out += "\n"; // GDS

    // struct member: uint32_t commandBufferCount
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->commandBufferCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkCommandBuffer* pCommandBuffers
    IndentSpaces(out, indent);
    *out += "pCommandBuffers:                ";
    *out += "const VkCommandBuffer* = "; // TEQ
    if (pstruct->pCommandBuffers == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCommandBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<const VkCommandBuffer*>(out, indent, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pstruct_in.pCommandBuffers.GetPointer()), "pCommandBuffers", pstruct->commandBufferCount,  vinfo_pCommandBuffers);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t signalSemaphoreCount
    IndentSpaces(out, indent);
    *out += "signalSemaphoreCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSemaphore* pSignalSemaphores
    IndentSpaces(out, indent);
    *out += "pSignalSemaphores:              ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pSignalSemaphores == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkImageResolve>(std::string* out, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageResolve *pstruct = (const VkImageResolve *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageSubresourceLayers srcSubresource
    IndentSpaces(out, indent);
    *out += "srcSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageResolve, srcSubresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D srcOffset
    IndentSpaces(out, indent);
    *out += "srcOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.srcOffset, indent+1,  base_addr + offsetof(VkImageResolve, srcOffset)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkImageSubresourceLayers dstSubresource
    IndentSpaces(out, indent);
    *out += "dstSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageResolve, dstSubresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D dstOffset
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.dstOffset, indent+1,  base_addr + offsetof(VkImageResolve, dstOffset)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageResolve, extent)); // AZJ
}

template <>
void StructureToString<Decoded_VkPipelineLayoutCreateInfo>(std::string* out, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineLayoutCreateInfo *pstruct = (const VkPipelineLayoutCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineLayoutCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineLayoutCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t setLayoutCount
    IndentSpaces(out, indent);
    *out += "setLayoutCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->setLayoutCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDescriptorSetLayout* pSetLayouts
    IndentSpaces(out, indent);
    *out += "pSetLayouts:                    ";
    *out += "const VkDescriptorSetLayout* = "; // TEQ
    if (pstruct->pSetLayouts == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSetLayouts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSetLayout*>(out, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pstruct_in.pSetLayouts.GetPointer()), "pSetLayouts", pstruct->setLayoutCount,  vinfo_pSetLayouts);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t pushConstantRangeCount
    IndentSpaces(out, indent);
    *out += "pushConstantRangeCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->pushConstantRangeCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkPushConstantRange* pPushConstantRanges
    IndentSpaces(out, indent);
    *out += "pPushConstantRanges:            ";
    *out += "const VkPushConstantRange* = "; // TEQ
    if (pstruct->pPushConstantRanges == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPushConstantRanges->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPushConstantRange>(out, indent+1, 1, "VkPushConstantRange", pstruct_in.pPushConstantRanges->GetMetaStructPointer(), "pPushConstantRanges", pstruct->pushConstantRangeCount, false, pstruct_in.pPushConstantRanges->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryBindInfo *pstruct = (const VkSparseImageMemoryBindInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t bindCount
    IndentSpaces(out, indent);
    *out += "bindCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSparseImageMemoryBind* pBinds
    IndentSpaces(out, indent);
    *out += "pBinds:                         ";
    *out += "const VkSparseImageMemoryBind* = "; // TEQ
    if (pstruct->pBinds == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryBind>(out, indent+1, 1, "VkSparseImageMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDeviceQueueCreateInfo>(std::string* out, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceQueueCreateInfo *pstruct = (const VkDeviceQueueCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceQueueCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDeviceQueueCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDeviceQueueCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndex); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t queueCount
    IndentSpaces(out, indent);
    *out += "queueCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueCount); // UYW
    *out += "\n"; // GDS

    // struct member: const float* pQueuePriorities
    IndentSpaces(out, indent);
    *out += "pQueuePriorities:               ";
    *out += "const float* = "; // TEQ
    if (pstruct->pQueuePriorities == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueuePriorities.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueuePriorities = {false, false, false, nullptr};
        ArrayToString<const float*>(out, indent, 1, "const float*", reinterpret_cast<const float*>(pstruct_in.pQueuePriorities.GetPointer()), "pQueuePriorities", pstruct->queueCount,  vinfo_pQueuePriorities);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(std::string* out, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineInputAssemblyStateCreateInfo *pstruct = (const VkPipelineInputAssemblyStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineInputAssemblyStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineInputAssemblyStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkPrimitiveTopology topology
    IndentSpaces(out, indent);
    *out += "topology:                       ";
    *out += "VkPrimitiveTopology = "; // TEQ
    EnumToStringVkPrimitiveTopology(out, pstruct->topology); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->topology);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 primitiveRestartEnable
    IndentSpaces(out, indent);
    *out += "primitiveRestartEnable:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->primitiveRestartEnable); //EQA
}

template <>
void StructureToString<Decoded_VkShaderModuleCreateInfo>(std::string* out, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderModuleCreateInfo *pstruct = (const VkShaderModuleCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkShaderModuleCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkShaderModuleCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkShaderModuleCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: size_t codeSize
    IndentSpaces(out, indent);
    *out += "codeSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->codeSize); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pCode
    IndentSpaces(out, indent);
    *out += "pCode:                          ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCode == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCode.GetAddress()); // WUX
        if (kPrintShaderCode)
        {
            ScalarValueToStringStruct vinfo_pCode = {false, false, false, nullptr};
            ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCode.GetPointer()), "pCode", pstruct->codeSize / 4, vinfo_pCode);  // CCY
        }
    }
}

template <>
void StructureToString<Decoded_VkImageCopy>(std::string* out, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageCopy *pstruct = (const VkImageCopy *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageSubresourceLayers srcSubresource
    IndentSpaces(out, indent);
    *out += "srcSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageCopy, srcSubresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D srcOffset
    IndentSpaces(out, indent);
    *out += "srcOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.srcOffset, indent+1,  base_addr + offsetof(VkImageCopy, srcOffset)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkImageSubresourceLayers dstSubresource
    IndentSpaces(out, indent);
    *out += "dstSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageCopy, dstSubresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D dstOffset
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.dstOffset, indent+1,  base_addr + offsetof(VkImageCopy, dstOffset)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageCopy, extent)); // AZJ
}

template <>
void StructureToString<Decoded_VkSparseBufferMemoryBindInfo>(std::string* out, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseBufferMemoryBindInfo *pstruct = (const VkSparseBufferMemoryBindInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t bindCount
    IndentSpaces(out, indent);
    *out += "bindCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSparseMemoryBind* pBinds
    IndentSpaces(out, indent);
    *out += "pBinds:                         ";
    *out += "const VkSparseMemoryBind* = "; // TEQ
    if (pstruct->pBinds == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseMemoryBind>(out, indent+1, 1, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkBufferCreateInfo>(std::string* out, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferCreateInfo *pstruct = (const VkBufferCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBufferCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBufferCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkBufferCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
    *out += "\n"; // GDS

    // struct member: VkBufferUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkBufferUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkBufferUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSharingMode sharingMode
    IndentSpaces(out, indent);
    *out += "sharingMode:                    ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->sharingMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkOffset2D>(std::string* out, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkOffset2D *pstruct = (const VkOffset2D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: int32_t x
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->x); //EQA
    *out += "\n"; // GDS

    // struct member: int32_t y
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->y); //EQA
}

template <>
void StructureToString<Decoded_VkComponentMapping>(std::string* out, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkComponentMapping *pstruct = (const VkComponentMapping *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkComponentSwizzle r
    IndentSpaces(out, indent);
    *out += "r:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->r); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->r);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentSwizzle g
    IndentSpaces(out, indent);
    *out += "g:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->g); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->g);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentSwizzle b
    IndentSpaces(out, indent);
    *out += "b:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->b); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->b);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentSwizzle a
    IndentSpaces(out, indent);
    *out += "a:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->a); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->a);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkInstanceCreateInfo>(std::string* out, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkInstanceCreateInfo *pstruct = (const VkInstanceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkInstanceCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkInstanceCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: const VkApplicationInfo* pApplicationInfo
    IndentSpaces(out, indent);
    *out += "pApplicationInfo:               ";
    *out += "const VkApplicationInfo* = "; // TEQ
    if (pstruct->pApplicationInfo == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pApplicationInfo->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkApplicationInfo>(out, *pstruct_in.pApplicationInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkInstanceCreateInfo, pApplicationInfo)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: uint32_t enabledLayerCount
    IndentSpaces(out, indent);
    *out += "enabledLayerCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledLayerCount); // UYW
    *out += "\n"; // GDS

    // struct member: const char* const* ppEnabledLayerNames
    IndentSpaces(out, indent);
    *out += "ppEnabledLayerNames:            ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledLayerNames == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledLayerNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pstruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t enabledExtensionCount
    IndentSpaces(out, indent);
    *out += "enabledExtensionCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledExtensionCount); // UYW
    *out += "\n"; // GDS

    // struct member: const char* const* ppEnabledExtensionNames
    IndentSpaces(out, indent);
    *out += "ppEnabledExtensionNames:        ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledExtensionNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pstruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkSparseMemoryBind>(std::string* out, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseMemoryBind *pstruct = (const VkSparseMemoryBind *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDeviceSize resourceOffset
    IndentSpaces(out, indent);
    *out += "resourceOffset:                 ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->resourceOffset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset); //EQA
    *out += "\n"; // GDS

    // struct member: VkSparseMemoryBindFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSparseMemoryBindFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSparseMemoryBindFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPipelineDynamicStateCreateInfo>(std::string* out, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineDynamicStateCreateInfo *pstruct = (const VkPipelineDynamicStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineDynamicStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineDynamicStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dynamicStateCount
    IndentSpaces(out, indent);
    *out += "dynamicStateCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dynamicStateCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDynamicState* pDynamicStates
    IndentSpaces(out, indent);
    *out += "pDynamicStates:                 ";
    *out += "const VkDynamicState* = "; // TEQ
    if (pstruct->pDynamicStates == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDynamicStates.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDynamicStates = {false, true, false, EnumToStringVkDynamicState};
        ArrayToString<const VkDynamicState*>(out, indent, 1, "const VkDynamicState*", reinterpret_cast<const VkDynamicState*>(pstruct_in.pDynamicStates.GetPointer()), "pDynamicStates", pstruct->dynamicStateCount,  vinfo_pDynamicStates);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkPipelineCacheCreateInfo>(std::string* out, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineCacheCreateInfo *pstruct = (const VkPipelineCacheCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineCacheCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCacheCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: size_t initialDataSize
    IndentSpaces(out, indent);
    *out += "initialDataSize:                ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->initialDataSize); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pInitialData
    IndentSpaces(out, indent);
    *out += "pInitialData:                   ";
    *out += "const void* = "; // TEQ
    if (pstruct->pInitialData == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInitialData.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkVertexInputAttributeDescription>(std::string* out, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkVertexInputAttributeDescription *pstruct = (const VkVertexInputAttributeDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t location
    IndentSpaces(out, indent);
    *out += "location:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->location); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t binding
    IndentSpaces(out, indent);
    *out += "binding:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->binding); // UYW
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset); // UYW
}

template <>
void StructureToString<Decoded_VkSpecializationInfo>(std::string* out, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSpecializationInfo *pstruct = (const VkSpecializationInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t mapEntryCount
    IndentSpaces(out, indent);
    *out += "mapEntryCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mapEntryCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSpecializationMapEntry* pMapEntries
    IndentSpaces(out, indent);
    *out += "pMapEntries:                    ";
    *out += "const VkSpecializationMapEntry* = "; // TEQ
    if (pstruct->pMapEntries == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pMapEntries->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSpecializationMapEntry>(out, indent+1, 1, "VkSpecializationMapEntry", pstruct_in.pMapEntries->GetMetaStructPointer(), "pMapEntries", pstruct->mapEntryCount, false, pstruct_in.pMapEntries->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: size_t dataSize
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dataSize); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pData == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pData.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkQueryPoolCreateInfo>(std::string* out, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueryPoolCreateInfo *pstruct = (const VkQueryPoolCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkQueryPoolCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkQueryPoolCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkQueryType queryType
    IndentSpaces(out, indent);
    *out += "queryType:                      ";
    *out += "VkQueryType = "; // TEQ
    EnumToStringVkQueryType(out, pstruct->queryType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->queryType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t queryCount
    IndentSpaces(out, indent);
    *out += "queryCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queryCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkQueryPipelineStatisticFlags pipelineStatistics
    IndentSpaces(out, indent);
    *out += "pipelineStatistics:             ";
    *out += "VkQueryPipelineStatisticFlags = "; // TEQ
    FlagsToString(out, pstruct->pipelineStatistics, EnumToStringVkQueryPipelineStatisticFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkOffset3D>(std::string* out, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkOffset3D *pstruct = (const VkOffset3D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: int32_t x
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->x); //EQA
    *out += "\n"; // GDS

    // struct member: int32_t y
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->y); //EQA
    *out += "\n"; // GDS

    // struct member: int32_t z
    IndentSpaces(out, indent);
    *out += "z:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->z); //EQA
}

template <>
void StructureToString<Decoded_VkExtent3D>(std::string* out, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExtent3D *pstruct = (const VkExtent3D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t width
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->width); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t height
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->height); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t depth
    IndentSpaces(out, indent);
    *out += "depth:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->depth); // UYW
}

template <>
void StructureToString<Decoded_VkCommandPoolCreateInfo>(std::string* out, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandPoolCreateInfo *pstruct = (const VkCommandPoolCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkCommandPoolCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandPoolCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkCommandPoolCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndex); // UYW
}

template <>
void StructureToString<Decoded_VkImageMemoryBarrier>(std::string* out, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageMemoryBarrier *pstruct = (const VkImageMemoryBarrier *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkImageLayout oldLayout
    IndentSpaces(out, indent);
    *out += "oldLayout:                      ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->oldLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->oldLayout);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageLayout newLayout
    IndentSpaces(out, indent);
    *out += "newLayout:                      ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->newLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->newLayout);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t srcQueueFamilyIndex
    IndentSpaces(out, indent);
    *out += "srcQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcQueueFamilyIndex); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dstQueueFamilyIndex
    IndentSpaces(out, indent);
    *out += "dstQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstQueueFamilyIndex); // UYW
    *out += "\n"; // GDS

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // struct member: VkImageSubresourceRange subresourceRange
    IndentSpaces(out, indent);
    *out += "subresourceRange:               ";
    *out += "VkImageSubresourceRange = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceRange>(out, *pstruct_in.subresourceRange, indent+1,  base_addr + offsetof(VkImageMemoryBarrier, subresourceRange)); // AZJ
}

template <>
void StructureToString<Decoded_VkDescriptorBufferInfo>(std::string* out, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorBufferInfo *pstruct = (const VkDescriptorBufferInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize range
    IndentSpaces(out, indent);
    *out += "range:                          ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->range); //EQA
}

template <>
void StructureToString<Decoded_VkClearColorValue>(std::string* out, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearColorValue *pstruct = (const VkClearColorValue *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: float float32
    IndentSpaces(out, indent);
    *out += "float32:                        ";
    *out += "float[";
    *out += "4"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkClearColorValue, float32)); // IYY
    ScalarValueToStringStruct vinfo_float32 = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->float32), "float32", 4, vinfo_float32); // JPA
    *out += "\n"; // GDS

    // struct member: int32_t int32
    IndentSpaces(out, indent);
    *out += "int32:                          ";
    *out += "int32_t[";
    *out += "4"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkClearColorValue, int32)); // IYY
    ScalarValueToStringStruct vinfo_int32 = {false, false, false, nullptr};
    ArrayToString<int32_t*>(out, indent, 0, "int32_t", const_cast<int32_t*>(pstruct->int32), "int32", 4, vinfo_int32); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t uint32
    IndentSpaces(out, indent);
    *out += "uint32:                         ";
    *out += "uint32_t[";
    *out += "4"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkClearColorValue, uint32)); // IYY
    ScalarValueToStringStruct vinfo_uint32 = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->uint32), "uint32", 4, vinfo_uint32); // JPA
}

template <>
void StructureToString<Decoded_VkDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceCreateInfo *pstruct = (const VkDeviceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDeviceCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t queueCreateInfoCount
    IndentSpaces(out, indent);
    *out += "queueCreateInfoCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueCreateInfoCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDeviceQueueCreateInfo* pQueueCreateInfos
    IndentSpaces(out, indent);
    *out += "pQueueCreateInfos:              ";
    *out += "const VkDeviceQueueCreateInfo* = "; // TEQ
    if (pstruct->pQueueCreateInfos == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueCreateInfos->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDeviceQueueCreateInfo>(out, indent+1, 1, "VkDeviceQueueCreateInfo", pstruct_in.pQueueCreateInfos->GetMetaStructPointer(), "pQueueCreateInfos", pstruct->queueCreateInfoCount, false, pstruct_in.pQueueCreateInfos->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t enabledLayerCount
    IndentSpaces(out, indent);
    *out += "enabledLayerCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledLayerCount); // UYW
    *out += "\n"; // GDS

    // struct member: const char* const* ppEnabledLayerNames
    IndentSpaces(out, indent);
    *out += "ppEnabledLayerNames:            ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledLayerNames == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledLayerNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pstruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t enabledExtensionCount
    IndentSpaces(out, indent);
    *out += "enabledExtensionCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledExtensionCount); // UYW
    *out += "\n"; // GDS

    // struct member: const char* const* ppEnabledExtensionNames
    IndentSpaces(out, indent);
    *out += "ppEnabledExtensionNames:        ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledExtensionNames.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pstruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: const VkPhysicalDeviceFeatures* pEnabledFeatures
    IndentSpaces(out, indent);
    *out += "pEnabledFeatures:               ";
    *out += "const VkPhysicalDeviceFeatures* = "; // TEQ
    if (pstruct->pEnabledFeatures == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pEnabledFeatures->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceFeatures>(out, *pstruct_in.pEnabledFeatures->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkDeviceCreateInfo, pEnabledFeatures)); // GLN
    }
}

template <>
void StructureToString<Decoded_VkPipelineColorBlendAttachmentState>(std::string* out, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineColorBlendAttachmentState *pstruct = (const VkPipelineColorBlendAttachmentState *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkBool32 blendEnable
    IndentSpaces(out, indent);
    *out += "blendEnable:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->blendEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkBlendFactor srcColorBlendFactor
    IndentSpaces(out, indent);
    *out += "srcColorBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->srcColorBlendFactor); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->srcColorBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBlendFactor dstColorBlendFactor
    IndentSpaces(out, indent);
    *out += "dstColorBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->dstColorBlendFactor); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->dstColorBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBlendOp colorBlendOp
    IndentSpaces(out, indent);
    *out += "colorBlendOp:                   ";
    *out += "VkBlendOp = "; // TEQ
    EnumToStringVkBlendOp(out, pstruct->colorBlendOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->colorBlendOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBlendFactor srcAlphaBlendFactor
    IndentSpaces(out, indent);
    *out += "srcAlphaBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->srcAlphaBlendFactor); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->srcAlphaBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBlendFactor dstAlphaBlendFactor
    IndentSpaces(out, indent);
    *out += "dstAlphaBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->dstAlphaBlendFactor); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->dstAlphaBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBlendOp alphaBlendOp
    IndentSpaces(out, indent);
    *out += "alphaBlendOp:                   ";
    *out += "VkBlendOp = "; // TEQ
    EnumToStringVkBlendOp(out, pstruct->alphaBlendOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->alphaBlendOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkColorComponentFlags colorWriteMask
    IndentSpaces(out, indent);
    *out += "colorWriteMask:                 ";
    *out += "VkColorComponentFlags = "; // TEQ
    FlagsToString(out, pstruct->colorWriteMask, EnumToStringVkColorComponentFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkDispatchIndirectCommand>(std::string* out, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDispatchIndirectCommand *pstruct = (const VkDispatchIndirectCommand *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t x
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->x); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t y
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->y); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t z
    IndentSpaces(out, indent);
    *out += "z:                              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->z); // UYW
}

template <>
void StructureToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageOpaqueMemoryBindInfo *pstruct = (const VkSparseImageOpaqueMemoryBindInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t bindCount
    IndentSpaces(out, indent);
    *out += "bindCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSparseMemoryBind* pBinds
    IndentSpaces(out, indent);
    *out += "pBinds:                         ";
    *out += "const VkSparseMemoryBind* = "; // TEQ
    if (pstruct->pBinds == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseMemoryBind>(out, indent+1, 1, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkClearDepthStencilValue>(std::string* out, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearDepthStencilValue *pstruct = (const VkClearDepthStencilValue *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: float depth
    IndentSpaces(out, indent);
    *out += "depth:                          ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depth); // PEZ
    *out += "\n"; // GDS

    // struct member: uint32_t stencil
    IndentSpaces(out, indent);
    *out += "stencil:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stencil); // UYW
}

template <>
void StructureToString<Decoded_VkDescriptorSetAllocateInfo>(std::string* out, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetAllocateInfo *pstruct = (const VkDescriptorSetAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDescriptorPool descriptorPool
    IndentSpaces(out, indent);
    *out += "descriptorPool:                 ";
    *out += "VkDescriptorPool = "; // TEQ
    AddrToString(out, pstruct_in.descriptorPool); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t descriptorSetCount
    IndentSpaces(out, indent);
    *out += "descriptorSetCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorSetCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDescriptorSetLayout* pSetLayouts
    IndentSpaces(out, indent);
    *out += "pSetLayouts:                    ";
    *out += "const VkDescriptorSetLayout* = "; // TEQ
    if (pstruct->pSetLayouts == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSetLayouts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSetLayout*>(out, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pstruct_in.pSetLayouts.GetPointer()), "pSetLayouts", pstruct->descriptorSetCount,  vinfo_pSetLayouts);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkDrawIndexedIndirectCommand>(std::string* out, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrawIndexedIndirectCommand *pstruct = (const VkDrawIndexedIndirectCommand *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t indexCount
    IndentSpaces(out, indent);
    *out += "indexCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->indexCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t instanceCount
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->instanceCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t firstIndex
    IndentSpaces(out, indent);
    *out += "firstIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstIndex); // UYW
    *out += "\n"; // GDS

    // struct member: int32_t vertexOffset
    IndentSpaces(out, indent);
    *out += "vertexOffset:                   ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexOffset); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t firstInstance
    IndentSpaces(out, indent);
    *out += "firstInstance:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstInstance); // UYW
}

template <>
void StructureToString<Decoded_VkCommandBufferInheritanceInfo>(std::string* out, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferInheritanceInfo *pstruct = (const VkCommandBufferInheritanceInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkRenderPass renderPass
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t subpass
    IndentSpaces(out, indent);
    *out += "subpass:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpass); // UYW
    *out += "\n"; // GDS

    // struct member: VkFramebuffer framebuffer
    IndentSpaces(out, indent);
    *out += "framebuffer:                    ";
    *out += "VkFramebuffer = "; // TEQ
    AddrToString(out, pstruct_in.framebuffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkBool32 occlusionQueryEnable
    IndentSpaces(out, indent);
    *out += "occlusionQueryEnable:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->occlusionQueryEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkQueryControlFlags queryFlags
    IndentSpaces(out, indent);
    *out += "queryFlags:                     ";
    *out += "VkQueryControlFlags = "; // TEQ
    FlagsToString(out, pstruct->queryFlags, EnumToStringVkQueryControlFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkQueryPipelineStatisticFlags pipelineStatistics
    IndentSpaces(out, indent);
    *out += "pipelineStatistics:             ";
    *out += "VkQueryPipelineStatisticFlags = "; // TEQ
    FlagsToString(out, pstruct->pipelineStatistics, EnumToStringVkQueryPipelineStatisticFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkDescriptorPoolSize>(std::string* out, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorPoolSize *pstruct = (const VkDescriptorPoolSize *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDescriptorType type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount); // UYW
}

template <>
void StructureToString<Decoded_VkImageFormatProperties>(std::string* out, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageFormatProperties *pstruct = (const VkImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkExtent3D maxExtent
    IndentSpaces(out, indent);
    *out += "maxExtent:                      ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.maxExtent, indent+1,  base_addr + offsetof(VkImageFormatProperties, maxExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t maxMipLevels
    IndentSpaces(out, indent);
    *out += "maxMipLevels:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMipLevels); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxArrayLayers
    IndentSpaces(out, indent);
    *out += "maxArrayLayers:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxArrayLayers); // UYW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags sampleCounts
    IndentSpaces(out, indent);
    *out += "sampleCounts:                   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize maxResourceSize
    IndentSpaces(out, indent);
    *out += "maxResourceSize:                ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->maxResourceSize); //EQA
}

template <>
void StructureToString<Decoded_VkMemoryBarrier>(std::string* out, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryBarrier *pstruct = (const VkMemoryBarrier *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkExtent2D>(std::string* out, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExtent2D *pstruct = (const VkExtent2D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t width
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->width); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t height
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->height); // UYW
}

template <>
void StructureToString<Decoded_VkPipelineTessellationStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineTessellationStateCreateInfo *pstruct = (const VkPipelineTessellationStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineTessellationStateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineTessellationStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t patchControlPoints
    IndentSpaces(out, indent);
    *out += "patchControlPoints:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->patchControlPoints); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceLimits>(std::string* out, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceLimits *pstruct = (const VkPhysicalDeviceLimits *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t maxImageDimension1D
    IndentSpaces(out, indent);
    *out += "maxImageDimension1D:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimension1D); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageDimension2D
    IndentSpaces(out, indent);
    *out += "maxImageDimension2D:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimension2D); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageDimension3D
    IndentSpaces(out, indent);
    *out += "maxImageDimension3D:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimension3D); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageDimensionCube
    IndentSpaces(out, indent);
    *out += "maxImageDimensionCube:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimensionCube); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageArrayLayers
    IndentSpaces(out, indent);
    *out += "maxImageArrayLayers:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageArrayLayers); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTexelBufferElements
    IndentSpaces(out, indent);
    *out += "maxTexelBufferElements:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTexelBufferElements); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxUniformBufferRange
    IndentSpaces(out, indent);
    *out += "maxUniformBufferRange:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxUniformBufferRange); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxStorageBufferRange
    IndentSpaces(out, indent);
    *out += "maxStorageBufferRange:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxStorageBufferRange); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPushConstantsSize
    IndentSpaces(out, indent);
    *out += "maxPushConstantsSize:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPushConstantsSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxMemoryAllocationCount
    IndentSpaces(out, indent);
    *out += "maxMemoryAllocationCount:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMemoryAllocationCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxSamplerAllocationCount
    IndentSpaces(out, indent);
    *out += "maxSamplerAllocationCount:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSamplerAllocationCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize bufferImageGranularity
    IndentSpaces(out, indent);
    *out += "bufferImageGranularity:         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferImageGranularity); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize sparseAddressSpaceSize
    IndentSpaces(out, indent);
    *out += "sparseAddressSpaceSize:         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseAddressSpaceSize); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t maxBoundDescriptorSets
    IndentSpaces(out, indent);
    *out += "maxBoundDescriptorSets:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxBoundDescriptorSets); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerStageDescriptorSamplers
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorSamplers:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorSamplers); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerStageDescriptorUniformBuffers
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorUniformBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorUniformBuffers); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerStageDescriptorStorageBuffers
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorStorageBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorStorageBuffers); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerStageDescriptorSampledImages
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorSampledImages: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorSampledImages); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerStageDescriptorStorageImages
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorStorageImages: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorStorageImages); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerStageDescriptorInputAttachments
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorInputAttachments: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorInputAttachments); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerStageResources
    IndentSpaces(out, indent);
    *out += "maxPerStageResources:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageResources); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetSamplers
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetSamplers:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetSamplers); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetUniformBuffers
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetUniformBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetUniformBuffers); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetUniformBuffersDynamic
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetUniformBuffersDynamic: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetUniformBuffersDynamic); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetStorageBuffers
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetStorageBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetStorageBuffers); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetStorageBuffersDynamic
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetStorageBuffersDynamic: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetStorageBuffersDynamic); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetSampledImages
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetSampledImages:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetSampledImages); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetStorageImages
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetStorageImages:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetStorageImages); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetInputAttachments
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetInputAttachments: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetInputAttachments); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxVertexInputAttributes
    IndentSpaces(out, indent);
    *out += "maxVertexInputAttributes:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputAttributes); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxVertexInputBindings
    IndentSpaces(out, indent);
    *out += "maxVertexInputBindings:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputBindings); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxVertexInputAttributeOffset
    IndentSpaces(out, indent);
    *out += "maxVertexInputAttributeOffset:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputAttributeOffset); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxVertexInputBindingStride
    IndentSpaces(out, indent);
    *out += "maxVertexInputBindingStride:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputBindingStride); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxVertexOutputComponents
    IndentSpaces(out, indent);
    *out += "maxVertexOutputComponents:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexOutputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationGenerationLevel
    IndentSpaces(out, indent);
    *out += "maxTessellationGenerationLevel: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationGenerationLevel); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationPatchSize
    IndentSpaces(out, indent);
    *out += "maxTessellationPatchSize:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationPatchSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationControlPerVertexInputComponents
    IndentSpaces(out, indent);
    *out += "maxTessellationControlPerVertexInputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlPerVertexInputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationControlPerVertexOutputComponents
    IndentSpaces(out, indent);
    *out += "maxTessellationControlPerVertexOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlPerVertexOutputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationControlPerPatchOutputComponents
    IndentSpaces(out, indent);
    *out += "maxTessellationControlPerPatchOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlPerPatchOutputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationControlTotalOutputComponents
    IndentSpaces(out, indent);
    *out += "maxTessellationControlTotalOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlTotalOutputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationEvaluationInputComponents
    IndentSpaces(out, indent);
    *out += "maxTessellationEvaluationInputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationEvaluationInputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTessellationEvaluationOutputComponents
    IndentSpaces(out, indent);
    *out += "maxTessellationEvaluationOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationEvaluationOutputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxGeometryShaderInvocations
    IndentSpaces(out, indent);
    *out += "maxGeometryShaderInvocations:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryShaderInvocations); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxGeometryInputComponents
    IndentSpaces(out, indent);
    *out += "maxGeometryInputComponents:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryInputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxGeometryOutputComponents
    IndentSpaces(out, indent);
    *out += "maxGeometryOutputComponents:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryOutputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxGeometryOutputVertices
    IndentSpaces(out, indent);
    *out += "maxGeometryOutputVertices:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryOutputVertices); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxGeometryTotalOutputComponents
    IndentSpaces(out, indent);
    *out += "maxGeometryTotalOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryTotalOutputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxFragmentInputComponents
    IndentSpaces(out, indent);
    *out += "maxFragmentInputComponents:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentInputComponents); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxFragmentOutputAttachments
    IndentSpaces(out, indent);
    *out += "maxFragmentOutputAttachments:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentOutputAttachments); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxFragmentDualSrcAttachments
    IndentSpaces(out, indent);
    *out += "maxFragmentDualSrcAttachments:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentDualSrcAttachments); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxFragmentCombinedOutputResources
    IndentSpaces(out, indent);
    *out += "maxFragmentCombinedOutputResources: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentCombinedOutputResources); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxComputeSharedMemorySize
    IndentSpaces(out, indent);
    *out += "maxComputeSharedMemorySize:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxComputeSharedMemorySize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxComputeWorkGroupCount
    IndentSpaces(out, indent);
    *out += "maxComputeWorkGroupCount:       ";
    *out += "uint32_t[";
    *out += "3"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupCount)); // IYY
    ScalarValueToStringStruct vinfo_maxComputeWorkGroupCount = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxComputeWorkGroupCount), "maxComputeWorkGroupCount", 3, vinfo_maxComputeWorkGroupCount); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t maxComputeWorkGroupInvocations
    IndentSpaces(out, indent);
    *out += "maxComputeWorkGroupInvocations: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxComputeWorkGroupInvocations); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxComputeWorkGroupSize
    IndentSpaces(out, indent);
    *out += "maxComputeWorkGroupSize:        ";
    *out += "uint32_t[";
    *out += "3"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupSize)); // IYY
    ScalarValueToStringStruct vinfo_maxComputeWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxComputeWorkGroupSize), "maxComputeWorkGroupSize", 3, vinfo_maxComputeWorkGroupSize); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t subPixelPrecisionBits
    IndentSpaces(out, indent);
    *out += "subPixelPrecisionBits:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subPixelPrecisionBits); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t subTexelPrecisionBits
    IndentSpaces(out, indent);
    *out += "subTexelPrecisionBits:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subTexelPrecisionBits); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t mipmapPrecisionBits
    IndentSpaces(out, indent);
    *out += "mipmapPrecisionBits:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipmapPrecisionBits); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDrawIndexedIndexValue
    IndentSpaces(out, indent);
    *out += "maxDrawIndexedIndexValue:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDrawIndexedIndexValue); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDrawIndirectCount
    IndentSpaces(out, indent);
    *out += "maxDrawIndirectCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDrawIndirectCount); // UYW
    *out += "\n"; // GDS

    // struct member: float maxSamplerLodBias
    IndentSpaces(out, indent);
    *out += "maxSamplerLodBias:              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxSamplerLodBias); // PEZ
    *out += "\n"; // GDS

    // struct member: float maxSamplerAnisotropy
    IndentSpaces(out, indent);
    *out += "maxSamplerAnisotropy:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxSamplerAnisotropy); // PEZ
    *out += "\n"; // GDS

    // struct member: uint32_t maxViewports
    IndentSpaces(out, indent);
    *out += "maxViewports:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxViewports); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxViewportDimensions
    IndentSpaces(out, indent);
    *out += "maxViewportDimensions:          ";
    *out += "uint32_t[";
    *out += "2"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, maxViewportDimensions)); // IYY
    ScalarValueToStringStruct vinfo_maxViewportDimensions = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxViewportDimensions), "maxViewportDimensions", 2, vinfo_maxViewportDimensions); // JPA
    *out += "\n"; // GDS

    // struct member: float viewportBoundsRange
    IndentSpaces(out, indent);
    *out += "viewportBoundsRange:            ";
    *out += "float[";
    *out += "2"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, viewportBoundsRange)); // IYY
    ScalarValueToStringStruct vinfo_viewportBoundsRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->viewportBoundsRange), "viewportBoundsRange", 2, vinfo_viewportBoundsRange); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t viewportSubPixelBits
    IndentSpaces(out, indent);
    *out += "viewportSubPixelBits:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportSubPixelBits); // UYW
    *out += "\n"; // GDS

    // struct member: size_t minMemoryMapAlignment
    IndentSpaces(out, indent);
    *out += "minMemoryMapAlignment:          ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minMemoryMapAlignment); // UYW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize minTexelBufferOffsetAlignment
    IndentSpaces(out, indent);
    *out += "minTexelBufferOffsetAlignment:  ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minTexelBufferOffsetAlignment); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize minUniformBufferOffsetAlignment
    IndentSpaces(out, indent);
    *out += "minUniformBufferOffsetAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minUniformBufferOffsetAlignment); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize minStorageBufferOffsetAlignment
    IndentSpaces(out, indent);
    *out += "minStorageBufferOffsetAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minStorageBufferOffsetAlignment); //EQA
    *out += "\n"; // GDS

    // struct member: int32_t minTexelOffset
    IndentSpaces(out, indent);
    *out += "minTexelOffset:                 ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->minTexelOffset); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t maxTexelOffset
    IndentSpaces(out, indent);
    *out += "maxTexelOffset:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTexelOffset); // UYW
    *out += "\n"; // GDS

    // struct member: int32_t minTexelGatherOffset
    IndentSpaces(out, indent);
    *out += "minTexelGatherOffset:           ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->minTexelGatherOffset); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t maxTexelGatherOffset
    IndentSpaces(out, indent);
    *out += "maxTexelGatherOffset:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTexelGatherOffset); // UYW
    *out += "\n"; // GDS

    // struct member: float minInterpolationOffset
    IndentSpaces(out, indent);
    *out += "minInterpolationOffset:         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minInterpolationOffset); // PEZ
    *out += "\n"; // GDS

    // struct member: float maxInterpolationOffset
    IndentSpaces(out, indent);
    *out += "maxInterpolationOffset:         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxInterpolationOffset); // PEZ
    *out += "\n"; // GDS

    // struct member: uint32_t subPixelInterpolationOffsetBits
    IndentSpaces(out, indent);
    *out += "subPixelInterpolationOffsetBits: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subPixelInterpolationOffsetBits); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxFramebufferWidth
    IndentSpaces(out, indent);
    *out += "maxFramebufferWidth:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFramebufferWidth); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxFramebufferHeight
    IndentSpaces(out, indent);
    *out += "maxFramebufferHeight:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFramebufferHeight); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxFramebufferLayers
    IndentSpaces(out, indent);
    *out += "maxFramebufferLayers:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFramebufferLayers); // UYW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags framebufferColorSampleCounts
    IndentSpaces(out, indent);
    *out += "framebufferColorSampleCounts:   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferColorSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags framebufferDepthSampleCounts
    IndentSpaces(out, indent);
    *out += "framebufferDepthSampleCounts:   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferDepthSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags framebufferStencilSampleCounts
    IndentSpaces(out, indent);
    *out += "framebufferStencilSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferStencilSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags framebufferNoAttachmentsSampleCounts
    IndentSpaces(out, indent);
    *out += "framebufferNoAttachmentsSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferNoAttachmentsSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t maxColorAttachments
    IndentSpaces(out, indent);
    *out += "maxColorAttachments:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxColorAttachments); // UYW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags sampledImageColorSampleCounts
    IndentSpaces(out, indent);
    *out += "sampledImageColorSampleCounts:  ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageColorSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags sampledImageIntegerSampleCounts
    IndentSpaces(out, indent);
    *out += "sampledImageIntegerSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageIntegerSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags sampledImageDepthSampleCounts
    IndentSpaces(out, indent);
    *out += "sampledImageDepthSampleCounts:  ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageDepthSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags sampledImageStencilSampleCounts
    IndentSpaces(out, indent);
    *out += "sampledImageStencilSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageStencilSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags storageImageSampleCounts
    IndentSpaces(out, indent);
    *out += "storageImageSampleCounts:       ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->storageImageSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t maxSampleMaskWords
    IndentSpaces(out, indent);
    *out += "maxSampleMaskWords:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSampleMaskWords); // UYW
    *out += "\n"; // GDS

    // struct member: VkBool32 timestampComputeAndGraphics
    IndentSpaces(out, indent);
    *out += "timestampComputeAndGraphics:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->timestampComputeAndGraphics); //EQA
    *out += "\n"; // GDS

    // struct member: float timestampPeriod
    IndentSpaces(out, indent);
    *out += "timestampPeriod:                ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->timestampPeriod); // PEZ
    *out += "\n"; // GDS

    // struct member: uint32_t maxClipDistances
    IndentSpaces(out, indent);
    *out += "maxClipDistances:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxClipDistances); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxCullDistances
    IndentSpaces(out, indent);
    *out += "maxCullDistances:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxCullDistances); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxCombinedClipAndCullDistances
    IndentSpaces(out, indent);
    *out += "maxCombinedClipAndCullDistances: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxCombinedClipAndCullDistances); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t discreteQueuePriorities
    IndentSpaces(out, indent);
    *out += "discreteQueuePriorities:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->discreteQueuePriorities); // UYW
    *out += "\n"; // GDS

    // struct member: float pointSizeRange
    IndentSpaces(out, indent);
    *out += "pointSizeRange:                 ";
    *out += "float[";
    *out += "2"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, pointSizeRange)); // IYY
    ScalarValueToStringStruct vinfo_pointSizeRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->pointSizeRange), "pointSizeRange", 2, vinfo_pointSizeRange); // JPA
    *out += "\n"; // GDS

    // struct member: float lineWidthRange
    IndentSpaces(out, indent);
    *out += "lineWidthRange:                 ";
    *out += "float[";
    *out += "2"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, lineWidthRange)); // IYY
    ScalarValueToStringStruct vinfo_lineWidthRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->lineWidthRange), "lineWidthRange", 2, vinfo_lineWidthRange); // JPA
    *out += "\n"; // GDS

    // struct member: float pointSizeGranularity
    IndentSpaces(out, indent);
    *out += "pointSizeGranularity:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->pointSizeGranularity); // PEZ
    *out += "\n"; // GDS

    // struct member: float lineWidthGranularity
    IndentSpaces(out, indent);
    *out += "lineWidthGranularity:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->lineWidthGranularity); // PEZ
    *out += "\n"; // GDS

    // struct member: VkBool32 strictLines
    IndentSpaces(out, indent);
    *out += "strictLines:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->strictLines); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 standardSampleLocations
    IndentSpaces(out, indent);
    *out += "standardSampleLocations:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->standardSampleLocations); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize optimalBufferCopyOffsetAlignment
    IndentSpaces(out, indent);
    *out += "optimalBufferCopyOffsetAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->optimalBufferCopyOffsetAlignment); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize optimalBufferCopyRowPitchAlignment
    IndentSpaces(out, indent);
    *out += "optimalBufferCopyRowPitchAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->optimalBufferCopyRowPitchAlignment); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize nonCoherentAtomSize
    IndentSpaces(out, indent);
    *out += "nonCoherentAtomSize:            ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->nonCoherentAtomSize); //EQA
}

template <>
void StructureToString<Decoded_VkImageBlit>(std::string* out, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageBlit *pstruct = (const VkImageBlit *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageSubresourceLayers srcSubresource
    IndentSpaces(out, indent);
    *out += "srcSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageBlit, srcSubresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D srcOffsets
    IndentSpaces(out, indent);
    *out += "srcOffsets:                     ";
    *out += "VkOffset3D[";
    *out += "2"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkImageBlit, srcOffsets)); // IYY
    ArrayOfStructsToString<Decoded_VkOffset3D>(out, indent+1, 0, "VkOffset3D", pstruct_in.srcOffsets->GetMetaStructPointer(), "srcOffsets", 2 , false, pstruct_in.srcOffsets->GetAddress()); // EPB
    *out += "\n"; // GDS

    // struct member: VkImageSubresourceLayers dstSubresource
    IndentSpaces(out, indent);
    *out += "dstSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageBlit, dstSubresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D dstOffsets
    IndentSpaces(out, indent);
    *out += "dstOffsets:                     ";
    *out += "VkOffset3D[";
    *out += "2"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkImageBlit, dstOffsets)); // IYY
    ArrayOfStructsToString<Decoded_VkOffset3D>(out, indent+1, 0, "VkOffset3D", pstruct_in.dstOffsets->GetMetaStructPointer(), "dstOffsets", 2 , false, pstruct_in.dstOffsets->GetAddress()); // EPB
}

template <>
void StructureToString<Decoded_VkWriteDescriptorSet>(std::string* out, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWriteDescriptorSet *pstruct = (const VkWriteDescriptorSet *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDescriptorSet dstSet
    IndentSpaces(out, indent);
    *out += "dstSet:                         ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.dstSet); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t dstBinding
    IndentSpaces(out, indent);
    *out += "dstBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstBinding); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dstArrayElement
    IndentSpaces(out, indent);
    *out += "dstArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstArrayElement); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const VkDescriptorImageInfo* pImageInfo
    IndentSpaces(out, indent);
    *out += "pImageInfo:                     ";
    *out += "const VkDescriptorImageInfo* = "; // TEQ
    if (pstruct->pImageInfo == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageInfo->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorImageInfo>(out, indent+1, 1, "VkDescriptorImageInfo", pstruct_in.pImageInfo->GetMetaStructPointer(), "pImageInfo", pstruct->descriptorCount, false, pstruct_in.pImageInfo->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: const VkDescriptorBufferInfo* pBufferInfo
    IndentSpaces(out, indent);
    *out += "pBufferInfo:                    ";
    *out += "const VkDescriptorBufferInfo* = "; // TEQ
    if (pstruct->pBufferInfo == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBufferInfo->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorBufferInfo>(out, indent+1, 1, "VkDescriptorBufferInfo", pstruct_in.pBufferInfo->GetMetaStructPointer(), "pBufferInfo", pstruct->descriptorCount, false, pstruct_in.pBufferInfo->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: const VkBufferView* pTexelBufferView
    IndentSpaces(out, indent);
    *out += "pTexelBufferView:               ";
    *out += "const VkBufferView* = "; // TEQ
    if (pstruct->pTexelBufferView == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTexelBufferView.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pTexelBufferView = {true, false, false, nullptr};
        ArrayToString<const VkBufferView*>(out, indent, 1, "const VkBufferView*", reinterpret_cast<const VkBufferView*>(pstruct_in.pTexelBufferView.GetPointer()), "pTexelBufferView", pstruct->descriptorCount,  vinfo_pTexelBufferView);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkApplicationInfo>(std::string* out, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkApplicationInfo *pstruct = (const VkApplicationInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: const char* pApplicationName
    IndentSpaces(out, indent);
    *out += "pApplicationName:               ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pApplicationName); // TGI
    *out += "\n"; // GDS

    // struct member: uint32_t applicationVersion
    IndentSpaces(out, indent);
    *out += "applicationVersion:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->applicationVersion); // UYW
    *out += "\n"; // GDS

    // struct member: const char* pEngineName
    IndentSpaces(out, indent);
    *out += "pEngineName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pEngineName); // TGI
    *out += "\n"; // GDS

    // struct member: uint32_t engineVersion
    IndentSpaces(out, indent);
    *out += "engineVersion:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->engineVersion); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t apiVersion
    IndentSpaces(out, indent);
    *out += "apiVersion:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->apiVersion); // UYW
}

template <>
void StructureToString<Decoded_VkSpecializationMapEntry>(std::string* out, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSpecializationMapEntry *pstruct = (const VkSpecializationMapEntry *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t constantID
    IndentSpaces(out, indent);
    *out += "constantID:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->constantID); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset); // UYW
    *out += "\n"; // GDS

    // struct member: size_t size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->size); // UYW
}

template <>
void StructureToString<Decoded_VkBindSparseInfo>(std::string* out, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindSparseInfo *pstruct = (const VkBindSparseInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSemaphore* pWaitSemaphores
    IndentSpaces(out, indent);
    *out += "pWaitSemaphores:                ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t bufferBindCount
    IndentSpaces(out, indent);
    *out += "bufferBindCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bufferBindCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSparseBufferMemoryBindInfo* pBufferBinds
    IndentSpaces(out, indent);
    *out += "pBufferBinds:                   ";
    *out += "const VkSparseBufferMemoryBindInfo* = "; // TEQ
    if (pstruct->pBufferBinds == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBufferBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseBufferMemoryBindInfo>(out, indent+1, 1, "VkSparseBufferMemoryBindInfo", pstruct_in.pBufferBinds->GetMetaStructPointer(), "pBufferBinds", pstruct->bufferBindCount, false, pstruct_in.pBufferBinds->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t imageOpaqueBindCount
    IndentSpaces(out, indent);
    *out += "imageOpaqueBindCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageOpaqueBindCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds
    IndentSpaces(out, indent);
    *out += "pImageOpaqueBinds:              ";
    *out += "const VkSparseImageOpaqueMemoryBindInfo* = "; // TEQ
    if (pstruct->pImageOpaqueBinds == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageOpaqueBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(out, indent+1, 1, "VkSparseImageOpaqueMemoryBindInfo", pstruct_in.pImageOpaqueBinds->GetMetaStructPointer(), "pImageOpaqueBinds", pstruct->imageOpaqueBindCount, false, pstruct_in.pImageOpaqueBinds->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t imageBindCount
    IndentSpaces(out, indent);
    *out += "imageBindCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageBindCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSparseImageMemoryBindInfo* pImageBinds
    IndentSpaces(out, indent);
    *out += "pImageBinds:                    ";
    *out += "const VkSparseImageMemoryBindInfo* = "; // TEQ
    if (pstruct->pImageBinds == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageBinds->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryBindInfo>(out, indent+1, 1, "VkSparseImageMemoryBindInfo", pstruct_in.pImageBinds->GetMetaStructPointer(), "pImageBinds", pstruct->imageBindCount, false, pstruct_in.pImageBinds->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t signalSemaphoreCount
    IndentSpaces(out, indent);
    *out += "signalSemaphoreCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSemaphore* pSignalSemaphores
    IndentSpaces(out, indent);
    *out += "pSignalSemaphores:              ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pSignalSemaphores == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkClearValue>(std::string* out, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearValue *pstruct = (const VkClearValue *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkClearColorValue color
    IndentSpaces(out, indent);
    *out += "color:                          ";
    *out += "VkClearColorValue = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkClearColorValue>(out, reinterpret_cast<const Decoded_VkClearColorValue&>(pstruct_in), indent+1,  base_addr + offsetof(VkClearValue, color)); // RLN
    *out += "\n"; // GDS

    // struct member: VkClearDepthStencilValue depthStencil
    IndentSpaces(out, indent);
    *out += "depthStencil:                   ";
    *out += "VkClearDepthStencilValue = "; // TEQ
    StructureToString<Decoded_VkClearDepthStencilValue>(out, reinterpret_cast<const Decoded_VkClearDepthStencilValue&>(pstruct_in), indent+1,  base_addr + offsetof(VkClearValue, depthStencil)); // RLN
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryBind>(std::string* out, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryBind *pstruct = (const VkSparseImageMemoryBind *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageSubresource subresource
    IndentSpaces(out, indent);
    *out += "subresource:                    ";
    *out += "VkImageSubresource = "; // TEQ
    StructureToString<Decoded_VkImageSubresource>(out, *pstruct_in.subresource, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, subresource)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset3D offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.offset, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, offset)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent3D extent
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, extent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset); //EQA
    *out += "\n"; // GDS

    // struct member: VkSparseMemoryBindFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSparseMemoryBindFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSparseMemoryBindFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkVertexInputBindingDescription>(std::string* out, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkVertexInputBindingDescription *pstruct = (const VkVertexInputBindingDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t binding
    IndentSpaces(out, indent);
    *out += "binding:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->binding); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stride); // UYW
    *out += "\n"; // GDS

    // struct member: VkVertexInputRate inputRate
    IndentSpaces(out, indent);
    *out += "inputRate:                      ";
    *out += "VkVertexInputRate = "; // TEQ
    EnumToStringVkVertexInputRate(out, pstruct->inputRate); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->inputRate);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSamplerCreateInfo>(std::string* out, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerCreateInfo *pstruct = (const VkSamplerCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSamplerCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSamplerCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSamplerCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkFilter magFilter
    IndentSpaces(out, indent);
    *out += "magFilter:                      ";
    *out += "VkFilter = "; // TEQ
    EnumToStringVkFilter(out, pstruct->magFilter); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->magFilter);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkFilter minFilter
    IndentSpaces(out, indent);
    *out += "minFilter:                      ";
    *out += "VkFilter = "; // TEQ
    EnumToStringVkFilter(out, pstruct->minFilter); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->minFilter);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSamplerMipmapMode mipmapMode
    IndentSpaces(out, indent);
    *out += "mipmapMode:                     ";
    *out += "VkSamplerMipmapMode = "; // TEQ
    EnumToStringVkSamplerMipmapMode(out, pstruct->mipmapMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->mipmapMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSamplerAddressMode addressModeU
    IndentSpaces(out, indent);
    *out += "addressModeU:                   ";
    *out += "VkSamplerAddressMode = "; // TEQ
    EnumToStringVkSamplerAddressMode(out, pstruct->addressModeU); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->addressModeU);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSamplerAddressMode addressModeV
    IndentSpaces(out, indent);
    *out += "addressModeV:                   ";
    *out += "VkSamplerAddressMode = "; // TEQ
    EnumToStringVkSamplerAddressMode(out, pstruct->addressModeV); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->addressModeV);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSamplerAddressMode addressModeW
    IndentSpaces(out, indent);
    *out += "addressModeW:                   ";
    *out += "VkSamplerAddressMode = "; // TEQ
    EnumToStringVkSamplerAddressMode(out, pstruct->addressModeW); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->addressModeW);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: float mipLodBias
    IndentSpaces(out, indent);
    *out += "mipLodBias:                     ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->mipLodBias); // PEZ
    *out += "\n"; // GDS

    // struct member: VkBool32 anisotropyEnable
    IndentSpaces(out, indent);
    *out += "anisotropyEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->anisotropyEnable); //EQA
    *out += "\n"; // GDS

    // struct member: float maxAnisotropy
    IndentSpaces(out, indent);
    *out += "maxAnisotropy:                  ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxAnisotropy); // PEZ
    *out += "\n"; // GDS

    // struct member: VkBool32 compareEnable
    IndentSpaces(out, indent);
    *out += "compareEnable:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->compareEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkCompareOp compareOp
    IndentSpaces(out, indent);
    *out += "compareOp:                      ";
    *out += "VkCompareOp = "; // TEQ
    EnumToStringVkCompareOp(out, pstruct->compareOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->compareOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: float minLod
    IndentSpaces(out, indent);
    *out += "minLod:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minLod); // PEZ
    *out += "\n"; // GDS

    // struct member: float maxLod
    IndentSpaces(out, indent);
    *out += "maxLod:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxLod); // PEZ
    *out += "\n"; // GDS

    // struct member: VkBorderColor borderColor
    IndentSpaces(out, indent);
    *out += "borderColor:                    ";
    *out += "VkBorderColor = "; // TEQ
    EnumToStringVkBorderColor(out, pstruct->borderColor); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->borderColor);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 unnormalizedCoordinates
    IndentSpaces(out, indent);
    *out += "unnormalizedCoordinates:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->unnormalizedCoordinates); //EQA
}

template <>
void StructureToString<Decoded_VkSemaphoreCreateInfo>(std::string* out, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreCreateInfo *pstruct = (const VkSemaphoreCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphoreCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
}

template <>
void StructureToString<Decoded_VkClearAttachment>(std::string* out, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearAttachment *pstruct = (const VkClearAttachment *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t colorAttachment
    IndentSpaces(out, indent);
    *out += "colorAttachment:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->colorAttachment); // UYW
    *out += "\n"; // GDS

    // struct member: VkClearValue clearValue
    IndentSpaces(out, indent);
    *out += "clearValue:                     ";
    *out += "VkClearValue = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkClearValue>(out, *pstruct_in.clearValue, indent+1,  base_addr + offsetof(VkClearAttachment, clearValue)); // AZJ
}

template <>
void StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(std::string* out, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetLayoutCreateInfo *pstruct = (const VkDescriptorSetLayoutCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDescriptorSetLayoutCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDescriptorSetLayoutCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDescriptorSetLayoutCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t bindingCount
    IndentSpaces(out, indent);
    *out += "bindingCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindingCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDescriptorSetLayoutBinding* pBindings
    IndentSpaces(out, indent);
    *out += "pBindings:                      ";
    *out += "const VkDescriptorSetLayoutBinding* = "; // TEQ
    if (pstruct->pBindings == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBindings->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorSetLayoutBinding>(out, indent+1, 1, "VkDescriptorSetLayoutBinding", pstruct_in.pBindings->GetMetaStructPointer(), "pBindings", pstruct->bindingCount, false, pstruct_in.pBindings->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDescriptorPoolCreateInfo>(std::string* out, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorPoolCreateInfo *pstruct = (const VkDescriptorPoolCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDescriptorPoolCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDescriptorPoolCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDescriptorPoolCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t maxSets
    IndentSpaces(out, indent);
    *out += "maxSets:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSets); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t poolSizeCount
    IndentSpaces(out, indent);
    *out += "poolSizeCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->poolSizeCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDescriptorPoolSize* pPoolSizes
    IndentSpaces(out, indent);
    *out += "pPoolSizes:                     ";
    *out += "const VkDescriptorPoolSize* = "; // TEQ
    if (pstruct->pPoolSizes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPoolSizes->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorPoolSize>(out, indent+1, 1, "VkDescriptorPoolSize", pstruct_in.pPoolSizes->GetMetaStructPointer(), "pPoolSizes", pstruct->poolSizeCount, false, pstruct_in.pPoolSizes->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDescriptorImageInfo>(std::string* out, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorImageInfo *pstruct = (const VkDescriptorImageInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkSampler sampler
    IndentSpaces(out, indent);
    *out += "sampler:                        ";
    *out += "VkSampler = "; // TEQ
    AddrToString(out, pstruct_in.sampler); // PAQ
    *out += "\n"; // GDS

    // struct member: VkImageView imageView
    IndentSpaces(out, indent);
    *out += "imageView:                      ";
    *out += "VkImageView = "; // TEQ
    AddrToString(out, pstruct_in.imageView); // PAQ
    *out += "\n"; // GDS

    // struct member: VkImageLayout imageLayout
    IndentSpaces(out, indent);
    *out += "imageLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->imageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkAllocationCallbacks>(std::string* out, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAllocationCallbacks *pstruct = (const VkAllocationCallbacks *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: void* pUserData
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
    *out += "\n"; // GDS

    // struct member: PFN_vkAllocationFunction pfnAllocation
    IndentSpaces(out, indent);
    *out += "pfnAllocation:                  ";
    *out += "PFN_vkAllocationFunction = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnAllocation)); // WRX
    *out += "\n"; // GDS

    // struct member: PFN_vkReallocationFunction pfnReallocation
    IndentSpaces(out, indent);
    *out += "pfnReallocation:                ";
    *out += "PFN_vkReallocationFunction = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnReallocation)); // WRX
    *out += "\n"; // GDS

    // struct member: PFN_vkFreeFunction pfnFree
    IndentSpaces(out, indent);
    *out += "pfnFree:                        ";
    *out += "PFN_vkFreeFunction = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnFree)); // WRX
    *out += "\n"; // GDS

    // struct member: PFN_vkInternalAllocationNotification pfnInternalAllocation
    IndentSpaces(out, indent);
    *out += "pfnInternalAllocation:          ";
    *out += "PFN_vkInternalAllocationNotification = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnInternalAllocation)); // WRX
    *out += "\n"; // GDS

    // struct member: PFN_vkInternalFreeNotification pfnInternalFree
    IndentSpaces(out, indent);
    *out += "pfnInternalFree:                ";
    *out += "PFN_vkInternalFreeNotification = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnInternalFree)); // WRX
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceFeatures>(std::string* out, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceFeatures *pstruct = (const VkPhysicalDeviceFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkBool32 robustBufferAccess
    IndentSpaces(out, indent);
    *out += "robustBufferAccess:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->robustBufferAccess); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 fullDrawIndexUint32
    IndentSpaces(out, indent);
    *out += "fullDrawIndexUint32:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fullDrawIndexUint32); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 imageCubeArray
    IndentSpaces(out, indent);
    *out += "imageCubeArray:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->imageCubeArray); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 independentBlend
    IndentSpaces(out, indent);
    *out += "independentBlend:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->independentBlend); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 geometryShader
    IndentSpaces(out, indent);
    *out += "geometryShader:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->geometryShader); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 tessellationShader
    IndentSpaces(out, indent);
    *out += "tessellationShader:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->tessellationShader); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sampleRateShading
    IndentSpaces(out, indent);
    *out += "sampleRateShading:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sampleRateShading); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 dualSrcBlend
    IndentSpaces(out, indent);
    *out += "dualSrcBlend:                   ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->dualSrcBlend); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 logicOp
    IndentSpaces(out, indent);
    *out += "logicOp:                        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->logicOp); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 multiDrawIndirect
    IndentSpaces(out, indent);
    *out += "multiDrawIndirect:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiDrawIndirect); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 drawIndirectFirstInstance
    IndentSpaces(out, indent);
    *out += "drawIndirectFirstInstance:      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->drawIndirectFirstInstance); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 depthClamp
    IndentSpaces(out, indent);
    *out += "depthClamp:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthClamp); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 depthBiasClamp
    IndentSpaces(out, indent);
    *out += "depthBiasClamp:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBiasClamp); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 fillModeNonSolid
    IndentSpaces(out, indent);
    *out += "fillModeNonSolid:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fillModeNonSolid); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 depthBounds
    IndentSpaces(out, indent);
    *out += "depthBounds:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBounds); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 wideLines
    IndentSpaces(out, indent);
    *out += "wideLines:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->wideLines); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 largePoints
    IndentSpaces(out, indent);
    *out += "largePoints:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->largePoints); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 alphaToOne
    IndentSpaces(out, indent);
    *out += "alphaToOne:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->alphaToOne); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 multiViewport
    IndentSpaces(out, indent);
    *out += "multiViewport:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiViewport); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 samplerAnisotropy
    IndentSpaces(out, indent);
    *out += "samplerAnisotropy:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->samplerAnisotropy); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 textureCompressionETC2
    IndentSpaces(out, indent);
    *out += "textureCompressionETC2:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->textureCompressionETC2); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 textureCompressionASTC_LDR
    IndentSpaces(out, indent);
    *out += "textureCompressionASTC_LDR:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->textureCompressionASTC_LDR); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 textureCompressionBC
    IndentSpaces(out, indent);
    *out += "textureCompressionBC:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->textureCompressionBC); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 occlusionQueryPrecise
    IndentSpaces(out, indent);
    *out += "occlusionQueryPrecise:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->occlusionQueryPrecise); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 pipelineStatisticsQuery
    IndentSpaces(out, indent);
    *out += "pipelineStatisticsQuery:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->pipelineStatisticsQuery); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 vertexPipelineStoresAndAtomics
    IndentSpaces(out, indent);
    *out += "vertexPipelineStoresAndAtomics: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexPipelineStoresAndAtomics); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 fragmentStoresAndAtomics
    IndentSpaces(out, indent);
    *out += "fragmentStoresAndAtomics:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fragmentStoresAndAtomics); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderTessellationAndGeometryPointSize
    IndentSpaces(out, indent);
    *out += "shaderTessellationAndGeometryPointSize: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderTessellationAndGeometryPointSize); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderImageGatherExtended
    IndentSpaces(out, indent);
    *out += "shaderImageGatherExtended:      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderImageGatherExtended); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderStorageImageExtendedFormats
    IndentSpaces(out, indent);
    *out += "shaderStorageImageExtendedFormats: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageExtendedFormats); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderStorageImageMultisample
    IndentSpaces(out, indent);
    *out += "shaderStorageImageMultisample:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageMultisample); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderStorageImageReadWithoutFormat
    IndentSpaces(out, indent);
    *out += "shaderStorageImageReadWithoutFormat: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageReadWithoutFormat); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderStorageImageWriteWithoutFormat
    IndentSpaces(out, indent);
    *out += "shaderStorageImageWriteWithoutFormat: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageWriteWithoutFormat); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderUniformBufferArrayDynamicIndexing
    IndentSpaces(out, indent);
    *out += "shaderUniformBufferArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderUniformBufferArrayDynamicIndexing); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderSampledImageArrayDynamicIndexing
    IndentSpaces(out, indent);
    *out += "shaderSampledImageArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderSampledImageArrayDynamicIndexing); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderStorageBufferArrayDynamicIndexing
    IndentSpaces(out, indent);
    *out += "shaderStorageBufferArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageBufferArrayDynamicIndexing); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderStorageImageArrayDynamicIndexing
    IndentSpaces(out, indent);
    *out += "shaderStorageImageArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageArrayDynamicIndexing); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderClipDistance
    IndentSpaces(out, indent);
    *out += "shaderClipDistance:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderClipDistance); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderCullDistance
    IndentSpaces(out, indent);
    *out += "shaderCullDistance:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderCullDistance); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderFloat64
    IndentSpaces(out, indent);
    *out += "shaderFloat64:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderFloat64); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderInt64
    IndentSpaces(out, indent);
    *out += "shaderInt64:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderInt64); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderInt16
    IndentSpaces(out, indent);
    *out += "shaderInt16:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderInt16); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderResourceResidency
    IndentSpaces(out, indent);
    *out += "shaderResourceResidency:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderResourceResidency); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderResourceMinLod
    IndentSpaces(out, indent);
    *out += "shaderResourceMinLod:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderResourceMinLod); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseBinding
    IndentSpaces(out, indent);
    *out += "sparseBinding:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseBinding); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidencyBuffer
    IndentSpaces(out, indent);
    *out += "sparseResidencyBuffer:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyBuffer); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidencyImage2D
    IndentSpaces(out, indent);
    *out += "sparseResidencyImage2D:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyImage2D); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidencyImage3D
    IndentSpaces(out, indent);
    *out += "sparseResidencyImage3D:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyImage3D); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidency2Samples
    IndentSpaces(out, indent);
    *out += "sparseResidency2Samples:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency2Samples); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidency4Samples
    IndentSpaces(out, indent);
    *out += "sparseResidency4Samples:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency4Samples); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidency8Samples
    IndentSpaces(out, indent);
    *out += "sparseResidency8Samples:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency8Samples); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidency16Samples
    IndentSpaces(out, indent);
    *out += "sparseResidency16Samples:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency16Samples); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 sparseResidencyAliased
    IndentSpaces(out, indent);
    *out += "sparseResidencyAliased:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyAliased); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 variableMultisampleRate
    IndentSpaces(out, indent);
    *out += "variableMultisampleRate:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variableMultisampleRate); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 inheritedQueries
    IndentSpaces(out, indent);
    *out += "inheritedQueries:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->inheritedQueries); //EQA
}

template <>
void StructureToString<Decoded_VkMemoryHeap>(std::string* out, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryHeap *pstruct = (const VkMemoryHeap *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
    *out += "\n"; // GDS

    // struct member: VkMemoryHeapFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMemoryHeapFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkMemoryHeapFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPipelineShaderStageCreateInfo>(std::string* out, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineShaderStageCreateInfo *pstruct = (const VkPipelineShaderStageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineShaderStageCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineShaderStageCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineShaderStageCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkShaderStageFlagBits stage
    IndentSpaces(out, indent);
    *out += "stage:                          ";
    *out += "VkShaderStageFlagBits = "; // TEQ
    EnumToStringVkShaderStageFlagBits(out, pstruct->stage); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stage);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkShaderModule module
    IndentSpaces(out, indent);
    *out += "module:                         ";
    *out += "VkShaderModule = "; // TEQ
    AddrToString(out, pstruct_in.module); // PAQ
    *out += "\n"; // GDS

    // struct member: const char* pName
    IndentSpaces(out, indent);
    *out += "pName:                          ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pName); // TGI
    *out += "\n"; // GDS

    // struct member: const VkSpecializationInfo* pSpecializationInfo
    IndentSpaces(out, indent);
    *out += "pSpecializationInfo:            ";
    *out += "const VkSpecializationInfo* = "; // TEQ
    if (pstruct->pSpecializationInfo == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSpecializationInfo->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkSpecializationInfo>(out, *pstruct_in.pSpecializationInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkPipelineShaderStageCreateInfo, pSpecializationInfo)); // GLN
    }
}

template <>
void StructureToString<Decoded_VkMappedMemoryRange>(std::string* out, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMappedMemoryRange *pstruct = (const VkMappedMemoryRange *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
    *out += "\n"; // GDS

    // struct member: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size); //EQA
}

template <>
void StructureToString<Decoded_VkClearRect>(std::string* out, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearRect *pstruct = (const VkClearRect *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkRect2D rect
    IndentSpaces(out, indent);
    *out += "rect:                           ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.rect, indent+1,  base_addr + offsetof(VkClearRect, rect)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t baseArrayLayer
    IndentSpaces(out, indent);
    *out += "baseArrayLayer:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseArrayLayer); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t layerCount
    IndentSpaces(out, indent);
    *out += "layerCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layerCount); // UYW
}

template <>
void StructureToString<Decoded_VkImageSubresourceRange>(std::string* out, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSubresourceRange *pstruct = (const VkImageSubresourceRange *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t baseMipLevel
    IndentSpaces(out, indent);
    *out += "baseMipLevel:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseMipLevel); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t levelCount
    IndentSpaces(out, indent);
    *out += "levelCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->levelCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t baseArrayLayer
    IndentSpaces(out, indent);
    *out += "baseArrayLayer:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseArrayLayer); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t layerCount
    IndentSpaces(out, indent);
    *out += "layerCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layerCount); // UYW
}

void VulkanAsciiConsumer::Process_vkCreateShaderModule(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkShaderModuleCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkShaderModule>& pShaderModule)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkShaderModuleCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkShaderModuleCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkShaderModuleCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkShaderModule* pShaderModule
    IndentSpaces(out, indent);
    *out += "pShaderModule:                  ";
    *out += "VkShaderModule* = "; // TEQ
    if (pShaderModule.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pShaderModule = {true, false, false, nullptr};
        ScalarValueToString(out, pShaderModule.GetPointer(), vinfo_pShaderModule); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindVertexBuffers(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const HandlePointerDecoder<VkBuffer>&       pBuffers,
    const PointerDecoder<VkDeviceSize>&         pOffsets)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstBinding
    IndentSpaces(out, indent);
    *out += "firstBinding:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstBinding); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t bindingCount
    IndentSpaces(out, indent);
    *out += "bindingCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindingCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBuffer* pBuffers
    IndentSpaces(out, indent);
    *out += "pBuffers:                       ";
    *out += "const VkBuffer* = "; // TEQ
    if (pBuffers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(out, indent, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pBuffers.GetPointer()), "pBuffers", bindingCount,  vinfo_pBuffers);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: const VkDeviceSize* pOffsets
    IndentSpaces(out, indent);
    *out += "pOffsets:                       ";
    *out += "const VkDeviceSize* = "; // TEQ
    if (pOffsets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pOffsets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pOffsets = {false, false, false, nullptr};
        ArrayToString<const VkDeviceSize*>(out, indent, 1, "const VkDeviceSize*", reinterpret_cast<const VkDeviceSize*>(pOffsets.GetPointer()), "pOffsets", bindingCount,  vinfo_pOffsets);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWaitEvents(
    format::HandleId                            commandBuffer,
    uint32_t                                    eventCount,
    const HandlePointerDecoder<VkEvent>&        pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const StructPointerDecoder<Decoded_VkMemoryBarrier>& pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkBufferMemoryBarrier>& pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkImageMemoryBarrier>& pImageMemoryBarriers)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t eventCount
    IndentSpaces(out, indent);
    *out += "eventCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, eventCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkEvent* pEvents
    IndentSpaces(out, indent);
    *out += "pEvents:                        ";
    *out += "const VkEvent* = "; // TEQ
    if (pEvents.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pEvents.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pEvents = {true, false, false, nullptr};
        ArrayToString<const VkEvent*>(out, indent, 1, "const VkEvent*", reinterpret_cast<const VkEvent*>(pEvents.GetPointer()), "pEvents", eventCount,  vinfo_pEvents);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlags srcStageMask
    IndentSpaces(out, indent);
    *out += "srcStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlags dstStageMask
    IndentSpaces(out, indent);
    *out += "dstStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: uint32_t memoryBarrierCount
    IndentSpaces(out, indent);
    *out += "memoryBarrierCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, memoryBarrierCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkMemoryBarrier* pMemoryBarriers
    IndentSpaces(out, indent);
    *out += "pMemoryBarriers:                ";
    *out += "const VkMemoryBarrier* = "; // TEQ
    if (pMemoryBarriers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryBarriers.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkMemoryBarrier>(out, indent+1, 1, "VkMemoryBarrier", pMemoryBarriers.GetMetaStructPointer(), "pMemoryBarriers", memoryBarrierCount, false, pMemoryBarriers.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: uint32_t bufferMemoryBarrierCount
    IndentSpaces(out, indent);
    *out += "bufferMemoryBarrierCount:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bufferMemoryBarrierCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBufferMemoryBarrier* pBufferMemoryBarriers
    IndentSpaces(out, indent);
    *out += "pBufferMemoryBarriers:          ";
    *out += "const VkBufferMemoryBarrier* = "; // TEQ
    if (pBufferMemoryBarriers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBufferMemoryBarriers.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBufferMemoryBarrier>(out, indent+1, 1, "VkBufferMemoryBarrier", pBufferMemoryBarriers.GetMetaStructPointer(), "pBufferMemoryBarriers", bufferMemoryBarrierCount, false, pBufferMemoryBarriers.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: uint32_t imageMemoryBarrierCount
    IndentSpaces(out, indent);
    *out += "imageMemoryBarrierCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, imageMemoryBarrierCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkImageMemoryBarrier* pImageMemoryBarriers
    IndentSpaces(out, indent);
    *out += "pImageMemoryBarriers:           ";
    *out += "const VkImageMemoryBarrier* = "; // TEQ
    if (pImageMemoryBarriers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImageMemoryBarriers.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkImageMemoryBarrier>(out, indent+1, 1, "VkImageMemoryBarrier", pImageMemoryBarriers.GetMetaStructPointer(), "pImageMemoryBarriers", imageMemoryBarrierCount, false, pImageMemoryBarriers.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateCommandPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkCommandPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkCommandPool>&  pCommandPool)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkCommandPoolCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkCommandPoolCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkCommandPoolCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkCommandPool* pCommandPool
    IndentSpaces(out, indent);
    *out += "pCommandPool:                   ";
    *out += "VkCommandPool* = "; // TEQ
    if (pCommandPool.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pCommandPool = {true, false, false, nullptr};
        ScalarValueToString(out, pCommandPool.GetPointer(), vinfo_pCommandPool); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceMemoryCommitment(
    format::HandleId                            device,
    format::HandleId                            memory,
    const PointerDecoder<VkDeviceSize>&         pCommittedMemoryInBytes)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, memory); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize* pCommittedMemoryInBytes
    IndentSpaces(out, indent);
    *out += "pCommittedMemoryInBytes:        ";
    *out += "VkDeviceSize* = "; // TEQ
    if (pCommittedMemoryInBytes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pCommittedMemoryInBytes = {false, false, false, nullptr};
        ScalarValueToString(out, pCommittedMemoryInBytes.GetPointer(), vinfo_pCommittedMemoryInBytes); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDepthBounds(
    format::HandleId                            commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: float minDepthBounds
    IndentSpaces(out, indent);
    *out += "minDepthBounds:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, minDepthBounds); // PEZ
    outString += "\n";   // HHS

    // func arg: float maxDepthBounds
    IndentSpaces(out, indent);
    *out += "maxDepthBounds:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, maxDepthBounds); // PEZ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdNextSubpass(
    format::HandleId                            commandBuffer,
    VkSubpassContents                           contents)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdNextSubpass(commandBuffer, contents)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSubpassContents contents
    IndentSpaces(out, indent);
    *out += "contents:                       ";
    *out += "VkSubpassContents = "; // TEQ
    EnumToStringVkSubpassContents(out, contents); // VSA
    *out += " (";
    UnsignedDecimalToString(out, contents);
    *out += ")";
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceQueue(
    format::HandleId                            device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    const HandlePointerDecoder<VkQueue>&        pQueue)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queueFamilyIndex); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t queueIndex
    IndentSpaces(out, indent);
    *out += "queueIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queueIndex); // UYW
    outString += "\n";   // HHS

    // func arg: VkQueue* pQueue
    IndentSpaces(out, indent);
    *out += "pQueue:                         ";
    *out += "VkQueue* = "; // TEQ
    if (pQueue.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pQueue = {true, false, false, nullptr};
        ScalarValueToString(out, pQueue.GetPointer(), vinfo_pQueue); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDevice(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDeviceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDevice>&       pDevice)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDeviceCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDeviceCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDeviceCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDevice* pDevice
    IndentSpaces(out, indent);
    *out += "pDevice:                        ";
    *out += "VkDevice* = "; // TEQ
    if (pDevice.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDevice = {true, false, false, nullptr};
        ScalarValueToString(out, pDevice.GetPointer(), vinfo_pDevice); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyInstance(
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyInstance(instance, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResetQueryPool(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstQuery
    IndentSpaces(out, indent);
    *out += "firstQuery:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstQuery); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t queryCount
    IndentSpaces(out, indent);
    *out += "queryCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queryCount); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDeviceWaitIdle(
    VkResult                                    returnValue,
    format::HandleId                            device)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDeviceWaitIdle(device)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindIndexBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: VkIndexType indexType
    IndentSpaces(out, indent);
    *out += "indexType:                      ";
    *out += "VkIndexType = "; // TEQ
    EnumToStringVkIndexType(out, indexType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, indexType);
    *out += ")";
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkInvalidateMappedMemoryRanges(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    const StructPointerDecoder<Decoded_VkMappedMemoryRange>& pMemoryRanges)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t memoryRangeCount
    IndentSpaces(out, indent);
    *out += "memoryRangeCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, memoryRangeCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkMappedMemoryRange* pMemoryRanges
    IndentSpaces(out, indent);
    *out += "pMemoryRanges:                  ";
    *out += "const VkMappedMemoryRange* = "; // TEQ
    if (pMemoryRanges.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRanges.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkMappedMemoryRange>(out, indent+1, 1, "VkMappedMemoryRange", pMemoryRanges.GetMetaStructPointer(), "pMemoryRanges", memoryRangeCount, false, pMemoryRanges.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateFramebuffer(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFramebufferCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFramebuffer>&  pFramebuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkFramebufferCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkFramebufferCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkFramebufferCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkFramebuffer* pFramebuffer
    IndentSpaces(out, indent);
    *out += "pFramebuffer:                   ";
    *out += "VkFramebuffer* = "; // TEQ
    if (pFramebuffer.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pFramebuffer = {true, false, false, nullptr};
        ScalarValueToString(out, pFramebuffer.GetPointer(), vinfo_pFramebuffer); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyEvent(
    format::HandleId                            device,
    format::HandleId                            event,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyEvent(device, event, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkEvent event
    IndentSpaces(out, indent);
    *out += "event:                          ";
    *out += "VkEvent = "; // TEQ
    AddrToString(out, event); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyQueryPool(
    format::HandleId                            device,
    format::HandleId                            queryPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyQueryPool(device, queryPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetEvent(
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetEvent(commandBuffer, event, stageMask)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkEvent event
    IndentSpaces(out, indent);
    *out += "event:                          ";
    *out += "VkEvent = "; // TEQ
    AddrToString(out, event); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlags stageMask
    IndentSpaces(out, indent);
    *out += "stageMask:                      ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, stageMask, EnumToStringVkPipelineStageFlagBits); // URW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyBufferToImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferImageCopy>& pRegions)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer srcBuffer
    IndentSpaces(out, indent);
    *out += "srcBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, srcBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage dstImage
    IndentSpaces(out, indent);
    *out += "dstImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, dstImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout dstImageLayout
    IndentSpaces(out, indent);
    *out += "dstImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, dstImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, dstImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint32_t regionCount
    IndentSpaces(out, indent);
    *out += "regionCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, regionCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBufferImageCopy* pRegions
    IndentSpaces(out, indent);
    *out += "pRegions:                       ";
    *out += "const VkBufferImageCopy* = "; // TEQ
    if (pRegions.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRegions.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBufferImageCopy>(out, indent+1, 1, "VkBufferImageCopy", pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateCommandBuffers(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkCommandBufferAllocateInfo>& pAllocateInfo,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkCommandBufferAllocateInfo* pAllocateInfo
    IndentSpaces(out, indent);
    *out += "pAllocateInfo:                  ";
    *out += "const VkCommandBufferAllocateInfo* = "; // TEQ
    if (pAllocateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkCommandBufferAllocateInfo>(out, *pAllocateInfo.GetMetaStructPointer(), indent+1,pAllocateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkCommandBuffer* pCommandBuffers
    IndentSpaces(out, indent);
    *out += "pCommandBuffers:                ";
    *out += "VkCommandBuffer* = "; // TEQ
    if (pCommandBuffers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCommandBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<VkCommandBuffer*>(out, indent, 1, "VkCommandBuffer*", reinterpret_cast<VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", pAllocateInfo.GetPointer()->commandBufferCount,  vinfo_pCommandBuffers);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkBeginCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCommandBufferBeginInfo>& pBeginInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBeginCommandBuffer(commandBuffer, pBeginInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkCommandBufferBeginInfo* pBeginInfo
    IndentSpaces(out, indent);
    *out += "pBeginInfo:                     ";
    *out += "const VkCommandBufferBeginInfo* = "; // TEQ
    if (pBeginInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBeginInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkCommandBufferBeginInfo>(out, *pBeginInfo.GetMetaStructPointer(), indent+1,pBeginInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreatePipelineCache(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineCacheCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipelineCache>& pPipelineCache)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPipelineCacheCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkPipelineCacheCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPipelineCacheCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkPipelineCache* pPipelineCache
    IndentSpaces(out, indent);
    *out += "pPipelineCache:                 ";
    *out += "VkPipelineCache* = "; // TEQ
    if (pPipelineCache.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPipelineCache = {true, false, false, nullptr};
        ScalarValueToString(out, pPipelineCache.GetPointer(), vinfo_pPipelineCache); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkEndCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkEndCommandBuffer(commandBuffer)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkMergePipelineCaches(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    const HandlePointerDecoder<VkPipelineCache>& pSrcCaches)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineCache dstCache
    IndentSpaces(out, indent);
    *out += "dstCache:                       ";
    *out += "VkPipelineCache = "; // TEQ
    AddrToString(out, dstCache); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t srcCacheCount
    IndentSpaces(out, indent);
    *out += "srcCacheCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, srcCacheCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkPipelineCache* pSrcCaches
    IndentSpaces(out, indent);
    *out += "pSrcCaches:                     ";
    *out += "const VkPipelineCache* = "; // TEQ
    if (pSrcCaches.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSrcCaches.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSrcCaches = {true, false, false, nullptr};
        ArrayToString<const VkPipelineCache*>(out, indent, 1, "const VkPipelineCache*", reinterpret_cast<const VkPipelineCache*>(pSrcCaches.GetPointer()), "pSrcCaches", srcCacheCount,  vinfo_pSrcCaches);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkEventCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkEvent>&        pEvent)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateEvent(device, pCreateInfo, pAllocator, pEvent)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkEventCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkEventCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkEventCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkEvent* pEvent
    IndentSpaces(out, indent);
    *out += "pEvent:                         ";
    *out += "VkEvent* = "; // TEQ
    if (pEvent.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pEvent = {true, false, false, nullptr};
        ScalarValueToString(out, pEvent.GetPointer(), vinfo_pEvent); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateImageView(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageViewCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkImageView>&    pView)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateImageView(device, pCreateInfo, pAllocator, pView)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageViewCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkImageViewCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageViewCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkImageView* pView
    IndentSpaces(out, indent);
    *out += "pView:                          ";
    *out += "VkImageView* = "; // TEQ
    if (pView.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, *(static_cast<uint64_t*>(pView.GetPointer()))); // PWA
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeCommandBuffers(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    uint32_t                                    commandBufferCount,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPool commandPool
    IndentSpaces(out, indent);
    *out += "commandPool:                    ";
    *out += "VkCommandPool = "; // TEQ
    AddrToString(out, commandPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t commandBufferCount
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, commandBufferCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkCommandBuffer* pCommandBuffers
    IndentSpaces(out, indent);
    *out += "pCommandBuffers:                ";
    *out += "const VkCommandBuffer* = "; // TEQ
    if (pCommandBuffers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCommandBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<const VkCommandBuffer*>(out, indent, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", commandBufferCount,  vinfo_pCommandBuffers);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResolveImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageResolve>& pRegions)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage srcImage
    IndentSpaces(out, indent);
    *out += "srcImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, srcImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout srcImageLayout
    IndentSpaces(out, indent);
    *out += "srcImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, srcImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, srcImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImage dstImage
    IndentSpaces(out, indent);
    *out += "dstImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, dstImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout dstImageLayout
    IndentSpaces(out, indent);
    *out += "dstImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, dstImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, dstImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint32_t regionCount
    IndentSpaces(out, indent);
    *out += "regionCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, regionCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkImageResolve* pRegions
    IndentSpaces(out, indent);
    *out += "pRegions:                       ";
    *out += "const VkImageResolve* = "; // TEQ
    if (pRegions.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRegions.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkImageResolve>(out, indent+1, 1, "VkImageResolve", pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRenderAreaGranularity(
    format::HandleId                            device,
    format::HandleId                            renderPass,
    const StructPointerDecoder<Decoded_VkExtent2D>& pGranularity)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetRenderAreaGranularity(device, renderPass, pGranularity)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkRenderPass renderPass
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, renderPass); // PAQ
    outString += "\n";   // HHS

    // func arg: VkExtent2D* pGranularity
    IndentSpaces(out, indent);
    *out += "pGranularity:                   ";
    *out += "VkExtent2D* = "; // TEQ
    if (pGranularity.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pGranularity.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExtent2D>(out, *pGranularity.GetMetaStructPointer(), indent+1,pGranularity.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyQueryPoolResults(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstQuery
    IndentSpaces(out, indent);
    *out += "firstQuery:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstQuery); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t queryCount
    IndentSpaces(out, indent);
    *out += "queryCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queryCount); // UYW
    outString += "\n";   // HHS

    // func arg: VkBuffer dstBuffer
    IndentSpaces(out, indent);
    *out += "dstBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, dstBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize dstOffset
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, dstOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkDeviceSize stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, stride); //EQA
    outString += "\n";   // HHS

    // func arg: VkQueryResultFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkQueryResultFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkQueryResultFlagBits); // URW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetQueryPoolResults(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstQuery
    IndentSpaces(out, indent);
    *out += "firstQuery:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstQuery); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t queryCount
    IndentSpaces(out, indent);
    *out += "queryCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queryCount); // UYW
    outString += "\n";   // HHS

    // func arg: size_t dataSize
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, dataSize); // UYW
    outString += "\n";   // HHS

    // func arg: void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "void* = "; // TEQ
    if (pData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pData.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    // func arg: VkDeviceSize stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, stride); //EQA
    outString += "\n";   // HHS

    // func arg: VkQueryResultFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkQueryResultFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkQueryResultFlagBits); // URW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginQuery(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBeginQuery(commandBuffer, queryPool, query, flags)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t query
    IndentSpaces(out, indent);
    *out += "query:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, query); // UYW
    outString += "\n";   // HHS

    // func arg: VkQueryControlFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkQueryControlFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkQueryControlFlagBits); // URW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateDescriptorSets(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetAllocateInfo>& pAllocateInfo,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDescriptorSetAllocateInfo* pAllocateInfo
    IndentSpaces(out, indent);
    *out += "pAllocateInfo:                  ";
    *out += "const VkDescriptorSetAllocateInfo* = "; // TEQ
    if (pAllocateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorSetAllocateInfo>(out, *pAllocateInfo.GetMetaStructPointer(), indent+1,pAllocateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDescriptorSet* pDescriptorSets
    IndentSpaces(out, indent);
    *out += "pDescriptorSets:                ";
    *out += "VkDescriptorSet* = "; // TEQ
    if (pDescriptorSets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDescriptorSets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        ArrayToString<VkDescriptorSet*>(out, indent, 1, "VkDescriptorSet*", reinterpret_cast<VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", pAllocateInfo.GetPointer()->descriptorSetCount,  vinfo_pDescriptorSets);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndRenderPass(
    format::HandleId                            commandBuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdEndRenderPass(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyBuffer(
    format::HandleId                            device,
    format::HandleId                            buffer,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyBuffer(device, buffer, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDispatchIndirect(commandBuffer, buffer, offset)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkResetEvent(device, event)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkEvent event
    IndentSpaces(out, indent);
    *out += "event:                          ";
    *out += "VkEvent = "; // TEQ
    AddrToString(out, event); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDraw(
    format::HandleId                            commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t vertexCount
    IndentSpaces(out, indent);
    *out += "vertexCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, vertexCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t instanceCount
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, instanceCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t firstVertex
    IndentSpaces(out, indent);
    *out += "firstVertex:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstVertex); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t firstInstance
    IndentSpaces(out, indent);
    *out += "firstInstance:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstInstance); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWriteTimestamp(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlagBits pipelineStage
    IndentSpaces(out, indent);
    *out += "pipelineStage:                  ";
    *out += "VkPipelineStageFlagBits = "; // TEQ
    EnumToStringVkPipelineStageFlagBits(out, pipelineStage); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pipelineStage);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t query
    IndentSpaces(out, indent);
    *out += "query:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, query); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilWriteMask(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkStencilFaceFlags faceMask
    IndentSpaces(out, indent);
    *out += "faceMask:                       ";
    *out += "VkStencilFaceFlags = "; // TEQ
    FlagsToString(out, faceMask, EnumToStringVkStencilFaceFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: uint32_t writeMask
    IndentSpaces(out, indent);
    *out += "writeMask:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, writeMask); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDevice(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyDevice(device, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t drawCount
    IndentSpaces(out, indent);
    *out += "drawCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, drawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkFlushMappedMemoryRanges(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    const StructPointerDecoder<Decoded_VkMappedMemoryRange>& pMemoryRanges)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t memoryRangeCount
    IndentSpaces(out, indent);
    *out += "memoryRangeCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, memoryRangeCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkMappedMemoryRange* pMemoryRanges
    IndentSpaces(out, indent);
    *out += "pMemoryRanges:                  ";
    *out += "const VkMappedMemoryRange* = "; // TEQ
    if (pMemoryRanges.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRanges.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkMappedMemoryRange>(out, indent+1, 1, "VkMappedMemoryRange", pMemoryRanges.GetMetaStructPointer(), "pMemoryRanges", memoryRangeCount, false, pMemoryRanges.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSubresourceLayout(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkImageSubresource>& pSubresource,
    const StructPointerDecoder<Decoded_VkSubresourceLayout>& pLayout)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageSubresourceLayout(device, image, pSubresource, pLayout)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageSubresource* pSubresource
    IndentSpaces(out, indent);
    *out += "pSubresource:                   ";
    *out += "const VkImageSubresource* = "; // TEQ
    if (pSubresource.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSubresource.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageSubresource>(out, *pSubresource.GetMetaStructPointer(), indent+1,pSubresource.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSubresourceLayout* pLayout
    IndentSpaces(out, indent);
    *out += "pLayout:                        ";
    *out += "VkSubresourceLayout* = "; // TEQ
    if (pLayout.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pLayout.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSubresourceLayout>(out, *pLayout.GetMetaStructPointer(), indent+1,pLayout.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBindImageMemory(device, image, memory, memoryOffset)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, memory); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize memoryOffset
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, memoryOffset); //EQA
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyRenderPass(
    format::HandleId                            device,
    format::HandleId                            renderPass,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyRenderPass(device, renderPass, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkRenderPass renderPass
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, renderPass); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindBufferMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            buffer,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBindBufferMemory(device, buffer, memory, memoryOffset)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, memory); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize memoryOffset
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, memoryOffset); //EQA
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateComputePipelines(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkComputePipelineCreateInfo>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineCache pipelineCache
    IndentSpaces(out, indent);
    *out += "pipelineCache:                  ";
    *out += "VkPipelineCache = "; // TEQ
    AddrToString(out, pipelineCache); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t createInfoCount
    IndentSpaces(out, indent);
    *out += "createInfoCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, createInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkComputePipelineCreateInfo* pCreateInfos
    IndentSpaces(out, indent);
    *out += "pCreateInfos:                   ";
    *out += "const VkComputePipelineCreateInfo* = "; // TEQ
    if (pCreateInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkComputePipelineCreateInfo>(out, indent+1, 1, "VkComputePipelineCreateInfo", pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkPipeline* pPipelines
    IndentSpaces(out, indent);
    *out += "pPipelines:                     ";
    *out += "VkPipeline* = "; // TEQ
    if (pPipelines.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPipelines.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        ArrayToString<VkPipeline*>(out, indent, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount,  vinfo_pPipelines);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateImage(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkImage>&        pImage)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateImage(device, pCreateInfo, pAllocator, pImage)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkImageCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkImage* pImage
    IndentSpaces(out, indent);
    *out += "pImage:                         ";
    *out += "VkImage* = "; // TEQ
    if (pImage.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pImage = {true, false, false, nullptr};
        ScalarValueToString(out, pImage.GetPointer(), vinfo_pImage); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateQueryPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkQueryPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkQueryPool>&    pQueryPool)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkQueryPoolCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkQueryPoolCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkQueryPoolCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkQueryPool* pQueryPool
    IndentSpaces(out, indent);
    *out += "pQueryPool:                     ";
    *out += "VkQueryPool* = "; // TEQ
    if (pQueryPool.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pQueryPool = {true, false, false, nullptr};
        ScalarValueToString(out, pQueryPool.GetPointer(), vinfo_pQueryPool); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipelineLayout(
    format::HandleId                            device,
    format::HandleId                            pipelineLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyPipelineLayout(device, pipelineLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineLayout pipelineLayout
    IndentSpaces(out, indent);
    *out += "pipelineLayout:                 ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pipelineLayout); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdExecuteCommands(
    format::HandleId                            commandBuffer,
    uint32_t                                    commandBufferCount,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t commandBufferCount
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, commandBufferCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkCommandBuffer* pCommandBuffers
    IndentSpaces(out, indent);
    *out += "pCommandBuffers:                ";
    *out += "const VkCommandBuffer* = "; // TEQ
    if (pCommandBuffers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCommandBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<const VkCommandBuffer*>(out, indent, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", commandBufferCount,  vinfo_pCommandBuffers);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferCopy>& pRegions)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer srcBuffer
    IndentSpaces(out, indent);
    *out += "srcBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, srcBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer dstBuffer
    IndentSpaces(out, indent);
    *out += "dstBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, dstBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t regionCount
    IndentSpaces(out, indent);
    *out += "regionCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, regionCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBufferCopy* pRegions
    IndentSpaces(out, indent);
    *out += "pRegions:                       ";
    *out += "const VkBufferCopy* = "; // TEQ
    if (pRegions.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRegions.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBufferCopy>(out, indent+1, 1, "VkBufferCopy", pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetEventStatus(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetEventStatus(device, event)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkEvent event
    IndentSpaces(out, indent);
    *out += "event:                          ";
    *out += "VkEvent = "; // TEQ
    AddrToString(out, event); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorSetLayout(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorSetLayout>& pSetLayout)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDescriptorSetLayoutCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDescriptorSetLayoutCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDescriptorSetLayout* pSetLayout
    IndentSpaces(out, indent);
    *out += "pSetLayout:                     ";
    *out += "VkDescriptorSetLayout* = "; // TEQ
    if (pSetLayout.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSetLayout = {true, false, false, nullptr};
        ScalarValueToString(out, pSetLayout.GetPointer(), vinfo_pSetLayout); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipeline(
    format::HandleId                            device,
    format::HandleId                            pipeline,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyPipeline(device, pipeline, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pipeline); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetFences(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    const HandlePointerDecoder<VkFence>&        pFences)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkResetFences(device, fenceCount, pFences)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t fenceCount
    IndentSpaces(out, indent);
    *out += "fenceCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, fenceCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkFence* pFences
    IndentSpaces(out, indent);
    *out += "pFences:                        ";
    *out += "const VkFence* = "; // TEQ
    if (pFences.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFences.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pFences = {true, false, false, nullptr};
        ArrayToString<const VkFence*>(out, indent, 1, "const VkFence*", reinterpret_cast<const VkFence*>(pFences.GetPointer()), "pFences", fenceCount,  vinfo_pFences);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkUnmapMemory(
    format::HandleId                            device,
    format::HandleId                            memory)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkUnmapMemory(device, memory)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, memory); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyShaderModule(
    format::HandleId                            device,
    format::HandleId                            shaderModule,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyShaderModule(device, shaderModule, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkShaderModule shaderModule
    IndentSpaces(out, indent);
    *out += "shaderModule:                   ";
    *out += "VkShaderModule = "; // TEQ
    AddrToString(out, shaderModule); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSampler(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSampler>&      pSampler)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateSampler(device, pCreateInfo, pAllocator, pSampler)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSamplerCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkSamplerCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSamplerCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSampler* pSampler
    IndentSpaces(out, indent);
    *out += "pSampler:                       ";
    *out += "VkSampler* = "; // TEQ
    if (pSampler.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSampler = {true, false, false, nullptr};
        ScalarValueToString(out, pSampler.GetPointer(), vinfo_pSampler); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyFramebuffer(
    format::HandleId                            device,
    format::HandleId                            framebuffer,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyFramebuffer(device, framebuffer, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFramebuffer framebuffer
    IndentSpaces(out, indent);
    *out += "framebuffer:                    ";
    *out += "VkFramebuffer = "; // TEQ
    AddrToString(out, framebuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetViewport(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkViewport>& pViewports)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstViewport
    IndentSpaces(out, indent);
    *out += "firstViewport:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstViewport); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t viewportCount
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, viewportCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkViewport* pViewports
    IndentSpaces(out, indent);
    *out += "pViewports:                     ";
    *out += "const VkViewport* = "; // TEQ
    if (pViewports.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pViewports.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkViewport>(out, indent+1, 1, "VkViewport", pViewports.GetMetaStructPointer(), "pViewports", viewportCount, false, pViewports.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearDepthStencilImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    const StructPointerDecoder<Decoded_VkClearDepthStencilValue>& pDepthStencil,
    uint32_t                                    rangeCount,
    const StructPointerDecoder<Decoded_VkImageSubresourceRange>& pRanges)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout imageLayout
    IndentSpaces(out, indent);
    *out += "imageLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, imageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, imageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: const VkClearDepthStencilValue* pDepthStencil
    IndentSpaces(out, indent);
    *out += "pDepthStencil:                  ";
    *out += "const VkClearDepthStencilValue* = "; // TEQ
    if (pDepthStencil.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDepthStencil.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkClearDepthStencilValue>(out, *pDepthStencil.GetMetaStructPointer(), indent+1,pDepthStencil.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t rangeCount
    IndentSpaces(out, indent);
    *out += "rangeCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, rangeCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkImageSubresourceRange* pRanges
    IndentSpaces(out, indent);
    *out += "pRanges:                        ";
    *out += "const VkImageSubresourceRange* = "; // TEQ
    if (pRanges.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRanges.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkImageSubresourceRange>(out, indent+1, 1, "VkImageSubresourceRange", pRanges.GetMetaStructPointer(), "pRanges", rangeCount, false, pRanges.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, format);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageType type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, type);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkSampleCountFlagBits samples
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, samples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, samples);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, usage, EnumToStringVkImageUsageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkImageTiling tiling
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, tiling); // VSA
    *out += " (";
    UnsignedDecimalToString(out, tiling);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSparseImageFormatProperties* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkSparseImageFormatProperties* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageFormatProperties>(out, indent+1, 1, "VkSparseImageFormatProperties", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetBlendConstants(
    format::HandleId                            commandBuffer,
    const PointerDecoder<float>&                blendConstants)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetBlendConstants(commandBuffer, blendConstants)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const float blendConstants
    IndentSpaces(out, indent);
    *out += "blendConstants:                 ";
    *out += "float[";
    *out += "4"; // TPK
    *out += "] = ";
    ScalarValueToStringStruct vinfo_blendConstants = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "const float", blendConstants.GetPointer(), "blendConstants", 4, vinfo_blendConstants); // JPA
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorSetLayout(
    format::HandleId                            device,
    format::HandleId                            descriptorSetLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDescriptorSetLayout descriptorSetLayout
    IndentSpaces(out, indent);
    *out += "descriptorSetLayout:            ";
    *out += "VkDescriptorSetLayout = "; // TEQ
    AddrToString(out, descriptorSetLayout); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorPool(
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyDescriptorPool(device, descriptorPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDescriptorPool descriptorPool
    IndentSpaces(out, indent);
    *out += "descriptorPool:                 ";
    *out += "VkDescriptorPool = "; // TEQ
    AddrToString(out, descriptorPool); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueWaitIdle(
    VkResult                                    returnValue,
    format::HandleId                            queue)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueueWaitIdle(queue)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    VkCommandBufferResetFlags                   flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkResetCommandBuffer(commandBuffer, flags)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandBufferResetFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandBufferResetFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkCommandBufferResetFlagBits); // URW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateGraphicsPipelines(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkGraphicsPipelineCreateInfo>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineCache pipelineCache
    IndentSpaces(out, indent);
    *out += "pipelineCache:                  ";
    *out += "VkPipelineCache = "; // TEQ
    AddrToString(out, pipelineCache); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t createInfoCount
    IndentSpaces(out, indent);
    *out += "createInfoCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, createInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkGraphicsPipelineCreateInfo* pCreateInfos
    IndentSpaces(out, indent);
    *out += "pCreateInfos:                   ";
    *out += "const VkGraphicsPipelineCreateInfo* = "; // TEQ
    if (pCreateInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkGraphicsPipelineCreateInfo>(out, indent+1, 1, "VkGraphicsPipelineCreateInfo", pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkPipeline* pPipelines
    IndentSpaces(out, indent);
    *out += "pPipelines:                     ";
    *out += "VkPipeline* = "; // TEQ
    if (pPipelines.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPipelines.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        ArrayToString<VkPipeline*>(out, indent, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount,  vinfo_pPipelines);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkWaitForFences(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    const HandlePointerDecoder<VkFence>&        pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkWaitForFences(device, fenceCount, pFences, waitAll, timeout)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t fenceCount
    IndentSpaces(out, indent);
    *out += "fenceCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, fenceCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkFence* pFences
    IndentSpaces(out, indent);
    *out += "pFences:                        ";
    *out += "const VkFence* = "; // TEQ
    if (pFences.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFences.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pFences = {true, false, false, nullptr};
        ArrayToString<const VkFence*>(out, indent, 1, "const VkFence*", reinterpret_cast<const VkFence*>(pFences.GetPointer()), "pFences", fenceCount,  vinfo_pFences);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: VkBool32 waitAll
    IndentSpaces(out, indent);
    *out += "waitAll:                        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, waitAll); //EQA
    outString += "\n";   // HHS

    // func arg: uint64_t timeout
    IndentSpaces(out, indent);
    *out += "timeout:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, timeout); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties>& pFormatProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, format);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkFormatProperties* pFormatProperties
    IndentSpaces(out, indent);
    *out += "pFormatProperties:              ";
    *out += "VkFormatProperties* = "; // TEQ
    if (pFormatProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFormatProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkFormatProperties>(out, *pFormatProperties.GetMetaStructPointer(), indent+1,pFormatProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            buffer,
    const StructPointerDecoder<Decoded_VkMemoryRequirements>& pMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkMemoryRequirements* pMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pMemoryRequirements:            ";
    *out += "VkMemoryRequirements* = "; // TEQ
    if (pMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRequirements.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryRequirements>(out, *pMemoryRequirements.GetMetaStructPointer(), indent+1,pMemoryRequirements.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorPool>& pDescriptorPool)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDescriptorPoolCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDescriptorPoolCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorPoolCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDescriptorPool* pDescriptorPool
    IndentSpaces(out, indent);
    *out += "pDescriptorPool:                ";
    *out += "VkDescriptorPool* = "; // TEQ
    if (pDescriptorPool.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDescriptorPool = {true, false, false, nullptr};
        ScalarValueToString(out, pDescriptorPool.GetPointer(), vinfo_pDescriptorPool); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueSubmit(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    submitCount,
    const StructPointerDecoder<Decoded_VkSubmitInfo>& pSubmits,
    format::HandleId                            fence)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueueSubmit(queue, submitCount, pSubmits, fence)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t submitCount
    IndentSpaces(out, indent);
    *out += "submitCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, submitCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkSubmitInfo* pSubmits
    IndentSpaces(out, indent);
    *out += "pSubmits:                       ";
    *out += "const VkSubmitInfo* = "; // TEQ
    if (pSubmits.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSubmits.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSubmitInfo>(out, indent+1, 1, "VkSubmitInfo", pSubmits.GetMetaStructPointer(), "pSubmits", submitCount, false, pSubmits.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, fence); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageCopy>& pRegions)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage srcImage
    IndentSpaces(out, indent);
    *out += "srcImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, srcImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout srcImageLayout
    IndentSpaces(out, indent);
    *out += "srcImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, srcImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, srcImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImage dstImage
    IndentSpaces(out, indent);
    *out += "dstImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, dstImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout dstImageLayout
    IndentSpaces(out, indent);
    *out += "dstImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, dstImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, dstImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint32_t regionCount
    IndentSpaces(out, indent);
    *out += "regionCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, regionCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkImageCopy* pRegions
    IndentSpaces(out, indent);
    *out += "pRegions:                       ";
    *out += "const VkImageCopy* = "; // TEQ
    if (pRegions.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRegions.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkImageCopy>(out, indent+1, 1, "VkImageCopy", pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatch(
    format::HandleId                            commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountX
    IndentSpaces(out, indent);
    *out += "groupCountX:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountX); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountY
    IndentSpaces(out, indent);
    *out += "groupCountY:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountY); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountZ
    IndentSpaces(out, indent);
    *out += "groupCountZ:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountZ); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyImageView(
    format::HandleId                            device,
    format::HandleId                            imageView,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyImageView(device, imageView, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageView imageView
    IndentSpaces(out, indent);
    *out += "imageView:                      ";
    *out += "VkImageView = "; // TEQ
    AddrToString(out, imageView); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceProperties* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkPhysicalDeviceProperties* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceProperties>(out, *pProperties.GetMetaStructPointer(), indent+1,pProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateBufferView(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferViewCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkBufferView>&   pView)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateBufferView(device, pCreateInfo, pAllocator, pView)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkBufferViewCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkBufferViewCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkBufferViewCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkBufferView* pView
    IndentSpaces(out, indent);
    *out += "pView:                          ";
    *out += "VkBufferView* = "; // TEQ
    if (pView.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, *(static_cast<uint64_t*>(pView.GetPointer()))); // PWA
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearAttachments(
    format::HandleId                            commandBuffer,
    uint32_t                                    attachmentCount,
    const StructPointerDecoder<Decoded_VkClearAttachment>& pAttachments,
    uint32_t                                    rectCount,
    const StructPointerDecoder<Decoded_VkClearRect>& pRects)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t attachmentCount
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, attachmentCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkClearAttachment* pAttachments
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkClearAttachment* = "; // TEQ
    if (pAttachments.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAttachments.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkClearAttachment>(out, indent+1, 1, "VkClearAttachment", pAttachments.GetMetaStructPointer(), "pAttachments", attachmentCount, false, pAttachments.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: uint32_t rectCount
    IndentSpaces(out, indent);
    *out += "rectCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, rectCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkClearRect* pRects
    IndentSpaces(out, indent);
    *out += "pRects:                         ";
    *out += "const VkClearRect* = "; // TEQ
    if (pRects.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRects.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkClearRect>(out, indent+1, 1, "VkClearRect", pRects.GetMetaStructPointer(), "pRects", rectCount, false, pRects.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateFence(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateFence(device, pCreateInfo, pAllocator, pFence)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkFenceCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkFenceCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkFenceCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkFence* pFence
    IndentSpaces(out, indent);
    *out += "pFence:                         ";
    *out += "VkFence* = "; // TEQ
    if (pFence.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pFence = {true, false, false, nullptr};
        ScalarValueToString(out, pFence.GetPointer(), vinfo_pFence); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties>& pMemoryProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceMemoryProperties* pMemoryProperties
    IndentSpaces(out, indent);
    *out += "pMemoryProperties:              ";
    *out += "VkPhysicalDeviceMemoryProperties* = "; // TEQ
    if (pMemoryProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(out, *pMemoryProperties.GetMetaStructPointer(), indent+1,pMemoryProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSemaphore(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSemaphore>&    pSemaphore)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSemaphoreCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkSemaphoreCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSemaphoreCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSemaphore* pSemaphore
    IndentSpaces(out, indent);
    *out += "pSemaphore:                     ";
    *out += "VkSemaphore* = "; // TEQ
    if (pSemaphore.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSemaphore = {true, false, false, nullptr};
        ScalarValueToString(out, pSemaphore.GetPointer(), vinfo_pSemaphore); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdPipelineBarrier(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const StructPointerDecoder<Decoded_VkMemoryBarrier>& pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkBufferMemoryBarrier>& pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkImageMemoryBarrier>& pImageMemoryBarriers)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlags srcStageMask
    IndentSpaces(out, indent);
    *out += "srcStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlags dstStageMask
    IndentSpaces(out, indent);
    *out += "dstStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkDependencyFlags dependencyFlags
    IndentSpaces(out, indent);
    *out += "dependencyFlags:                ";
    *out += "VkDependencyFlags = "; // TEQ
    FlagsToString(out, dependencyFlags, EnumToStringVkDependencyFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: uint32_t memoryBarrierCount
    IndentSpaces(out, indent);
    *out += "memoryBarrierCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, memoryBarrierCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkMemoryBarrier* pMemoryBarriers
    IndentSpaces(out, indent);
    *out += "pMemoryBarriers:                ";
    *out += "const VkMemoryBarrier* = "; // TEQ
    if (pMemoryBarriers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryBarriers.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkMemoryBarrier>(out, indent+1, 1, "VkMemoryBarrier", pMemoryBarriers.GetMetaStructPointer(), "pMemoryBarriers", memoryBarrierCount, false, pMemoryBarriers.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: uint32_t bufferMemoryBarrierCount
    IndentSpaces(out, indent);
    *out += "bufferMemoryBarrierCount:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bufferMemoryBarrierCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBufferMemoryBarrier* pBufferMemoryBarriers
    IndentSpaces(out, indent);
    *out += "pBufferMemoryBarriers:          ";
    *out += "const VkBufferMemoryBarrier* = "; // TEQ
    if (pBufferMemoryBarriers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBufferMemoryBarriers.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBufferMemoryBarrier>(out, indent+1, 1, "VkBufferMemoryBarrier", pBufferMemoryBarriers.GetMetaStructPointer(), "pBufferMemoryBarriers", bufferMemoryBarrierCount, false, pBufferMemoryBarriers.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: uint32_t imageMemoryBarrierCount
    IndentSpaces(out, indent);
    *out += "imageMemoryBarrierCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, imageMemoryBarrierCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkImageMemoryBarrier* pImageMemoryBarriers
    IndentSpaces(out, indent);
    *out += "pImageMemoryBarriers:           ";
    *out += "const VkImageMemoryBarrier* = "; // TEQ
    if (pImageMemoryBarriers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImageMemoryBarriers.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkImageMemoryBarrier>(out, indent+1, 1, "VkImageMemoryBarrier", pImageMemoryBarriers.GetMetaStructPointer(), "pImageMemoryBarriers", imageMemoryBarrierCount, false, pImageMemoryBarriers.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyImageToBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferImageCopy>& pRegions)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage srcImage
    IndentSpaces(out, indent);
    *out += "srcImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, srcImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout srcImageLayout
    IndentSpaces(out, indent);
    *out += "srcImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, srcImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, srcImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkBuffer dstBuffer
    IndentSpaces(out, indent);
    *out += "dstBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, dstBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t regionCount
    IndentSpaces(out, indent);
    *out += "regionCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, regionCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBufferImageCopy* pRegions
    IndentSpaces(out, indent);
    *out += "pRegions:                       ";
    *out += "const VkBufferImageCopy* = "; // TEQ
    if (pRegions.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRegions.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBufferImageCopy>(out, indent+1, 1, "VkBufferImageCopy", pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyFence(
    format::HandleId                            device,
    format::HandleId                            fence,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyFence(device, fence, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, fence); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetFenceStatus(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            fence)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetFenceStatus(device, fence)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, fence); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyCommandPool(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyCommandPool(device, commandPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPool commandPool
    IndentSpaces(out, indent);
    *out += "commandPool:                    ";
    *out += "VkCommandPool = "; // TEQ
    AddrToString(out, commandPool); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            image,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements>& pSparseMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pSparseMemoryRequirementCount
    IndentSpaces(out, indent);
    *out += "pSparseMemoryRequirementCount:  ";
    *out += "uint32_t* = "; // TEQ
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSparseMemoryRequirementCount = {false, false, false, nullptr};
        ScalarValueToString(out, pSparseMemoryRequirementCount.GetPointer(), vinfo_pSparseMemoryRequirementCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSparseImageMemoryRequirements* pSparseMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pSparseMemoryRequirements:      ";
    *out += "VkSparseImageMemoryRequirements* = "; // TEQ
    if (pSparseMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSparseMemoryRequirements.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements>(out, indent+1, 1, "VkSparseImageMemoryRequirements", pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySampler(
    format::HandleId                            device,
    format::HandleId                            sampler,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroySampler(device, sampler, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSampler sampler
    IndentSpaces(out, indent);
    *out += "sampler:                        ";
    *out += "VkSampler = "; // TEQ
    AddrToString(out, sampler); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkMapMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    const PointerDecoder<uint64_t>&             ppData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkMapMemory(device, memory, offset, size, flags, ppData)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, memory); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, size); //EQA
    outString += "\n";   // HHS

    // func arg: VkMemoryMapFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMemoryMapFlags = "; // TEQ
    UnsignedDecimalToString(out, flags); // UYW
    outString += "\n";   // HHS

    // func arg: void** ppData
    IndentSpaces(out, indent);
    *out += "ppData:                         ";
    *out += "void** = "; // TEQ
    if (ppData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_ppData = {true, false, false, nullptr};
        ScalarValueToString(out, ppData.GetPointer(), vinfo_ppData); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateBuffer(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkBuffer>&       pBuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkBufferCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkBufferCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkBufferCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkBuffer* pBuffer
    IndentSpaces(out, indent);
    *out += "pBuffer:                        ";
    *out += "VkBuffer* = "; // TEQ
    if (pBuffer.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pBuffer = {true, false, false, nullptr};
        ScalarValueToString(out, pBuffer.GetPointer(), vinfo_pBuffer); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryAllocateInfo>& pAllocateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDeviceMemory>& pMemory)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkMemoryAllocateInfo* pAllocateInfo
    IndentSpaces(out, indent);
    *out += "pAllocateInfo:                  ";
    *out += "const VkMemoryAllocateInfo* = "; // TEQ
    if (pAllocateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryAllocateInfo>(out, *pAllocateInfo.GetMetaStructPointer(), indent+1,pAllocateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory* pMemory
    IndentSpaces(out, indent);
    *out += "pMemory:                        ";
    *out += "VkDeviceMemory* = "; // TEQ
    if (pMemory.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pMemory = {true, false, false, nullptr};
        ScalarValueToString(out, pMemory.GetPointer(), vinfo_pMemory); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueBindSparse(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindSparseInfo>& pBindInfo,
    format::HandleId                            fence)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t bindInfoCount
    IndentSpaces(out, indent);
    *out += "bindInfoCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBindSparseInfo* pBindInfo
    IndentSpaces(out, indent);
    *out += "pBindInfo:                      ";
    *out += "const VkBindSparseInfo* = "; // TEQ
    if (pBindInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBindInfo.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBindSparseInfo>(out, indent+1, 1, "VkBindSparseInfo", pBindInfo.GetMetaStructPointer(), "pBindInfo", bindInfoCount, false, pBindInfo.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, fence); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetCommandPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolResetFlags                     flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkResetCommandPool(device, commandPool, flags)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPool commandPool
    IndentSpaces(out, indent);
    *out += "commandPool:                    ";
    *out += "VkCommandPool = "; // TEQ
    AddrToString(out, commandPool); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPoolResetFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandPoolResetFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkCommandPoolResetFlagBits); // URW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDepthBias(
    format::HandleId                            commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: float depthBiasConstantFactor
    IndentSpaces(out, indent);
    *out += "depthBiasConstantFactor:        ";
    *out += "float = "; // TEQ
    DoubleToString(out, depthBiasConstantFactor); // PEZ
    outString += "\n";   // HHS

    // func arg: float depthBiasClamp
    IndentSpaces(out, indent);
    *out += "depthBiasClamp:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, depthBiasClamp); // PEZ
    outString += "\n";   // HHS

    // func arg: float depthBiasSlopeFactor
    IndentSpaces(out, indent);
    *out += "depthBiasSlopeFactor:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, depthBiasSlopeFactor); // PEZ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    const StructPointerDecoder<Decoded_VkImageFormatProperties>& pImageFormatProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, format);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageType type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, type);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageTiling tiling
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, tiling); // VSA
    *out += " (";
    UnsignedDecimalToString(out, tiling);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, usage, EnumToStringVkImageUsageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkImageCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageCreateFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkImageCreateFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkImageFormatProperties* pImageFormatProperties
    IndentSpaces(out, indent);
    *out += "pImageFormatProperties:         ";
    *out += "VkImageFormatProperties* = "; // TEQ
    if (pImageFormatProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImageFormatProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageFormatProperties>(out, *pImageFormatProperties.GetMetaStructPointer(), indent+1,pImageFormatProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdPushConstants(
    format::HandleId                            commandBuffer,
    format::HandleId                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const PointerDecoder<uint8_t>&              pValues)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, layout); // PAQ
    outString += "\n";   // HHS

    // func arg: VkShaderStageFlags stageFlags
    IndentSpaces(out, indent);
    *out += "stageFlags:                     ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, stageFlags, EnumToStringVkShaderStageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: uint32_t offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, offset); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, size); // UYW
    outString += "\n";   // HHS

    // func arg: const void* pValues
    IndentSpaces(out, indent);
    *out += "pValues:                        ";
    *out += "const void* = "; // TEQ
    if (pValues.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pValues.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyImage(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyImage(device, image, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkSetEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkSetEvent(device, event)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkEvent event
    IndentSpaces(out, indent);
    *out += "event:                          ";
    *out += "VkEvent = "; // TEQ
    AddrToString(out, event); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipelineCache(
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyPipelineCache(device, pipelineCache, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineCache pipelineCache
    IndentSpaces(out, indent);
    *out += "pipelineCache:                  ";
    *out += "VkPipelineCache = "; // TEQ
    AddrToString(out, pipelineCache); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t drawCount
    IndentSpaces(out, indent);
    *out += "drawCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, drawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginRenderPass(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkRenderPassBeginInfo>& pRenderPassBegin,
    VkSubpassContents                           contents)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkRenderPassBeginInfo* pRenderPassBegin
    IndentSpaces(out, indent);
    *out += "pRenderPassBegin:               ";
    *out += "const VkRenderPassBeginInfo* = "; // TEQ
    if (pRenderPassBegin.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRenderPassBegin.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkRenderPassBeginInfo>(out, *pRenderPassBegin.GetMetaStructPointer(), indent+1,pRenderPassBegin.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSubpassContents contents
    IndentSpaces(out, indent);
    *out += "contents:                       ";
    *out += "VkSubpassContents = "; // TEQ
    EnumToStringVkSubpassContents(out, contents); // VSA
    *out += " (";
    UnsignedDecimalToString(out, contents);
    *out += ")";
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdUpdateBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer dstBuffer
    IndentSpaces(out, indent);
    *out += "dstBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, dstBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize dstOffset
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, dstOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkDeviceSize dataSize
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, dataSize); //EQA
    outString += "\n";   // HHS

    // func arg: const void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "const void* = "; // TEQ
    if (pData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pData.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySemaphore(
    format::HandleId                            device,
    format::HandleId                            semaphore,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroySemaphore(device, semaphore, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, semaphore); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetDescriptorPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkResetDescriptorPool(device, descriptorPool, flags)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDescriptorPool descriptorPool
    IndentSpaces(out, indent);
    *out += "descriptorPool:                 ";
    *out += "VkDescriptorPool = "; // TEQ
    AddrToString(out, descriptorPool); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDescriptorPoolResetFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDescriptorPoolResetFlags = "; // TEQ
    UnsignedDecimalToString(out, flags); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeMemory(
    format::HandleId                            device,
    format::HandleId                            memory,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkFreeMemory(device, memory, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, memory); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeDescriptorSets(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDescriptorPool descriptorPool
    IndentSpaces(out, indent);
    *out += "descriptorPool:                 ";
    *out += "VkDescriptorPool = "; // TEQ
    AddrToString(out, descriptorPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t descriptorSetCount
    IndentSpaces(out, indent);
    *out += "descriptorSetCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, descriptorSetCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkDescriptorSet* pDescriptorSets
    IndentSpaces(out, indent);
    *out += "pDescriptorSets:                ";
    *out += "const VkDescriptorSet* = "; // TEQ
    if (pDescriptorSets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDescriptorSets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSet*>(out, indent, 1, "const VkDescriptorSet*", reinterpret_cast<const VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", descriptorSetCount,  vinfo_pDescriptorSets);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexed(
    format::HandleId                            commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t indexCount
    IndentSpaces(out, indent);
    *out += "indexCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, indexCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t instanceCount
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, instanceCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t firstIndex
    IndentSpaces(out, indent);
    *out += "firstIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstIndex); // UYW
    outString += "\n";   // HHS

    // func arg: int32_t vertexOffset
    IndentSpaces(out, indent);
    *out += "vertexOffset:                   ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, vertexOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t firstInstance
    IndentSpaces(out, indent);
    *out += "firstInstance:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstInstance); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreatePipelineLayout(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipelineLayout>& pPipelineLayout)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPipelineLayoutCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkPipelineLayoutCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPipelineLayoutCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkPipelineLayout* pPipelineLayout
    IndentSpaces(out, indent);
    *out += "pPipelineLayout:                ";
    *out += "VkPipelineLayout* = "; // TEQ
    if (pPipelineLayout.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPipelineLayout = {true, false, false, nullptr};
        ScalarValueToString(out, pPipelineLayout.GetPointer(), vinfo_pPipelineLayout); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkUpdateDescriptorSets(
    format::HandleId                            device,
    uint32_t                                    descriptorWriteCount,
    const StructPointerDecoder<Decoded_VkWriteDescriptorSet>& pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const StructPointerDecoder<Decoded_VkCopyDescriptorSet>& pDescriptorCopies)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t descriptorWriteCount
    IndentSpaces(out, indent);
    *out += "descriptorWriteCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, descriptorWriteCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkWriteDescriptorSet* pDescriptorWrites
    IndentSpaces(out, indent);
    *out += "pDescriptorWrites:              ";
    *out += "const VkWriteDescriptorSet* = "; // TEQ
    if (pDescriptorWrites.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDescriptorWrites.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkWriteDescriptorSet>(out, indent+1, 1, "VkWriteDescriptorSet", pDescriptorWrites.GetMetaStructPointer(), "pDescriptorWrites", descriptorWriteCount, false, pDescriptorWrites.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: uint32_t descriptorCopyCount
    IndentSpaces(out, indent);
    *out += "descriptorCopyCount:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, descriptorCopyCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkCopyDescriptorSet* pDescriptorCopies
    IndentSpaces(out, indent);
    *out += "pDescriptorCopies:              ";
    *out += "const VkCopyDescriptorSet* = "; // TEQ
    if (pDescriptorCopies.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDescriptorCopies.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkCopyDescriptorSet>(out, indent+1, 1, "VkCopyDescriptorSet", pDescriptorCopies.GetMetaStructPointer(), "pDescriptorCopies", descriptorCopyCount, false, pDescriptorCopies.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyBufferView(
    format::HandleId                            device,
    format::HandleId                            bufferView,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyBufferView(device, bufferView, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBufferView bufferView
    IndentSpaces(out, indent);
    *out += "bufferView:                     ";
    *out += "VkBufferView = "; // TEQ
    AddrToString(out, bufferView); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkMemoryRequirements>& pMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageMemoryRequirements(device, image, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: VkMemoryRequirements* pMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pMemoryRequirements:            ";
    *out += "VkMemoryRequirements* = "; // TEQ
    if (pMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRequirements.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryRequirements>(out, *pMemoryRequirements.GetMetaStructPointer(), indent+1,pMemoryRequirements.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetScissor(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pScissors)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstScissor
    IndentSpaces(out, indent);
    *out += "firstScissor:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstScissor); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t scissorCount
    IndentSpaces(out, indent);
    *out += "scissorCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, scissorCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkRect2D* pScissors
    IndentSpaces(out, indent);
    *out += "pScissors:                      ";
    *out += "const VkRect2D* = "; // TEQ
    if (pScissors.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pScissors.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pScissors.GetMetaStructPointer(), "pScissors", scissorCount, false, pScissors.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResetEvent(
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdResetEvent(commandBuffer, event, stageMask)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkEvent event
    IndentSpaces(out, indent);
    *out += "event:                          ";
    *out += "VkEvent = "; // TEQ
    AddrToString(out, event); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlags stageMask
    IndentSpaces(out, indent);
    *out += "stageMask:                      ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, stageMask, EnumToStringVkPipelineStageFlagBits); // URW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilCompareMask(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkStencilFaceFlags faceMask
    IndentSpaces(out, indent);
    *out += "faceMask:                       ";
    *out += "VkStencilFaceFlags = "; // TEQ
    FlagsToString(out, faceMask, EnumToStringVkStencilFaceFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: uint32_t compareMask
    IndentSpaces(out, indent);
    *out += "compareMask:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, compareMask); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBlitImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageBlit>& pRegions,
    VkFilter                                    filter)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage srcImage
    IndentSpaces(out, indent);
    *out += "srcImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, srcImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout srcImageLayout
    IndentSpaces(out, indent);
    *out += "srcImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, srcImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, srcImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImage dstImage
    IndentSpaces(out, indent);
    *out += "dstImage:                       ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, dstImage); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout dstImageLayout
    IndentSpaces(out, indent);
    *out += "dstImageLayout:                 ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, dstImageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, dstImageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint32_t regionCount
    IndentSpaces(out, indent);
    *out += "regionCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, regionCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkImageBlit* pRegions
    IndentSpaces(out, indent);
    *out += "pRegions:                       ";
    *out += "const VkImageBlit* = "; // TEQ
    if (pRegions.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRegions.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkImageBlit>(out, indent+1, 1, "VkImageBlit", pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: VkFilter filter
    IndentSpaces(out, indent);
    *out += "filter:                         ";
    *out += "VkFilter = "; // TEQ
    EnumToStringVkFilter(out, filter); // VSA
    *out += " (";
    UnsignedDecimalToString(out, filter);
    *out += ")";
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndQuery(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdEndQuery(commandBuffer, queryPool, query)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t query
    IndentSpaces(out, indent);
    *out += "query:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, query); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineCacheData(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    const PointerDecoder<size_t>&               pDataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineCache pipelineCache
    IndentSpaces(out, indent);
    *out += "pipelineCache:                  ";
    *out += "VkPipelineCache = "; // TEQ
    AddrToString(out, pipelineCache); // PAQ
    outString += "\n";   // HHS

    // func arg: size_t* pDataSize
    IndentSpaces(out, indent);
    *out += "pDataSize:                      ";
    *out += "size_t* = "; // TEQ
    if (pDataSize.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDataSize = {false, false, false, nullptr};
        ScalarValueToString(out, pDataSize.GetPointer(), vinfo_pDataSize); // PWS
    }
    outString += "\n";   // HHS

    // func arg: void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "void* = "; // TEQ
    if (pData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pData.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateRenderPass(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkRenderPassCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkRenderPass>&   pRenderPass)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkRenderPassCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkRenderPassCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkRenderPassCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkRenderPass* pRenderPass
    IndentSpaces(out, indent);
    *out += "pRenderPass:                    ";
    *out += "VkRenderPass* = "; // TEQ
    if (pRenderPass.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pRenderPass = {true, false, false, nullptr};
        ScalarValueToString(out, pRenderPass.GetPointer(), vinfo_pRenderPass); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDevices(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceCount,
    const HandlePointerDecoder<VkPhysicalDevice>& pPhysicalDevices)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPhysicalDeviceCount
    IndentSpaces(out, indent);
    *out += "pPhysicalDeviceCount:           ";
    *out += "uint32_t* = "; // TEQ
    if (pPhysicalDeviceCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPhysicalDeviceCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPhysicalDeviceCount.GetPointer(), vinfo_pPhysicalDeviceCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPhysicalDevice* pPhysicalDevices
    IndentSpaces(out, indent);
    *out += "pPhysicalDevices:               ";
    *out += "VkPhysicalDevice* = "; // TEQ
    if (pPhysicalDevices.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPhysicalDevices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPhysicalDevices = {true, false, false, nullptr};
        ArrayToString<VkPhysicalDevice*>(out, indent, 1, "VkPhysicalDevice*", reinterpret_cast<VkPhysicalDevice*>(pPhysicalDevices.GetPointer()), "pPhysicalDevices", *pPhysicalDeviceCount.GetPointer(),  vinfo_pPhysicalDevices);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties>& pQueueFamilyProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pQueueFamilyPropertyCount
    IndentSpaces(out, indent);
    *out += "pQueueFamilyPropertyCount:      ";
    *out += "uint32_t* = "; // TEQ
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pQueueFamilyPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pQueueFamilyPropertyCount.GetPointer(), vinfo_pQueueFamilyPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkQueueFamilyProperties* pQueueFamilyProperties
    IndentSpaces(out, indent);
    *out += "pQueueFamilyProperties:         ";
    *out += "VkQueueFamilyProperties* = "; // TEQ
    if (pQueueFamilyProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pQueueFamilyProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkQueueFamilyProperties>(out, indent+1, 1, "VkQueueFamilyProperties", pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilReference(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetStencilReference(commandBuffer, faceMask, reference)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkStencilFaceFlags faceMask
    IndentSpaces(out, indent);
    *out += "faceMask:                       ";
    *out += "VkStencilFaceFlags = "; // TEQ
    FlagsToString(out, faceMask, EnumToStringVkStencilFaceFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: uint32_t reference
    IndentSpaces(out, indent);
    *out += "reference:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, reference); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindDescriptorSets(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const PointerDecoder<uint32_t>&             pDynamicOffsets)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pipelineBindPoint); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pipelineBindPoint);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkPipelineLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, layout); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstSet
    IndentSpaces(out, indent);
    *out += "firstSet:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstSet); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t descriptorSetCount
    IndentSpaces(out, indent);
    *out += "descriptorSetCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, descriptorSetCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkDescriptorSet* pDescriptorSets
    IndentSpaces(out, indent);
    *out += "pDescriptorSets:                ";
    *out += "const VkDescriptorSet* = "; // TEQ
    if (pDescriptorSets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDescriptorSets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSet*>(out, indent, 1, "const VkDescriptorSet*", reinterpret_cast<const VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", descriptorSetCount,  vinfo_pDescriptorSets);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: uint32_t dynamicOffsetCount
    IndentSpaces(out, indent);
    *out += "dynamicOffsetCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, dynamicOffsetCount); // UYW
    outString += "\n";   // HHS

    // func arg: const uint32_t* pDynamicOffsets
    IndentSpaces(out, indent);
    *out += "pDynamicOffsets:                ";
    *out += "const uint32_t* = "; // TEQ
    if (pDynamicOffsets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDynamicOffsets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDynamicOffsets = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pDynamicOffsets.GetPointer()), "pDynamicOffsets", dynamicOffsetCount,  vinfo_pDynamicOffsets);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindPipeline(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            pipeline)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pipelineBindPoint); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pipelineBindPoint);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pipeline); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearColorImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    const StructPointerDecoder<Decoded_VkClearColorValue>& pColor,
    uint32_t                                    rangeCount,
    const StructPointerDecoder<Decoded_VkImageSubresourceRange>& pRanges)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout imageLayout
    IndentSpaces(out, indent);
    *out += "imageLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, imageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, imageLayout);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: const VkClearColorValue* pColor
    IndentSpaces(out, indent);
    *out += "pColor:                         ";
    *out += "const VkClearColorValue* = "; // TEQ
    if (pColor.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pColor.GetAddress()); // JHI
        *out += " (Union)";
        *out += ":";
        StructureToString<Decoded_VkClearColorValue>(out, *pColor.GetMetaStructPointer(), indent+1,pColor.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t rangeCount
    IndentSpaces(out, indent);
    *out += "rangeCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, rangeCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkImageSubresourceRange* pRanges
    IndentSpaces(out, indent);
    *out += "pRanges:                        ";
    *out += "const VkImageSubresourceRange* = "; // TEQ
    if (pRanges.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRanges.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkImageSubresourceRange>(out, indent+1, 1, "VkImageSubresourceRange", pRanges.GetMetaStructPointer(), "pRanges", rangeCount, false, pRanges.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateInstance(
    VkResult                                    returnValue,
    const StructPointerDecoder<Decoded_VkInstanceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkInstance>&     pInstance)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateInstance(pCreateInfo, pAllocator, pInstance)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: const VkInstanceCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkInstanceCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkInstanceCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkInstance* pInstance
    IndentSpaces(out, indent);
    *out += "pInstance:                      ";
    *out += "VkInstance* = "; // TEQ
    if (pInstance.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pInstance = {true, false, false, nullptr};
        ScalarValueToString(out, pInstance.GetPointer(), vinfo_pInstance); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdFillBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer dstBuffer
    IndentSpaces(out, indent);
    *out += "dstBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, dstBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize dstOffset
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, dstOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkDeviceSize size
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, size); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t data
    IndentSpaces(out, indent);
    *out += "data:                           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, data); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures>& pFeatures)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceFeatures* pFeatures
    IndentSpaces(out, indent);
    *out += "pFeatures:                      ";
    *out += "VkPhysicalDeviceFeatures* = "; // TEQ
    if (pFeatures.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFeatures.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceFeatures>(out, *pFeatures.GetMetaStructPointer(), indent+1,pFeatures.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetLineWidth(
    format::HandleId                            commandBuffer,
    float                                       lineWidth)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetLineWidth(commandBuffer, lineWidth)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: float lineWidth
    IndentSpaces(out, indent);
    *out += "lineWidth:                      ";
    *out += "float = "; // TEQ
    DoubleToString(out, lineWidth); // PEZ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDescriptorUpdateTemplateEntry>(std::string* out, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassMultiviewCreateInfo>(std::string* out, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(std::string* out, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerYcbcrConversionImageFormatProperties>(std::string* out, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImageMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMaintenance3Properties>(std::string* out, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalImageFormatProperties>(std::string* out, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerYcbcrConversionInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalFenceProperties>(std::string* out, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceVariablePointersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSubgroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageFormatProperties2>(std::string* out, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetLayoutSupport>(std::string* out, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportFenceCreateInfo>(std::string* out, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupSubmitInfo>(std::string* out, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMultiviewFeatures>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceIDProperties>(std::string* out, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueueFamilyProperties2>(std::string* out, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalMemoryImageCreateInfo>(std::string* out, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupCommandBufferBeginInfo>(std::string* out, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryRequirements2>(std::string* out, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindBufferMemoryInfo>(std::string* out, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportSemaphoreCreateInfo>(std::string* out, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalMemoryProperties>(std::string* out, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupBindSparseInfo>(std::string* out, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkProtectedSubmitInfo>(std::string* out, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImagePlaneMemoryRequirementsInfo>(std::string* out, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(std::string* out, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(std::string* out, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryDedicatedRequirements>(std::string* out, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryAllocateFlagsInfo>(std::string* out, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportMemoryAllocateInfo>(std::string* out, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFormatProperties2>(std::string* out, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkInputAttachmentAspectReference>(std::string* out, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImageMemoryInfo>(std::string* out, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceGroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImagePlaneMemoryInfo>(std::string* out, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceFeatures2>(std::string* out, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDevicePointClippingProperties>(std::string* out, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMultiviewProperties>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalImageFormatInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalMemoryBufferCreateInfo>(std::string* out, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupRenderPassBeginInfo>(std::string* out, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageFormatProperties2>(std::string* out, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceQueueInfo2>(std::string* out, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryDedicatedAllocateInfo>(std::string* out, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalSemaphoreProperties>(std::string* out, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryRequirements2>(std::string* out, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalBufferProperties>(std::string* out, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>(std::string* out, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageViewUsageCreateInfo>(std::string* out, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProperties2>(std::string* out, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDevice16BitStorageFeatures>(std::string* out, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindBufferMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDescriptorUpdateTemplateEntry>(std::string* out, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorUpdateTemplateEntry *pstruct = (const VkDescriptorUpdateTemplateEntry *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t dstBinding
    IndentSpaces(out, indent);
    *out += "dstBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstBinding); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dstArrayElement
    IndentSpaces(out, indent);
    *out += "dstArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstArrayElement); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t descriptorCount
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: size_t offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset); // UYW
    *out += "\n"; // GDS

    // struct member: size_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stride); // UYW
}

template <>
void StructureToString<Decoded_VkRenderPassMultiviewCreateInfo>(std::string* out, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassMultiviewCreateInfo *pstruct = (const VkRenderPassMultiviewCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t subpassCount
    IndentSpaces(out, indent);
    *out += "subpassCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pViewMasks
    IndentSpaces(out, indent);
    *out += "pViewMasks:                     ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pViewMasks == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pViewMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pViewMasks.GetPointer()), "pViewMasks", pstruct->subpassCount,  vinfo_pViewMasks);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t dependencyCount
    IndentSpaces(out, indent);
    *out += "dependencyCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dependencyCount); // UYW
    *out += "\n"; // GDS

    // struct member: const int32_t* pViewOffsets
    IndentSpaces(out, indent);
    *out += "pViewOffsets:                   ";
    *out += "const int32_t* = "; // TEQ
    if (pstruct->pViewOffsets == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewOffsets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pViewOffsets = {false, false, false, nullptr};
        ArrayToString<const int32_t*>(out, indent, 1, "const int32_t*", reinterpret_cast<const int32_t*>(pstruct_in.pViewOffsets.GetPointer()), "pViewOffsets", pstruct->dependencyCount,  vinfo_pViewOffsets);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t correlationMaskCount
    IndentSpaces(out, indent);
    *out += "correlationMaskCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->correlationMaskCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pCorrelationMasks
    IndentSpaces(out, indent);
    *out += "pCorrelationMasks:              ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCorrelationMasks == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCorrelationMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCorrelationMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCorrelationMasks.GetPointer()), "pCorrelationMasks", pstruct->correlationMaskCount,  vinfo_pCorrelationMasks);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceImageFormatInfo2 *pstruct = (const VkPhysicalDeviceImageFormatInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageType type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageTiling tiling
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, pstruct->tiling); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tiling);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkImageCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkImageCreateFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(std::string* out, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferMemoryRequirementsInfo2 *pstruct = (const VkBufferMemoryRequirementsInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkSamplerYcbcrConversionImageFormatProperties>(std::string* out, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerYcbcrConversionImageFormatProperties *pstruct = (const VkSamplerYcbcrConversionImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t combinedImageSamplerDescriptorCount
    IndentSpaces(out, indent);
    *out += "combinedImageSamplerDescriptorCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->combinedImageSamplerDescriptorCount); // UYW
}

template <>
void StructureToString<Decoded_VkBindImageMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImageMemoryDeviceGroupInfo *pstruct = (const VkBindImageMemoryDeviceGroupInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t deviceIndexCount
    IndentSpaces(out, indent);
    *out += "deviceIndexCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceIndexCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pDeviceIndices
    IndentSpaces(out, indent);
    *out += "pDeviceIndices:                 ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t splitInstanceBindRegionCount
    IndentSpaces(out, indent);
    *out += "splitInstanceBindRegionCount:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->splitInstanceBindRegionCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkRect2D* pSplitInstanceBindRegions
    IndentSpaces(out, indent);
    *out += "pSplitInstanceBindRegions:      ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pSplitInstanceBindRegions == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSplitInstanceBindRegions->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pSplitInstanceBindRegions->GetMetaStructPointer(), "pSplitInstanceBindRegions", pstruct->splitInstanceBindRegionCount, false, pstruct_in.pSplitInstanceBindRegions->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMaintenance3Properties>(std::string* out, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMaintenance3Properties *pstruct = (const VkPhysicalDeviceMaintenance3Properties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxPerSetDescriptors
    IndentSpaces(out, indent);
    *out += "maxPerSetDescriptors:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerSetDescriptors); // UYW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize maxMemoryAllocationSize
    IndentSpaces(out, indent);
    *out += "maxMemoryAllocationSize:        ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->maxMemoryAllocationSize); //EQA
}

template <>
void StructureToString<Decoded_VkExternalImageFormatProperties>(std::string* out, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalImageFormatProperties *pstruct = (const VkExternalImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryProperties externalMemoryProperties
    IndentSpaces(out, indent);
    *out += "externalMemoryProperties:       ";
    *out += "VkExternalMemoryProperties = "; // TEQ
    StructureToString<Decoded_VkExternalMemoryProperties>(out, *pstruct_in.externalMemoryProperties, indent+1,  base_addr + offsetof(VkExternalImageFormatProperties, externalMemoryProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkSamplerYcbcrConversionInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerYcbcrConversionInfo *pstruct = (const VkSamplerYcbcrConversionInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSamplerYcbcrConversion conversion
    IndentSpaces(out, indent);
    *out += "conversion:                     ";
    *out += "VkSamplerYcbcrConversion = "; // TEQ
    AddrToString(out, pstruct_in.conversion); // PAQ
}

template <>
void StructureToString<Decoded_VkExternalFenceProperties>(std::string* out, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalFenceProperties *pstruct = (const VkExternalFenceProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalFenceHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlags compatibleHandleTypes
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalFenceHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalFenceFeatureFlags externalFenceFeatures
    IndentSpaces(out, indent);
    *out += "externalFenceFeatures:          ";
    *out += "VkExternalFenceFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->externalFenceFeatures, EnumToStringVkExternalFenceFeatureFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceVariablePointersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceVariablePointersFeatures *pstruct = (const VkPhysicalDeviceVariablePointersFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 variablePointersStorageBuffer
    IndentSpaces(out, indent);
    *out += "variablePointersStorageBuffer:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variablePointersStorageBuffer); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 variablePointers
    IndentSpaces(out, indent);
    *out += "variablePointers:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variablePointers); //EQA
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProtectedMemoryProperties *pstruct = (const VkPhysicalDeviceProtectedMemoryProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 protectedNoFault
    IndentSpaces(out, indent);
    *out += "protectedNoFault:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->protectedNoFault); //EQA
}

template <>
void StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageMemoryRequirementsInfo2 *pstruct = (const VkImageMemoryRequirementsInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSubgroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSubgroupProperties *pstruct = (const VkPhysicalDeviceSubgroupProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t subgroupSize
    IndentSpaces(out, indent);
    *out += "subgroupSize:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subgroupSize); // UYW
    *out += "\n"; // GDS

    // struct member: VkShaderStageFlags supportedStages
    IndentSpaces(out, indent);
    *out += "supportedStages:                ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedStages, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSubgroupFeatureFlags supportedOperations
    IndentSpaces(out, indent);
    *out += "supportedOperations:            ";
    *out += "VkSubgroupFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedOperations, EnumToStringVkSubgroupFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkBool32 quadOperationsInAllStages
    IndentSpaces(out, indent);
    *out += "quadOperationsInAllStages:      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->quadOperationsInAllStages); //EQA
}

template <>
void StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSparseMemoryRequirementsInfo2 *pstruct = (const VkImageSparseMemoryRequirementsInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
}

template <>
void StructureToString<Decoded_VkSparseImageFormatProperties2>(std::string* out, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageFormatProperties2 *pstruct = (const VkSparseImageFormatProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSparseImageFormatProperties properties
    IndentSpaces(out, indent);
    *out += "properties:                     ";
    *out += "VkSparseImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkSparseImageFormatProperties>(out, *pstruct_in.properties, indent+1,  base_addr + offsetof(VkSparseImageFormatProperties2, properties)); // AZJ
}

template <>
void StructureToString<Decoded_VkDescriptorSetLayoutSupport>(std::string* out, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetLayoutSupport *pstruct = (const VkDescriptorSetLayoutSupport *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 supported
    IndentSpaces(out, indent);
    *out += "supported:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->supported); //EQA
}

template <>
void StructureToString<Decoded_VkExportFenceCreateInfo>(std::string* out, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportFenceCreateInfo *pstruct = (const VkExportFenceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlags handleTypes
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalFenceHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkDeviceGroupSubmitInfo>(std::string* out, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupSubmitInfo *pstruct = (const VkDeviceGroupSubmitInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pWaitSemaphoreDeviceIndices
    IndentSpaces(out, indent);
    *out += "pWaitSemaphoreDeviceIndices:    ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pWaitSemaphoreDeviceIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphoreDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphoreDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pWaitSemaphoreDeviceIndices.GetPointer()), "pWaitSemaphoreDeviceIndices", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphoreDeviceIndices);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t commandBufferCount
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->commandBufferCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pCommandBufferDeviceMasks
    IndentSpaces(out, indent);
    *out += "pCommandBufferDeviceMasks:      ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCommandBufferDeviceMasks == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCommandBufferDeviceMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCommandBufferDeviceMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCommandBufferDeviceMasks.GetPointer()), "pCommandBufferDeviceMasks", pstruct->commandBufferCount,  vinfo_pCommandBufferDeviceMasks);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t signalSemaphoreCount
    IndentSpaces(out, indent);
    *out += "signalSemaphoreCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pSignalSemaphoreDeviceIndices
    IndentSpaces(out, indent);
    *out += "pSignalSemaphoreDeviceIndices:  ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pSignalSemaphoreDeviceIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphoreDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphoreDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pSignalSemaphoreDeviceIndices.GetPointer()), "pSignalSemaphoreDeviceIndices", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphoreDeviceIndices);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMultiviewFeatures>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMultiviewFeatures *pstruct = (const VkPhysicalDeviceMultiviewFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 multiview
    IndentSpaces(out, indent);
    *out += "multiview:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiview); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 multiviewGeometryShader
    IndentSpaces(out, indent);
    *out += "multiviewGeometryShader:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiviewGeometryShader); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 multiviewTessellationShader
    IndentSpaces(out, indent);
    *out += "multiviewTessellationShader:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiviewTessellationShader); //EQA
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalSemaphoreInfo *pstruct = (const VkPhysicalDeviceExternalSemaphoreInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceIDProperties>(std::string* out, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceIDProperties *pstruct = (const VkPhysicalDeviceIDProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint8_t deviceUUID
    IndentSpaces(out, indent);
    *out += "deviceUUID:                     ";
    *out += "uint8_t[";
    *out += "VK_UUID_SIZE"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceIDProperties, deviceUUID)); // IYY
    ScalarValueToStringStruct vinfo_deviceUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->deviceUUID), "deviceUUID", VK_UUID_SIZE, vinfo_deviceUUID); // JPA
    *out += "\n"; // GDS

    // struct member: uint8_t driverUUID
    IndentSpaces(out, indent);
    *out += "driverUUID:                     ";
    *out += "uint8_t[";
    *out += "VK_UUID_SIZE"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceIDProperties, driverUUID)); // IYY
    ScalarValueToStringStruct vinfo_driverUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->driverUUID), "driverUUID", VK_UUID_SIZE, vinfo_driverUUID); // JPA
    *out += "\n"; // GDS

    // struct member: uint8_t deviceLUID
    IndentSpaces(out, indent);
    *out += "deviceLUID:                     ";
    *out += "uint8_t[";
    *out += "VK_LUID_SIZE"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceIDProperties, deviceLUID)); // IYY
    ScalarValueToStringStruct vinfo_deviceLUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->deviceLUID), "deviceLUID", VK_LUID_SIZE, vinfo_deviceLUID); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t deviceNodeMask
    IndentSpaces(out, indent);
    *out += "deviceNodeMask:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceNodeMask); // UYW
    *out += "\n"; // GDS

    // struct member: VkBool32 deviceLUIDValid
    IndentSpaces(out, indent);
    *out += "deviceLUIDValid:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->deviceLUIDValid); //EQA
}

template <>
void StructureToString<Decoded_VkQueueFamilyProperties2>(std::string* out, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueueFamilyProperties2 *pstruct = (const VkQueueFamilyProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkQueueFamilyProperties queueFamilyProperties
    IndentSpaces(out, indent);
    *out += "queueFamilyProperties:          ";
    *out += "VkQueueFamilyProperties = "; // TEQ
    StructureToString<Decoded_VkQueueFamilyProperties>(out, *pstruct_in.queueFamilyProperties, indent+1,  base_addr + offsetof(VkQueueFamilyProperties2, queueFamilyProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalBufferInfo *pstruct = (const VkPhysicalDeviceExternalBufferInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBufferCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBufferCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkBufferCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkBufferUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkBufferUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkBufferUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExternalMemoryImageCreateInfo>(std::string* out, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalMemoryImageCreateInfo *pstruct = (const VkExternalMemoryImageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkDeviceGroupCommandBufferBeginInfo>(std::string* out, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupCommandBufferBeginInfo *pstruct = (const VkDeviceGroupCommandBufferBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMemoryProperties2 *pstruct = (const VkPhysicalDeviceMemoryProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPhysicalDeviceMemoryProperties memoryProperties
    IndentSpaces(out, indent);
    *out += "memoryProperties:               ";
    *out += "VkPhysicalDeviceMemoryProperties = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(out, *pstruct_in.memoryProperties, indent+1,  base_addr + offsetof(VkPhysicalDeviceMemoryProperties2, memoryProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryRequirements2>(std::string* out, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryRequirements2 *pstruct = (const VkSparseImageMemoryRequirements2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSparseImageMemoryRequirements memoryRequirements
    IndentSpaces(out, indent);
    *out += "memoryRequirements:             ";
    *out += "VkSparseImageMemoryRequirements = "; // TEQ
    StructureToString<Decoded_VkSparseImageMemoryRequirements>(out, *pstruct_in.memoryRequirements, indent+1,  base_addr + offsetof(VkSparseImageMemoryRequirements2, memoryRequirements)); // AZJ
}

template <>
void StructureToString<Decoded_VkBindBufferMemoryInfo>(std::string* out, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindBufferMemoryInfo *pstruct = (const VkBindBufferMemoryInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset); //EQA
}

template <>
void StructureToString<Decoded_VkExportSemaphoreCreateInfo>(std::string* out, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportSemaphoreCreateInfo *pstruct = (const VkExportSemaphoreCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlags handleTypes
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkExternalMemoryProperties>(std::string* out, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalMemoryProperties *pstruct = (const VkExternalMemoryProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkExternalMemoryFeatureFlags externalMemoryFeatures
    IndentSpaces(out, indent);
    *out += "externalMemoryFeatures:         ";
    *out += "VkExternalMemoryFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->externalMemoryFeatures, EnumToStringVkExternalMemoryFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlags compatibleHandleTypes
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkDeviceGroupBindSparseInfo>(std::string* out, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupBindSparseInfo *pstruct = (const VkDeviceGroupBindSparseInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t resourceDeviceIndex
    IndentSpaces(out, indent);
    *out += "resourceDeviceIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->resourceDeviceIndex); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t memoryDeviceIndex
    IndentSpaces(out, indent);
    *out += "memoryDeviceIndex:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryDeviceIndex); // UYW
}

template <>
void StructureToString<Decoded_VkProtectedSubmitInfo>(std::string* out, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkProtectedSubmitInfo *pstruct = (const VkProtectedSubmitInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 protectedSubmit
    IndentSpaces(out, indent);
    *out += "protectedSubmit:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->protectedSubmit); //EQA
}

template <>
void StructureToString<Decoded_VkImagePlaneMemoryRequirementsInfo>(std::string* out, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImagePlaneMemoryRequirementsInfo *pstruct = (const VkImagePlaneMemoryRequirementsInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageAspectFlagBits planeAspect
    IndentSpaces(out, indent);
    *out += "planeAspect:                    ";
    *out += "VkImageAspectFlagBits = "; // TEQ
    EnumToStringVkImageAspectFlagBits(out, pstruct->planeAspect); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->planeAspect);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(std::string* out, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures *pstruct = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 samplerYcbcrConversion
    IndentSpaces(out, indent);
    *out += "samplerYcbcrConversion:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->samplerYcbcrConversion); //EQA
}

template <>
void StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerYcbcrConversionCreateInfo *pstruct = (const VkSamplerYcbcrConversionCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSamplerYcbcrModelConversion ycbcrModel
    IndentSpaces(out, indent);
    *out += "ycbcrModel:                     ";
    *out += "VkSamplerYcbcrModelConversion = "; // TEQ
    EnumToStringVkSamplerYcbcrModelConversion(out, pstruct->ycbcrModel); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->ycbcrModel);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSamplerYcbcrRange ycbcrRange
    IndentSpaces(out, indent);
    *out += "ycbcrRange:                     ";
    *out += "VkSamplerYcbcrRange = "; // TEQ
    EnumToStringVkSamplerYcbcrRange(out, pstruct->ycbcrRange); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->ycbcrRange);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentMapping components
    IndentSpaces(out, indent);
    *out += "components:                     ";
    *out += "VkComponentMapping = "; // TEQ
    StructureToString<Decoded_VkComponentMapping>(out, *pstruct_in.components, indent+1,  base_addr + offsetof(VkSamplerYcbcrConversionCreateInfo, components)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkChromaLocation xChromaOffset
    IndentSpaces(out, indent);
    *out += "xChromaOffset:                  ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->xChromaOffset); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->xChromaOffset);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkChromaLocation yChromaOffset
    IndentSpaces(out, indent);
    *out += "yChromaOffset:                  ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->yChromaOffset); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->yChromaOffset);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkFilter chromaFilter
    IndentSpaces(out, indent);
    *out += "chromaFilter:                   ";
    *out += "VkFilter = "; // TEQ
    EnumToStringVkFilter(out, pstruct->chromaFilter); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->chromaFilter);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 forceExplicitReconstruction
    IndentSpaces(out, indent);
    *out += "forceExplicitReconstruction:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->forceExplicitReconstruction); //EQA
}

template <>
void StructureToString<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineTessellationDomainOriginStateCreateInfo *pstruct = (const VkPipelineTessellationDomainOriginStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkTessellationDomainOrigin domainOrigin
    IndentSpaces(out, indent);
    *out += "domainOrigin:                   ";
    *out += "VkTessellationDomainOrigin = "; // TEQ
    EnumToStringVkTessellationDomainOrigin(out, pstruct->domainOrigin); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->domainOrigin);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(std::string* out, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorUpdateTemplateCreateInfo *pstruct = (const VkDescriptorUpdateTemplateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDescriptorUpdateTemplateCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDescriptorUpdateTemplateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t descriptorUpdateEntryCount
    IndentSpaces(out, indent);
    *out += "descriptorUpdateEntryCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorUpdateEntryCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries
    IndentSpaces(out, indent);
    *out += "pDescriptorUpdateEntries:       ";
    *out += "const VkDescriptorUpdateTemplateEntry* = "; // TEQ
    if (pstruct->pDescriptorUpdateEntries == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDescriptorUpdateEntries->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDescriptorUpdateTemplateEntry>(out, indent+1, 1, "VkDescriptorUpdateTemplateEntry", pstruct_in.pDescriptorUpdateEntries->GetMetaStructPointer(), "pDescriptorUpdateEntries", pstruct->descriptorUpdateEntryCount, false, pstruct_in.pDescriptorUpdateEntries->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: VkDescriptorUpdateTemplateType templateType
    IndentSpaces(out, indent);
    *out += "templateType:                   ";
    *out += "VkDescriptorUpdateTemplateType = "; // TEQ
    EnumToStringVkDescriptorUpdateTemplateType(out, pstruct->templateType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->templateType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkDescriptorSetLayout descriptorSetLayout
    IndentSpaces(out, indent);
    *out += "descriptorSetLayout:            ";
    *out += "VkDescriptorSetLayout = "; // TEQ
    AddrToString(out, pstruct_in.descriptorSetLayout); // PAQ
    *out += "\n"; // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkPipelineLayout pipelineLayout
    IndentSpaces(out, indent);
    *out += "pipelineLayout:                 ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.pipelineLayout); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t set
    IndentSpaces(out, indent);
    *out += "set:                            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->set); // UYW
}

template <>
void StructureToString<Decoded_VkMemoryDedicatedRequirements>(std::string* out, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryDedicatedRequirements *pstruct = (const VkMemoryDedicatedRequirements *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 prefersDedicatedAllocation
    IndentSpaces(out, indent);
    *out += "prefersDedicatedAllocation:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->prefersDedicatedAllocation); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 requiresDedicatedAllocation
    IndentSpaces(out, indent);
    *out += "requiresDedicatedAllocation:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->requiresDedicatedAllocation); //EQA
}

template <>
void StructureToString<Decoded_VkMemoryAllocateFlagsInfo>(std::string* out, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryAllocateFlagsInfo *pstruct = (const VkMemoryAllocateFlagsInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkMemoryAllocateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMemoryAllocateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkMemoryAllocateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask); // UYW
}

template <>
void StructureToString<Decoded_VkExportMemoryAllocateInfo>(std::string* out, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportMemoryAllocateInfo *pstruct = (const VkExportMemoryAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkFormatProperties2>(std::string* out, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFormatProperties2 *pstruct = (const VkFormatProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFormatProperties formatProperties
    IndentSpaces(out, indent);
    *out += "formatProperties:               ";
    *out += "VkFormatProperties = "; // TEQ
    StructureToString<Decoded_VkFormatProperties>(out, *pstruct_in.formatProperties, indent+1,  base_addr + offsetof(VkFormatProperties2, formatProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkInputAttachmentAspectReference>(std::string* out, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkInputAttachmentAspectReference *pstruct = (const VkInputAttachmentAspectReference *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t subpass
    IndentSpaces(out, indent);
    *out += "subpass:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpass); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t inputAttachmentIndex
    IndentSpaces(out, indent);
    *out += "inputAttachmentIndex:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->inputAttachmentIndex); // UYW
    *out += "\n"; // GDS

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkBindImageMemoryInfo>(std::string* out, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImageMemoryInfo *pstruct = (const VkBindImageMemoryInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset); //EQA
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceGroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceGroupProperties *pstruct = (const VkPhysicalDeviceGroupProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t physicalDeviceCount
    IndentSpaces(out, indent);
    *out += "physicalDeviceCount:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->physicalDeviceCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkPhysicalDevice physicalDevices
    IndentSpaces(out, indent);
    *out += "physicalDevices:                ";
    *out += "VkPhysicalDevice[";
    UnsignedDecimalToString(out, pstruct->physicalDeviceCount); // DFW
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceGroupProperties, physicalDevices)); // IYY
    ScalarValueToStringStruct vinfo_physicalDevices = {true, false, false, nullptr};
    ArrayToString<VkPhysicalDevice*>(out, indent, 0, "VkPhysicalDevice", const_cast<VkPhysicalDevice*>(pstruct->physicalDevices), "physicalDevices", pstruct->physicalDeviceCount, vinfo_physicalDevices); // JPA
    *out += "\n"; // GDS

    // struct member: VkBool32 subsetAllocation
    IndentSpaces(out, indent);
    *out += "subsetAllocation:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->subsetAllocation); //EQA
}

template <>
void StructureToString<Decoded_VkBindImagePlaneMemoryInfo>(std::string* out, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImagePlaneMemoryInfo *pstruct = (const VkBindImagePlaneMemoryInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageAspectFlagBits planeAspect
    IndentSpaces(out, indent);
    *out += "planeAspect:                    ";
    *out += "VkImageAspectFlagBits = "; // TEQ
    EnumToStringVkImageAspectFlagBits(out, pstruct->planeAspect); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->planeAspect);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalFenceInfo *pstruct = (const VkPhysicalDeviceExternalFenceInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceFeatures2>(std::string* out, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceFeatures2 *pstruct = (const VkPhysicalDeviceFeatures2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPhysicalDeviceFeatures features
    IndentSpaces(out, indent);
    *out += "features:                       ";
    *out += "VkPhysicalDeviceFeatures = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceFeatures>(out, *pstruct_in.features, indent+1,  base_addr + offsetof(VkPhysicalDeviceFeatures2, features)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSparseImageFormatInfo2 *pstruct = (const VkPhysicalDeviceSparseImageFormatInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageType type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkImageTiling tiling
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, pstruct->tiling); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tiling);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDevicePointClippingProperties>(std::string* out, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevicePointClippingProperties *pstruct = (const VkPhysicalDevicePointClippingProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPointClippingBehavior pointClippingBehavior
    IndentSpaces(out, indent);
    *out += "pointClippingBehavior:          ";
    *out += "VkPointClippingBehavior = "; // TEQ
    EnumToStringVkPointClippingBehavior(out, pstruct->pointClippingBehavior); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pointClippingBehavior);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMultiviewProperties>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMultiviewProperties *pstruct = (const VkPhysicalDeviceMultiviewProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxMultiviewViewCount
    IndentSpaces(out, indent);
    *out += "maxMultiviewViewCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMultiviewViewCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxMultiviewInstanceIndex
    IndentSpaces(out, indent);
    *out += "maxMultiviewInstanceIndex:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMultiviewInstanceIndex); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalImageFormatInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalImageFormatInfo *pstruct = (const VkPhysicalDeviceExternalImageFormatInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExternalMemoryBufferCreateInfo>(std::string* out, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalMemoryBufferCreateInfo *pstruct = (const VkExternalMemoryBufferCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceShaderDrawParametersFeatures *pstruct = (const VkPhysicalDeviceShaderDrawParametersFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 shaderDrawParameters
    IndentSpaces(out, indent);
    *out += "shaderDrawParameters:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderDrawParameters); //EQA
}

template <>
void StructureToString<Decoded_VkDeviceGroupRenderPassBeginInfo>(std::string* out, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupRenderPassBeginInfo *pstruct = (const VkDeviceGroupRenderPassBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t deviceRenderAreaCount
    IndentSpaces(out, indent);
    *out += "deviceRenderAreaCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceRenderAreaCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkRect2D* pDeviceRenderAreas
    IndentSpaces(out, indent);
    *out += "pDeviceRenderAreas:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pDeviceRenderAreas == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceRenderAreas->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pDeviceRenderAreas->GetMetaStructPointer(), "pDeviceRenderAreas", pstruct->deviceRenderAreaCount, false, pstruct_in.pDeviceRenderAreas->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkImageFormatProperties2>(std::string* out, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageFormatProperties2 *pstruct = (const VkImageFormatProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageFormatProperties imageFormatProperties
    IndentSpaces(out, indent);
    *out += "imageFormatProperties:          ";
    *out += "VkImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkImageFormatProperties>(out, *pstruct_in.imageFormatProperties, indent+1,  base_addr + offsetof(VkImageFormatProperties2, imageFormatProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProtectedMemoryFeatures *pstruct = (const VkPhysicalDeviceProtectedMemoryFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 protectedMemory
    IndentSpaces(out, indent);
    *out += "protectedMemory:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->protectedMemory); //EQA
}

template <>
void StructureToString<Decoded_VkDeviceQueueInfo2>(std::string* out, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceQueueInfo2 *pstruct = (const VkDeviceQueueInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceQueueCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDeviceQueueCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDeviceQueueCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndex); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t queueIndex
    IndentSpaces(out, indent);
    *out += "queueIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueIndex); // UYW
}

template <>
void StructureToString<Decoded_VkMemoryDedicatedAllocateInfo>(std::string* out, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryDedicatedAllocateInfo *pstruct = (const VkMemoryDedicatedAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkExternalSemaphoreProperties>(std::string* out, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalSemaphoreProperties *pstruct = (const VkExternalSemaphoreProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures
    IndentSpaces(out, indent);
    *out += "externalSemaphoreFeatures:      ";
    *out += "VkExternalSemaphoreFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->externalSemaphoreFeatures, EnumToStringVkExternalSemaphoreFeatureFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkMemoryRequirements2>(std::string* out, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryRequirements2 *pstruct = (const VkMemoryRequirements2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkMemoryRequirements memoryRequirements
    IndentSpaces(out, indent);
    *out += "memoryRequirements:             ";
    *out += "VkMemoryRequirements = "; // TEQ
    StructureToString<Decoded_VkMemoryRequirements>(out, *pstruct_in.memoryRequirements, indent+1,  base_addr + offsetof(VkMemoryRequirements2, memoryRequirements)); // AZJ
}

template <>
void StructureToString<Decoded_VkDeviceGroupDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupDeviceCreateInfo *pstruct = (const VkDeviceGroupDeviceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t physicalDeviceCount
    IndentSpaces(out, indent);
    *out += "physicalDeviceCount:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->physicalDeviceCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkPhysicalDevice* pPhysicalDevices
    IndentSpaces(out, indent);
    *out += "pPhysicalDevices:               ";
    *out += "const VkPhysicalDevice* = "; // TEQ
    if (pstruct->pPhysicalDevices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPhysicalDevices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPhysicalDevices = {true, false, false, nullptr};
        ArrayToString<const VkPhysicalDevice*>(out, indent, 1, "const VkPhysicalDevice*", reinterpret_cast<const VkPhysicalDevice*>(pstruct_in.pPhysicalDevices.GetPointer()), "pPhysicalDevices", pstruct->physicalDeviceCount,  vinfo_pPhysicalDevices);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkExternalBufferProperties>(std::string* out, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalBufferProperties *pstruct = (const VkExternalBufferProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryProperties externalMemoryProperties
    IndentSpaces(out, indent);
    *out += "externalMemoryProperties:       ";
    *out += "VkExternalMemoryProperties = "; // TEQ
    StructureToString<Decoded_VkExternalMemoryProperties>(out, *pstruct_in.externalMemoryProperties, indent+1,  base_addr + offsetof(VkExternalBufferProperties, externalMemoryProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>(std::string* out, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassInputAttachmentAspectCreateInfo *pstruct = (const VkRenderPassInputAttachmentAspectCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t aspectReferenceCount
    IndentSpaces(out, indent);
    *out += "aspectReferenceCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->aspectReferenceCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkInputAttachmentAspectReference* pAspectReferences
    IndentSpaces(out, indent);
    *out += "pAspectReferences:              ";
    *out += "const VkInputAttachmentAspectReference* = "; // TEQ
    if (pstruct->pAspectReferences == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAspectReferences->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkInputAttachmentAspectReference>(out, indent+1, 1, "VkInputAttachmentAspectReference", pstruct_in.pAspectReferences->GetMetaStructPointer(), "pAspectReferences", pstruct->aspectReferenceCount, false, pstruct_in.pAspectReferences->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkImageViewUsageCreateInfo>(std::string* out, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageViewUsageCreateInfo *pstruct = (const VkImageViewUsageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProperties2>(std::string* out, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProperties2 *pstruct = (const VkPhysicalDeviceProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPhysicalDeviceProperties properties
    IndentSpaces(out, indent);
    *out += "properties:                     ";
    *out += "VkPhysicalDeviceProperties = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceProperties>(out, *pstruct_in.properties, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties2, properties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDevice16BitStorageFeatures>(std::string* out, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevice16BitStorageFeatures *pstruct = (const VkPhysicalDevice16BitStorageFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 storageBuffer16BitAccess
    IndentSpaces(out, indent);
    *out += "storageBuffer16BitAccess:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->storageBuffer16BitAccess); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 uniformAndStorageBuffer16BitAccess
    IndentSpaces(out, indent);
    *out += "uniformAndStorageBuffer16BitAccess: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->uniformAndStorageBuffer16BitAccess); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 storagePushConstant16
    IndentSpaces(out, indent);
    *out += "storagePushConstant16:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->storagePushConstant16); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 storageInputOutput16
    IndentSpaces(out, indent);
    *out += "storageInputOutput16:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->storageInputOutput16); //EQA
}

template <>
void StructureToString<Decoded_VkBindBufferMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindBufferMemoryDeviceGroupInfo *pstruct = (const VkBindBufferMemoryDeviceGroupInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t deviceIndexCount
    IndentSpaces(out, indent);
    *out += "deviceIndexCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceIndexCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pDeviceIndices
    IndentSpaces(out, indent);
    *out += "pDeviceIndices:                 ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CXC
    }
}

void VulkanAsciiConsumer::Process_vkGetDeviceGroupPeerMemoryFeatures(
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    const PointerDecoder<VkPeerMemoryFeatureFlags>& pPeerMemoryFeatures)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t heapIndex
    IndentSpaces(out, indent);
    *out += "heapIndex:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, heapIndex); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t localDeviceIndex
    IndentSpaces(out, indent);
    *out += "localDeviceIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, localDeviceIndex); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t remoteDeviceIndex
    IndentSpaces(out, indent);
    *out += "remoteDeviceIndex:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, remoteDeviceIndex); // UYW
    outString += "\n";   // HHS

    // func arg: VkPeerMemoryFeatureFlags* pPeerMemoryFeatures
    IndentSpaces(out, indent);
    *out += "pPeerMemoryFeatures:            ";
    *out += "VkPeerMemoryFeatureFlags* = "; // TEQ
    if (pPeerMemoryFeatures.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPeerMemoryFeatures = {false, false, true, EnumToStringVkPeerMemoryFeatureFlagBits};
        ScalarValueToString(out, pPeerMemoryFeatures.GetPointer(), vinfo_pPeerMemoryFeatures); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>& pImageFormatInfo,
    const StructPointerDecoder<Decoded_VkImageFormatProperties2>& pImageFormatProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo
    IndentSpaces(out, indent);
    *out += "pImageFormatInfo:               ";
    *out += "const VkPhysicalDeviceImageFormatInfo2* = "; // TEQ
    if (pImageFormatInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImageFormatInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(out, *pImageFormatInfo.GetMetaStructPointer(), indent+1,pImageFormatInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkImageFormatProperties2* pImageFormatProperties
    IndentSpaces(out, indent);
    *out += "pImageFormatProperties:         ";
    *out += "VkImageFormatProperties2* = "; // TEQ
    if (pImageFormatProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImageFormatProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageFormatProperties2>(out, *pImageFormatProperties.GetMetaStructPointer(), indent+1,pImageFormatProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties2>& pQueueFamilyProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pQueueFamilyPropertyCount
    IndentSpaces(out, indent);
    *out += "pQueueFamilyPropertyCount:      ";
    *out += "uint32_t* = "; // TEQ
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pQueueFamilyPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pQueueFamilyPropertyCount.GetPointer(), vinfo_pQueueFamilyPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkQueueFamilyProperties2* pQueueFamilyProperties
    IndentSpaces(out, indent);
    *out += "pQueueFamilyProperties:         ";
    *out += "VkQueueFamilyProperties2* = "; // TEQ
    if (pQueueFamilyProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pQueueFamilyProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkQueueFamilyProperties2>(out, indent+1, 1, "VkQueueFamilyProperties2", pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>& pInfo,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>& pSparseMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageSparseMemoryRequirementsInfo2* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkImageSparseMemoryRequirementsInfo2* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pSparseMemoryRequirementCount
    IndentSpaces(out, indent);
    *out += "pSparseMemoryRequirementCount:  ";
    *out += "uint32_t* = "; // TEQ
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSparseMemoryRequirementCount = {false, false, false, nullptr};
        ScalarValueToString(out, pSparseMemoryRequirementCount.GetPointer(), vinfo_pSparseMemoryRequirementCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSparseImageMemoryRequirements2* pSparseMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pSparseMemoryRequirements:      ";
    *out += "VkSparseImageMemoryRequirements2* = "; // TEQ
    if (pSparseMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSparseMemoryRequirements.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements2>(out, indent+1, 1, "VkSparseImageMemoryRequirements2", pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDeviceMask(
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetDeviceMask(commandBuffer, deviceMask)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t deviceMask
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, deviceMask); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalSemaphoreProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>& pExternalSemaphoreInfo,
    const StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>& pExternalSemaphoreProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo
    IndentSpaces(out, indent);
    *out += "pExternalSemaphoreInfo:         ";
    *out += "const VkPhysicalDeviceExternalSemaphoreInfo* = "; // TEQ
    if (pExternalSemaphoreInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalSemaphoreInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(out, *pExternalSemaphoreInfo.GetMetaStructPointer(), indent+1,pExternalSemaphoreInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkExternalSemaphoreProperties* pExternalSemaphoreProperties
    IndentSpaces(out, indent);
    *out += "pExternalSemaphoreProperties:   ";
    *out += "VkExternalSemaphoreProperties* = "; // TEQ
    if (pExternalSemaphoreProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalSemaphoreProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExternalSemaphoreProperties>(out, *pExternalSemaphoreProperties.GetMetaStructPointer(), indent+1,pExternalSemaphoreProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorUpdateTemplate(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorUpdateTemplate>& pDescriptorUpdateTemplate)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDescriptorUpdateTemplateCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate
    IndentSpaces(out, indent);
    *out += "pDescriptorUpdateTemplate:      ";
    *out += "VkDescriptorUpdateTemplate* = "; // TEQ
    if (pDescriptorUpdateTemplate.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDescriptorUpdateTemplate = {true, false, false, nullptr};
        ScalarValueToString(out, pDescriptorUpdateTemplate.GetPointer(), vinfo_pDescriptorUpdateTemplate); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDescriptorSetLayoutSupport(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>& pSupport)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDescriptorSetLayoutCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDescriptorSetLayoutCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDescriptorSetLayoutSupport* pSupport
    IndentSpaces(out, indent);
    *out += "pSupport:                       ";
    *out += "VkDescriptorSetLayoutSupport* = "; // TEQ
    if (pSupport.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSupport.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorSetLayoutSupport>(out, *pSupport.GetMetaStructPointer(), indent+1,pSupport.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindBufferMemory2(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>& pBindInfos)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBindBufferMemory2(device, bindInfoCount, pBindInfos)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t bindInfoCount
    IndentSpaces(out, indent);
    *out += "bindInfoCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBindBufferMemoryInfo* pBindInfos
    IndentSpaces(out, indent);
    *out += "pBindInfos:                     ";
    *out += "const VkBindBufferMemoryInfo* = "; // TEQ
    if (pBindInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBindInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBindBufferMemoryInfo>(out, indent+1, 1, "VkBindBufferMemoryInfo", pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties2(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties2>& pFormatProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, format);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkFormatProperties2* pFormatProperties
    IndentSpaces(out, indent);
    *out += "pFormatProperties:              ";
    *out += "VkFormatProperties2* = "; // TEQ
    if (pFormatProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFormatProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkFormatProperties2>(out, *pFormatProperties.GetMetaStructPointer(), indent+1,pFormatProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkTrimCommandPool(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkTrimCommandPool(device, commandPool, flags)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPool commandPool
    IndentSpaces(out, indent);
    *out += "commandPool:                    ";
    *out += "VkCommandPool = "; // TEQ
    AddrToString(out, commandPool); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPoolTrimFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandPoolTrimFlags = "; // TEQ
    UnsignedDecimalToString(out, flags); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySamplerYcbcrConversion(
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSamplerYcbcrConversion ycbcrConversion
    IndentSpaces(out, indent);
    *out += "ycbcrConversion:                ";
    *out += "VkSamplerYcbcrConversion = "; // TEQ
    AddrToString(out, ycbcrConversion); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSamplerYcbcrConversion(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSamplerYcbcrConversion>& pYcbcrConversion)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSamplerYcbcrConversionCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkSamplerYcbcrConversionCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSamplerYcbcrConversion* pYcbcrConversion
    IndentSpaces(out, indent);
    *out += "pYcbcrConversion:               ";
    *out += "VkSamplerYcbcrConversion* = "; // TEQ
    if (pYcbcrConversion.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pYcbcrConversion = {true, false, false, nullptr};
        ScalarValueToString(out, pYcbcrConversion.GetPointer(), vinfo_pYcbcrConversion); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceQueue2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceQueueInfo2>& pQueueInfo,
    const HandlePointerDecoder<VkQueue>&        pQueue)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceQueue2(device, pQueueInfo, pQueue)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDeviceQueueInfo2* pQueueInfo
    IndentSpaces(out, indent);
    *out += "pQueueInfo:                     ";
    *out += "const VkDeviceQueueInfo2* = "; // TEQ
    if (pQueueInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pQueueInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDeviceQueueInfo2>(out, *pQueueInfo.GetMetaStructPointer(), indent+1,pQueueInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkQueue* pQueue
    IndentSpaces(out, indent);
    *out += "pQueue:                         ";
    *out += "VkQueue* = "; // TEQ
    if (pQueue.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pQueue = {true, false, false, nullptr};
        ScalarValueToString(out, pQueue.GetPointer(), vinfo_pQueue); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageMemoryRequirementsInfo2* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkImageMemoryRequirementsInfo2* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkMemoryRequirements2* pMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pMemoryRequirements:            ";
    *out += "VkMemoryRequirements2* = "; // TEQ
    if (pMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRequirements.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryRequirements2>(out, *pMemoryRequirements.GetMetaStructPointer(), indent+1,pMemoryRequirements.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalBufferProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>& pExternalBufferInfo,
    const StructPointerDecoder<Decoded_VkExternalBufferProperties>& pExternalBufferProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo
    IndentSpaces(out, indent);
    *out += "pExternalBufferInfo:            ";
    *out += "const VkPhysicalDeviceExternalBufferInfo* = "; // TEQ
    if (pExternalBufferInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalBufferInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(out, *pExternalBufferInfo.GetMetaStructPointer(), indent+1,pExternalBufferInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkExternalBufferProperties* pExternalBufferProperties
    IndentSpaces(out, indent);
    *out += "pExternalBufferProperties:      ";
    *out += "VkExternalBufferProperties* = "; // TEQ
    if (pExternalBufferProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalBufferProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExternalBufferProperties>(out, *pExternalBufferProperties.GetMetaStructPointer(), indent+1,pExternalBufferProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchBase(
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t baseGroupX
    IndentSpaces(out, indent);
    *out += "baseGroupX:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, baseGroupX); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t baseGroupY
    IndentSpaces(out, indent);
    *out += "baseGroupY:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, baseGroupY); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t baseGroupZ
    IndentSpaces(out, indent);
    *out += "baseGroupZ:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, baseGroupZ); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountX
    IndentSpaces(out, indent);
    *out += "groupCountX:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountX); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountY
    IndentSpaces(out, indent);
    *out += "groupCountY:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountY); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountZ
    IndentSpaces(out, indent);
    *out += "groupCountZ:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountZ); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDeviceGroups(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceGroupCount,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>& pPhysicalDeviceGroupProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPhysicalDeviceGroupCount
    IndentSpaces(out, indent);
    *out += "pPhysicalDeviceGroupCount:      ";
    *out += "uint32_t* = "; // TEQ
    if (pPhysicalDeviceGroupCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPhysicalDeviceGroupCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPhysicalDeviceGroupCount.GetPointer(), vinfo_pPhysicalDeviceGroupCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties
    IndentSpaces(out, indent);
    *out += "pPhysicalDeviceGroupProperties: ";
    *out += "VkPhysicalDeviceGroupProperties* = "; // TEQ
    if (pPhysicalDeviceGroupProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPhysicalDeviceGroupProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPhysicalDeviceGroupProperties>(out, indent+1, 1, "VkPhysicalDeviceGroupProperties", pPhysicalDeviceGroupProperties.GetMetaStructPointer(), "pPhysicalDeviceGroupProperties", *pPhysicalDeviceGroupCount.GetPointer(), false, pPhysicalDeviceGroupProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory2(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindImageMemoryInfo>& pBindInfos)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBindImageMemory2(device, bindInfoCount, pBindInfos)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t bindInfoCount
    IndentSpaces(out, indent);
    *out += "bindInfoCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBindImageMemoryInfo* pBindInfos
    IndentSpaces(out, indent);
    *out += "pBindInfos:                     ";
    *out += "const VkBindImageMemoryInfo* = "; // TEQ
    if (pBindInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBindInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBindImageMemoryInfo>(out, indent+1, 1, "VkBindImageMemoryInfo", pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorUpdateTemplate(
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDescriptorUpdateTemplate descriptorUpdateTemplate
    IndentSpaces(out, indent);
    *out += "descriptorUpdateTemplate:       ";
    *out += "VkDescriptorUpdateTemplate = "; // TEQ
    AddrToString(out, descriptorUpdateTemplate); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties2(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceProperties2* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkPhysicalDeviceProperties2* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceProperties2>(out, *pProperties.GetMetaStructPointer(), indent+1,pProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>& pFormatInfo,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo
    IndentSpaces(out, indent);
    *out += "pFormatInfo:                    ";
    *out += "const VkPhysicalDeviceSparseImageFormatInfo2* = "; // TEQ
    if (pFormatInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFormatInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(out, *pFormatInfo.GetMetaStructPointer(), indent+1,pFormatInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSparseImageFormatProperties2* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkSparseImageFormatProperties2* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageFormatProperties2>(out, indent+1, 1, "VkSparseImageFormatProperties2", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>& pMemoryProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceMemoryProperties2* pMemoryProperties
    IndentSpaces(out, indent);
    *out += "pMemoryProperties:              ";
    *out += "VkPhysicalDeviceMemoryProperties2* = "; // TEQ
    if (pMemoryProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(out, *pMemoryProperties.GetMetaStructPointer(), indent+1,pMemoryProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkBufferMemoryRequirementsInfo2* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkBufferMemoryRequirementsInfo2* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkMemoryRequirements2* pMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pMemoryRequirements:            ";
    *out += "VkMemoryRequirements2* = "; // TEQ
    if (pMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRequirements.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryRequirements2>(out, *pMemoryRequirements.GetMetaStructPointer(), indent+1,pMemoryRequirements.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>& pFeatures)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceFeatures2* pFeatures
    IndentSpaces(out, indent);
    *out += "pFeatures:                      ";
    *out += "VkPhysicalDeviceFeatures2* = "; // TEQ
    if (pFeatures.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFeatures.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceFeatures2>(out, *pFeatures.GetMetaStructPointer(), indent+1,pFeatures.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalFenceProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>& pExternalFenceInfo,
    const StructPointerDecoder<Decoded_VkExternalFenceProperties>& pExternalFenceProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo
    IndentSpaces(out, indent);
    *out += "pExternalFenceInfo:             ";
    *out += "const VkPhysicalDeviceExternalFenceInfo* = "; // TEQ
    if (pExternalFenceInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalFenceInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(out, *pExternalFenceInfo.GetMetaStructPointer(), indent+1,pExternalFenceInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkExternalFenceProperties* pExternalFenceProperties
    IndentSpaces(out, indent);
    *out += "pExternalFenceProperties:       ";
    *out += "VkExternalFenceProperties* = "; // TEQ
    if (pExternalFenceProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalFenceProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExternalFenceProperties>(out, *pExternalFenceProperties.GetMetaStructPointer(), indent+1,pExternalFenceProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceFormatKHR>(std::string* out, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilitiesKHR *pstruct = (const VkSurfaceCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t minImageCount
    IndentSpaces(out, indent);
    *out += "minImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minImageCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageCount
    IndentSpaces(out, indent);
    *out += "maxImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkExtent2D currentExtent
    IndentSpaces(out, indent);
    *out += "currentExtent:                  ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.currentExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, currentExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D minImageExtent
    IndentSpaces(out, indent);
    *out += "minImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, minImageExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D maxImageExtent
    IndentSpaces(out, indent);
    *out += "maxImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, maxImageExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageArrayLayers
    IndentSpaces(out, indent);
    *out += "maxImageArrayLayers:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageArrayLayers); // UYW
    *out += "\n"; // GDS

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    IndentSpaces(out, indent);
    *out += "supportedTransforms:            ";
    *out += "VkSurfaceTransformFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR currentTransform
    IndentSpaces(out, indent);
    *out += "currentTransform:               ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->currentTransform); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->currentTransform);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkCompositeAlphaFlagsKHR supportedCompositeAlpha
    IndentSpaces(out, indent);
    *out += "supportedCompositeAlpha:        ";
    *out += "VkCompositeAlphaFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedCompositeAlpha, EnumToStringVkCompositeAlphaFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags supportedUsageFlags
    IndentSpaces(out, indent);
    *out += "supportedUsageFlags:            ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSurfaceFormatKHR>(std::string* out, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFormatKHR *pstruct = (const VkSurfaceFormatKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkColorSpaceKHR colorSpace
    IndentSpaces(out, indent);
    *out += "colorSpace:                     ";
    *out += "VkColorSpaceKHR = "; // TEQ
    EnumToStringVkColorSpaceKHR(out, pstruct->colorSpace); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->colorSpace);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pPresentModeCount,
    const PointerDecoder<VkPresentModeKHR>&     pPresentModes)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPresentModeCount
    IndentSpaces(out, indent);
    *out += "pPresentModeCount:              ";
    *out += "uint32_t* = "; // TEQ
    if (pPresentModeCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPresentModeCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPresentModeCount.GetPointer(), vinfo_pPresentModeCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPresentModeKHR* pPresentModes
    IndentSpaces(out, indent);
    *out += "pPresentModes:                  ";
    *out += "VkPresentModeKHR* = "; // TEQ
    if (pPresentModes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPresentModes.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPresentModes = {false, true, false, EnumToStringVkPresentModeKHR};
        ArrayToString<VkPresentModeKHR*>(out, indent, 1, "VkPresentModeKHR*", reinterpret_cast<VkPresentModeKHR*>(pPresentModes.GetPointer()), "pPresentModes", *pPresentModeCount.GetPointer(),  vinfo_pPresentModes);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySurfaceKHR(
    format::HandleId                            instance,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroySurfaceKHR(instance, surface, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceSupportKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    format::HandleId                            surface,
    const PointerDecoder<VkBool32>&             pSupported)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queueFamilyIndex); // UYW
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBool32* pSupported
    IndentSpaces(out, indent);
    *out += "pSupported:                     ";
    *out += "VkBool32* = "; // TEQ
    if (pSupported.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSupported = {false, false, false, nullptr};
        ScalarValueToString(out, pSupported.GetPointer(), vinfo_pSupported); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilitiesKHR>& pSurfaceCapabilities)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceCapabilitiesKHR* pSurfaceCapabilities
    IndentSpaces(out, indent);
    *out += "pSurfaceCapabilities:           ";
    *out += "VkSurfaceCapabilitiesKHR* = "; // TEQ
    if (pSurfaceCapabilities.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceCapabilities.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(out, *pSurfaceCapabilities.GetMetaStructPointer(), indent+1,pSurfaceCapabilities.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pSurfaceFormatCount,
    const StructPointerDecoder<Decoded_VkSurfaceFormatKHR>& pSurfaceFormats)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pSurfaceFormatCount
    IndentSpaces(out, indent);
    *out += "pSurfaceFormatCount:            ";
    *out += "uint32_t* = "; // TEQ
    if (pSurfaceFormatCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurfaceFormatCount = {false, false, false, nullptr};
        ScalarValueToString(out, pSurfaceFormatCount.GetPointer(), vinfo_pSurfaceFormatCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceFormatKHR* pSurfaceFormats
    IndentSpaces(out, indent);
    *out += "pSurfaceFormats:                ";
    *out += "VkSurfaceFormatKHR* = "; // TEQ
    if (pSurfaceFormats.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceFormats.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSurfaceFormatKHR>(out, indent+1, 1, "VkSurfaceFormatKHR", pSurfaceFormats.GetMetaStructPointer(), "pSurfaceFormats", *pSurfaceFormatCount.GetPointer(), false, pSurfaceFormats.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImageMemorySwapchainInfoKHR>(std::string* out, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(std::string* out, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAcquireNextImageInfoKHR>(std::string* out, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPresentInfoKHR>(std::string* out, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupPresentInfoKHR>(std::string* out, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSwapchainCreateInfoKHR *pstruct = (const VkSwapchainCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSwapchainCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSwapchainCreateFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSwapchainCreateFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, pstruct_in.surface); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t minImageCount
    IndentSpaces(out, indent);
    *out += "minImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minImageCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkFormat imageFormat
    IndentSpaces(out, indent);
    *out += "imageFormat:                    ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->imageFormat); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageFormat);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkColorSpaceKHR imageColorSpace
    IndentSpaces(out, indent);
    *out += "imageColorSpace:                ";
    *out += "VkColorSpaceKHR = "; // TEQ
    EnumToStringVkColorSpaceKHR(out, pstruct->imageColorSpace); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageColorSpace);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkExtent2D imageExtent
    IndentSpaces(out, indent);
    *out += "imageExtent:                    ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkSwapchainCreateInfoKHR, imageExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t imageArrayLayers
    IndentSpaces(out, indent);
    *out += "imageArrayLayers:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageArrayLayers); // UYW
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags imageUsage
    IndentSpaces(out, indent);
    *out += "imageUsage:                     ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->imageUsage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSharingMode imageSharingMode
    IndentSpaces(out, indent);
    *out += "imageSharingMode:               ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->imageSharingMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageSharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR preTransform
    IndentSpaces(out, indent);
    *out += "preTransform:                   ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->preTransform); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->preTransform);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkCompositeAlphaFlagBitsKHR compositeAlpha
    IndentSpaces(out, indent);
    *out += "compositeAlpha:                 ";
    *out += "VkCompositeAlphaFlagBitsKHR = "; // TEQ
    EnumToStringVkCompositeAlphaFlagBitsKHR(out, pstruct->compositeAlpha); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->compositeAlpha);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkPresentModeKHR presentMode
    IndentSpaces(out, indent);
    *out += "presentMode:                    ";
    *out += "VkPresentModeKHR = "; // TEQ
    EnumToStringVkPresentModeKHR(out, pstruct->presentMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->presentMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 clipped
    IndentSpaces(out, indent);
    *out += "clipped:                        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->clipped); //EQA
    *out += "\n"; // GDS

    // struct member: VkSwapchainKHR oldSwapchain
    IndentSpaces(out, indent);
    *out += "oldSwapchain:                   ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.oldSwapchain); // PAQ
}

template <>
void StructureToString<Decoded_VkBindImageMemorySwapchainInfoKHR>(std::string* out, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImageMemorySwapchainInfoKHR *pstruct = (const VkBindImageMemorySwapchainInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.swapchain); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t imageIndex
    IndentSpaces(out, indent);
    *out += "imageIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageIndex); // UYW
}

template <>
void StructureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(std::string* out, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupPresentCapabilitiesKHR *pstruct = (const VkDeviceGroupPresentCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t presentMask
    IndentSpaces(out, indent);
    *out += "presentMask:                    ";
    *out += "uint32_t[";
    *out += "VK_MAX_DEVICE_GROUP_SIZE"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkDeviceGroupPresentCapabilitiesKHR, presentMask)); // IYY
    ScalarValueToStringStruct vinfo_presentMask = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->presentMask), "presentMask", VK_MAX_DEVICE_GROUP_SIZE, vinfo_presentMask); // JPA
    *out += "\n"; // GDS

    // struct member: VkDeviceGroupPresentModeFlagsKHR modes
    IndentSpaces(out, indent);
    *out += "modes:                          ";
    *out += "VkDeviceGroupPresentModeFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->modes, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR); // URW
}

template <>
void StructureToString<Decoded_VkAcquireNextImageInfoKHR>(std::string* out, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAcquireNextImageInfoKHR *pstruct = (const VkAcquireNextImageInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.swapchain); // PAQ
    *out += "\n"; // GDS

    // struct member: uint64_t timeout
    IndentSpaces(out, indent);
    *out += "timeout:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->timeout); // UYW
    *out += "\n"; // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // struct member: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t deviceMask
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask); // UYW
}

template <>
void StructureToString<Decoded_VkPresentInfoKHR>(std::string* out, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPresentInfoKHR *pstruct = (const VkPresentInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t waitSemaphoreCount
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSemaphore* pWaitSemaphores
    IndentSpaces(out, indent);
    *out += "pWaitSemaphores:                ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t swapchainCount
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->swapchainCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSwapchainKHR* pSwapchains
    IndentSpaces(out, indent);
    *out += "pSwapchains:                    ";
    *out += "const VkSwapchainKHR* = "; // TEQ
    if (pstruct->pSwapchains == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSwapchains.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        ArrayToString<const VkSwapchainKHR*>(out, indent, 1, "const VkSwapchainKHR*", reinterpret_cast<const VkSwapchainKHR*>(pstruct_in.pSwapchains.GetPointer()), "pSwapchains", pstruct->swapchainCount,  vinfo_pSwapchains);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: const uint32_t* pImageIndices
    IndentSpaces(out, indent);
    *out += "pImageIndices:                  ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pImageIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pImageIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pImageIndices.GetPointer()), "pImageIndices", pstruct->swapchainCount,  vinfo_pImageIndices);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: VkResult* pResults
    IndentSpaces(out, indent);
    *out += "pResults:                       ";
    *out += "VkResult* = "; // TEQ
    if (pstruct->pResults == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pResults.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pResults = {false, true, false, EnumToStringVkResult};
        ArrayToString<VkResult*>(out, indent, 1, "VkResult*", reinterpret_cast<VkResult*>(pstruct_in.pResults.GetPointer()), "pResults", pstruct->swapchainCount,  vinfo_pResults);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkImageSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSwapchainCreateInfoKHR *pstruct = (const VkImageSwapchainCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.swapchain); // PAQ
}

template <>
void StructureToString<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupSwapchainCreateInfoKHR *pstruct = (const VkDeviceGroupSwapchainCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceGroupPresentModeFlagsKHR modes
    IndentSpaces(out, indent);
    *out += "modes:                          ";
    *out += "VkDeviceGroupPresentModeFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->modes, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR); // URW
}

template <>
void StructureToString<Decoded_VkDeviceGroupPresentInfoKHR>(std::string* out, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupPresentInfoKHR *pstruct = (const VkDeviceGroupPresentInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t swapchainCount
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->swapchainCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pDeviceMasks
    IndentSpaces(out, indent);
    *out += "pDeviceMasks:                   ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceMasks == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceMasks.GetPointer()), "pDeviceMasks", pstruct->swapchainCount,  vinfo_pDeviceMasks);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceGroupPresentModeFlagBitsKHR mode
    IndentSpaces(out, indent);
    *out += "mode:                           ";
    *out += "VkDeviceGroupPresentModeFlagBitsKHR = "; // TEQ
    EnumToStringVkDeviceGroupPresentModeFlagBitsKHR(out, pstruct->mode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->mode);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetDeviceGroupSurfacePresentModesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            surface,
    const PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>& pModes)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceGroupPresentModeFlagsKHR* pModes
    IndentSpaces(out, indent);
    *out += "pModes:                         ";
    *out += "VkDeviceGroupPresentModeFlagsKHR* = "; // TEQ
    if (pModes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pModes = {false, false, true, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR};
        ScalarValueToString(out, pModes.GetPointer(), vinfo_pModes); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireNextImageKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    uint64_t                                    timeout,
    format::HandleId                            semaphore,
    format::HandleId                            fence,
    const PointerDecoder<uint32_t>&             pImageIndex)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    // func arg: uint64_t timeout
    IndentSpaces(out, indent);
    *out += "timeout:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, timeout); // UYW
    outString += "\n";   // HHS

    // func arg: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, semaphore); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, fence); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pImageIndex
    IndentSpaces(out, indent);
    *out += "pImageIndex:                    ";
    *out += "uint32_t* = "; // TEQ
    if (pImageIndex.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pImageIndex = {false, false, false, nullptr};
        ScalarValueToString(out, pImageIndex.GetPointer(), vinfo_pImageIndex); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireNextImage2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAcquireNextImageInfoKHR>& pAcquireInfo,
    const PointerDecoder<uint32_t>&             pImageIndex)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAcquireNextImageInfoKHR* pAcquireInfo
    IndentSpaces(out, indent);
    *out += "pAcquireInfo:                   ";
    *out += "const VkAcquireNextImageInfoKHR* = "; // TEQ
    if (pAcquireInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAcquireInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAcquireNextImageInfoKHR>(out, *pAcquireInfo.GetMetaStructPointer(), indent+1,pAcquireInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pImageIndex
    IndentSpaces(out, indent);
    *out += "pImageIndex:                    ";
    *out += "uint32_t* = "; // TEQ
    if (pImageIndex.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pImageIndex = {false, false, false, nullptr};
        ScalarValueToString(out, pImageIndex.GetPointer(), vinfo_pImageIndex); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSwapchainImagesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const PointerDecoder<uint32_t>&             pSwapchainImageCount,
    const HandlePointerDecoder<VkImage>&        pSwapchainImages)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pSwapchainImageCount
    IndentSpaces(out, indent);
    *out += "pSwapchainImageCount:           ";
    *out += "uint32_t* = "; // TEQ
    if (pSwapchainImageCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSwapchainImageCount = {false, false, false, nullptr};
        ScalarValueToString(out, pSwapchainImageCount.GetPointer(), vinfo_pSwapchainImageCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkImage* pSwapchainImages
    IndentSpaces(out, indent);
    *out += "pSwapchainImages:               ";
    *out += "VkImage* = "; // TEQ
    if (pSwapchainImages.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSwapchainImages.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSwapchainImages = {true, false, false, nullptr};
        ArrayToString<VkImage*>(out, indent, 1, "VkImage*", reinterpret_cast<VkImage*>(pSwapchainImages.GetPointer()), "pSwapchainImages", *pSwapchainImageCount.GetPointer(),  vinfo_pSwapchainImages);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSwapchainKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchain)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSwapchainCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkSwapchainCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSwapchainCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR* pSwapchain
    IndentSpaces(out, indent);
    *out += "pSwapchain:                     ";
    *out += "VkSwapchainKHR* = "; // TEQ
    if (pSwapchain.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSwapchain = {true, false, false, nullptr};
        ScalarValueToString(out, pSwapchain.GetPointer(), vinfo_pSwapchain); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueuePresentKHR(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkPresentInfoKHR>& pPresentInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueuePresentKHR(queue, pPresentInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPresentInfoKHR* pPresentInfo
    IndentSpaces(out, indent);
    *out += "pPresentInfo:                   ";
    *out += "const VkPresentInfoKHR* = "; // TEQ
    if (pPresentInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPresentInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPresentInfoKHR>(out, *pPresentInfo.GetMetaStructPointer(), indent+1,pPresentInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupPresentCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceGroupPresentCapabilitiesKHR>& pDeviceGroupPresentCapabilities)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities
    IndentSpaces(out, indent);
    *out += "pDeviceGroupPresentCapabilities: ";
    *out += "VkDeviceGroupPresentCapabilitiesKHR* = "; // TEQ
    if (pDeviceGroupPresentCapabilities.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDeviceGroupPresentCapabilities.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(out, *pDeviceGroupPresentCapabilities.GetMetaStructPointer(), indent+1,pDeviceGroupPresentCapabilities.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDevicePresentRectanglesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pRectCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pRects)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pRectCount
    IndentSpaces(out, indent);
    *out += "pRectCount:                     ";
    *out += "uint32_t* = "; // TEQ
    if (pRectCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pRectCount = {false, false, false, nullptr};
        ScalarValueToString(out, pRectCount.GetPointer(), vinfo_pRectCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkRect2D* pRects
    IndentSpaces(out, indent);
    *out += "pRects:                         ";
    *out += "VkRect2D* = "; // TEQ
    if (pRects.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRects.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pRects.GetMetaStructPointer(), "pRects", *pRectCount.GetPointer(), false, pRects.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySwapchainKHR(
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroySwapchainKHR(device, swapchain, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModePropertiesKHR>(std::string* out, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModeCreateInfoKHR>(std::string* out, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlanePropertiesKHR>(std::string* out, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPropertiesKHR>(std::string* out, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModeParametersKHR>(std::string* out, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(std::string* out, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneCapabilitiesKHR *pstruct = (const VkDisplayPlaneCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDisplayPlaneAlphaFlagsKHR supportedAlpha
    IndentSpaces(out, indent);
    *out += "supportedAlpha:                 ";
    *out += "VkDisplayPlaneAlphaFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedAlpha, EnumToStringVkDisplayPlaneAlphaFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: VkOffset2D minSrcPosition
    IndentSpaces(out, indent);
    *out += "minSrcPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.minSrcPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcPosition)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset2D maxSrcPosition
    IndentSpaces(out, indent);
    *out += "maxSrcPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.maxSrcPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcPosition)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D minSrcExtent
    IndentSpaces(out, indent);
    *out += "minSrcExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minSrcExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D maxSrcExtent
    IndentSpaces(out, indent);
    *out += "maxSrcExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxSrcExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset2D minDstPosition
    IndentSpaces(out, indent);
    *out += "minDstPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.minDstPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstPosition)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkOffset2D maxDstPosition
    IndentSpaces(out, indent);
    *out += "maxDstPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.maxDstPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstPosition)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D minDstExtent
    IndentSpaces(out, indent);
    *out += "minDstExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minDstExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D maxDstExtent
    IndentSpaces(out, indent);
    *out += "maxDstExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxDstExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstExtent)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayModePropertiesKHR>(std::string* out, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModePropertiesKHR *pstruct = (const VkDisplayModePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDisplayModeKHR displayMode
    IndentSpaces(out, indent);
    *out += "displayMode:                    ";
    *out += "VkDisplayModeKHR = "; // TEQ
    AddrToString(out, pstruct_in.displayMode); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDisplayModeParametersKHR parameters
    IndentSpaces(out, indent);
    *out += "parameters:                     ";
    *out += "VkDisplayModeParametersKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayModeParametersKHR>(out, *pstruct_in.parameters, indent+1,  base_addr + offsetof(VkDisplayModePropertiesKHR, parameters)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayModeCreateInfoKHR>(std::string* out, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModeCreateInfoKHR *pstruct = (const VkDisplayModeCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayModeCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDisplayModeCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkDisplayModeParametersKHR parameters
    IndentSpaces(out, indent);
    *out += "parameters:                     ";
    *out += "VkDisplayModeParametersKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayModeParametersKHR>(out, *pstruct_in.parameters, indent+1,  base_addr + offsetof(VkDisplayModeCreateInfoKHR, parameters)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayPlanePropertiesKHR>(std::string* out, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlanePropertiesKHR *pstruct = (const VkDisplayPlanePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDisplayKHR currentDisplay
    IndentSpaces(out, indent);
    *out += "currentDisplay:                 ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, pstruct_in.currentDisplay); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t currentStackIndex
    IndentSpaces(out, indent);
    *out += "currentStackIndex:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->currentStackIndex); // UYW
}

template <>
void StructureToString<Decoded_VkDisplayPropertiesKHR>(std::string* out, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPropertiesKHR *pstruct = (const VkDisplayPropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, pstruct_in.display); // PAQ
    *out += "\n"; // GDS

    // struct member: const char* displayName
    IndentSpaces(out, indent);
    *out += "displayName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->displayName); // TGI
    *out += "\n"; // GDS

    // struct member: VkExtent2D physicalDimensions
    IndentSpaces(out, indent);
    *out += "physicalDimensions:             ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.physicalDimensions, indent+1,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalDimensions)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D physicalResolution
    IndentSpaces(out, indent);
    *out += "physicalResolution:             ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.physicalResolution, indent+1,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalResolution)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    IndentSpaces(out, indent);
    *out += "supportedTransforms:            ";
    *out += "VkSurfaceTransformFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: VkBool32 planeReorderPossible
    IndentSpaces(out, indent);
    *out += "planeReorderPossible:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->planeReorderPossible); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 persistentContent
    IndentSpaces(out, indent);
    *out += "persistentContent:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->persistentContent); //EQA
}

template <>
void StructureToString<Decoded_VkDisplayModeParametersKHR>(std::string* out, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModeParametersKHR *pstruct = (const VkDisplayModeParametersKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkExtent2D visibleRegion
    IndentSpaces(out, indent);
    *out += "visibleRegion:                  ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.visibleRegion, indent+1,  base_addr + offsetof(VkDisplayModeParametersKHR, visibleRegion)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t refreshRate
    IndentSpaces(out, indent);
    *out += "refreshRate:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->refreshRate); // UYW
}

template <>
void StructureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(std::string* out, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplaySurfaceCreateInfoKHR *pstruct = (const VkDisplaySurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplaySurfaceCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDisplaySurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkDisplayModeKHR displayMode
    IndentSpaces(out, indent);
    *out += "displayMode:                    ";
    *out += "VkDisplayModeKHR = "; // TEQ
    AddrToString(out, pstruct_in.displayMode); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t planeIndex
    IndentSpaces(out, indent);
    *out += "planeIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->planeIndex); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t planeStackIndex
    IndentSpaces(out, indent);
    *out += "planeStackIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->planeStackIndex); // UYW
    *out += "\n"; // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR transform
    IndentSpaces(out, indent);
    *out += "transform:                      ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->transform); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->transform);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: float globalAlpha
    IndentSpaces(out, indent);
    *out += "globalAlpha:                    ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->globalAlpha); // PEZ
    *out += "\n"; // GDS

    // struct member: VkDisplayPlaneAlphaFlagBitsKHR alphaMode
    IndentSpaces(out, indent);
    *out += "alphaMode:                      ";
    *out += "VkDisplayPlaneAlphaFlagBitsKHR = "; // TEQ
    EnumToStringVkDisplayPlaneAlphaFlagBitsKHR(out, pstruct->alphaMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->alphaMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkExtent2D imageExtent
    IndentSpaces(out, indent);
    *out += "imageExtent:                    ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkDisplaySurfaceCreateInfoKHR, imageExtent)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetDisplayModePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayModePropertiesKHR>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, display); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayModePropertiesKHR* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkDisplayModePropertiesKHR* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDisplayModePropertiesKHR>(out, indent+1, 1, "VkDisplayModePropertiesKHR", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPlanePropertiesKHR>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayPlanePropertiesKHR* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkDisplayPlanePropertiesKHR* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDisplayPlanePropertiesKHR>(out, indent+1, 1, "VkDisplayPlanePropertiesKHR", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPropertiesKHR>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayPropertiesKHR* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkDisplayPropertiesKHR* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDisplayPropertiesKHR>(out, indent+1, 1, "VkDisplayPropertiesKHR", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDisplayModeKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayModeCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDisplayModeKHR>& pMode)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, display); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDisplayModeCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDisplayModeCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDisplayModeCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayModeKHR* pMode
    IndentSpaces(out, indent);
    *out += "pMode:                          ";
    *out += "VkDisplayModeKHR* = "; // TEQ
    if (pMode.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pMode = {true, false, false, nullptr};
        ScalarValueToString(out, pMode.GetPointer(), vinfo_pMode); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneSupportedDisplaysKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    planeIndex,
    const PointerDecoder<uint32_t>&             pDisplayCount,
    const HandlePointerDecoder<VkDisplayKHR>&   pDisplays)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t planeIndex
    IndentSpaces(out, indent);
    *out += "planeIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, planeIndex); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t* pDisplayCount
    IndentSpaces(out, indent);
    *out += "pDisplayCount:                  ";
    *out += "uint32_t* = "; // TEQ
    if (pDisplayCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDisplayCount = {false, false, false, nullptr};
        ScalarValueToString(out, pDisplayCount.GetPointer(), vinfo_pDisplayCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR* pDisplays
    IndentSpaces(out, indent);
    *out += "pDisplays:                      ";
    *out += "VkDisplayKHR* = "; // TEQ
    if (pDisplays.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDisplays.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDisplays = {true, false, false, nullptr};
        ArrayToString<VkDisplayKHR*>(out, indent, 1, "VkDisplayKHR*", reinterpret_cast<VkDisplayKHR*>(pDisplays.GetPointer()), "pDisplays", *pDisplayCount.GetPointer(),  vinfo_pDisplays);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDisplayPlaneSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDisplaySurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDisplaySurfaceCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDisplaySurfaceCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            mode,
    uint32_t                                    planeIndex,
    const StructPointerDecoder<Decoded_VkDisplayPlaneCapabilitiesKHR>& pCapabilities)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayModeKHR mode
    IndentSpaces(out, indent);
    *out += "mode:                           ";
    *out += "VkDisplayModeKHR = "; // TEQ
    AddrToString(out, mode); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t planeIndex
    IndentSpaces(out, indent);
    *out += "planeIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, planeIndex); // UYW
    outString += "\n";   // HHS

    // func arg: VkDisplayPlaneCapabilitiesKHR* pCapabilities
    IndentSpaces(out, indent);
    *out += "pCapabilities:                  ";
    *out += "VkDisplayPlaneCapabilitiesKHR* = "; // TEQ
    if (pCapabilities.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCapabilities.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(out, *pCapabilities.GetMetaStructPointer(), indent+1,pCapabilities.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDisplayPresentInfoKHR>(std::string* out, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayPresentInfoKHR>(std::string* out, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPresentInfoKHR *pstruct = (const VkDisplayPresentInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkRect2D srcRect
    IndentSpaces(out, indent);
    *out += "srcRect:                        ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.srcRect, indent+1,  base_addr + offsetof(VkDisplayPresentInfoKHR, srcRect)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkRect2D dstRect
    IndentSpaces(out, indent);
    *out += "dstRect:                        ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.dstRect, indent+1,  base_addr + offsetof(VkDisplayPresentInfoKHR, dstRect)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkBool32 persistent
    IndentSpaces(out, indent);
    *out += "persistent:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->persistent); //EQA
}

void VulkanAsciiConsumer::Process_vkCreateSharedSwapchainsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    const StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchains)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t swapchainCount
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, swapchainCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkSwapchainCreateInfoKHR* pCreateInfos
    IndentSpaces(out, indent);
    *out += "pCreateInfos:                   ";
    *out += "const VkSwapchainCreateInfoKHR* = "; // TEQ
    if (pCreateInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSwapchainCreateInfoKHR>(out, indent+1, 1, "VkSwapchainCreateInfoKHR", pCreateInfos.GetMetaStructPointer(), "pCreateInfos", swapchainCount, false, pCreateInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR* pSwapchains
    IndentSpaces(out, indent);
    *out += "pSwapchains:                    ";
    *out += "VkSwapchainKHR* = "; // TEQ
    if (pSwapchains.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSwapchains.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        ArrayToString<VkSwapchainKHR*>(out, indent, 1, "VkSwapchainKHR*", reinterpret_cast<VkSwapchainKHR*>(pSwapchains.GetPointer()), "pSwapchains", swapchainCount,  vinfo_pSwapchains);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkXlibSurfaceCreateInfoKHR *pstruct = (const VkXlibSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkXlibSurfaceCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkXlibSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: void* dpy
    IndentSpaces(out, indent);
    *out += "dpy:                            ";
    *out += "void* = "; // TEQ
    AddrToString(out, pstruct_in.dpy); // PAQ
    *out += "\n"; // GDS

    // struct member: size_t window
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->window); // UYW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    dpy,
    size_t                                      visualID)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID)");
    fprintf(GetFile(), " returns %u:\n", returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queueFamilyIndex); // UYW
    outString += "\n";   // HHS

    // func arg: void* dpy
    IndentSpaces(out, indent);
    *out += "dpy:                            ";
    *out += "void* = "; // TEQ
    AddrToString(out, dpy); // PAQ
    outString += "\n";   // HHS

    // func arg: size_t visualID
    IndentSpaces(out, indent);
    *out += "visualID:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, visualID); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateXlibSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkXlibSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkXlibSurfaceCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkXlibSurfaceCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkXcbSurfaceCreateInfoKHR *pstruct = (const VkXcbSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkXcbSurfaceCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkXcbSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: void* connection
    IndentSpaces(out, indent);
    *out += "connection:                     ";
    *out += "void* = "; // TEQ
    if (pstruct->connection == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.connection); // PWR
    }
    *out += "\n"; // GDS

    // struct member: uint32_t window
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->window); // UYW
}

void VulkanAsciiConsumer::Process_vkCreateXcbSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkXcbSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkXcbSurfaceCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkXcbSurfaceCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    connection,
    uint32_t                                    visual_id)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id)");
    fprintf(GetFile(), " returns %u:\n", returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queueFamilyIndex); // UYW
    outString += "\n";   // HHS

    // func arg: void* connection
    IndentSpaces(out, indent);
    *out += "connection:                     ";
    *out += "void* = "; // TEQ
    if ( !connection) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, connection); // PWR
    }
    outString += "\n";   // HHS

    // func arg: uint32_t visual_id
    IndentSpaces(out, indent);
    *out += "visual_id:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, visual_id); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWaylandSurfaceCreateInfoKHR *pstruct = (const VkWaylandSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkWaylandSurfaceCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkWaylandSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: struct void* display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "struct void* = "; // TEQ
    if (pstruct->display == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.display); // PWR
    }
    *out += "\n"; // GDS

    // struct member: struct void* surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "struct void* = "; // TEQ
    if (pstruct->surface == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.surface); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateWaylandSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkWaylandSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkWaylandSurfaceCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkWaylandSurfaceCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    display)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display)");
    fprintf(GetFile(), " returns %u:\n", returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queueFamilyIndex); // UYW
    outString += "\n";   // HHS

    // func arg: struct void* display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "struct void* = "; // TEQ
    if ( !display) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, display); // PWR
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidSurfaceCreateInfoKHR *pstruct = (const VkAndroidSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAndroidSurfaceCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkAndroidSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: struct void* window
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "struct void* = "; // TEQ
    if (pstruct->window == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.window); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateAndroidSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkAndroidSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAndroidSurfaceCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkAndroidSurfaceCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWin32SurfaceCreateInfoKHR *pstruct = (const VkWin32SurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkWin32SurfaceCreateFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkWin32SurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: void* hinstance
    IndentSpaces(out, indent);
    *out += "hinstance:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->hinstance == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.hinstance); // PWR
    }
    *out += "\n"; // GDS

    // struct member: void* hwnd
    IndentSpaces(out, indent);
    *out += "hwnd:                           ";
    *out += "void* = "; // TEQ
    if (pstruct->hwnd == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.hwnd); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateWin32SurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkWin32SurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkWin32SurfaceCreateInfoKHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkWin32SurfaceCreateInfoKHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex)");
    fprintf(GetFile(), " returns %u:\n", returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t queueFamilyIndex
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queueFamilyIndex); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties2KHR(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties2>& pFormatProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, format);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkFormatProperties2* pFormatProperties
    IndentSpaces(out, indent);
    *out += "pFormatProperties:              ";
    *out += "VkFormatProperties2* = "; // TEQ
    if (pFormatProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFormatProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkFormatProperties2>(out, *pFormatProperties.GetMetaStructPointer(), indent+1,pFormatProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>& pImageFormatInfo,
    const StructPointerDecoder<Decoded_VkImageFormatProperties2>& pImageFormatProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo
    IndentSpaces(out, indent);
    *out += "pImageFormatInfo:               ";
    *out += "const VkPhysicalDeviceImageFormatInfo2* = "; // TEQ
    if (pImageFormatInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImageFormatInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(out, *pImageFormatInfo.GetMetaStructPointer(), indent+1,pImageFormatInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkImageFormatProperties2* pImageFormatProperties
    IndentSpaces(out, indent);
    *out += "pImageFormatProperties:         ";
    *out += "VkImageFormatProperties2* = "; // TEQ
    if (pImageFormatProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImageFormatProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageFormatProperties2>(out, *pImageFormatProperties.GetMetaStructPointer(), indent+1,pImageFormatProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>& pMemoryProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceMemoryProperties2* pMemoryProperties
    IndentSpaces(out, indent);
    *out += "pMemoryProperties:              ";
    *out += "VkPhysicalDeviceMemoryProperties2* = "; // TEQ
    if (pMemoryProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(out, *pMemoryProperties.GetMetaStructPointer(), indent+1,pMemoryProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>& pFeatures)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceFeatures2* pFeatures
    IndentSpaces(out, indent);
    *out += "pFeatures:                      ";
    *out += "VkPhysicalDeviceFeatures2* = "; // TEQ
    if (pFeatures.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFeatures.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceFeatures2>(out, *pFeatures.GetMetaStructPointer(), indent+1,pFeatures.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties2>& pQueueFamilyProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pQueueFamilyPropertyCount
    IndentSpaces(out, indent);
    *out += "pQueueFamilyPropertyCount:      ";
    *out += "uint32_t* = "; // TEQ
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pQueueFamilyPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pQueueFamilyPropertyCount.GetPointer(), vinfo_pQueueFamilyPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkQueueFamilyProperties2* pQueueFamilyProperties
    IndentSpaces(out, indent);
    *out += "pQueueFamilyProperties:         ";
    *out += "VkQueueFamilyProperties2* = "; // TEQ
    if (pQueueFamilyProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pQueueFamilyProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkQueueFamilyProperties2>(out, indent+1, 1, "VkQueueFamilyProperties2", pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>& pFormatInfo,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo
    IndentSpaces(out, indent);
    *out += "pFormatInfo:                    ";
    *out += "const VkPhysicalDeviceSparseImageFormatInfo2* = "; // TEQ
    if (pFormatInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFormatInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(out, *pFormatInfo.GetMetaStructPointer(), indent+1,pFormatInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSparseImageFormatProperties2* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkSparseImageFormatProperties2* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageFormatProperties2>(out, indent+1, 1, "VkSparseImageFormatProperties2", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceProperties2* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkPhysicalDeviceProperties2* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceProperties2>(out, *pProperties.GetMetaStructPointer(), indent+1,pProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdSetDeviceMaskKHR(
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t deviceMask
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, deviceMask); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    const PointerDecoder<VkPeerMemoryFeatureFlags>& pPeerMemoryFeatures)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t heapIndex
    IndentSpaces(out, indent);
    *out += "heapIndex:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, heapIndex); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t localDeviceIndex
    IndentSpaces(out, indent);
    *out += "localDeviceIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, localDeviceIndex); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t remoteDeviceIndex
    IndentSpaces(out, indent);
    *out += "remoteDeviceIndex:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, remoteDeviceIndex); // UYW
    outString += "\n";   // HHS

    // func arg: VkPeerMemoryFeatureFlags* pPeerMemoryFeatures
    IndentSpaces(out, indent);
    *out += "pPeerMemoryFeatures:            ";
    *out += "VkPeerMemoryFeatureFlags* = "; // TEQ
    if (pPeerMemoryFeatures.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPeerMemoryFeatures = {false, false, true, EnumToStringVkPeerMemoryFeatureFlagBits};
        ScalarValueToString(out, pPeerMemoryFeatures.GetPointer(), vinfo_pPeerMemoryFeatures); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchBaseKHR(
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t baseGroupX
    IndentSpaces(out, indent);
    *out += "baseGroupX:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, baseGroupX); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t baseGroupY
    IndentSpaces(out, indent);
    *out += "baseGroupY:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, baseGroupY); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t baseGroupZ
    IndentSpaces(out, indent);
    *out += "baseGroupZ:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, baseGroupZ); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountX
    IndentSpaces(out, indent);
    *out += "groupCountX:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountX); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountY
    IndentSpaces(out, indent);
    *out += "groupCountY:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountY); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCountZ
    IndentSpaces(out, indent);
    *out += "groupCountZ:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCountZ); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkTrimCommandPoolKHR(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkTrimCommandPoolKHR(device, commandPool, flags)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPool commandPool
    IndentSpaces(out, indent);
    *out += "commandPool:                    ";
    *out += "VkCommandPool = "; // TEQ
    AddrToString(out, commandPool); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCommandPoolTrimFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandPoolTrimFlags = "; // TEQ
    UnsignedDecimalToString(out, flags); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDeviceGroupsKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceGroupCount,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>& pPhysicalDeviceGroupProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPhysicalDeviceGroupCount
    IndentSpaces(out, indent);
    *out += "pPhysicalDeviceGroupCount:      ";
    *out += "uint32_t* = "; // TEQ
    if (pPhysicalDeviceGroupCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPhysicalDeviceGroupCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPhysicalDeviceGroupCount.GetPointer(), vinfo_pPhysicalDeviceGroupCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties
    IndentSpaces(out, indent);
    *out += "pPhysicalDeviceGroupProperties: ";
    *out += "VkPhysicalDeviceGroupProperties* = "; // TEQ
    if (pPhysicalDeviceGroupProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPhysicalDeviceGroupProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPhysicalDeviceGroupProperties>(out, indent+1, 1, "VkPhysicalDeviceGroupProperties", pPhysicalDeviceGroupProperties.GetMetaStructPointer(), "pPhysicalDeviceGroupProperties", *pPhysicalDeviceGroupCount.GetPointer(), false, pPhysicalDeviceGroupProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>& pExternalBufferInfo,
    const StructPointerDecoder<Decoded_VkExternalBufferProperties>& pExternalBufferProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo
    IndentSpaces(out, indent);
    *out += "pExternalBufferInfo:            ";
    *out += "const VkPhysicalDeviceExternalBufferInfo* = "; // TEQ
    if (pExternalBufferInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalBufferInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(out, *pExternalBufferInfo.GetMetaStructPointer(), indent+1,pExternalBufferInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkExternalBufferProperties* pExternalBufferProperties
    IndentSpaces(out, indent);
    *out += "pExternalBufferProperties:      ";
    *out += "VkExternalBufferProperties* = "; // TEQ
    if (pExternalBufferProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalBufferProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExternalBufferProperties>(out, *pExternalBufferProperties.GetMetaStructPointer(), indent+1,pExternalBufferProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkExportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(std::string* out, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkExportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportMemoryWin32HandleInfoKHR *pstruct = (const VkExportMemoryWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(out, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    *out += "\n"; // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess); // UYW
    *out += "\n"; // GDS

    // struct member: const wchar_t* name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(std::string* out, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryWin32HandlePropertiesKHR *pstruct = (const VkMemoryWin32HandlePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits); // UYW
}

template <>
void StructureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryGetWin32HandleInfoKHR *pstruct = (const VkMemoryGetWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkImportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryWin32HandleInfoKHR *pstruct = (const VkImportMemoryWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* handle
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
    *out += "\n"; // GDS

    // struct member: const wchar_t* name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandlePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    handle,
    const StructPointerDecoder<Decoded_VkMemoryWin32HandlePropertiesKHR>& pMemoryWin32HandleProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, handleType);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: void* handle
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if ( !handle) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, handle); // PWR
    }
    outString += "\n";   // HHS

    // func arg: VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties
    IndentSpaces(out, indent);
    *out += "pMemoryWin32HandleProperties:   ";
    *out += "VkMemoryWin32HandlePropertiesKHR* = "; // TEQ
    if (pMemoryWin32HandleProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryWin32HandleProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(out, *pMemoryWin32HandleProperties.GetMetaStructPointer(), indent+1,pMemoryWin32HandleProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo
    IndentSpaces(out, indent);
    *out += "pGetWin32HandleInfo:            ";
    *out += "const VkMemoryGetWin32HandleInfoKHR* = "; // TEQ
    if (pGetWin32HandleInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pGetWin32HandleInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(out, *pGetWin32HandleInfo.GetMetaStructPointer(), indent+1,pGetWin32HandleInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: void** pHandle
    IndentSpaces(out, indent);
    *out += "pHandle:                        ";
    *out += "void** = "; // TEQ
    if (pHandle.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pHandle = {false, false, false, nullptr};
        ScalarValueToString(out, pHandle.GetPointer(), vinfo_pHandle); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkImportMemoryFdInfoKHR>(std::string* out, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryFdPropertiesKHR>(std::string* out, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryGetFdInfoKHR>(std::string* out, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportMemoryFdInfoKHR>(std::string* out, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryFdInfoKHR *pstruct = (const VkImportMemoryFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: int fd
    IndentSpaces(out, indent);
    *out += "fd:                             ";
    *out += "int = "; // TEQ
    SignedDecimalToString(out, pstruct->fd); //EQA
}

template <>
void StructureToString<Decoded_VkMemoryFdPropertiesKHR>(std::string* out, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryFdPropertiesKHR *pstruct = (const VkMemoryFdPropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits); // UYW
}

template <>
void StructureToString<Decoded_VkMemoryGetFdInfoKHR>(std::string* out, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryGetFdInfoKHR *pstruct = (const VkMemoryGetFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetMemoryFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetMemoryFdKHR(device, pGetFdInfo, pFd)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkMemoryGetFdInfoKHR* pGetFdInfo
    IndentSpaces(out, indent);
    *out += "pGetFdInfo:                     ";
    *out += "const VkMemoryGetFdInfoKHR* = "; // TEQ
    if (pGetFdInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pGetFdInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryGetFdInfoKHR>(out, *pGetFdInfo.GetMetaStructPointer(), indent+1,pGetFdInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: int* pFd
    IndentSpaces(out, indent);
    *out += "pFd:                            ";
    *out += "int* = "; // TEQ
    if (pFd.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pFd = {false, false, false, nullptr};
        ScalarValueToString(out, pFd.GetPointer(), vinfo_pFd); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryFdPropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd,
    const StructPointerDecoder<Decoded_VkMemoryFdPropertiesKHR>& pMemoryFdProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, handleType);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: int fd
    IndentSpaces(out, indent);
    *out += "fd:                             ";
    *out += "int = "; // TEQ
    SignedDecimalToString(out, fd); //EQA
    outString += "\n";   // HHS

    // func arg: VkMemoryFdPropertiesKHR* pMemoryFdProperties
    IndentSpaces(out, indent);
    *out += "pMemoryFdProperties:            ";
    *out += "VkMemoryFdPropertiesKHR* = "; // TEQ
    if (pMemoryFdProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryFdProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryFdPropertiesKHR>(out, *pMemoryFdProperties.GetMetaStructPointer(), indent+1,pMemoryFdProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>& pExternalSemaphoreInfo,
    const StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>& pExternalSemaphoreProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo
    IndentSpaces(out, indent);
    *out += "pExternalSemaphoreInfo:         ";
    *out += "const VkPhysicalDeviceExternalSemaphoreInfo* = "; // TEQ
    if (pExternalSemaphoreInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalSemaphoreInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(out, *pExternalSemaphoreInfo.GetMetaStructPointer(), indent+1,pExternalSemaphoreInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkExternalSemaphoreProperties* pExternalSemaphoreProperties
    IndentSpaces(out, indent);
    *out += "pExternalSemaphoreProperties:   ";
    *out += "VkExternalSemaphoreProperties* = "; // TEQ
    if (pExternalSemaphoreProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalSemaphoreProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExternalSemaphoreProperties>(out, *pExternalSemaphoreProperties.GetMetaStructPointer(), indent+1,pExternalSemaphoreProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkD3D12FenceSubmitInfoKHR>(std::string* out, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreGetWin32HandleInfoKHR *pstruct = (const VkSemaphoreGetWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkD3D12FenceSubmitInfoKHR>(std::string* out, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkD3D12FenceSubmitInfoKHR *pstruct = (const VkD3D12FenceSubmitInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t waitSemaphoreValuesCount
    IndentSpaces(out, indent);
    *out += "waitSemaphoreValuesCount:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreValuesCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint64_t* pWaitSemaphoreValues
    IndentSpaces(out, indent);
    *out += "pWaitSemaphoreValues:           ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pstruct->waitSemaphoreValuesCount,  vinfo_pWaitSemaphoreValues);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t signalSemaphoreValuesCount
    IndentSpaces(out, indent);
    *out += "signalSemaphoreValuesCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreValuesCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint64_t* pSignalSemaphoreValues
    IndentSpaces(out, indent);
    *out += "pSignalSemaphoreValues:         ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pstruct->signalSemaphoreValuesCount,  vinfo_pSignalSemaphoreValues);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportSemaphoreWin32HandleInfoKHR *pstruct = (const VkImportSemaphoreWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // struct member: VkSemaphoreImportFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSemaphoreImportFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* handle
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
    *out += "\n"; // GDS

    // struct member: const wchar_t* name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkExportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportSemaphoreWin32HandleInfoKHR *pstruct = (const VkExportSemaphoreWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(out, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    *out += "\n"; // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess); // UYW
    *out += "\n"; // GDS

    // struct member: const wchar_t* name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

void VulkanAsciiConsumer::Process_vkImportSemaphoreWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportSemaphoreWin32HandleInfoKHR>& pImportSemaphoreWin32HandleInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo
    IndentSpaces(out, indent);
    *out += "pImportSemaphoreWin32HandleInfo: ";
    *out += "const VkImportSemaphoreWin32HandleInfoKHR* = "; // TEQ
    if (pImportSemaphoreWin32HandleInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImportSemaphoreWin32HandleInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(out, *pImportSemaphoreWin32HandleInfo.GetMetaStructPointer(), indent+1,pImportSemaphoreWin32HandleInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSemaphoreWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo
    IndentSpaces(out, indent);
    *out += "pGetWin32HandleInfo:            ";
    *out += "const VkSemaphoreGetWin32HandleInfoKHR* = "; // TEQ
    if (pGetWin32HandleInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pGetWin32HandleInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(out, *pGetWin32HandleInfo.GetMetaStructPointer(), indent+1,pGetWin32HandleInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: void** pHandle
    IndentSpaces(out, indent);
    *out += "pHandle:                        ";
    *out += "void** = "; // TEQ
    if (pHandle.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pHandle = {false, false, false, nullptr};
        ScalarValueToString(out, pHandle.GetPointer(), vinfo_pHandle); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkImportSemaphoreFdInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreGetFdInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportSemaphoreFdInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportSemaphoreFdInfoKHR *pstruct = (const VkImportSemaphoreFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // struct member: VkSemaphoreImportFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSemaphoreImportFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: int fd
    IndentSpaces(out, indent);
    *out += "fd:                             ";
    *out += "int = "; // TEQ
    SignedDecimalToString(out, pstruct->fd); //EQA
}

template <>
void StructureToString<Decoded_VkSemaphoreGetFdInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreGetFdInfoKHR *pstruct = (const VkSemaphoreGetFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetSemaphoreFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSemaphoreGetFdInfoKHR* pGetFdInfo
    IndentSpaces(out, indent);
    *out += "pGetFdInfo:                     ";
    *out += "const VkSemaphoreGetFdInfoKHR* = "; // TEQ
    if (pGetFdInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pGetFdInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSemaphoreGetFdInfoKHR>(out, *pGetFdInfo.GetMetaStructPointer(), indent+1,pGetFdInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: int* pFd
    IndentSpaces(out, indent);
    *out += "pFd:                            ";
    *out += "int* = "; // TEQ
    if (pFd.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pFd = {false, false, false, nullptr};
        ScalarValueToString(out, pFd.GetPointer(), vinfo_pFd); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkImportSemaphoreFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportSemaphoreFdInfoKHR>& pImportSemaphoreFdInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo
    IndentSpaces(out, indent);
    *out += "pImportSemaphoreFdInfo:         ";
    *out += "const VkImportSemaphoreFdInfoKHR* = "; // TEQ
    if (pImportSemaphoreFdInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImportSemaphoreFdInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImportSemaphoreFdInfoKHR>(out, *pImportSemaphoreFdInfo.GetMetaStructPointer(), indent+1,pImportSemaphoreFdInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR>(std::string* out, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR>(std::string* out, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevicePushDescriptorPropertiesKHR *pstruct = (const VkPhysicalDevicePushDescriptorPropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxPushDescriptors
    IndentSpaces(out, indent);
    *out += "maxPushDescriptors:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPushDescriptors); // UYW
}

void VulkanAsciiConsumer::Process_vkCmdPushDescriptorSetKHR(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const StructPointerDecoder<Decoded_VkWriteDescriptorSet>& pDescriptorWrites)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pipelineBindPoint); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pipelineBindPoint);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkPipelineLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, layout); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t set
    IndentSpaces(out, indent);
    *out += "set:                            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, set); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t descriptorWriteCount
    IndentSpaces(out, indent);
    *out += "descriptorWriteCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, descriptorWriteCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkWriteDescriptorSet* pDescriptorWrites
    IndentSpaces(out, indent);
    *out += "pDescriptorWrites:              ";
    *out += "const VkWriteDescriptorSet* = "; // TEQ
    if (pDescriptorWrites.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDescriptorWrites.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkWriteDescriptorSet>(out, indent+1, 1, "VkWriteDescriptorSet", pDescriptorWrites.GetMetaStructPointer(), "pDescriptorWrites", descriptorWriteCount, false, pDescriptorWrites.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkDestroyDescriptorUpdateTemplateKHR(
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDescriptorUpdateTemplate descriptorUpdateTemplate
    IndentSpaces(out, indent);
    *out += "descriptorUpdateTemplate:       ";
    *out += "VkDescriptorUpdateTemplate = "; // TEQ
    AddrToString(out, descriptorUpdateTemplate); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorUpdateTemplateKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorUpdateTemplate>& pDescriptorUpdateTemplate)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDescriptorUpdateTemplateCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate
    IndentSpaces(out, indent);
    *out += "pDescriptorUpdateTemplate:      ";
    *out += "VkDescriptorUpdateTemplate* = "; // TEQ
    if (pDescriptorUpdateTemplate.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDescriptorUpdateTemplate = {true, false, false, nullptr};
        ScalarValueToString(out, pDescriptorUpdateTemplate.GetPointer(), vinfo_pDescriptorUpdateTemplate); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkAttachmentReference2KHR>(std::string* out, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDependency2KHR>(std::string* out, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassBeginInfoKHR>(std::string* out, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDescription2KHR>(std::string* out, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassCreateInfo2KHR>(std::string* out, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentDescription2KHR>(std::string* out, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassEndInfoKHR>(std::string* out, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkAttachmentReference2KHR>(std::string* out, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentReference2KHR *pstruct = (const VkAttachmentReference2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t attachment
    IndentSpaces(out, indent);
    *out += "attachment:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachment); // UYW
    *out += "\n"; // GDS

    // struct member: VkImageLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->layout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->layout);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageAspectFlags aspectMask
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSubpassDependency2KHR>(std::string* out, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDependency2KHR *pstruct = (const VkSubpassDependency2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t srcSubpass
    IndentSpaces(out, indent);
    *out += "srcSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcSubpass); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dstSubpass
    IndentSpaces(out, indent);
    *out += "dstSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstSubpass); // UYW
    *out += "\n"; // GDS

    // struct member: VkPipelineStageFlags srcStageMask
    IndentSpaces(out, indent);
    *out += "srcStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkPipelineStageFlags dstStageMask
    IndentSpaces(out, indent);
    *out += "dstStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkAccessFlags srcAccessMask
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkAccessFlags dstAccessMask
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkDependencyFlags dependencyFlags
    IndentSpaces(out, indent);
    *out += "dependencyFlags:                ";
    *out += "VkDependencyFlags = "; // TEQ
    FlagsToString(out, pstruct->dependencyFlags, EnumToStringVkDependencyFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: int32_t viewOffset
    IndentSpaces(out, indent);
    *out += "viewOffset:                     ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->viewOffset); //EQA
}

template <>
void StructureToString<Decoded_VkSubpassBeginInfoKHR>(std::string* out, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassBeginInfoKHR *pstruct = (const VkSubpassBeginInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSubpassContents contents
    IndentSpaces(out, indent);
    *out += "contents:                       ";
    *out += "VkSubpassContents = "; // TEQ
    EnumToStringVkSubpassContents(out, pstruct->contents); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->contents);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSubpassDescription2KHR>(std::string* out, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDescription2KHR *pstruct = (const VkSubpassDescription2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSubpassDescriptionFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSubpassDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSubpassDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t viewMask
    IndentSpaces(out, indent);
    *out += "viewMask:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewMask); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t inputAttachmentCount
    IndentSpaces(out, indent);
    *out += "inputAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->inputAttachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference2KHR* pInputAttachments
    IndentSpaces(out, indent);
    *out += "pInputAttachments:              ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pInputAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInputAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(out, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t colorAttachmentCount
    IndentSpaces(out, indent);
    *out += "colorAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->colorAttachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference2KHR* pColorAttachments
    IndentSpaces(out, indent);
    *out += "pColorAttachments:              ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pColorAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pColorAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(out, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference2KHR* pResolveAttachments
    IndentSpaces(out, indent);
    *out += "pResolveAttachments:            ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pResolveAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pResolveAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(out, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: const VkAttachmentReference2KHR* pDepthStencilAttachment
    IndentSpaces(out, indent);
    *out += "pDepthStencilAttachment:        ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pDepthStencilAttachment == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDepthStencilAttachment->GetAddress()); // JHJ
        *out += ":";
        StructureToString<Decoded_VkAttachmentReference2KHR>(out, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkSubpassDescription2KHR, pDepthStencilAttachment)); // GLN
    }
    *out += "\n"; // GDS

    // struct member: uint32_t preserveAttachmentCount
    IndentSpaces(out, indent);
    *out += "preserveAttachmentCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->preserveAttachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pPreserveAttachments
    IndentSpaces(out, indent);
    *out += "pPreserveAttachments:           ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pPreserveAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPreserveAttachments.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pstruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkRenderPassCreateInfo2KHR>(std::string* out, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassCreateInfo2KHR *pstruct = (const VkRenderPassCreateInfo2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkRenderPassCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkRenderPassCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkRenderPassCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t attachmentCount
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAttachmentDescription2KHR* pAttachments
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkAttachmentDescription2KHR* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentDescription2KHR>(out, indent+1, 1, "VkAttachmentDescription2KHR", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t subpassCount
    IndentSpaces(out, indent);
    *out += "subpassCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSubpassDescription2KHR* pSubpasses
    IndentSpaces(out, indent);
    *out += "pSubpasses:                     ";
    *out += "const VkSubpassDescription2KHR* = "; // TEQ
    if (pstruct->pSubpasses == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSubpasses->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDescription2KHR>(out, indent+1, 1, "VkSubpassDescription2KHR", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t dependencyCount
    IndentSpaces(out, indent);
    *out += "dependencyCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dependencyCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSubpassDependency2KHR* pDependencies
    IndentSpaces(out, indent);
    *out += "pDependencies:                  ";
    *out += "const VkSubpassDependency2KHR* = "; // TEQ
    if (pstruct->pDependencies == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDependencies->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassDependency2KHR>(out, indent+1, 1, "VkSubpassDependency2KHR", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t correlatedViewMaskCount
    IndentSpaces(out, indent);
    *out += "correlatedViewMaskCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->correlatedViewMaskCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pCorrelatedViewMasks
    IndentSpaces(out, indent);
    *out += "pCorrelatedViewMasks:           ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCorrelatedViewMasks == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCorrelatedViewMasks.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCorrelatedViewMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCorrelatedViewMasks.GetPointer()), "pCorrelatedViewMasks", pstruct->correlatedViewMaskCount,  vinfo_pCorrelatedViewMasks);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkAttachmentDescription2KHR>(std::string* out, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentDescription2KHR *pstruct = (const VkAttachmentDescription2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAttachmentDescriptionFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkAttachmentDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkAttachmentDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlagBits samples
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentLoadOp loadOp
    IndentSpaces(out, indent);
    *out += "loadOp:                         ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->loadOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->loadOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentStoreOp storeOp
    IndentSpaces(out, indent);
    *out += "storeOp:                        ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->storeOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->storeOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentLoadOp stencilLoadOp
    IndentSpaces(out, indent);
    *out += "stencilLoadOp:                  ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->stencilLoadOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilLoadOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAttachmentStoreOp stencilStoreOp
    IndentSpaces(out, indent);
    *out += "stencilStoreOp:                 ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->stencilStoreOp); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilStoreOp);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageLayout initialLayout
    IndentSpaces(out, indent);
    *out += "initialLayout:                  ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->initialLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->initialLayout);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkImageLayout finalLayout
    IndentSpaces(out, indent);
    *out += "finalLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->finalLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->finalLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSubpassEndInfoKHR>(std::string* out, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassEndInfoKHR *pstruct = (const VkSubpassEndInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
}

void VulkanAsciiConsumer::Process_vkCmdBeginRenderPass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkRenderPassBeginInfo>& pRenderPassBegin,
    const StructPointerDecoder<Decoded_VkSubpassBeginInfoKHR>& pSubpassBeginInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkRenderPassBeginInfo* pRenderPassBegin
    IndentSpaces(out, indent);
    *out += "pRenderPassBegin:               ";
    *out += "const VkRenderPassBeginInfo* = "; // TEQ
    if (pRenderPassBegin.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pRenderPassBegin.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkRenderPassBeginInfo>(out, *pRenderPassBegin.GetMetaStructPointer(), indent+1,pRenderPassBegin.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkSubpassBeginInfoKHR* pSubpassBeginInfo
    IndentSpaces(out, indent);
    *out += "pSubpassBeginInfo:              ";
    *out += "const VkSubpassBeginInfoKHR* = "; // TEQ
    if (pSubpassBeginInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSubpassBeginInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSubpassBeginInfoKHR>(out, *pSubpassBeginInfo.GetMetaStructPointer(), indent+1,pSubpassBeginInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndRenderPass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSubpassEndInfoKHR>& pSubpassEndInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSubpassEndInfoKHR* pSubpassEndInfo
    IndentSpaces(out, indent);
    *out += "pSubpassEndInfo:                ";
    *out += "const VkSubpassEndInfoKHR* = "; // TEQ
    if (pSubpassEndInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSubpassEndInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSubpassEndInfoKHR>(out, *pSubpassEndInfo.GetMetaStructPointer(), indent+1,pSubpassEndInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateRenderPass2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkRenderPassCreateInfo2KHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkRenderPass>&   pRenderPass)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkRenderPassCreateInfo2KHR* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkRenderPassCreateInfo2KHR* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkRenderPassCreateInfo2KHR>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkRenderPass* pRenderPass
    IndentSpaces(out, indent);
    *out += "pRenderPass:                    ";
    *out += "VkRenderPass* = "; // TEQ
    if (pRenderPass.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pRenderPass = {true, false, false, nullptr};
        ScalarValueToString(out, pRenderPass.GetPointer(), vinfo_pRenderPass); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdNextSubpass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSubpassBeginInfoKHR>& pSubpassBeginInfo,
    const StructPointerDecoder<Decoded_VkSubpassEndInfoKHR>& pSubpassEndInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSubpassBeginInfoKHR* pSubpassBeginInfo
    IndentSpaces(out, indent);
    *out += "pSubpassBeginInfo:              ";
    *out += "const VkSubpassBeginInfoKHR* = "; // TEQ
    if (pSubpassBeginInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSubpassBeginInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSubpassBeginInfoKHR>(out, *pSubpassBeginInfo.GetMetaStructPointer(), indent+1,pSubpassBeginInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkSubpassEndInfoKHR* pSubpassEndInfo
    IndentSpaces(out, indent);
    *out += "pSubpassEndInfo:                ";
    *out += "const VkSubpassEndInfoKHR* = "; // TEQ
    if (pSubpassEndInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSubpassEndInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSubpassEndInfoKHR>(out, *pSubpassEndInfo.GetMetaStructPointer(), indent+1,pSubpassEndInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSharedPresentSurfaceCapabilitiesKHR *pstruct = (const VkSharedPresentSurfaceCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags sharedPresentSupportedUsageFlags
    IndentSpaces(out, indent);
    *out += "sharedPresentSupportedUsageFlags: ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->sharedPresentSupportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetSwapchainStatusKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetSwapchainStatusKHR(device, swapchain)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>& pExternalFenceInfo,
    const StructPointerDecoder<Decoded_VkExternalFenceProperties>& pExternalFenceProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo
    IndentSpaces(out, indent);
    *out += "pExternalFenceInfo:             ";
    *out += "const VkPhysicalDeviceExternalFenceInfo* = "; // TEQ
    if (pExternalFenceInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalFenceInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(out, *pExternalFenceInfo.GetMetaStructPointer(), indent+1,pExternalFenceInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkExternalFenceProperties* pExternalFenceProperties
    IndentSpaces(out, indent);
    *out += "pExternalFenceProperties:       ";
    *out += "VkExternalFenceProperties* = "; // TEQ
    if (pExternalFenceProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalFenceProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExternalFenceProperties>(out, *pExternalFenceProperties.GetMetaStructPointer(), indent+1,pExternalFenceProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportFenceWin32HandleInfoKHR *pstruct = (const VkImportFenceWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // struct member: VkFenceImportFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFenceImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFenceImportFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* handle
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
    *out += "\n"; // GDS

    // struct member: const wchar_t* name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFenceGetWin32HandleInfoKHR *pstruct = (const VkFenceGetWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportFenceWin32HandleInfoKHR *pstruct = (const VkExportFenceWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(out, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    *out += "\n"; // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess); // UYW
    *out += "\n"; // GDS

    // struct member: const wchar_t* name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

void VulkanAsciiConsumer::Process_vkGetFenceWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo
    IndentSpaces(out, indent);
    *out += "pGetWin32HandleInfo:            ";
    *out += "const VkFenceGetWin32HandleInfoKHR* = "; // TEQ
    if (pGetWin32HandleInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pGetWin32HandleInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(out, *pGetWin32HandleInfo.GetMetaStructPointer(), indent+1,pGetWin32HandleInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: void** pHandle
    IndentSpaces(out, indent);
    *out += "pHandle:                        ";
    *out += "void** = "; // TEQ
    if (pHandle.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pHandle = {false, false, false, nullptr};
        ScalarValueToString(out, pHandle.GetPointer(), vinfo_pHandle); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkImportFenceWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportFenceWin32HandleInfoKHR>& pImportFenceWin32HandleInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo
    IndentSpaces(out, indent);
    *out += "pImportFenceWin32HandleInfo:    ";
    *out += "const VkImportFenceWin32HandleInfoKHR* = "; // TEQ
    if (pImportFenceWin32HandleInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImportFenceWin32HandleInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(out, *pImportFenceWin32HandleInfo.GetMetaStructPointer(), indent+1,pImportFenceWin32HandleInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkImportFenceFdInfoKHR>(std::string* out, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFenceGetFdInfoKHR>(std::string* out, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportFenceFdInfoKHR>(std::string* out, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportFenceFdInfoKHR *pstruct = (const VkImportFenceFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // struct member: VkFenceImportFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFenceImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFenceImportFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: int fd
    IndentSpaces(out, indent);
    *out += "fd:                             ";
    *out += "int = "; // TEQ
    SignedDecimalToString(out, pstruct->fd); //EQA
}

template <>
void StructureToString<Decoded_VkFenceGetFdInfoKHR>(std::string* out, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFenceGetFdInfoKHR *pstruct = (const VkFenceGetFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFence fence
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetFenceFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetFenceFdKHR(device, pGetFdInfo, pFd)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkFenceGetFdInfoKHR* pGetFdInfo
    IndentSpaces(out, indent);
    *out += "pGetFdInfo:                     ";
    *out += "const VkFenceGetFdInfoKHR* = "; // TEQ
    if (pGetFdInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pGetFdInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkFenceGetFdInfoKHR>(out, *pGetFdInfo.GetMetaStructPointer(), indent+1,pGetFdInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: int* pFd
    IndentSpaces(out, indent);
    *out += "pFd:                            ";
    *out += "int* = "; // TEQ
    if (pFd.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pFd = {false, false, false, nullptr};
        ScalarValueToString(out, pFd.GetPointer(), vinfo_pFd); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkImportFenceFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportFenceFdInfoKHR>& pImportFenceFdInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkImportFenceFdKHR(device, pImportFenceFdInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImportFenceFdInfoKHR* pImportFenceFdInfo
    IndentSpaces(out, indent);
    *out += "pImportFenceFdInfo:             ";
    *out += "const VkImportFenceFdInfoKHR* = "; // TEQ
    if (pImportFenceFdInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pImportFenceFdInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImportFenceFdInfoKHR>(out, *pImportFenceFdInfo.GetMetaStructPointer(), indent+1,pImportFenceFdInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(std::string* out, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceCapabilities2KHR>(std::string* out, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceFormat2KHR>(std::string* out, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(std::string* out, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSurfaceInfo2KHR *pstruct = (const VkPhysicalDeviceSurfaceInfo2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, pstruct_in.surface); // PAQ
}

template <>
void StructureToString<Decoded_VkSurfaceCapabilities2KHR>(std::string* out, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilities2KHR *pstruct = (const VkSurfaceCapabilities2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSurfaceCapabilitiesKHR surfaceCapabilities
    IndentSpaces(out, indent);
    *out += "surfaceCapabilities:            ";
    *out += "VkSurfaceCapabilitiesKHR = "; // TEQ
    StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(out, *pstruct_in.surfaceCapabilities, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2KHR, surfaceCapabilities)); // AZJ
}

template <>
void StructureToString<Decoded_VkSurfaceFormat2KHR>(std::string* out, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFormat2KHR *pstruct = (const VkSurfaceFormat2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSurfaceFormatKHR surfaceFormat
    IndentSpaces(out, indent);
    *out += "surfaceFormat:                  ";
    *out += "VkSurfaceFormatKHR = "; // TEQ
    StructureToString<Decoded_VkSurfaceFormatKHR>(out, *pstruct_in.surfaceFormat, indent+1,  base_addr + offsetof(VkSurfaceFormat2KHR, surfaceFormat)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilities2KHR>& pSurfaceCapabilities)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo
    IndentSpaces(out, indent);
    *out += "pSurfaceInfo:                   ";
    *out += "const VkPhysicalDeviceSurfaceInfo2KHR* = "; // TEQ
    if (pSurfaceInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(out, *pSurfaceInfo.GetMetaStructPointer(), indent+1,pSurfaceInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceCapabilities2KHR* pSurfaceCapabilities
    IndentSpaces(out, indent);
    *out += "pSurfaceCapabilities:           ";
    *out += "VkSurfaceCapabilities2KHR* = "; // TEQ
    if (pSurfaceCapabilities.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceCapabilities.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSurfaceCapabilities2KHR>(out, *pSurfaceCapabilities.GetMetaStructPointer(), indent+1,pSurfaceCapabilities.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<uint32_t>&             pSurfaceFormatCount,
    const StructPointerDecoder<Decoded_VkSurfaceFormat2KHR>& pSurfaceFormats)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo
    IndentSpaces(out, indent);
    *out += "pSurfaceInfo:                   ";
    *out += "const VkPhysicalDeviceSurfaceInfo2KHR* = "; // TEQ
    if (pSurfaceInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(out, *pSurfaceInfo.GetMetaStructPointer(), indent+1,pSurfaceInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pSurfaceFormatCount
    IndentSpaces(out, indent);
    *out += "pSurfaceFormatCount:            ";
    *out += "uint32_t* = "; // TEQ
    if (pSurfaceFormatCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurfaceFormatCount = {false, false, false, nullptr};
        ScalarValueToString(out, pSurfaceFormatCount.GetPointer(), vinfo_pSurfaceFormatCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceFormat2KHR* pSurfaceFormats
    IndentSpaces(out, indent);
    *out += "pSurfaceFormats:                ";
    *out += "VkSurfaceFormat2KHR* = "; // TEQ
    if (pSurfaceFormats.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceFormats.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSurfaceFormat2KHR>(out, indent+1, 1, "VkSurfaceFormat2KHR", pSurfaceFormats.GetMetaStructPointer(), "pSurfaceFormats", *pSurfaceFormatCount.GetPointer(), false, pSurfaceFormats.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlaneProperties2KHR>(std::string* out, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayProperties2KHR>(std::string* out, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlaneInfo2KHR>(std::string* out, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModeProperties2KHR>(std::string* out, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneCapabilities2KHR *pstruct = (const VkDisplayPlaneCapabilities2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayPlaneCapabilitiesKHR capabilities
    IndentSpaces(out, indent);
    *out += "capabilities:                   ";
    *out += "VkDisplayPlaneCapabilitiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(out, *pstruct_in.capabilities, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilities2KHR, capabilities)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayPlaneProperties2KHR>(std::string* out, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneProperties2KHR *pstruct = (const VkDisplayPlaneProperties2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayPlanePropertiesKHR displayPlaneProperties
    IndentSpaces(out, indent);
    *out += "displayPlaneProperties:         ";
    *out += "VkDisplayPlanePropertiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayPlanePropertiesKHR>(out, *pstruct_in.displayPlaneProperties, indent+1,  base_addr + offsetof(VkDisplayPlaneProperties2KHR, displayPlaneProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayProperties2KHR>(std::string* out, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayProperties2KHR *pstruct = (const VkDisplayProperties2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayPropertiesKHR displayProperties
    IndentSpaces(out, indent);
    *out += "displayProperties:              ";
    *out += "VkDisplayPropertiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayPropertiesKHR>(out, *pstruct_in.displayProperties, indent+1,  base_addr + offsetof(VkDisplayProperties2KHR, displayProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayPlaneInfo2KHR>(std::string* out, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneInfo2KHR *pstruct = (const VkDisplayPlaneInfo2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayModeKHR mode
    IndentSpaces(out, indent);
    *out += "mode:                           ";
    *out += "VkDisplayModeKHR = "; // TEQ
    AddrToString(out, pstruct_in.mode); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t planeIndex
    IndentSpaces(out, indent);
    *out += "planeIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->planeIndex); // UYW
}

template <>
void StructureToString<Decoded_VkDisplayModeProperties2KHR>(std::string* out, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModeProperties2KHR *pstruct = (const VkDisplayModeProperties2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayModePropertiesKHR displayModeProperties
    IndentSpaces(out, indent);
    *out += "displayModeProperties:          ";
    *out += "VkDisplayModePropertiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayModePropertiesKHR>(out, *pstruct_in.displayModeProperties, indent+1,  base_addr + offsetof(VkDisplayModeProperties2KHR, displayModeProperties)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetDisplayModeProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayModeProperties2KHR>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, display); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayModeProperties2KHR* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkDisplayModeProperties2KHR* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDisplayModeProperties2KHR>(out, indent+1, 1, "VkDisplayModeProperties2KHR", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPlaneProperties2KHR>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayPlaneProperties2KHR* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkDisplayPlaneProperties2KHR* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDisplayPlaneProperties2KHR>(out, indent+1, 1, "VkDisplayPlaneProperties2KHR", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneCapabilities2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDisplayPlaneInfo2KHR>& pDisplayPlaneInfo,
    const StructPointerDecoder<Decoded_VkDisplayPlaneCapabilities2KHR>& pCapabilities)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo
    IndentSpaces(out, indent);
    *out += "pDisplayPlaneInfo:              ";
    *out += "const VkDisplayPlaneInfo2KHR* = "; // TEQ
    if (pDisplayPlaneInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDisplayPlaneInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDisplayPlaneInfo2KHR>(out, *pDisplayPlaneInfo.GetMetaStructPointer(), indent+1,pDisplayPlaneInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayPlaneCapabilities2KHR* pCapabilities
    IndentSpaces(out, indent);
    *out += "pCapabilities:                  ";
    *out += "VkDisplayPlaneCapabilities2KHR* = "; // TEQ
    if (pCapabilities.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCapabilities.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(out, *pCapabilities.GetMetaStructPointer(), indent+1,pCapabilities.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayProperties2KHR>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkDisplayProperties2KHR* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkDisplayProperties2KHR* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDisplayProperties2KHR>(out, indent+1, 1, "VkDisplayProperties2KHR", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageMemoryRequirementsInfo2* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkImageMemoryRequirementsInfo2* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkMemoryRequirements2* pMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pMemoryRequirements:            ";
    *out += "VkMemoryRequirements2* = "; // TEQ
    if (pMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRequirements.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryRequirements2>(out, *pMemoryRequirements.GetMetaStructPointer(), indent+1,pMemoryRequirements.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkBufferMemoryRequirementsInfo2* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkBufferMemoryRequirementsInfo2* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkMemoryRequirements2* pMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pMemoryRequirements:            ";
    *out += "VkMemoryRequirements2* = "; // TEQ
    if (pMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRequirements.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryRequirements2>(out, *pMemoryRequirements.GetMetaStructPointer(), indent+1,pMemoryRequirements.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>& pInfo,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>& pSparseMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageSparseMemoryRequirementsInfo2* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkImageSparseMemoryRequirementsInfo2* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pSparseMemoryRequirementCount
    IndentSpaces(out, indent);
    *out += "pSparseMemoryRequirementCount:  ";
    *out += "uint32_t* = "; // TEQ
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSparseMemoryRequirementCount = {false, false, false, nullptr};
        ScalarValueToString(out, pSparseMemoryRequirementCount.GetPointer(), vinfo_pSparseMemoryRequirementCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkSparseImageMemoryRequirements2* pSparseMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pSparseMemoryRequirements:      ";
    *out += "VkSparseImageMemoryRequirements2* = "; // TEQ
    if (pSparseMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSparseMemoryRequirements.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements2>(out, indent+1, 1, "VkSparseImageMemoryRequirements2", pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkCreateSamplerYcbcrConversionKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSamplerYcbcrConversion>& pYcbcrConversion)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSamplerYcbcrConversionCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkSamplerYcbcrConversionCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSamplerYcbcrConversion* pYcbcrConversion
    IndentSpaces(out, indent);
    *out += "pYcbcrConversion:               ";
    *out += "VkSamplerYcbcrConversion* = "; // TEQ
    if (pYcbcrConversion.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pYcbcrConversion = {true, false, false, nullptr};
        ScalarValueToString(out, pYcbcrConversion.GetPointer(), vinfo_pYcbcrConversion); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySamplerYcbcrConversionKHR(
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSamplerYcbcrConversion ycbcrConversion
    IndentSpaces(out, indent);
    *out += "ycbcrConversion:                ";
    *out += "VkSamplerYcbcrConversion = "; // TEQ
    AddrToString(out, ycbcrConversion); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkBindImageMemory2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindImageMemoryInfo>& pBindInfos)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t bindInfoCount
    IndentSpaces(out, indent);
    *out += "bindInfoCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBindImageMemoryInfo* pBindInfos
    IndentSpaces(out, indent);
    *out += "pBindInfos:                     ";
    *out += "const VkBindImageMemoryInfo* = "; // TEQ
    if (pBindInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBindInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBindImageMemoryInfo>(out, indent+1, 1, "VkBindImageMemoryInfo", pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindBufferMemory2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>& pBindInfos)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t bindInfoCount
    IndentSpaces(out, indent);
    *out += "bindInfoCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBindBufferMemoryInfo* pBindInfos
    IndentSpaces(out, indent);
    *out += "pBindInfos:                     ";
    *out += "const VkBindBufferMemoryInfo* = "; // TEQ
    if (pBindInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBindInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBindBufferMemoryInfo>(out, indent+1, 1, "VkBindBufferMemoryInfo", pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetDescriptorSetLayoutSupportKHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>& pSupport)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDescriptorSetLayoutCreateInfo* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDescriptorSetLayoutCreateInfo* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDescriptorSetLayoutSupport* pSupport
    IndentSpaces(out, indent);
    *out += "pSupport:                       ";
    *out += "VkDescriptorSetLayoutSupport* = "; // TEQ
    if (pSupport.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSupport.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDescriptorSetLayoutSupport>(out, *pSupport.GetMetaStructPointer(), indent+1,pSupport.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirectCountKHR(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer countBuffer
    IndentSpaces(out, indent);
    *out += "countBuffer:                    ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, countBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize countBufferOffset
    IndentSpaces(out, indent);
    *out += "countBufferOffset:              ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, countBufferOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t maxDrawCount
    IndentSpaces(out, indent);
    *out += "maxDrawCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, maxDrawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndirectCountKHR(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer countBuffer
    IndentSpaces(out, indent);
    *out += "countBuffer:                    ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, countBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize countBufferOffset
    IndentSpaces(out, indent);
    *out += "countBufferOffset:              ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, countBufferOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t maxDrawCount
    IndentSpaces(out, indent);
    *out += "maxDrawCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, maxDrawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSemaphoreTypeCreateInfoKHR>(std::string* out, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreWaitInfoKHR>(std::string* out, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkTimelineSemaphoreSubmitInfoKHR>(std::string* out, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreSignalInfoKHR>(std::string* out, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSemaphoreTypeCreateInfoKHR>(std::string* out, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreTypeCreateInfoKHR *pstruct = (const VkSemaphoreTypeCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphoreTypeKHR semaphoreType
    IndentSpaces(out, indent);
    *out += "semaphoreType:                  ";
    *out += "VkSemaphoreTypeKHR = "; // TEQ
    EnumToStringVkSemaphoreTypeKHR(out, pstruct->semaphoreType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->semaphoreType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint64_t initialValue
    IndentSpaces(out, indent);
    *out += "initialValue:                   ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->initialValue); // UYW
}

template <>
void StructureToString<Decoded_VkSemaphoreWaitInfoKHR>(std::string* out, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreWaitInfoKHR *pstruct = (const VkSemaphoreWaitInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphoreWaitFlagsKHR flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreWaitFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSemaphoreWaitFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t semaphoreCount
    IndentSpaces(out, indent);
    *out += "semaphoreCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->semaphoreCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSemaphore* pSemaphores
    IndentSpaces(out, indent);
    *out += "pSemaphores:                    ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pSemaphores == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSemaphores.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSemaphores.GetPointer()), "pSemaphores", pstruct->semaphoreCount,  vinfo_pSemaphores);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: const uint64_t* pValues
    IndentSpaces(out, indent);
    *out += "pValues:                        ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pValues == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pValues.GetPointer()), "pValues", pstruct->semaphoreCount,  vinfo_pValues);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkTimelineSemaphoreSubmitInfoKHR>(std::string* out, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkTimelineSemaphoreSubmitInfoKHR *pstruct = (const VkTimelineSemaphoreSubmitInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t waitSemaphoreValueCount
    IndentSpaces(out, indent);
    *out += "waitSemaphoreValueCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreValueCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint64_t* pWaitSemaphoreValues
    IndentSpaces(out, indent);
    *out += "pWaitSemaphoreValues:           ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pstruct->waitSemaphoreValueCount,  vinfo_pWaitSemaphoreValues);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: uint32_t signalSemaphoreValueCount
    IndentSpaces(out, indent);
    *out += "signalSemaphoreValueCount:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreValueCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint64_t* pSignalSemaphoreValues
    IndentSpaces(out, indent);
    *out += "pSignalSemaphoreValues:         ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphoreValues.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pstruct->signalSemaphoreValueCount,  vinfo_pSignalSemaphoreValues);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *pstruct = (const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint64_t maxTimelineSemaphoreValueDifference
    IndentSpaces(out, indent);
    *out += "maxTimelineSemaphoreValueDifference: ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTimelineSemaphoreValueDifference); // UYW
}

template <>
void StructureToString<Decoded_VkSemaphoreSignalInfoKHR>(std::string* out, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreSignalInfoKHR *pstruct = (const VkSemaphoreSignalInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // struct member: uint64_t value
    IndentSpaces(out, indent);
    *out += "value:                          ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->value); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *pstruct = (const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 timelineSemaphore
    IndentSpaces(out, indent);
    *out += "timelineSemaphore:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->timelineSemaphore); //EQA
}

void VulkanAsciiConsumer::Process_vkGetSemaphoreCounterValueKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            semaphore,
    const PointerDecoder<uint64_t>&             pValue)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetSemaphoreCounterValueKHR(device, semaphore, pValue)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSemaphore semaphore
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, semaphore); // PAQ
    outString += "\n";   // HHS

    // func arg: uint64_t* pValue
    IndentSpaces(out, indent);
    *out += "pValue:                         ";
    *out += "uint64_t* = "; // TEQ
    if (pValue.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pValue = {false, false, false, nullptr};
        ScalarValueToString(out, pValue.GetPointer(), vinfo_pValue); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkSignalSemaphoreKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreSignalInfoKHR>& pSignalInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkSignalSemaphoreKHR(device, pSignalInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSemaphoreSignalInfoKHR* pSignalInfo
    IndentSpaces(out, indent);
    *out += "pSignalInfo:                    ";
    *out += "const VkSemaphoreSignalInfoKHR* = "; // TEQ
    if (pSignalInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSignalInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSemaphoreSignalInfoKHR>(out, *pSignalInfo.GetMetaStructPointer(), indent+1,pSignalInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkWaitSemaphoresKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreWaitInfoKHR>& pWaitInfo,
    uint64_t                                    timeout)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkWaitSemaphoresKHR(device, pWaitInfo, timeout)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSemaphoreWaitInfoKHR* pWaitInfo
    IndentSpaces(out, indent);
    *out += "pWaitInfo:                      ";
    *out += "const VkSemaphoreWaitInfoKHR* = "; // TEQ
    if (pWaitInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pWaitInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSemaphoreWaitInfoKHR>(out, *pWaitInfo.GetMetaStructPointer(), indent+1,pWaitInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint64_t timeout
    IndentSpaces(out, indent);
    *out += "timeout:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, timeout); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPipelineExecutablePropertiesKHR>(std::string* out, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(std::string* out, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableInfoKHR>(std::string* out, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableStatisticKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineInfoKHR>(std::string* out, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPipelineExecutablePropertiesKHR>(std::string* out, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutablePropertiesKHR *pstruct = (const VkPipelineExecutablePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkShaderStageFlags stages
    IndentSpaces(out, indent);
    *out += "stages:                         ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stages, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: char name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *out += "\n"; // GDS

    // struct member: char description
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t subgroupSize
    IndentSpaces(out, indent);
    *out += "subgroupSize:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subgroupSize); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *pstruct = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 pipelineExecutableInfo
    IndentSpaces(out, indent);
    *out += "pipelineExecutableInfo:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->pipelineExecutableInfo); //EQA
}

template <>
void StructureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableStatisticValueKHR *pstruct = (const VkPipelineExecutableStatisticValueKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkBool32 b32
    IndentSpaces(out, indent);
    *out += "b32:                            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->b32); //EQA
    *out += "\n"; // GDS

    // struct member: int64_t i64
    IndentSpaces(out, indent);
    *out += "i64:                            ";
    *out += "int64_t = "; // TEQ
    SignedDecimalToString(out, pstruct->i64); //EQA
    *out += "\n"; // GDS

    // struct member: uint64_t u64
    IndentSpaces(out, indent);
    *out += "u64:                            ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->u64); // UYW
    *out += "\n"; // GDS

    // struct member: double f64
    IndentSpaces(out, indent);
    *out += "f64:                            ";
    *out += "double = "; // TEQ
    DoubleToString(out, pstruct->f64); // PEZ
}

template <>
void StructureToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(std::string* out, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableInternalRepresentationKHR *pstruct = (const VkPipelineExecutableInternalRepresentationKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: char name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *out += "\n"; // GDS

    // struct member: char description
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *out += "\n"; // GDS

    // struct member: VkBool32 isText
    IndentSpaces(out, indent);
    *out += "isText:                         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->isText); //EQA
    *out += "\n"; // GDS

    // struct member: size_t dataSize
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dataSize); // UYW
    *out += "\n"; // GDS

    // struct member: void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pData == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pData.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkPipelineExecutableInfoKHR>(std::string* out, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableInfoKHR *pstruct = (const VkPipelineExecutableInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.pipeline); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t executableIndex
    IndentSpaces(out, indent);
    *out += "executableIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->executableIndex); // UYW
}

template <>
void StructureToString<Decoded_VkPipelineExecutableStatisticKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableStatisticKHR *pstruct = (const VkPipelineExecutableStatisticKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: char name
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *out += "\n"; // GDS

    // struct member: char description
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ScalarValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *out += "\n"; // GDS

    // struct member: VkPipelineExecutableStatisticFormatKHR format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkPipelineExecutableStatisticFormatKHR = "; // TEQ
    EnumToStringVkPipelineExecutableStatisticFormatKHR(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkPipelineExecutableStatisticValueKHR value
    IndentSpaces(out, indent);
    *out += "value:                          ";
    *out += "VkPipelineExecutableStatisticValueKHR = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(out, *pstruct_in.value, indent+1,  base_addr + offsetof(VkPipelineExecutableStatisticKHR, value)); // AZJ
}

template <>
void StructureToString<Decoded_VkPipelineInfoKHR>(std::string* out, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineInfoKHR *pstruct = (const VkPipelineInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.pipeline); // PAQ
}

void VulkanAsciiConsumer::Process_vkGetPipelineExecutablePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineInfoKHR>& pPipelineInfo,
    const PointerDecoder<uint32_t>&             pExecutableCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutablePropertiesKHR>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPipelineInfoKHR* pPipelineInfo
    IndentSpaces(out, indent);
    *out += "pPipelineInfo:                  ";
    *out += "const VkPipelineInfoKHR* = "; // TEQ
    if (pPipelineInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPipelineInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPipelineInfoKHR>(out, *pPipelineInfo.GetMetaStructPointer(), indent+1,pPipelineInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pExecutableCount
    IndentSpaces(out, indent);
    *out += "pExecutableCount:               ";
    *out += "uint32_t* = "; // TEQ
    if (pExecutableCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pExecutableCount = {false, false, false, nullptr};
        ScalarValueToString(out, pExecutableCount.GetPointer(), vinfo_pExecutableCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPipelineExecutablePropertiesKHR* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkPipelineExecutablePropertiesKHR* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPipelineExecutablePropertiesKHR>(out, indent+1, 1, "VkPipelineExecutablePropertiesKHR", pProperties.GetMetaStructPointer(), "pProperties", *pExecutableCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineExecutableInternalRepresentationsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>& pExecutableInfo,
    const PointerDecoder<uint32_t>&             pInternalRepresentationCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInternalRepresentationKHR>& pInternalRepresentations)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPipelineExecutableInfoKHR* pExecutableInfo
    IndentSpaces(out, indent);
    *out += "pExecutableInfo:                ";
    *out += "const VkPipelineExecutableInfoKHR* = "; // TEQ
    if (pExecutableInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExecutableInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPipelineExecutableInfoKHR>(out, *pExecutableInfo.GetMetaStructPointer(), indent+1,pExecutableInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pInternalRepresentationCount
    IndentSpaces(out, indent);
    *out += "pInternalRepresentationCount:   ";
    *out += "uint32_t* = "; // TEQ
    if (pInternalRepresentationCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pInternalRepresentationCount = {false, false, false, nullptr};
        ScalarValueToString(out, pInternalRepresentationCount.GetPointer(), vinfo_pInternalRepresentationCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations
    IndentSpaces(out, indent);
    *out += "pInternalRepresentations:       ";
    *out += "VkPipelineExecutableInternalRepresentationKHR* = "; // TEQ
    if (pInternalRepresentations.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInternalRepresentations.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(out, indent+1, 1, "VkPipelineExecutableInternalRepresentationKHR", pInternalRepresentations.GetMetaStructPointer(), "pInternalRepresentations", *pInternalRepresentationCount.GetPointer(), false, pInternalRepresentations.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineExecutableStatisticsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>& pExecutableInfo,
    const PointerDecoder<uint32_t>&             pStatisticCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutableStatisticKHR>& pStatistics)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPipelineExecutableInfoKHR* pExecutableInfo
    IndentSpaces(out, indent);
    *out += "pExecutableInfo:                ";
    *out += "const VkPipelineExecutableInfoKHR* = "; // TEQ
    if (pExecutableInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExecutableInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPipelineExecutableInfoKHR>(out, *pExecutableInfo.GetMetaStructPointer(), indent+1,pExecutableInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pStatisticCount
    IndentSpaces(out, indent);
    *out += "pStatisticCount:                ";
    *out += "uint32_t* = "; // TEQ
    if (pStatisticCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pStatisticCount = {false, false, false, nullptr};
        ScalarValueToString(out, pStatisticCount.GetPointer(), vinfo_pStatisticCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPipelineExecutableStatisticKHR* pStatistics
    IndentSpaces(out, indent);
    *out += "pStatistics:                    ";
    *out += "VkPipelineExecutableStatisticKHR* = "; // TEQ
    if (pStatistics.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pStatistics.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPipelineExecutableStatisticKHR>(out, indent+1, 1, "VkPipelineExecutableStatisticKHR", pStatistics.GetMetaStructPointer(), "pStatistics", *pStatisticCount.GetPointer(), false, pStatistics.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(std::string* out, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(std::string* out, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugReportCallbackCreateInfoEXT *pstruct = (const VkDebugReportCallbackCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDebugReportFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDebugReportFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDebugReportFlagBitsEXT); // URW
    *out += "\n"; // GDS

    // struct member: PFN_vkDebugReportCallbackEXT pfnCallback
    IndentSpaces(out, indent);
    *out += "pfnCallback:                    ";
    *out += "PFN_vkDebugReportCallbackEXT = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnCallback)); // WRX
    *out += "\n"; // GDS

    // struct member: void* pUserData
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkDestroyDebugReportCallbackEXT(
    format::HandleId                            instance,
    format::HandleId                            callback,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDebugReportCallbackEXT callback
    IndentSpaces(out, indent);
    *out += "callback:                       ";
    *out += "VkDebugReportCallbackEXT = "; // TEQ
    AddrToString(out, callback); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDebugReportCallbackEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDebugReportCallbackCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDebugReportCallbackEXT>& pCallback)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugReportCallbackCreateInfoEXT* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDebugReportCallbackCreateInfoEXT* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDebugReportCallbackEXT* pCallback
    IndentSpaces(out, indent);
    *out += "pCallback:                      ";
    *out += "VkDebugReportCallbackEXT* = "; // TEQ
    if (pCallback.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pCallback = {true, false, false, nullptr};
        ScalarValueToString(out, pCallback.GetPointer(), vinfo_pCallback); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDebugReportMessageEXT(
    format::HandleId                            instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const StringDecoder&                        pLayerPrefix,
    const StringDecoder&                        pMessage)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDebugReportFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDebugReportFlagsEXT = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkDebugReportFlagBitsEXT); // URW
    outString += "\n";   // HHS

    // func arg: VkDebugReportObjectTypeEXT objectType
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkDebugReportObjectTypeEXT = "; // TEQ
    EnumToStringVkDebugReportObjectTypeEXT(out, objectType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, objectType);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint64_t object
    IndentSpaces(out, indent);
    *out += "object:                         ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, object); // UYW
    outString += "\n";   // HHS

    // func arg: size_t location
    IndentSpaces(out, indent);
    *out += "location:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, location); // UYW
    outString += "\n";   // HHS

    // func arg: int32_t messageCode
    IndentSpaces(out, indent);
    *out += "messageCode:                    ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, messageCode); //EQA
    outString += "\n";   // HHS

    // func arg: const char* pLayerPrefix
    IndentSpaces(out, indent);
    *out += "pLayerPrefix:                   ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pLayerPrefix.GetPointer()); // TGH
    outString += "\n";   // HHS

    // func arg: const char* pMessage
    IndentSpaces(out, indent);
    *out += "pMessage:                       ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pMessage.GetPointer()); // TGH
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(std::string* out, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(std::string* out, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugMarkerMarkerInfoEXT *pstruct = (const VkDebugMarkerMarkerInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: const char* pMarkerName
    IndentSpaces(out, indent);
    *out += "pMarkerName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pMarkerName); // TGI
    *out += "\n"; // GDS

    // struct member: float color
    IndentSpaces(out, indent);
    *out += "color:                          ";
    *out += "float[";
    *out += "4"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkDebugMarkerMarkerInfoEXT, color)); // IYY
    ScalarValueToStringStruct vinfo_color = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->color), "color", 4, vinfo_color); // JPA
}

template <>
void StructureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugMarkerObjectNameInfoEXT *pstruct = (const VkDebugMarkerObjectNameInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDebugReportObjectTypeEXT objectType
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkDebugReportObjectTypeEXT = "; // TEQ
    EnumToStringVkDebugReportObjectTypeEXT(out, pstruct->objectType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint64_t object
    IndentSpaces(out, indent);
    *out += "object:                         ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->object); // UYW
    *out += "\n"; // GDS

    // struct member: const char* pObjectName
    IndentSpaces(out, indent);
    *out += "pObjectName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pObjectName); // TGI
}

template <>
void StructureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugMarkerObjectTagInfoEXT *pstruct = (const VkDebugMarkerObjectTagInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDebugReportObjectTypeEXT objectType
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkDebugReportObjectTypeEXT = "; // TEQ
    EnumToStringVkDebugReportObjectTypeEXT(out, pstruct->objectType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint64_t object
    IndentSpaces(out, indent);
    *out += "object:                         ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->object); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t tagName
    IndentSpaces(out, indent);
    *out += "tagName:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagName); // UYW
    *out += "\n"; // GDS

    // struct member: size_t tagSize
    IndentSpaces(out, indent);
    *out += "tagSize:                        ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagSize); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pTag
    IndentSpaces(out, indent);
    *out += "pTag:                           ";
    *out += "const void* = "; // TEQ
    if (pstruct->pTag == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTag.GetAddress()); // AHW
    }
}

void VulkanAsciiConsumer::Process_vkCmdDebugMarkerBeginEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>& pMarkerInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugMarkerMarkerInfoEXT* pMarkerInfo
    IndentSpaces(out, indent);
    *out += "pMarkerInfo:                    ";
    *out += "const VkDebugMarkerMarkerInfoEXT* = "; // TEQ
    if (pMarkerInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMarkerInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(out, *pMarkerInfo.GetMetaStructPointer(), indent+1,pMarkerInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerEndEXT(
    format::HandleId                            commandBuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDebugMarkerEndEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDebugMarkerSetObjectNameEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugMarkerObjectNameInfoEXT>& pNameInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDebugMarkerSetObjectNameEXT(device, pNameInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugMarkerObjectNameInfoEXT* pNameInfo
    IndentSpaces(out, indent);
    *out += "pNameInfo:                      ";
    *out += "const VkDebugMarkerObjectNameInfoEXT* = "; // TEQ
    if (pNameInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pNameInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(out, *pNameInfo.GetMetaStructPointer(), indent+1,pNameInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDebugMarkerSetObjectTagEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugMarkerObjectTagInfoEXT>& pTagInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDebugMarkerSetObjectTagEXT(device, pTagInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugMarkerObjectTagInfoEXT* pTagInfo
    IndentSpaces(out, indent);
    *out += "pTagInfo:                       ";
    *out += "const VkDebugMarkerObjectTagInfoEXT* = "; // TEQ
    if (pTagInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pTagInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(out, *pTagInfo.GetMetaStructPointer(), indent+1,pTagInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerInsertEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>& pMarkerInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugMarkerMarkerInfoEXT* pMarkerInfo
    IndentSpaces(out, indent);
    *out += "pMarkerInfo:                    ";
    *out += "const VkDebugMarkerMarkerInfoEXT* = "; // TEQ
    if (pMarkerInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMarkerInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(out, *pMarkerInfo.GetMetaStructPointer(), indent+1,pMarkerInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT *pstruct = (const VkPhysicalDeviceTransformFeedbackPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxTransformFeedbackStreams
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackStreams:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackStreams); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTransformFeedbackBuffers
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBuffers:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackBuffers); // UYW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize maxTransformFeedbackBufferSize
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBufferSize: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->maxTransformFeedbackBufferSize); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t maxTransformFeedbackStreamDataSize
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackStreamDataSize: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackStreamDataSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTransformFeedbackBufferDataSize
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBufferDataSize: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackBufferDataSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTransformFeedbackBufferDataStride
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBufferDataStride: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackBufferDataStride); // UYW
    *out += "\n"; // GDS

    // struct member: VkBool32 transformFeedbackQueries
    IndentSpaces(out, indent);
    *out += "transformFeedbackQueries:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackQueries); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 transformFeedbackStreamsLinesTriangles
    IndentSpaces(out, indent);
    *out += "transformFeedbackStreamsLinesTriangles: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackStreamsLinesTriangles); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 transformFeedbackRasterizationStreamSelect
    IndentSpaces(out, indent);
    *out += "transformFeedbackRasterizationStreamSelect: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackRasterizationStreamSelect); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 transformFeedbackDraw
    IndentSpaces(out, indent);
    *out += "transformFeedbackDraw:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackDraw); //EQA
}

template <>
void StructureToString<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineRasterizationStateStreamCreateInfoEXT *pstruct = (const VkPipelineRasterizationStateStreamCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineRasterizationStateStreamCreateFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineRasterizationStateStreamCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t rasterizationStream
    IndentSpaces(out, indent);
    *out += "rasterizationStream:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->rasterizationStream); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT *pstruct = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 transformFeedback
    IndentSpaces(out, indent);
    *out += "transformFeedback:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedback); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 geometryStreams
    IndentSpaces(out, indent);
    *out += "geometryStreams:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->geometryStreams); //EQA
}

void VulkanAsciiConsumer::Process_vkCmdBeginQueryIndexedEXT(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags,
    uint32_t                                    index)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t query
    IndentSpaces(out, indent);
    *out += "query:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, query); // UYW
    outString += "\n";   // HHS

    // func arg: VkQueryControlFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkQueryControlFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkQueryControlFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: uint32_t index
    IndentSpaces(out, indent);
    *out += "index:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, index); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndirectByteCountEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    format::HandleId                            counterBuffer,
    VkDeviceSize                                counterBufferOffset,
    uint32_t                                    counterOffset,
    uint32_t                                    vertexStride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t instanceCount
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, instanceCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t firstInstance
    IndentSpaces(out, indent);
    *out += "firstInstance:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstInstance); // UYW
    outString += "\n";   // HHS

    // func arg: VkBuffer counterBuffer
    IndentSpaces(out, indent);
    *out += "counterBuffer:                  ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, counterBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize counterBufferOffset
    IndentSpaces(out, indent);
    *out += "counterBufferOffset:            ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, counterBufferOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t counterOffset
    IndentSpaces(out, indent);
    *out += "counterOffset:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, counterOffset); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t vertexStride
    IndentSpaces(out, indent);
    *out += "vertexStride:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, vertexStride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndTransformFeedbackEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const HandlePointerDecoder<VkBuffer>&       pCounterBuffers,
    const PointerDecoder<VkDeviceSize>&         pCounterBufferOffsets)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstCounterBuffer
    IndentSpaces(out, indent);
    *out += "firstCounterBuffer:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstCounterBuffer); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t counterBufferCount
    IndentSpaces(out, indent);
    *out += "counterBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, counterBufferCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBuffer* pCounterBuffers
    IndentSpaces(out, indent);
    *out += "pCounterBuffers:                ";
    *out += "const VkBuffer* = "; // TEQ
    if (pCounterBuffers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCounterBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCounterBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(out, indent, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pCounterBuffers.GetPointer()), "pCounterBuffers", counterBufferCount,  vinfo_pCounterBuffers);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: const VkDeviceSize* pCounterBufferOffsets
    IndentSpaces(out, indent);
    *out += "pCounterBufferOffsets:          ";
    *out += "const VkDeviceSize* = "; // TEQ
    if (pCounterBufferOffsets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCounterBufferOffsets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCounterBufferOffsets = {false, false, false, nullptr};
        ArrayToString<const VkDeviceSize*>(out, indent, 1, "const VkDeviceSize*", reinterpret_cast<const VkDeviceSize*>(pCounterBufferOffsets.GetPointer()), "pCounterBufferOffsets", counterBufferCount,  vinfo_pCounterBufferOffsets);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndQueryIndexedEXT(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    uint32_t                                    index)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t query
    IndentSpaces(out, indent);
    *out += "query:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, query); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t index
    IndentSpaces(out, indent);
    *out += "index:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, index); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginTransformFeedbackEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const HandlePointerDecoder<VkBuffer>&       pCounterBuffers,
    const PointerDecoder<VkDeviceSize>&         pCounterBufferOffsets)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstCounterBuffer
    IndentSpaces(out, indent);
    *out += "firstCounterBuffer:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstCounterBuffer); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t counterBufferCount
    IndentSpaces(out, indent);
    *out += "counterBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, counterBufferCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBuffer* pCounterBuffers
    IndentSpaces(out, indent);
    *out += "pCounterBuffers:                ";
    *out += "const VkBuffer* = "; // TEQ
    if (pCounterBuffers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCounterBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCounterBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(out, indent, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pCounterBuffers.GetPointer()), "pCounterBuffers", counterBufferCount,  vinfo_pCounterBuffers);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: const VkDeviceSize* pCounterBufferOffsets
    IndentSpaces(out, indent);
    *out += "pCounterBufferOffsets:          ";
    *out += "const VkDeviceSize* = "; // TEQ
    if (pCounterBufferOffsets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCounterBufferOffsets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pCounterBufferOffsets = {false, false, false, nullptr};
        ArrayToString<const VkDeviceSize*>(out, indent, 1, "const VkDeviceSize*", reinterpret_cast<const VkDeviceSize*>(pCounterBufferOffsets.GetPointer()), "pCounterBufferOffsets", counterBufferCount,  vinfo_pCounterBufferOffsets);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindTransformFeedbackBuffersEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const HandlePointerDecoder<VkBuffer>&       pBuffers,
    const PointerDecoder<VkDeviceSize>&         pOffsets,
    const PointerDecoder<VkDeviceSize>&         pSizes)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstBinding
    IndentSpaces(out, indent);
    *out += "firstBinding:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstBinding); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t bindingCount
    IndentSpaces(out, indent);
    *out += "bindingCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindingCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBuffer* pBuffers
    IndentSpaces(out, indent);
    *out += "pBuffers:                       ";
    *out += "const VkBuffer* = "; // TEQ
    if (pBuffers.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBuffers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(out, indent, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pBuffers.GetPointer()), "pBuffers", bindingCount,  vinfo_pBuffers);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: const VkDeviceSize* pOffsets
    IndentSpaces(out, indent);
    *out += "pOffsets:                       ";
    *out += "const VkDeviceSize* = "; // TEQ
    if (pOffsets.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pOffsets.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pOffsets = {false, false, false, nullptr};
        ArrayToString<const VkDeviceSize*>(out, indent, 1, "const VkDeviceSize*", reinterpret_cast<const VkDeviceSize*>(pOffsets.GetPointer()), "pOffsets", bindingCount,  vinfo_pOffsets);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: const VkDeviceSize* pSizes
    IndentSpaces(out, indent);
    *out += "pSizes:                         ";
    *out += "const VkDeviceSize* = "; // TEQ
    if (pSizes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSizes.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSizes = {false, false, false, nullptr};
        ArrayToString<const VkDeviceSize*>(out, indent, 1, "const VkDeviceSize*", reinterpret_cast<const VkDeviceSize*>(pSizes.GetPointer()), "pSizes", bindingCount,  vinfo_pSizes);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkImageViewHandleInfoNVX>(std::string* out, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImageViewHandleInfoNVX>(std::string* out, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageViewHandleInfoNVX *pstruct = (const VkImageViewHandleInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImageView imageView
    IndentSpaces(out, indent);
    *out += "imageView:                      ";
    *out += "VkImageView = "; // TEQ
    AddrToString(out, pstruct_in.imageView); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDescriptorType descriptorType
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSampler sampler
    IndentSpaces(out, indent);
    *out += "sampler:                        ";
    *out += "VkSampler = "; // TEQ
    AddrToString(out, pstruct_in.sampler); // PAQ
}

void VulkanAsciiConsumer::Process_vkGetImageViewHandleNVX(
    uint32_t                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageViewHandleInfoNVX>& pInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageViewHandleNVX(device, pInfo)");
    fprintf(GetFile(), " returns %u:\n", returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImageViewHandleInfoNVX* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkImageViewHandleInfoNVX* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageViewHandleInfoNVX>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdDrawIndirectCountAMD(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer countBuffer
    IndentSpaces(out, indent);
    *out += "countBuffer:                    ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, countBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize countBufferOffset
    IndentSpaces(out, indent);
    *out += "countBufferOffset:              ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, countBufferOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t maxDrawCount
    IndentSpaces(out, indent);
    *out += "maxDrawCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, maxDrawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirectCountAMD(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer countBuffer
    IndentSpaces(out, indent);
    *out += "countBuffer:                    ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, countBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize countBufferOffset
    IndentSpaces(out, indent);
    *out += "countBufferOffset:              ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, countBufferOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t maxDrawCount
    IndentSpaces(out, indent);
    *out += "maxDrawCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, maxDrawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkShaderResourceUsageAMD>(std::string* out, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkShaderStatisticsInfoAMD>(std::string* out, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkShaderResourceUsageAMD>(std::string* out, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderResourceUsageAMD *pstruct = (const VkShaderResourceUsageAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t numUsedVgprs
    IndentSpaces(out, indent);
    *out += "numUsedVgprs:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numUsedVgprs); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t numUsedSgprs
    IndentSpaces(out, indent);
    *out += "numUsedSgprs:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numUsedSgprs); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t ldsSizePerLocalWorkGroup
    IndentSpaces(out, indent);
    *out += "ldsSizePerLocalWorkGroup:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->ldsSizePerLocalWorkGroup); // UYW
    *out += "\n"; // GDS

    // struct member: size_t ldsUsageSizeInBytes
    IndentSpaces(out, indent);
    *out += "ldsUsageSizeInBytes:            ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->ldsUsageSizeInBytes); // UYW
    *out += "\n"; // GDS

    // struct member: size_t scratchMemUsageInBytes
    IndentSpaces(out, indent);
    *out += "scratchMemUsageInBytes:         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->scratchMemUsageInBytes); // UYW
}

template <>
void StructureToString<Decoded_VkShaderStatisticsInfoAMD>(std::string* out, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderStatisticsInfoAMD *pstruct = (const VkShaderStatisticsInfoAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkShaderStageFlags shaderStageMask
    IndentSpaces(out, indent);
    *out += "shaderStageMask:                ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->shaderStageMask, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkShaderResourceUsageAMD resourceUsage
    IndentSpaces(out, indent);
    *out += "resourceUsage:                  ";
    *out += "VkShaderResourceUsageAMD = "; // TEQ
    StructureToString<Decoded_VkShaderResourceUsageAMD>(out, *pstruct_in.resourceUsage, indent+1,  base_addr + offsetof(VkShaderStatisticsInfoAMD, resourceUsage)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t numPhysicalVgprs
    IndentSpaces(out, indent);
    *out += "numPhysicalVgprs:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numPhysicalVgprs); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t numPhysicalSgprs
    IndentSpaces(out, indent);
    *out += "numPhysicalSgprs:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numPhysicalSgprs); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t numAvailableVgprs
    IndentSpaces(out, indent);
    *out += "numAvailableVgprs:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numAvailableVgprs); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t numAvailableSgprs
    IndentSpaces(out, indent);
    *out += "numAvailableSgprs:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numAvailableSgprs); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t computeWorkGroupSize
    IndentSpaces(out, indent);
    *out += "computeWorkGroupSize:           ";
    *out += "uint32_t[";
    *out += "3"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkShaderStatisticsInfoAMD, computeWorkGroupSize)); // IYY
    ScalarValueToStringStruct vinfo_computeWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->computeWorkGroupSize), "computeWorkGroupSize", 3, vinfo_computeWorkGroupSize); // JPA
}

void VulkanAsciiConsumer::Process_vkGetShaderInfoAMD(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    const PointerDecoder<size_t>&               pInfoSize,
    const PointerDecoder<uint8_t>&              pInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pipeline); // PAQ
    outString += "\n";   // HHS

    // func arg: VkShaderStageFlagBits shaderStage
    IndentSpaces(out, indent);
    *out += "shaderStage:                    ";
    *out += "VkShaderStageFlagBits = "; // TEQ
    EnumToStringVkShaderStageFlagBits(out, shaderStage); // VSA
    *out += " (";
    UnsignedDecimalToString(out, shaderStage);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkShaderInfoTypeAMD infoType
    IndentSpaces(out, indent);
    *out += "infoType:                       ";
    *out += "VkShaderInfoTypeAMD = "; // TEQ
    EnumToStringVkShaderInfoTypeAMD(out, infoType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, infoType);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: size_t* pInfoSize
    IndentSpaces(out, indent);
    *out += "pInfoSize:                      ";
    *out += "size_t* = "; // TEQ
    if (pInfoSize.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pInfoSize = {false, false, false, nullptr};
        ScalarValueToString(out, pInfoSize.GetPointer(), vinfo_pInfoSize); // PWS
    }
    outString += "\n";   // HHS

    // func arg: void* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "void* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(std::string* out, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(std::string* out, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkStreamDescriptorSurfaceCreateInfoGGP *pstruct = (const VkStreamDescriptorSurfaceCreateInfoGGP *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkStreamDescriptorSurfaceCreateFlagsGGP flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkStreamDescriptorSurfaceCreateFlagsGGP = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t streamDescriptor
    IndentSpaces(out, indent);
    *out += "streamDescriptor:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->streamDescriptor); // UYW
}

void VulkanAsciiConsumer::Process_vkCreateStreamDescriptorSurfaceGGP(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkStreamDescriptorSurfaceCreateInfoGGP* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkExternalImageFormatPropertiesNV>(std::string* out, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkExternalImageFormatPropertiesNV>(std::string* out, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalImageFormatPropertiesNV *pstruct = (const VkExternalImageFormatPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkImageFormatProperties imageFormatProperties
    IndentSpaces(out, indent);
    *out += "imageFormatProperties:          ";
    *out += "VkImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkImageFormatProperties>(out, *pstruct_in.imageFormatProperties, indent+1,  base_addr + offsetof(VkExternalImageFormatPropertiesNV, imageFormatProperties)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryFeatureFlagsNV externalMemoryFeatures
    IndentSpaces(out, indent);
    *out += "externalMemoryFeatures:         ";
    *out += "VkExternalMemoryFeatureFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->externalMemoryFeatures, EnumToStringVkExternalMemoryFeatureFlagBitsNV); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    const StructPointerDecoder<Decoded_VkExternalImageFormatPropertiesNV>& pExternalImageFormatProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, format);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageType type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, type);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageTiling tiling
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, tiling); // VSA
    *out += " (";
    UnsignedDecimalToString(out, tiling);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkImageUsageFlags usage
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, usage, EnumToStringVkImageUsageFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkImageCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageCreateFlags = "; // TEQ
    FlagsToString(out, flags, EnumToStringVkImageCreateFlagBits); // URW
    outString += "\n";   // HHS

    // func arg: VkExternalMemoryHandleTypeFlagsNV externalHandleType
    IndentSpaces(out, indent);
    *out += "externalHandleType:             ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, externalHandleType, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    outString += "\n";   // HHS

    // func arg: VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties
    IndentSpaces(out, indent);
    *out += "pExternalImageFormatProperties: ";
    *out += "VkExternalImageFormatPropertiesNV* = "; // TEQ
    if (pExternalImageFormatProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExternalImageFormatProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkExternalImageFormatPropertiesNV>(out, *pExternalImageFormatProperties.GetMetaStructPointer(), indent+1,pExternalImageFormatProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkExportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkExportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportMemoryWin32HandleInfoNV *pstruct = (const VkExportMemoryWin32HandleInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAttributes = {false, false, false, nullptr};
        ScalarValueToString(out, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PWT
    }
    *out += "\n"; // GDS

    // struct member: uint32_t dwAccess
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess); // UYW
}

template <>
void StructureToString<Decoded_VkImportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryWin32HandleInfoNV *pstruct = (const VkImportMemoryWin32HandleInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagsNV handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->handleType, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    *out += "\n"; // GDS

    // struct member: void* handle
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandleNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, memory); // PAQ
    outString += "\n";   // HHS

    // func arg: VkExternalMemoryHandleTypeFlagsNV handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, handleType, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    outString += "\n";   // HHS

    // func arg: void** pHandle
    IndentSpaces(out, indent);
    *out += "pHandle:                        ";
    *out += "void** = "; // TEQ
    if (pHandle.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pHandle = {false, false, false, nullptr};
        ScalarValueToString(out, pHandle.GetPointer(), vinfo_pHandle); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkViSurfaceCreateInfoNN>(std::string* out, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkViSurfaceCreateInfoNN>(std::string* out, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkViSurfaceCreateInfoNN *pstruct = (const VkViSurfaceCreateInfoNN *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkViSurfaceCreateFlagsNN flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkViSurfaceCreateFlagsNN = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: void* window
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->window == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.window); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateViSurfaceNN(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkViSurfaceCreateInfoNN>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkViSurfaceCreateInfoNN* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkViSurfaceCreateInfoNN* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkViSurfaceCreateInfoNN>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(std::string* out, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(std::string* out, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(std::string* out, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkConditionalRenderingBeginInfoEXT *pstruct = (const VkConditionalRenderingBeginInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
    *out += "\n"; // GDS

    // struct member: VkConditionalRenderingFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkConditionalRenderingFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkConditionalRenderingFlagBitsEXT); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT *pstruct = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 conditionalRendering
    IndentSpaces(out, indent);
    *out += "conditionalRendering:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->conditionalRendering); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 inheritedConditionalRendering
    IndentSpaces(out, indent);
    *out += "inheritedConditionalRendering:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->inheritedConditionalRendering); //EQA
}

template <>
void StructureToString<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(std::string* out, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT *pstruct = (const VkCommandBufferInheritanceConditionalRenderingInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 conditionalRenderingEnable
    IndentSpaces(out, indent);
    *out += "conditionalRenderingEnable:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->conditionalRenderingEnable); //EQA
}

void VulkanAsciiConsumer::Process_vkCmdBeginConditionalRenderingEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkConditionalRenderingBeginInfoEXT>& pConditionalRenderingBegin)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin
    IndentSpaces(out, indent);
    *out += "pConditionalRenderingBegin:     ";
    *out += "const VkConditionalRenderingBeginInfoEXT* = "; // TEQ
    if (pConditionalRenderingBegin.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pConditionalRenderingBegin.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(out, *pConditionalRenderingBegin.GetMetaStructPointer(), indent+1,pConditionalRenderingBegin.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndConditionalRenderingEXT(
    format::HandleId                            commandBuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdEndConditionalRenderingEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTablePipelineEntryNVX>(std::string* out, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(std::string* out, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTablePushConstantEntryNVX>(std::string* out, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableVertexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableDescriptorSetEntryNVX>(std::string* out, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableEntryNVX>(std::string* out, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCmdProcessCommandsInfoNVX>(std::string* out, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableIndexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkIndirectCommandsTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableCreateInfoNVX>(std::string* out, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGeneratedCommandsLimitsNVX *pstruct = (const VkDeviceGeneratedCommandsLimitsNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxIndirectCommandsLayoutTokenCount
    IndentSpaces(out, indent);
    *out += "maxIndirectCommandsLayoutTokenCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxIndirectCommandsLayoutTokenCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxObjectEntryCounts
    IndentSpaces(out, indent);
    *out += "maxObjectEntryCounts:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxObjectEntryCounts); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t minSequenceCountBufferOffsetAlignment
    IndentSpaces(out, indent);
    *out += "minSequenceCountBufferOffsetAlignment: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minSequenceCountBufferOffsetAlignment); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t minSequenceIndexBufferOffsetAlignment
    IndentSpaces(out, indent);
    *out += "minSequenceIndexBufferOffsetAlignment: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minSequenceIndexBufferOffsetAlignment); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t minCommandsTokenBufferOffsetAlignment
    IndentSpaces(out, indent);
    *out += "minCommandsTokenBufferOffsetAlignment: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minCommandsTokenBufferOffsetAlignment); // UYW
}

template <>
void StructureToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIndirectCommandsLayoutTokenNVX *pstruct = (const VkIndirectCommandsLayoutTokenNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkIndirectCommandsTokenTypeNVX tokenType
    IndentSpaces(out, indent);
    *out += "tokenType:                      ";
    *out += "VkIndirectCommandsTokenTypeNVX = "; // TEQ
    EnumToStringVkIndirectCommandsTokenTypeNVX(out, pstruct->tokenType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tokenType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t bindingUnit
    IndentSpaces(out, indent);
    *out += "bindingUnit:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindingUnit); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t dynamicCount
    IndentSpaces(out, indent);
    *out += "dynamicCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dynamicCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t divisor
    IndentSpaces(out, indent);
    *out += "divisor:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->divisor); // UYW
}

template <>
void StructureToString<Decoded_VkObjectTablePipelineEntryNVX>(std::string* out, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTablePipelineEntryNVX *pstruct = (const VkObjectTablePipelineEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // struct member: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.pipeline); // PAQ
}

template <>
void StructureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(std::string* out, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCmdReserveSpaceForCommandsInfoNVX *pstruct = (const VkCmdReserveSpaceForCommandsInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkObjectTableNVX objectTable
    IndentSpaces(out, indent);
    *out += "objectTable:                    ";
    *out += "VkObjectTableNVX = "; // TEQ
    AddrToString(out, pstruct_in.objectTable); // PAQ
    *out += "\n"; // GDS

    // struct member: VkIndirectCommandsLayoutNVX indirectCommandsLayout
    IndentSpaces(out, indent);
    *out += "indirectCommandsLayout:         ";
    *out += "VkIndirectCommandsLayoutNVX = "; // TEQ
    AddrToString(out, pstruct_in.indirectCommandsLayout); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t maxSequencesCount
    IndentSpaces(out, indent);
    *out += "maxSequencesCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSequencesCount); // UYW
}

template <>
void StructureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGeneratedCommandsFeaturesNVX *pstruct = (const VkDeviceGeneratedCommandsFeaturesNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 computeBindingPointSupport
    IndentSpaces(out, indent);
    *out += "computeBindingPointSupport:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->computeBindingPointSupport); //EQA
}

template <>
void StructureToString<Decoded_VkObjectTablePushConstantEntryNVX>(std::string* out, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTablePushConstantEntryNVX *pstruct = (const VkObjectTablePushConstantEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // struct member: VkPipelineLayout pipelineLayout
    IndentSpaces(out, indent);
    *out += "pipelineLayout:                 ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.pipelineLayout); // PAQ
    *out += "\n"; // GDS

    // struct member: VkShaderStageFlags stageFlags
    IndentSpaces(out, indent);
    *out += "stageFlags:                     ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkObjectTableVertexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableVertexBufferEntryNVX *pstruct = (const VkObjectTableVertexBufferEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkObjectTableDescriptorSetEntryNVX>(std::string* out, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableDescriptorSetEntryNVX *pstruct = (const VkObjectTableDescriptorSetEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // struct member: VkPipelineLayout pipelineLayout
    IndentSpaces(out, indent);
    *out += "pipelineLayout:                 ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.pipelineLayout); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDescriptorSet descriptorSet
    IndentSpaces(out, indent);
    *out += "descriptorSet:                  ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.descriptorSet); // PAQ
}

template <>
void StructureToString<Decoded_VkObjectTableEntryNVX>(std::string* out, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableEntryNVX *pstruct = (const VkObjectTableEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
}

template <>
void StructureToString<Decoded_VkCmdProcessCommandsInfoNVX>(std::string* out, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCmdProcessCommandsInfoNVX *pstruct = (const VkCmdProcessCommandsInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkObjectTableNVX objectTable
    IndentSpaces(out, indent);
    *out += "objectTable:                    ";
    *out += "VkObjectTableNVX = "; // TEQ
    AddrToString(out, pstruct_in.objectTable); // PAQ
    *out += "\n"; // GDS

    // struct member: VkIndirectCommandsLayoutNVX indirectCommandsLayout
    IndentSpaces(out, indent);
    *out += "indirectCommandsLayout:         ";
    *out += "VkIndirectCommandsLayoutNVX = "; // TEQ
    AddrToString(out, pstruct_in.indirectCommandsLayout); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t indirectCommandsTokenCount
    IndentSpaces(out, indent);
    *out += "indirectCommandsTokenCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->indirectCommandsTokenCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkIndirectCommandsTokenNVX* pIndirectCommandsTokens
    IndentSpaces(out, indent);
    *out += "pIndirectCommandsTokens:        ";
    *out += "const VkIndirectCommandsTokenNVX* = "; // TEQ
    if (pstruct->pIndirectCommandsTokens == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pIndirectCommandsTokens->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkIndirectCommandsTokenNVX>(out, indent+1, 1, "VkIndirectCommandsTokenNVX", pstruct_in.pIndirectCommandsTokens->GetMetaStructPointer(), "pIndirectCommandsTokens", pstruct->indirectCommandsTokenCount, false, pstruct_in.pIndirectCommandsTokens->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxSequencesCount
    IndentSpaces(out, indent);
    *out += "maxSequencesCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSequencesCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkCommandBuffer targetCommandBuffer
    IndentSpaces(out, indent);
    *out += "targetCommandBuffer:            ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, pstruct_in.targetCommandBuffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkBuffer sequencesCountBuffer
    IndentSpaces(out, indent);
    *out += "sequencesCountBuffer:           ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.sequencesCountBuffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize sequencesCountOffset
    IndentSpaces(out, indent);
    *out += "sequencesCountOffset:           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->sequencesCountOffset); //EQA
    *out += "\n"; // GDS

    // struct member: VkBuffer sequencesIndexBuffer
    IndentSpaces(out, indent);
    *out += "sequencesIndexBuffer:           ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.sequencesIndexBuffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize sequencesIndexOffset
    IndentSpaces(out, indent);
    *out += "sequencesIndexOffset:           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->sequencesIndexOffset); //EQA
}

template <>
void StructureToString<Decoded_VkObjectTableIndexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableIndexBufferEntryNVX *pstruct = (const VkObjectTableIndexBufferEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkObjectEntryTypeNVX type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkObjectEntryUsageFlagsNVX flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkIndexType indexType
    IndentSpaces(out, indent);
    *out += "indexType:                      ";
    *out += "VkIndexType = "; // TEQ
    EnumToStringVkIndexType(out, pstruct->indexType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->indexType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkIndirectCommandsTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIndirectCommandsTokenNVX *pstruct = (const VkIndirectCommandsTokenNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkIndirectCommandsTokenTypeNVX tokenType
    IndentSpaces(out, indent);
    *out += "tokenType:                      ";
    *out += "VkIndirectCommandsTokenTypeNVX = "; // TEQ
    EnumToStringVkIndirectCommandsTokenTypeNVX(out, pstruct->tokenType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tokenType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
}

template <>
void StructureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIndirectCommandsLayoutCreateInfoNVX *pstruct = (const VkIndirectCommandsLayoutCreateInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineBindPoint pipelineBindPoint
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkIndirectCommandsLayoutUsageFlagsNVX flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkIndirectCommandsLayoutUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkIndirectCommandsLayoutUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t tokenCount
    IndentSpaces(out, indent);
    *out += "tokenCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tokenCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkIndirectCommandsLayoutTokenNVX* pTokens
    IndentSpaces(out, indent);
    *out += "pTokens:                        ";
    *out += "const VkIndirectCommandsLayoutTokenNVX* = "; // TEQ
    if (pstruct->pTokens == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTokens->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(out, indent+1, 1, "VkIndirectCommandsLayoutTokenNVX", pstruct_in.pTokens->GetMetaStructPointer(), "pTokens", pstruct->tokenCount, false, pstruct_in.pTokens->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkObjectTableCreateInfoNVX>(std::string* out, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableCreateInfoNVX *pstruct = (const VkObjectTableCreateInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t objectCount
    IndentSpaces(out, indent);
    *out += "objectCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkObjectEntryTypeNVX* pObjectEntryTypes
    IndentSpaces(out, indent);
    *out += "pObjectEntryTypes:              ";
    *out += "const VkObjectEntryTypeNVX* = "; // TEQ
    if (pstruct->pObjectEntryTypes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjectEntryTypes.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectEntryTypes = {false, true, false, EnumToStringVkObjectEntryTypeNVX};
        ArrayToString<const VkObjectEntryTypeNVX*>(out, indent, 1, "const VkObjectEntryTypeNVX*", reinterpret_cast<const VkObjectEntryTypeNVX*>(pstruct_in.pObjectEntryTypes.GetPointer()), "pObjectEntryTypes", pstruct->objectCount,  vinfo_pObjectEntryTypes);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: const uint32_t* pObjectEntryCounts
    IndentSpaces(out, indent);
    *out += "pObjectEntryCounts:             ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pObjectEntryCounts == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjectEntryCounts.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectEntryCounts = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pObjectEntryCounts.GetPointer()), "pObjectEntryCounts", pstruct->objectCount,  vinfo_pObjectEntryCounts);  // CXC
    }
    *out += "\n"; // GDS

    // struct member: const VkObjectEntryUsageFlagsNVX* pObjectEntryUsageFlags
    IndentSpaces(out, indent);
    *out += "pObjectEntryUsageFlags:         ";
    *out += "const VkObjectEntryUsageFlagsNVX* = "; // TEQ
    if (pstruct->pObjectEntryUsageFlags == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjectEntryUsageFlags.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectEntryUsageFlags = {false, false, true, EnumToStringVkObjectEntryUsageFlagBitsNVX};
        ArrayToString<const VkObjectEntryUsageFlagsNVX*>(out, indent, 1, "const VkObjectEntryUsageFlagsNVX*", reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(pstruct_in.pObjectEntryUsageFlags.GetPointer()), "pObjectEntryUsageFlags", pstruct->objectCount,  vinfo_pObjectEntryUsageFlags);  // CCR
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxUniformBuffersPerDescriptor
    IndentSpaces(out, indent);
    *out += "maxUniformBuffersPerDescriptor: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxUniformBuffersPerDescriptor); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxStorageBuffersPerDescriptor
    IndentSpaces(out, indent);
    *out += "maxStorageBuffersPerDescriptor: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxStorageBuffersPerDescriptor); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxStorageImagesPerDescriptor
    IndentSpaces(out, indent);
    *out += "maxStorageImagesPerDescriptor:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxStorageImagesPerDescriptor); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxSampledImagesPerDescriptor
    IndentSpaces(out, indent);
    *out += "maxSampledImagesPerDescriptor:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSampledImagesPerDescriptor); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxPipelineLayouts
    IndentSpaces(out, indent);
    *out += "maxPipelineLayouts:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPipelineLayouts); // UYW
}

void VulkanAsciiConsumer::Process_vkUnregisterObjectsNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            objectTable,
    uint32_t                                    objectCount,
    const PointerDecoder<VkObjectEntryTypeNVX>& pObjectEntryTypes,
    const PointerDecoder<uint32_t>&             pObjectIndices)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkUnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkObjectTableNVX objectTable
    IndentSpaces(out, indent);
    *out += "objectTable:                    ";
    *out += "VkObjectTableNVX = "; // TEQ
    AddrToString(out, objectTable); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t objectCount
    IndentSpaces(out, indent);
    *out += "objectCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, objectCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkObjectEntryTypeNVX* pObjectEntryTypes
    IndentSpaces(out, indent);
    *out += "pObjectEntryTypes:              ";
    *out += "const VkObjectEntryTypeNVX* = "; // TEQ
    if (pObjectEntryTypes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pObjectEntryTypes.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectEntryTypes = {false, true, false, EnumToStringVkObjectEntryTypeNVX};
        ArrayToString<const VkObjectEntryTypeNVX*>(out, indent, 1, "const VkObjectEntryTypeNVX*", reinterpret_cast<const VkObjectEntryTypeNVX*>(pObjectEntryTypes.GetPointer()), "pObjectEntryTypes", objectCount,  vinfo_pObjectEntryTypes);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: const uint32_t* pObjectIndices
    IndentSpaces(out, indent);
    *out += "pObjectIndices:                 ";
    *out += "const uint32_t* = "; // TEQ
    if (pObjectIndices.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pObjectIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pObjectIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pObjectIndices.GetPointer()), "pObjectIndices", objectCount,  vinfo_pObjectIndices);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateIndirectCommandsLayoutNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkIndirectCommandsLayoutNVX>& pIndirectCommandsLayout)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, pIndirectCommandsLayout)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkIndirectCommandsLayoutCreateInfoNVX* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout
    IndentSpaces(out, indent);
    *out += "pIndirectCommandsLayout:        ";
    *out += "VkIndirectCommandsLayoutNVX* = "; // TEQ
    if (pIndirectCommandsLayout.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pIndirectCommandsLayout = {true, false, false, nullptr};
        ScalarValueToString(out, pIndirectCommandsLayout.GetPointer(), vinfo_pIndirectCommandsLayout); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>& pFeatures,
    const StructPointerDecoder<Decoded_VkDeviceGeneratedCommandsLimitsNVX>& pLimits)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, pLimits)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceGeneratedCommandsFeaturesNVX* pFeatures
    IndentSpaces(out, indent);
    *out += "pFeatures:                      ";
    *out += "VkDeviceGeneratedCommandsFeaturesNVX* = "; // TEQ
    if (pFeatures.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pFeatures.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(out, *pFeatures.GetMetaStructPointer(), indent+1,pFeatures.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDeviceGeneratedCommandsLimitsNVX* pLimits
    IndentSpaces(out, indent);
    *out += "pLimits:                        ";
    *out += "VkDeviceGeneratedCommandsLimitsNVX* = "; // TEQ
    if (pLimits.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pLimits.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(out, *pLimits.GetMetaStructPointer(), indent+1,pLimits.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyObjectTableNVX(
    format::HandleId                            device,
    format::HandleId                            objectTable,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyObjectTableNVX(device, objectTable, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkObjectTableNVX objectTable
    IndentSpaces(out, indent);
    *out += "objectTable:                    ";
    *out += "VkObjectTableNVX = "; // TEQ
    AddrToString(out, objectTable); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdProcessCommandsNVX(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCmdProcessCommandsInfoNVX>& pProcessCommandsInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo
    IndentSpaces(out, indent);
    *out += "pProcessCommandsInfo:           ";
    *out += "const VkCmdProcessCommandsInfoNVX* = "; // TEQ
    if (pProcessCommandsInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProcessCommandsInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkCmdProcessCommandsInfoNVX>(out, *pProcessCommandsInfo.GetMetaStructPointer(), indent+1,pProcessCommandsInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateObjectTableNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkObjectTableCreateInfoNVX>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkObjectTableNVX>& pObjectTable)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateObjectTableNVX(device, pCreateInfo, pAllocator, pObjectTable)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkObjectTableCreateInfoNVX* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkObjectTableCreateInfoNVX* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkObjectTableCreateInfoNVX>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkObjectTableNVX* pObjectTable
    IndentSpaces(out, indent);
    *out += "pObjectTable:                   ";
    *out += "VkObjectTableNVX* = "; // TEQ
    if (pObjectTable.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pObjectTable = {true, false, false, nullptr};
        ScalarValueToString(out, pObjectTable.GetPointer(), vinfo_pObjectTable); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyIndirectCommandsLayoutNVX(
    format::HandleId                            device,
    format::HandleId                            indirectCommandsLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkIndirectCommandsLayoutNVX indirectCommandsLayout
    IndentSpaces(out, indent);
    *out += "indirectCommandsLayout:         ";
    *out += "VkIndirectCommandsLayoutNVX = "; // TEQ
    AddrToString(out, indirectCommandsLayout); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdReserveSpaceForCommandsNVX(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>& pReserveSpaceInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo
    IndentSpaces(out, indent);
    *out += "pReserveSpaceInfo:              ";
    *out += "const VkCmdReserveSpaceForCommandsInfoNVX* = "; // TEQ
    if (pReserveSpaceInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pReserveSpaceInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(out, *pReserveSpaceInfo.GetMetaStructPointer(), indent+1,pReserveSpaceInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkViewportWScalingNV>(std::string* out, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkViewportWScalingNV>(std::string* out, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkViewportWScalingNV *pstruct = (const VkViewportWScalingNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: float xcoeff
    IndentSpaces(out, indent);
    *out += "xcoeff:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->xcoeff); // PEZ
    *out += "\n"; // GDS

    // struct member: float ycoeff
    IndentSpaces(out, indent);
    *out += "ycoeff:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->ycoeff); // PEZ
}

template <>
void StructureToString<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportWScalingStateCreateInfoNV *pstruct = (const VkPipelineViewportWScalingStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 viewportWScalingEnable
    IndentSpaces(out, indent);
    *out += "viewportWScalingEnable:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->viewportWScalingEnable); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t viewportCount
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkViewportWScalingNV* pViewportWScalings
    IndentSpaces(out, indent);
    *out += "pViewportWScalings:             ";
    *out += "const VkViewportWScalingNV* = "; // TEQ
    if (pstruct->pViewportWScalings == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewportWScalings->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkViewportWScalingNV>(out, indent+1, 1, "VkViewportWScalingNV", pstruct_in.pViewportWScalings->GetMetaStructPointer(), "pViewportWScalings", pstruct->viewportCount, false, pstruct_in.pViewportWScalings->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetViewportWScalingNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkViewportWScalingNV>& pViewportWScalings)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstViewport
    IndentSpaces(out, indent);
    *out += "firstViewport:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstViewport); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t viewportCount
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, viewportCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkViewportWScalingNV* pViewportWScalings
    IndentSpaces(out, indent);
    *out += "pViewportWScalings:             ";
    *out += "const VkViewportWScalingNV* = "; // TEQ
    if (pViewportWScalings.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pViewportWScalings.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkViewportWScalingNV>(out, indent+1, 1, "VkViewportWScalingNV", pViewportWScalings.GetMetaStructPointer(), "pViewportWScalings", viewportCount, false, pViewportWScalings.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkReleaseDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkReleaseDisplayEXT(physicalDevice, display)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, display); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkAcquireXlibDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    format::HandleId                            display)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAcquireXlibDisplayEXT(physicalDevice, dpy, display)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: void* dpy
    IndentSpaces(out, indent);
    *out += "dpy:                            ";
    *out += "void* = "; // TEQ
    AddrToString(out, dpy); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, display); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRandROutputDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    size_t                                      rrOutput,
    const HandlePointerDecoder<VkDisplayKHR>&   pDisplay)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: void* dpy
    IndentSpaces(out, indent);
    *out += "dpy:                            ";
    *out += "void* = "; // TEQ
    AddrToString(out, dpy); // PAQ
    outString += "\n";   // HHS

    // func arg: size_t rrOutput
    IndentSpaces(out, indent);
    *out += "rrOutput:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, rrOutput); // UYW
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR* pDisplay
    IndentSpaces(out, indent);
    *out += "pDisplay:                       ";
    *out += "VkDisplayKHR* = "; // TEQ
    if (pDisplay.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDisplay = {true, false, false, nullptr};
        ScalarValueToString(out, pDisplay.GetPointer(), vinfo_pDisplay); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSurfaceCapabilities2EXT>(std::string* out, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSurfaceCapabilities2EXT>(std::string* out, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilities2EXT *pstruct = (const VkSurfaceCapabilities2EXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t minImageCount
    IndentSpaces(out, indent);
    *out += "minImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minImageCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageCount
    IndentSpaces(out, indent);
    *out += "maxImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkExtent2D currentExtent
    IndentSpaces(out, indent);
    *out += "currentExtent:                  ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.currentExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, currentExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D minImageExtent
    IndentSpaces(out, indent);
    *out += "minImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, minImageExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkExtent2D maxImageExtent
    IndentSpaces(out, indent);
    *out += "maxImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, maxImageExtent)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t maxImageArrayLayers
    IndentSpaces(out, indent);
    *out += "maxImageArrayLayers:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageArrayLayers); // UYW
    *out += "\n"; // GDS

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    IndentSpaces(out, indent);
    *out += "supportedTransforms:            ";
    *out += "VkSurfaceTransformFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: VkSurfaceTransformFlagBitsKHR currentTransform
    IndentSpaces(out, indent);
    *out += "currentTransform:               ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->currentTransform); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->currentTransform);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkCompositeAlphaFlagsKHR supportedCompositeAlpha
    IndentSpaces(out, indent);
    *out += "supportedCompositeAlpha:        ";
    *out += "VkCompositeAlphaFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedCompositeAlpha, EnumToStringVkCompositeAlphaFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // struct member: VkImageUsageFlags supportedUsageFlags
    IndentSpaces(out, indent);
    *out += "supportedUsageFlags:            ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSurfaceCounterFlagsEXT supportedSurfaceCounters
    IndentSpaces(out, indent);
    *out += "supportedSurfaceCounters:       ";
    *out += "VkSurfaceCounterFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->supportedSurfaceCounters, EnumToStringVkSurfaceCounterFlagBitsEXT); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilities2EXT>& pSurfaceCapabilities)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR surface
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, surface); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceCapabilities2EXT* pSurfaceCapabilities
    IndentSpaces(out, indent);
    *out += "pSurfaceCapabilities:           ";
    *out += "VkSurfaceCapabilities2EXT* = "; // TEQ
    if (pSurfaceCapabilities.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceCapabilities.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSurfaceCapabilities2EXT>(out, *pSurfaceCapabilities.GetMetaStructPointer(), indent+1,pSurfaceCapabilities.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSwapchainCounterCreateInfoEXT>(std::string* out, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceEventInfoEXT>(std::string* out, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPowerInfoEXT>(std::string* out, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayEventInfoEXT>(std::string* out, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSwapchainCounterCreateInfoEXT>(std::string* out, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSwapchainCounterCreateInfoEXT *pstruct = (const VkSwapchainCounterCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSurfaceCounterFlagsEXT surfaceCounters
    IndentSpaces(out, indent);
    *out += "surfaceCounters:                ";
    *out += "VkSurfaceCounterFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->surfaceCounters, EnumToStringVkSurfaceCounterFlagBitsEXT); // URW
}

template <>
void StructureToString<Decoded_VkDeviceEventInfoEXT>(std::string* out, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceEventInfoEXT *pstruct = (const VkDeviceEventInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceEventTypeEXT deviceEvent
    IndentSpaces(out, indent);
    *out += "deviceEvent:                    ";
    *out += "VkDeviceEventTypeEXT = "; // TEQ
    EnumToStringVkDeviceEventTypeEXT(out, pstruct->deviceEvent); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->deviceEvent);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkDisplayPowerInfoEXT>(std::string* out, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPowerInfoEXT *pstruct = (const VkDisplayPowerInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayPowerStateEXT powerState
    IndentSpaces(out, indent);
    *out += "powerState:                     ";
    *out += "VkDisplayPowerStateEXT = "; // TEQ
    EnumToStringVkDisplayPowerStateEXT(out, pstruct->powerState); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->powerState);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkDisplayEventInfoEXT>(std::string* out, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayEventInfoEXT *pstruct = (const VkDisplayEventInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDisplayEventTypeEXT displayEvent
    IndentSpaces(out, indent);
    *out += "displayEvent:                   ";
    *out += "VkDisplayEventTypeEXT = "; // TEQ
    EnumToStringVkDisplayEventTypeEXT(out, pstruct->displayEvent); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->displayEvent);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetSwapchainCounterEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    const PointerDecoder<uint64_t>&             pCounterValue)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSurfaceCounterFlagBitsEXT counter
    IndentSpaces(out, indent);
    *out += "counter:                        ";
    *out += "VkSurfaceCounterFlagBitsEXT = "; // TEQ
    EnumToStringVkSurfaceCounterFlagBitsEXT(out, counter); // VSA
    *out += " (";
    UnsignedDecimalToString(out, counter);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint64_t* pCounterValue
    IndentSpaces(out, indent);
    *out += "pCounterValue:                  ";
    *out += "uint64_t* = "; // TEQ
    if (pCounterValue.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pCounterValue = {false, false, false, nullptr};
        ScalarValueToString(out, pCounterValue.GetPointer(), vinfo_pCounterValue); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkRegisterDisplayEventEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayEventInfoEXT>& pDisplayEventInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, display); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDisplayEventInfoEXT* pDisplayEventInfo
    IndentSpaces(out, indent);
    *out += "pDisplayEventInfo:              ";
    *out += "const VkDisplayEventInfoEXT* = "; // TEQ
    if (pDisplayEventInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDisplayEventInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDisplayEventInfoEXT>(out, *pDisplayEventInfo.GetMetaStructPointer(), indent+1,pDisplayEventInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkFence* pFence
    IndentSpaces(out, indent);
    *out += "pFence:                         ";
    *out += "VkFence* = "; // TEQ
    if (pFence.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pFence = {true, false, false, nullptr};
        ScalarValueToString(out, pFence.GetPointer(), vinfo_pFence); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkRegisterDeviceEventEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceEventInfoEXT>& pDeviceEventInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDeviceEventInfoEXT* pDeviceEventInfo
    IndentSpaces(out, indent);
    *out += "pDeviceEventInfo:               ";
    *out += "const VkDeviceEventInfoEXT* = "; // TEQ
    if (pDeviceEventInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDeviceEventInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDeviceEventInfoEXT>(out, *pDeviceEventInfo.GetMetaStructPointer(), indent+1,pDeviceEventInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkFence* pFence
    IndentSpaces(out, indent);
    *out += "pFence:                         ";
    *out += "VkFence* = "; // TEQ
    if (pFence.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pFence = {true, false, false, nullptr};
        ScalarValueToString(out, pFence.GetPointer(), vinfo_pFence); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDisplayPowerControlEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayPowerInfoEXT>& pDisplayPowerInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDisplayKHR display
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, display); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDisplayPowerInfoEXT* pDisplayPowerInfo
    IndentSpaces(out, indent);
    *out += "pDisplayPowerInfo:              ";
    *out += "const VkDisplayPowerInfoEXT* = "; // TEQ
    if (pDisplayPowerInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDisplayPowerInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDisplayPowerInfoEXT>(out, *pDisplayPowerInfo.GetMetaStructPointer(), indent+1,pDisplayPowerInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPastPresentationTimingGOOGLE>(std::string* out, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRefreshCycleDurationGOOGLE>(std::string* out, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPresentTimeGOOGLE>(std::string* out, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPresentTimesInfoGOOGLE>(std::string* out, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPastPresentationTimingGOOGLE>(std::string* out, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPastPresentationTimingGOOGLE *pstruct = (const VkPastPresentationTimingGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t presentID
    IndentSpaces(out, indent);
    *out += "presentID:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->presentID); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t desiredPresentTime
    IndentSpaces(out, indent);
    *out += "desiredPresentTime:             ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->desiredPresentTime); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t actualPresentTime
    IndentSpaces(out, indent);
    *out += "actualPresentTime:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->actualPresentTime); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t earliestPresentTime
    IndentSpaces(out, indent);
    *out += "earliestPresentTime:            ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->earliestPresentTime); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t presentMargin
    IndentSpaces(out, indent);
    *out += "presentMargin:                  ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->presentMargin); // UYW
}

template <>
void StructureToString<Decoded_VkRefreshCycleDurationGOOGLE>(std::string* out, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRefreshCycleDurationGOOGLE *pstruct = (const VkRefreshCycleDurationGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint64_t refreshDuration
    IndentSpaces(out, indent);
    *out += "refreshDuration:                ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->refreshDuration); // UYW
}

template <>
void StructureToString<Decoded_VkPresentTimeGOOGLE>(std::string* out, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPresentTimeGOOGLE *pstruct = (const VkPresentTimeGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t presentID
    IndentSpaces(out, indent);
    *out += "presentID:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->presentID); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t desiredPresentTime
    IndentSpaces(out, indent);
    *out += "desiredPresentTime:             ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->desiredPresentTime); // UYW
}

template <>
void StructureToString<Decoded_VkPresentTimesInfoGOOGLE>(std::string* out, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPresentTimesInfoGOOGLE *pstruct = (const VkPresentTimesInfoGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t swapchainCount
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->swapchainCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkPresentTimeGOOGLE* pTimes
    IndentSpaces(out, indent);
    *out += "pTimes:                         ";
    *out += "const VkPresentTimeGOOGLE* = "; // TEQ
    if (pstruct->pTimes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTimes->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPresentTimeGOOGLE>(out, indent+1, 1, "VkPresentTimeGOOGLE", pstruct_in.pTimes->GetMetaStructPointer(), "pTimes", pstruct->swapchainCount, false, pstruct_in.pTimes->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkGetRefreshCycleDurationGOOGLE(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const StructPointerDecoder<Decoded_VkRefreshCycleDurationGOOGLE>& pDisplayTimingProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    // func arg: VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties
    IndentSpaces(out, indent);
    *out += "pDisplayTimingProperties:       ";
    *out += "VkRefreshCycleDurationGOOGLE* = "; // TEQ
    if (pDisplayTimingProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDisplayTimingProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkRefreshCycleDurationGOOGLE>(out, *pDisplayTimingProperties.GetMetaStructPointer(), indent+1,pDisplayTimingProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPastPresentationTimingGOOGLE(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const PointerDecoder<uint32_t>&             pPresentationTimingCount,
    const StructPointerDecoder<Decoded_VkPastPresentationTimingGOOGLE>& pPresentationTimings)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPresentationTimingCount
    IndentSpaces(out, indent);
    *out += "pPresentationTimingCount:       ";
    *out += "uint32_t* = "; // TEQ
    if (pPresentationTimingCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPresentationTimingCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPresentationTimingCount.GetPointer(), vinfo_pPresentationTimingCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPastPresentationTimingGOOGLE* pPresentationTimings
    IndentSpaces(out, indent);
    *out += "pPresentationTimings:           ";
    *out += "VkPastPresentationTimingGOOGLE* = "; // TEQ
    if (pPresentationTimings.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPresentationTimings.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPastPresentationTimingGOOGLE>(out, indent+1, 1, "VkPastPresentationTimingGOOGLE", pPresentationTimings.GetMetaStructPointer(), "pPresentationTimings", *pPresentationTimingCount.GetPointer(), false, pPresentationTimings.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT *pstruct = (const VkPhysicalDeviceDiscardRectanglePropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxDiscardRectangles
    IndentSpaces(out, indent);
    *out += "maxDiscardRectangles:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDiscardRectangles); // UYW
}

template <>
void StructureToString<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineDiscardRectangleStateCreateInfoEXT *pstruct = (const VkPipelineDiscardRectangleStateCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineDiscardRectangleStateCreateFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineDiscardRectangleStateCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkDiscardRectangleModeEXT discardRectangleMode
    IndentSpaces(out, indent);
    *out += "discardRectangleMode:           ";
    *out += "VkDiscardRectangleModeEXT = "; // TEQ
    EnumToStringVkDiscardRectangleModeEXT(out, pstruct->discardRectangleMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->discardRectangleMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t discardRectangleCount
    IndentSpaces(out, indent);
    *out += "discardRectangleCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->discardRectangleCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkRect2D* pDiscardRectangles
    IndentSpaces(out, indent);
    *out += "pDiscardRectangles:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pDiscardRectangles == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDiscardRectangles->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pDiscardRectangles->GetMetaStructPointer(), "pDiscardRectangles", pstruct->discardRectangleCount, false, pstruct_in.pDiscardRectangles->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetDiscardRectangleEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pDiscardRectangles)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstDiscardRectangle
    IndentSpaces(out, indent);
    *out += "firstDiscardRectangle:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstDiscardRectangle); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t discardRectangleCount
    IndentSpaces(out, indent);
    *out += "discardRectangleCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, discardRectangleCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkRect2D* pDiscardRectangles
    IndentSpaces(out, indent);
    *out += "pDiscardRectangles:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pDiscardRectangles.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pDiscardRectangles.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pDiscardRectangles.GetMetaStructPointer(), "pDiscardRectangles", discardRectangleCount, false, pDiscardRectangles.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkHdrMetadataEXT>(std::string* out, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkXYColorEXT>(std::string* out, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkHdrMetadataEXT>(std::string* out, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkHdrMetadataEXT *pstruct = (const VkHdrMetadataEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkXYColorEXT displayPrimaryRed
    IndentSpaces(out, indent);
    *out += "displayPrimaryRed:              ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.displayPrimaryRed, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryRed)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkXYColorEXT displayPrimaryGreen
    IndentSpaces(out, indent);
    *out += "displayPrimaryGreen:            ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.displayPrimaryGreen, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryGreen)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkXYColorEXT displayPrimaryBlue
    IndentSpaces(out, indent);
    *out += "displayPrimaryBlue:             ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.displayPrimaryBlue, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryBlue)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkXYColorEXT whitePoint
    IndentSpaces(out, indent);
    *out += "whitePoint:                     ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.whitePoint, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, whitePoint)); // AZJ
    *out += "\n"; // GDS

    // struct member: float maxLuminance
    IndentSpaces(out, indent);
    *out += "maxLuminance:                   ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxLuminance); // PEZ
    *out += "\n"; // GDS

    // struct member: float minLuminance
    IndentSpaces(out, indent);
    *out += "minLuminance:                   ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minLuminance); // PEZ
    *out += "\n"; // GDS

    // struct member: float maxContentLightLevel
    IndentSpaces(out, indent);
    *out += "maxContentLightLevel:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxContentLightLevel); // PEZ
    *out += "\n"; // GDS

    // struct member: float maxFrameAverageLightLevel
    IndentSpaces(out, indent);
    *out += "maxFrameAverageLightLevel:      ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxFrameAverageLightLevel); // PEZ
}

template <>
void StructureToString<Decoded_VkXYColorEXT>(std::string* out, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkXYColorEXT *pstruct = (const VkXYColorEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: float x
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->x); // PEZ
    *out += "\n"; // GDS

    // struct member: float y
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->y); // PEZ
}

void VulkanAsciiConsumer::Process_vkSetHdrMetadataEXT(
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchains,
    const StructPointerDecoder<Decoded_VkHdrMetadataEXT>& pMetadata)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t swapchainCount
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, swapchainCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkSwapchainKHR* pSwapchains
    IndentSpaces(out, indent);
    *out += "pSwapchains:                    ";
    *out += "const VkSwapchainKHR* = "; // TEQ
    if (pSwapchains.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSwapchains.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        ArrayToString<const VkSwapchainKHR*>(out, indent, 1, "const VkSwapchainKHR*", reinterpret_cast<const VkSwapchainKHR*>(pSwapchains.GetPointer()), "pSwapchains", swapchainCount,  vinfo_pSwapchains);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: const VkHdrMetadataEXT* pMetadata
    IndentSpaces(out, indent);
    *out += "pMetadata:                      ";
    *out += "const VkHdrMetadataEXT* = "; // TEQ
    if (pMetadata.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMetadata.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkHdrMetadataEXT>(out, indent+1, 1, "VkHdrMetadataEXT", pMetadata.GetMetaStructPointer(), "pMetadata", swapchainCount, false, pMetadata.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIOSSurfaceCreateInfoMVK *pstruct = (const VkIOSSurfaceCreateInfoMVK *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkIOSSurfaceCreateFlagsMVK flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkIOSSurfaceCreateFlagsMVK = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pView
    IndentSpaces(out, indent);
    *out += "pView:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pView == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pView); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateIOSSurfaceMVK(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkIOSSurfaceCreateInfoMVK>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkIOSSurfaceCreateInfoMVK* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkIOSSurfaceCreateInfoMVK* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMacOSSurfaceCreateInfoMVK *pstruct = (const VkMacOSSurfaceCreateInfoMVK *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkMacOSSurfaceCreateFlagsMVK flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMacOSSurfaceCreateFlagsMVK = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pView
    IndentSpaces(out, indent);
    *out += "pView:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pView == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pView); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateMacOSSurfaceMVK(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkMacOSSurfaceCreateInfoMVK>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkMacOSSurfaceCreateInfoMVK* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkMacOSSurfaceCreateInfoMVK* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsLabelEXT>(std::string* out, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsObjectTagInfoEXT *pstruct = (const VkDebugUtilsObjectTagInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkObjectType objectType
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkObjectType = "; // TEQ
    EnumToStringVkObjectType(out, pstruct->objectType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint64_t objectHandle
    IndentSpaces(out, indent);
    *out += "objectHandle:                   ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectHandle); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t tagName
    IndentSpaces(out, indent);
    *out += "tagName:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagName); // UYW
    *out += "\n"; // GDS

    // struct member: size_t tagSize
    IndentSpaces(out, indent);
    *out += "tagSize:                        ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagSize); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pTag
    IndentSpaces(out, indent);
    *out += "pTag:                           ";
    *out += "const void* = "; // TEQ
    if (pstruct->pTag == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTag.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsObjectNameInfoEXT *pstruct = (const VkDebugUtilsObjectNameInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkObjectType objectType
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkObjectType = "; // TEQ
    EnumToStringVkObjectType(out, pstruct->objectType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint64_t objectHandle
    IndentSpaces(out, indent);
    *out += "objectHandle:                   ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectHandle); // UYW
    *out += "\n"; // GDS

    // struct member: const char* pObjectName
    IndentSpaces(out, indent);
    *out += "pObjectName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pObjectName); // TGI
}

template <>
void StructureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsMessengerCallbackDataEXT *pstruct = (const VkDebugUtilsMessengerCallbackDataEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDebugUtilsMessengerCallbackDataFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDebugUtilsMessengerCallbackDataFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: const char* pMessageIdName
    IndentSpaces(out, indent);
    *out += "pMessageIdName:                 ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pMessageIdName); // TGI
    *out += "\n"; // GDS

    // struct member: int32_t messageIdNumber
    IndentSpaces(out, indent);
    *out += "messageIdNumber:                ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->messageIdNumber); //EQA
    *out += "\n"; // GDS

    // struct member: const char* pMessage
    IndentSpaces(out, indent);
    *out += "pMessage:                       ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pMessage); // TGI
    *out += "\n"; // GDS

    // struct member: uint32_t queueLabelCount
    IndentSpaces(out, indent);
    *out += "queueLabelCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueLabelCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDebugUtilsLabelEXT* pQueueLabels
    IndentSpaces(out, indent);
    *out += "pQueueLabels:                   ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pstruct->pQueueLabels == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueLabels->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(out, indent+1, 1, "VkDebugUtilsLabelEXT", pstruct_in.pQueueLabels->GetMetaStructPointer(), "pQueueLabels", pstruct->queueLabelCount, false, pstruct_in.pQueueLabels->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t cmdBufLabelCount
    IndentSpaces(out, indent);
    *out += "cmdBufLabelCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->cmdBufLabelCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDebugUtilsLabelEXT* pCmdBufLabels
    IndentSpaces(out, indent);
    *out += "pCmdBufLabels:                  ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pstruct->pCmdBufLabels == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCmdBufLabels->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(out, indent+1, 1, "VkDebugUtilsLabelEXT", pstruct_in.pCmdBufLabels->GetMetaStructPointer(), "pCmdBufLabels", pstruct->cmdBufLabelCount, false, pstruct_in.pCmdBufLabels->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t objectCount
    IndentSpaces(out, indent);
    *out += "objectCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkDebugUtilsObjectNameInfoEXT* pObjects
    IndentSpaces(out, indent);
    *out += "pObjects:                       ";
    *out += "const VkDebugUtilsObjectNameInfoEXT* = "; // TEQ
    if (pstruct->pObjects == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjects->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(out, indent+1, 1, "VkDebugUtilsObjectNameInfoEXT", pstruct_in.pObjects->GetMetaStructPointer(), "pObjects", pstruct->objectCount, false, pstruct_in.pObjects->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDebugUtilsLabelEXT>(std::string* out, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsLabelEXT *pstruct = (const VkDebugUtilsLabelEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: const char* pLabelName
    IndentSpaces(out, indent);
    *out += "pLabelName:                     ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pLabelName); // TGI
    *out += "\n"; // GDS

    // struct member: float color
    IndentSpaces(out, indent);
    *out += "color:                          ";
    *out += "float[";
    *out += "4"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkDebugUtilsLabelEXT, color)); // IYY
    ScalarValueToStringStruct vinfo_color = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->color), "color", 4, vinfo_color); // JPA
}

template <>
void StructureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsMessengerCreateInfoEXT *pstruct = (const VkDebugUtilsMessengerCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDebugUtilsMessengerCreateFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDebugUtilsMessengerCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkDebugUtilsMessageSeverityFlagsEXT messageSeverity
    IndentSpaces(out, indent);
    *out += "messageSeverity:                ";
    *out += "VkDebugUtilsMessageSeverityFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->messageSeverity, EnumToStringVkDebugUtilsMessageSeverityFlagBitsEXT); // URW
    *out += "\n"; // GDS

    // struct member: VkDebugUtilsMessageTypeFlagsEXT messageType
    IndentSpaces(out, indent);
    *out += "messageType:                    ";
    *out += "VkDebugUtilsMessageTypeFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->messageType, EnumToStringVkDebugUtilsMessageTypeFlagBitsEXT); // URW
    *out += "\n"; // GDS

    // struct member: PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback
    IndentSpaces(out, indent);
    *out += "pfnUserCallback:                ";
    *out += "PFN_vkDebugUtilsMessengerCallbackEXT = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnUserCallback)); // WRX
    *out += "\n"; // GDS

    // struct member: void* pUserData
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCmdBeginDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsLabelEXT* pLabelInfo
    IndentSpaces(out, indent);
    *out += "pLabelInfo:                     ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pLabelInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pLabelInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(out, *pLabelInfo.GetMetaStructPointer(), indent+1,pLabelInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDebugUtilsMessengerEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDebugUtilsMessengerCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDebugUtilsMessengerEXT>& pMessenger)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkDebugUtilsMessengerCreateInfoEXT* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDebugUtilsMessengerEXT* pMessenger
    IndentSpaces(out, indent);
    *out += "pMessenger:                     ";
    *out += "VkDebugUtilsMessengerEXT* = "; // TEQ
    if (pMessenger.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pMessenger = {true, false, false, nullptr};
        ScalarValueToString(out, pMessenger.GetPointer(), vinfo_pMessenger); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdEndDebugUtilsLabelEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDebugUtilsMessengerEXT(
    format::HandleId                            instance,
    format::HandleId                            messenger,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDebugUtilsMessengerEXT messenger
    IndentSpaces(out, indent);
    *out += "messenger:                      ";
    *out += "VkDebugUtilsMessengerEXT = "; // TEQ
    AddrToString(out, messenger); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueInsertDebugUtilsLabelEXT(
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsLabelEXT* pLabelInfo
    IndentSpaces(out, indent);
    *out += "pLabelInfo:                     ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pLabelInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pLabelInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(out, *pLabelInfo.GetMetaStructPointer(), indent+1,pLabelInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkSetDebugUtilsObjectTagEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugUtilsObjectTagInfoEXT>& pTagInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkSetDebugUtilsObjectTagEXT(device, pTagInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsObjectTagInfoEXT* pTagInfo
    IndentSpaces(out, indent);
    *out += "pTagInfo:                       ";
    *out += "const VkDebugUtilsObjectTagInfoEXT* = "; // TEQ
    if (pTagInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pTagInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(out, *pTagInfo.GetMetaStructPointer(), indent+1,pTagInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueBeginDebugUtilsLabelEXT(
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsLabelEXT* pLabelInfo
    IndentSpaces(out, indent);
    *out += "pLabelInfo:                     ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pLabelInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pLabelInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(out, *pLabelInfo.GetMetaStructPointer(), indent+1,pLabelInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkSetDebugUtilsObjectNameEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugUtilsObjectNameInfoEXT>& pNameInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkSetDebugUtilsObjectNameEXT(device, pNameInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsObjectNameInfoEXT* pNameInfo
    IndentSpaces(out, indent);
    *out += "pNameInfo:                      ";
    *out += "const VkDebugUtilsObjectNameInfoEXT* = "; // TEQ
    if (pNameInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pNameInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(out, *pNameInfo.GetMetaStructPointer(), indent+1,pNameInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdInsertDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsLabelEXT* pLabelInfo
    IndentSpaces(out, indent);
    *out += "pLabelInfo:                     ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pLabelInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pLabelInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(out, *pLabelInfo.GetMetaStructPointer(), indent+1,pLabelInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueEndDebugUtilsLabelEXT(
    format::HandleId                            queue)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueueEndDebugUtilsLabelEXT(queue)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkSubmitDebugUtilsMessageEXT(
    format::HandleId                            instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT             messageTypes,
    const StructPointerDecoder<Decoded_VkDebugUtilsMessengerCallbackDataEXT>& pCallbackData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity
    IndentSpaces(out, indent);
    *out += "messageSeverity:                ";
    *out += "VkDebugUtilsMessageSeverityFlagBitsEXT = "; // TEQ
    EnumToStringVkDebugUtilsMessageSeverityFlagBitsEXT(out, messageSeverity); // VSA
    *out += " (";
    UnsignedDecimalToString(out, messageSeverity);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkDebugUtilsMessageTypeFlagsEXT messageTypes
    IndentSpaces(out, indent);
    *out += "messageTypes:                   ";
    *out += "VkDebugUtilsMessageTypeFlagsEXT = "; // TEQ
    FlagsToString(out, messageTypes, EnumToStringVkDebugUtilsMessageTypeFlagBitsEXT); // URW
    outString += "\n";   // HHS

    // func arg: const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData
    IndentSpaces(out, indent);
    *out += "pCallbackData:                  ";
    *out += "const VkDebugUtilsMessengerCallbackDataEXT* = "; // TEQ
    if (pCallbackData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCallbackData.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(out, *pCallbackData.GetMetaStructPointer(), indent+1,pCallbackData.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkExternalFormatANDROID>(std::string* out, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImportAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAndroidHardwareBufferUsageANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkExternalFormatANDROID>(std::string* out, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalFormatANDROID *pstruct = (const VkExternalFormatANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint64_t externalFormat
    IndentSpaces(out, indent);
    *out += "externalFormat:                 ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->externalFormat); // UYW
}

template <>
void StructureToString<Decoded_VkImportAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportAndroidHardwareBufferInfoANDROID *pstruct = (const VkImportAndroidHardwareBufferInfoANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: struct void* buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "struct void* = "; // TEQ
    if (pstruct->buffer == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.buffer); // PWR
    }
}

template <>
void StructureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidHardwareBufferPropertiesANDROID *pstruct = (const VkAndroidHardwareBufferPropertiesANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceSize allocationSize
    IndentSpaces(out, indent);
    *out += "allocationSize:                 ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->allocationSize); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits); // UYW
}

template <>
void StructureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryGetAndroidHardwareBufferInfoANDROID *pstruct = (const VkMemoryGetAndroidHardwareBufferInfoANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
}

template <>
void StructureToString<Decoded_VkAndroidHardwareBufferUsageANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidHardwareBufferUsageANDROID *pstruct = (const VkAndroidHardwareBufferUsageANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint64_t androidHardwareBufferUsage
    IndentSpaces(out, indent);
    *out += "androidHardwareBufferUsage:     ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->androidHardwareBufferUsage); // UYW
}

template <>
void StructureToString<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidHardwareBufferFormatPropertiesANDROID *pstruct = (const VkAndroidHardwareBufferFormatPropertiesANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFormat format
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint64_t externalFormat
    IndentSpaces(out, indent);
    *out += "externalFormat:                 ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->externalFormat); // UYW
    *out += "\n"; // GDS

    // struct member: VkFormatFeatureFlags formatFeatures
    IndentSpaces(out, indent);
    *out += "formatFeatures:                 ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->formatFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkComponentMapping samplerYcbcrConversionComponents
    IndentSpaces(out, indent);
    *out += "samplerYcbcrConversionComponents: ";
    *out += "VkComponentMapping = "; // TEQ
    StructureToString<Decoded_VkComponentMapping>(out, *pstruct_in.samplerYcbcrConversionComponents, indent+1,  base_addr + offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkSamplerYcbcrModelConversion suggestedYcbcrModel
    IndentSpaces(out, indent);
    *out += "suggestedYcbcrModel:            ";
    *out += "VkSamplerYcbcrModelConversion = "; // TEQ
    EnumToStringVkSamplerYcbcrModelConversion(out, pstruct->suggestedYcbcrModel); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedYcbcrModel);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSamplerYcbcrRange suggestedYcbcrRange
    IndentSpaces(out, indent);
    *out += "suggestedYcbcrRange:            ";
    *out += "VkSamplerYcbcrRange = "; // TEQ
    EnumToStringVkSamplerYcbcrRange(out, pstruct->suggestedYcbcrRange); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedYcbcrRange);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkChromaLocation suggestedXChromaOffset
    IndentSpaces(out, indent);
    *out += "suggestedXChromaOffset:         ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->suggestedXChromaOffset); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedXChromaOffset);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkChromaLocation suggestedYChromaOffset
    IndentSpaces(out, indent);
    *out += "suggestedYChromaOffset:         ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->suggestedYChromaOffset); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedYChromaOffset);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetMemoryAndroidHardwareBufferANDROID(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>& pInfo,
    const PointerDecoder<uint64_t>&             pBuffer)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkMemoryGetAndroidHardwareBufferInfoANDROID* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: struct void** pBuffer
    IndentSpaces(out, indent);
    *out += "pBuffer:                        ";
    *out += "struct void** = "; // TEQ
    if (pBuffer.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pBuffer = {false, false, false, nullptr};
        ScalarValueToString(out, pBuffer.GetPointer(), vinfo_pBuffer); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetAndroidHardwareBufferPropertiesANDROID(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint64_t                                    buffer,
    const StructPointerDecoder<Decoded_VkAndroidHardwareBufferPropertiesANDROID>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const struct void* buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "const struct void* = "; // TEQ
    if ( !buffer) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, buffer); // PWR
    }
    outString += "\n";   // HHS

    // func arg: VkAndroidHardwareBufferPropertiesANDROID* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkAndroidHardwareBufferPropertiesANDROID* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(out, *pProperties.GetMetaStructPointer(), indent+1,pProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>(std::string* out, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMultisamplePropertiesEXT>(std::string* out, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassSampleLocationsEXT>(std::string* out, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSampleLocationsInfoEXT>(std::string* out, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentSampleLocationsEXT>(std::string* out, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSampleLocationEXT>(std::string* out, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>(std::string* out, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassSampleLocationsBeginInfoEXT *pstruct = (const VkRenderPassSampleLocationsBeginInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t attachmentInitialSampleLocationsCount
    IndentSpaces(out, indent);
    *out += "attachmentInitialSampleLocationsCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentInitialSampleLocationsCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations
    IndentSpaces(out, indent);
    *out += "pAttachmentInitialSampleLocations: ";
    *out += "const VkAttachmentSampleLocationsEXT* = "; // TEQ
    if (pstruct->pAttachmentInitialSampleLocations == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachmentInitialSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkAttachmentSampleLocationsEXT>(out, indent+1, 1, "VkAttachmentSampleLocationsEXT", pstruct_in.pAttachmentInitialSampleLocations->GetMetaStructPointer(), "pAttachmentInitialSampleLocations", pstruct->attachmentInitialSampleLocationsCount, false, pstruct_in.pAttachmentInitialSampleLocations->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t postSubpassSampleLocationsCount
    IndentSpaces(out, indent);
    *out += "postSubpassSampleLocationsCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->postSubpassSampleLocationsCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations
    IndentSpaces(out, indent);
    *out += "pPostSubpassSampleLocations:    ";
    *out += "const VkSubpassSampleLocationsEXT* = "; // TEQ
    if (pstruct->pPostSubpassSampleLocations == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPostSubpassSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubpassSampleLocationsEXT>(out, indent+1, 1, "VkSubpassSampleLocationsEXT", pstruct_in.pPostSubpassSampleLocations->GetMetaStructPointer(), "pPostSubpassSampleLocations", pstruct->postSubpassSampleLocationsCount, false, pstruct_in.pPostSubpassSampleLocations->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkMultisamplePropertiesEXT>(std::string* out, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMultisamplePropertiesEXT *pstruct = (const VkMultisamplePropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExtent2D maxSampleLocationGridSize
    IndentSpaces(out, indent);
    *out += "maxSampleLocationGridSize:      ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxSampleLocationGridSize, indent+1,  base_addr + offsetof(VkMultisamplePropertiesEXT, maxSampleLocationGridSize)); // AZJ
}

template <>
void StructureToString<Decoded_VkSubpassSampleLocationsEXT>(std::string* out, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassSampleLocationsEXT *pstruct = (const VkSubpassSampleLocationsEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t subpassIndex
    IndentSpaces(out, indent);
    *out += "subpassIndex:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassIndex); // UYW
    *out += "\n"; // GDS

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    IndentSpaces(out, indent);
    *out += "sampleLocationsInfo:            ";
    *out += "VkSampleLocationsInfoEXT = "; // TEQ
    StructureToString<Decoded_VkSampleLocationsInfoEXT>(out, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkSubpassSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

template <>
void StructureToString<Decoded_VkSampleLocationsInfoEXT>(std::string* out, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSampleLocationsInfoEXT *pstruct = (const VkSampleLocationsInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlagBits sampleLocationsPerPixel
    IndentSpaces(out, indent);
    *out += "sampleLocationsPerPixel:        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->sampleLocationsPerPixel); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sampleLocationsPerPixel);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkExtent2D sampleLocationGridSize
    IndentSpaces(out, indent);
    *out += "sampleLocationGridSize:         ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.sampleLocationGridSize, indent+1,  base_addr + offsetof(VkSampleLocationsInfoEXT, sampleLocationGridSize)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t sampleLocationsCount
    IndentSpaces(out, indent);
    *out += "sampleLocationsCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleLocationsCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSampleLocationEXT* pSampleLocations
    IndentSpaces(out, indent);
    *out += "pSampleLocations:               ";
    *out += "const VkSampleLocationEXT* = "; // TEQ
    if (pstruct->pSampleLocations == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSampleLocationEXT>(out, indent+1, 1, "VkSampleLocationEXT", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationsCount, false, pstruct_in.pSampleLocations->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkAttachmentSampleLocationsEXT>(std::string* out, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentSampleLocationsEXT *pstruct = (const VkAttachmentSampleLocationsEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t attachmentIndex
    IndentSpaces(out, indent);
    *out += "attachmentIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentIndex); // UYW
    *out += "\n"; // GDS

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    IndentSpaces(out, indent);
    *out += "sampleLocationsInfo:            ";
    *out += "VkSampleLocationsInfoEXT = "; // TEQ
    StructureToString<Decoded_VkSampleLocationsInfoEXT>(out, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkAttachmentSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSampleLocationsPropertiesEXT *pstruct = (const VkPhysicalDeviceSampleLocationsPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags sampleLocationSampleCounts
    IndentSpaces(out, indent);
    *out += "sampleLocationSampleCounts:     ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampleLocationSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkExtent2D maxSampleLocationGridSize
    IndentSpaces(out, indent);
    *out += "maxSampleLocationGridSize:      ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxSampleLocationGridSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize)); // AZJ
    *out += "\n"; // GDS

    // struct member: float sampleLocationCoordinateRange
    IndentSpaces(out, indent);
    *out += "sampleLocationCoordinateRange:  ";
    *out += "float[";
    *out += "2"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationCoordinateRange)); // IYY
    ScalarValueToStringStruct vinfo_sampleLocationCoordinateRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->sampleLocationCoordinateRange), "sampleLocationCoordinateRange", 2, vinfo_sampleLocationCoordinateRange); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t sampleLocationSubPixelBits
    IndentSpaces(out, indent);
    *out += "sampleLocationSubPixelBits:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleLocationSubPixelBits); // UYW
    *out += "\n"; // GDS

    // struct member: VkBool32 variableSampleLocations
    IndentSpaces(out, indent);
    *out += "variableSampleLocations:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variableSampleLocations); //EQA
}

template <>
void StructureToString<Decoded_VkSampleLocationEXT>(std::string* out, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSampleLocationEXT *pstruct = (const VkSampleLocationEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: float x
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->x); // PEZ
    *out += "\n"; // GDS

    // struct member: float y
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->y); // PEZ
}

template <>
void StructureToString<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineSampleLocationsStateCreateInfoEXT *pstruct = (const VkPipelineSampleLocationsStateCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 sampleLocationsEnable
    IndentSpaces(out, indent);
    *out += "sampleLocationsEnable:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sampleLocationsEnable); //EQA
    *out += "\n"; // GDS

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    IndentSpaces(out, indent);
    *out += "sampleLocationsInfo:            ";
    *out += "VkSampleLocationsInfoEXT = "; // TEQ
    StructureToString<Decoded_VkSampleLocationsInfoEXT>(out, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMultisamplePropertiesEXT(
    format::HandleId                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    const StructPointerDecoder<Decoded_VkMultisamplePropertiesEXT>& pMultisampleProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSampleCountFlagBits samples
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, samples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, samples);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkMultisamplePropertiesEXT* pMultisampleProperties
    IndentSpaces(out, indent);
    *out += "pMultisampleProperties:         ";
    *out += "VkMultisamplePropertiesEXT* = "; // TEQ
    if (pMultisampleProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMultisampleProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMultisamplePropertiesEXT>(out, *pMultisampleProperties.GetMetaStructPointer(), indent+1,pMultisampleProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetSampleLocationsEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSampleLocationsInfoEXT>& pSampleLocationsInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkSampleLocationsInfoEXT* pSampleLocationsInfo
    IndentSpaces(out, indent);
    *out += "pSampleLocationsInfo:           ";
    *out += "const VkSampleLocationsInfoEXT* = "; // TEQ
    if (pSampleLocationsInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSampleLocationsInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkSampleLocationsInfoEXT>(out, *pSampleLocationsInfo.GetMetaStructPointer(), indent+1,pSampleLocationsInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(std::string* out, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrmFormatModifierPropertiesListEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageDrmFormatModifierPropertiesEXT *pstruct = (const VkImageDrmFormatModifierPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier); // UYW
}

template <>
void StructureToString<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageDrmFormatModifierListCreateInfoEXT *pstruct = (const VkImageDrmFormatModifierListCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t drmFormatModifierCount
    IndentSpaces(out, indent);
    *out += "drmFormatModifierCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint64_t* pDrmFormatModifiers
    IndentSpaces(out, indent);
    *out += "pDrmFormatModifiers:            ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pDrmFormatModifiers == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDrmFormatModifiers.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDrmFormatModifiers = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pDrmFormatModifiers.GetPointer()), "pDrmFormatModifiers", pstruct->drmFormatModifierCount,  vinfo_pDrmFormatModifiers);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageDrmFormatModifierExplicitCreateInfoEXT *pstruct = (const VkImageDrmFormatModifierExplicitCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t drmFormatModifierPlaneCount
    IndentSpaces(out, indent);
    *out += "drmFormatModifierPlaneCount:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierPlaneCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkSubresourceLayout* pPlaneLayouts
    IndentSpaces(out, indent);
    *out += "pPlaneLayouts:                  ";
    *out += "const VkSubresourceLayout* = "; // TEQ
    if (pstruct->pPlaneLayouts == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPlaneLayouts->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkSubresourceLayout>(out, indent+1, 1, "VkSubresourceLayout", pstruct_in.pPlaneLayouts->GetMetaStructPointer(), "pPlaneLayouts", pstruct->drmFormatModifierPlaneCount, false, pstruct_in.pPlaneLayouts->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(std::string* out, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *pstruct = (const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier); // UYW
    *out += "\n"; // GDS

    // struct member: VkSharingMode sharingMode
    IndentSpaces(out, indent);
    *out += "sharingMode:                    ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->sharingMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t queueFamilyIndexCount
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pQueueFamilyIndices
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkDrmFormatModifierPropertiesListEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrmFormatModifierPropertiesListEXT *pstruct = (const VkDrmFormatModifierPropertiesListEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t drmFormatModifierCount
    IndentSpaces(out, indent);
    *out += "drmFormatModifierCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties
    IndentSpaces(out, indent);
    *out += "pDrmFormatModifierProperties:   ";
    *out += "VkDrmFormatModifierPropertiesEXT* = "; // TEQ
    if (pstruct->pDrmFormatModifierProperties == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDrmFormatModifierProperties->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkDrmFormatModifierPropertiesEXT>(out, indent+1, 1, "VkDrmFormatModifierPropertiesEXT", pstruct_in.pDrmFormatModifierProperties->GetMetaStructPointer(), "pDrmFormatModifierProperties", pstruct->drmFormatModifierCount, false, pstruct_in.pDrmFormatModifierProperties->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrmFormatModifierPropertiesEXT *pstruct = (const VkDrmFormatModifierPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint64_t drmFormatModifier
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t drmFormatModifierPlaneCount
    IndentSpaces(out, indent);
    *out += "drmFormatModifierPlaneCount:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierPlaneCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkFormatFeatureFlags drmFormatModifierTilingFeatures
    IndentSpaces(out, indent);
    *out += "drmFormatModifierTilingFeatures: ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->drmFormatModifierTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetImageDrmFormatModifierPropertiesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkImageDrmFormatModifierPropertiesEXT>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImage image
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, image); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageDrmFormatModifierPropertiesEXT* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkImageDrmFormatModifierPropertiesEXT* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(out, *pProperties.GetMetaStructPointer(), indent+1,pProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkValidationCacheCreateInfoEXT *pstruct = (const VkValidationCacheCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkValidationCacheCreateFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkValidationCacheCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: size_t initialDataSize
    IndentSpaces(out, indent);
    *out += "initialDataSize:                ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->initialDataSize); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pInitialData
    IndentSpaces(out, indent);
    *out += "pInitialData:                   ";
    *out += "const void* = "; // TEQ
    if (pstruct->pInitialData == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInitialData.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderModuleValidationCacheCreateInfoEXT *pstruct = (const VkShaderModuleValidationCacheCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkValidationCacheEXT validationCache
    IndentSpaces(out, indent);
    *out += "validationCache:                ";
    *out += "VkValidationCacheEXT = "; // TEQ
    AddrToString(out, pstruct_in.validationCache); // PAQ
}

void VulkanAsciiConsumer::Process_vkDestroyValidationCacheEXT(
    format::HandleId                            device,
    format::HandleId                            validationCache,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyValidationCacheEXT(device, validationCache, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkValidationCacheEXT validationCache
    IndentSpaces(out, indent);
    *out += "validationCache:                ";
    *out += "VkValidationCacheEXT = "; // TEQ
    AddrToString(out, validationCache); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateValidationCacheEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkValidationCacheCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkValidationCacheEXT>& pValidationCache)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkValidationCacheCreateInfoEXT* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkValidationCacheCreateInfoEXT* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkValidationCacheCreateInfoEXT>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkValidationCacheEXT* pValidationCache
    IndentSpaces(out, indent);
    *out += "pValidationCache:               ";
    *out += "VkValidationCacheEXT* = "; // TEQ
    if (pValidationCache.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pValidationCache = {true, false, false, nullptr};
        ScalarValueToString(out, pValidationCache.GetPointer(), vinfo_pValidationCache); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetValidationCacheDataEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            validationCache,
    const PointerDecoder<size_t>&               pDataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkValidationCacheEXT validationCache
    IndentSpaces(out, indent);
    *out += "validationCache:                ";
    *out += "VkValidationCacheEXT = "; // TEQ
    AddrToString(out, validationCache); // PAQ
    outString += "\n";   // HHS

    // func arg: size_t* pDataSize
    IndentSpaces(out, indent);
    *out += "pDataSize:                      ";
    *out += "size_t* = "; // TEQ
    if (pDataSize.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pDataSize = {false, false, false, nullptr};
        ScalarValueToString(out, pDataSize.GetPointer(), vinfo_pDataSize); // PWS
    }
    outString += "\n";   // HHS

    // func arg: void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "void* = "; // TEQ
    if (pData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pData.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkMergeValidationCachesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    const HandlePointerDecoder<VkValidationCacheEXT>& pSrcCaches)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkValidationCacheEXT dstCache
    IndentSpaces(out, indent);
    *out += "dstCache:                       ";
    *out += "VkValidationCacheEXT = "; // TEQ
    AddrToString(out, dstCache); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t srcCacheCount
    IndentSpaces(out, indent);
    *out += "srcCacheCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, srcCacheCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkValidationCacheEXT* pSrcCaches
    IndentSpaces(out, indent);
    *out += "pSrcCaches:                     ";
    *out += "const VkValidationCacheEXT* = "; // TEQ
    if (pSrcCaches.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSrcCaches.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pSrcCaches = {true, false, false, nullptr};
        ArrayToString<const VkValidationCacheEXT*>(out, indent, 1, "const VkValidationCacheEXT*", reinterpret_cast<const VkValidationCacheEXT*>(pSrcCaches.GetPointer()), "pSrcCaches", srcCacheCount,  vinfo_pSrcCaches);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCoarseSampleOrderCustomNV>(std::string* out, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkShadingRatePaletteNV>(std::string* out, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCoarseSampleLocationNV>(std::string* out, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceShadingRateImagePropertiesNV *pstruct = (const VkPhysicalDeviceShadingRateImagePropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExtent2D shadingRateTexelSize
    IndentSpaces(out, indent);
    *out += "shadingRateTexelSize:           ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.shadingRateTexelSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize)); // AZJ
    *out += "\n"; // GDS

    // struct member: uint32_t shadingRatePaletteSize
    IndentSpaces(out, indent);
    *out += "shadingRatePaletteSize:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shadingRatePaletteSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t shadingRateMaxCoarseSamples
    IndentSpaces(out, indent);
    *out += "shadingRateMaxCoarseSamples:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shadingRateMaxCoarseSamples); // UYW
}

template <>
void StructureToString<Decoded_VkCoarseSampleOrderCustomNV>(std::string* out, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCoarseSampleOrderCustomNV *pstruct = (const VkCoarseSampleOrderCustomNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkShadingRatePaletteEntryNV shadingRate
    IndentSpaces(out, indent);
    *out += "shadingRate:                    ";
    *out += "VkShadingRatePaletteEntryNV = "; // TEQ
    EnumToStringVkShadingRatePaletteEntryNV(out, pstruct->shadingRate); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->shadingRate);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t sampleCount
    IndentSpaces(out, indent);
    *out += "sampleCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t sampleLocationCount
    IndentSpaces(out, indent);
    *out += "sampleLocationCount:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleLocationCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkCoarseSampleLocationNV* pSampleLocations
    IndentSpaces(out, indent);
    *out += "pSampleLocations:               ";
    *out += "const VkCoarseSampleLocationNV* = "; // TEQ
    if (pstruct->pSampleLocations == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSampleLocations->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkCoarseSampleLocationNV>(out, indent+1, 1, "VkCoarseSampleLocationNV", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationCount, false, pstruct_in.pSampleLocations->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportShadingRateImageStateCreateInfoNV *pstruct = (const VkPipelineViewportShadingRateImageStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 shadingRateImageEnable
    IndentSpaces(out, indent);
    *out += "shadingRateImageEnable:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shadingRateImageEnable); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t viewportCount
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkShadingRatePaletteNV* pShadingRatePalettes
    IndentSpaces(out, indent);
    *out += "pShadingRatePalettes:           ";
    *out += "const VkShadingRatePaletteNV* = "; // TEQ
    if (pstruct->pShadingRatePalettes == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pShadingRatePalettes->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkShadingRatePaletteNV>(out, indent+1, 1, "VkShadingRatePaletteNV", pstruct_in.pShadingRatePalettes->GetMetaStructPointer(), "pShadingRatePalettes", pstruct->viewportCount, false, pstruct_in.pShadingRatePalettes->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceShadingRateImageFeaturesNV *pstruct = (const VkPhysicalDeviceShadingRateImageFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 shadingRateImage
    IndentSpaces(out, indent);
    *out += "shadingRateImage:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shadingRateImage); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 shadingRateCoarseSampleOrder
    IndentSpaces(out, indent);
    *out += "shadingRateCoarseSampleOrder:   ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shadingRateCoarseSampleOrder); //EQA
}

template <>
void StructureToString<Decoded_VkShadingRatePaletteNV>(std::string* out, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShadingRatePaletteNV *pstruct = (const VkShadingRatePaletteNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t shadingRatePaletteEntryCount
    IndentSpaces(out, indent);
    *out += "shadingRatePaletteEntryCount:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shadingRatePaletteEntryCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkShadingRatePaletteEntryNV* pShadingRatePaletteEntries
    IndentSpaces(out, indent);
    *out += "pShadingRatePaletteEntries:     ";
    *out += "const VkShadingRatePaletteEntryNV* = "; // TEQ
    if (pstruct->pShadingRatePaletteEntries == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pShadingRatePaletteEntries.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pShadingRatePaletteEntries = {false, true, false, EnumToStringVkShadingRatePaletteEntryNV};
        ArrayToString<const VkShadingRatePaletteEntryNV*>(out, indent, 1, "const VkShadingRatePaletteEntryNV*", reinterpret_cast<const VkShadingRatePaletteEntryNV*>(pstruct_in.pShadingRatePaletteEntries.GetPointer()), "pShadingRatePaletteEntries", pstruct->shadingRatePaletteEntryCount,  vinfo_pShadingRatePaletteEntries);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkCoarseSampleLocationNV>(std::string* out, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCoarseSampleLocationNV *pstruct = (const VkCoarseSampleLocationNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t pixelX
    IndentSpaces(out, indent);
    *out += "pixelX:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->pixelX); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t pixelY
    IndentSpaces(out, indent);
    *out += "pixelY:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->pixelY); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t sample
    IndentSpaces(out, indent);
    *out += "sample:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sample); // UYW
}

template <>
void StructureToString<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *pstruct = (const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkCoarseSampleOrderTypeNV sampleOrderType
    IndentSpaces(out, indent);
    *out += "sampleOrderType:                ";
    *out += "VkCoarseSampleOrderTypeNV = "; // TEQ
    EnumToStringVkCoarseSampleOrderTypeNV(out, pstruct->sampleOrderType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sampleOrderType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t customSampleOrderCount
    IndentSpaces(out, indent);
    *out += "customSampleOrderCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->customSampleOrderCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkCoarseSampleOrderCustomNV* pCustomSampleOrders
    IndentSpaces(out, indent);
    *out += "pCustomSampleOrders:            ";
    *out += "const VkCoarseSampleOrderCustomNV* = "; // TEQ
    if (pstruct->pCustomSampleOrders == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCustomSampleOrders->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkCoarseSampleOrderCustomNV>(out, indent+1, 1, "VkCoarseSampleOrderCustomNV", pstruct_in.pCustomSampleOrders->GetMetaStructPointer(), "pCustomSampleOrders", pstruct->customSampleOrderCount, false, pstruct_in.pCustomSampleOrders->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetCoarseSampleOrderNV(
    format::HandleId                            commandBuffer,
    VkCoarseSampleOrderTypeNV                   sampleOrderType,
    uint32_t                                    customSampleOrderCount,
    const StructPointerDecoder<Decoded_VkCoarseSampleOrderCustomNV>& pCustomSampleOrders)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCoarseSampleOrderTypeNV sampleOrderType
    IndentSpaces(out, indent);
    *out += "sampleOrderType:                ";
    *out += "VkCoarseSampleOrderTypeNV = "; // TEQ
    EnumToStringVkCoarseSampleOrderTypeNV(out, sampleOrderType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, sampleOrderType);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: uint32_t customSampleOrderCount
    IndentSpaces(out, indent);
    *out += "customSampleOrderCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, customSampleOrderCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkCoarseSampleOrderCustomNV* pCustomSampleOrders
    IndentSpaces(out, indent);
    *out += "pCustomSampleOrders:            ";
    *out += "const VkCoarseSampleOrderCustomNV* = "; // TEQ
    if (pCustomSampleOrders.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCustomSampleOrders.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkCoarseSampleOrderCustomNV>(out, indent+1, 1, "VkCoarseSampleOrderCustomNV", pCustomSampleOrders.GetMetaStructPointer(), "pCustomSampleOrders", customSampleOrderCount, false, pCustomSampleOrders.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetViewportShadingRatePaletteNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkShadingRatePaletteNV>& pShadingRatePalettes)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstViewport
    IndentSpaces(out, indent);
    *out += "firstViewport:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstViewport); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t viewportCount
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, viewportCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkShadingRatePaletteNV* pShadingRatePalettes
    IndentSpaces(out, indent);
    *out += "pShadingRatePalettes:           ";
    *out += "const VkShadingRatePaletteNV* = "; // TEQ
    if (pShadingRatePalettes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pShadingRatePalettes.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkShadingRatePaletteNV>(out, indent+1, 1, "VkShadingRatePaletteNV", pShadingRatePalettes.GetMetaStructPointer(), "pShadingRatePalettes", viewportCount, false, pShadingRatePalettes.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindShadingRateImageNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            imageView,
    VkImageLayout                               imageLayout)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageView imageView
    IndentSpaces(out, indent);
    *out += "imageView:                      ";
    *out += "VkImageView = "; // TEQ
    AddrToString(out, imageView); // PAQ
    outString += "\n";   // HHS

    // func arg: VkImageLayout imageLayout
    IndentSpaces(out, indent);
    *out += "imageLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, imageLayout); // VSA
    *out += " (";
    UnsignedDecimalToString(out, imageLayout);
    *out += ")";
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkRayTracingPipelineCreateInfoNV>(std::string* out, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryNV>(std::string* out, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAccelerationStructureInfoNV>(std::string* out, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryTrianglesNV>(std::string* out, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryDataNV>(std::string* out, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkWriteDescriptorSetAccelerationStructureNV>(std::string* out, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(std::string* out, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(std::string* out, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryAABBNV>(std::string* out, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAccelerationStructureCreateInfoNV>(std::string* out, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(std::string* out, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkRayTracingPipelineCreateInfoNV>(std::string* out, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRayTracingPipelineCreateInfoNV *pstruct = (const VkRayTracingPipelineCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineCreateFlags flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t stageCount
    IndentSpaces(out, indent);
    *out += "stageCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stageCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkPipelineShaderStageCreateInfo* pStages
    IndentSpaces(out, indent);
    *out += "pStages:                        ";
    *out += "const VkPipelineShaderStageCreateInfo* = "; // TEQ
    if (pstruct->pStages == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pStages->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(out, indent+1, 1, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t groupCount
    IndentSpaces(out, indent);
    *out += "groupCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->groupCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkRayTracingShaderGroupCreateInfoNV* pGroups
    IndentSpaces(out, indent);
    *out += "pGroups:                        ";
    *out += "const VkRayTracingShaderGroupCreateInfoNV* = "; // TEQ
    if (pstruct->pGroups == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pGroups->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(out, indent+1, 1, "VkRayTracingShaderGroupCreateInfoNV", pstruct_in.pGroups->GetMetaStructPointer(), "pGroups", pstruct->groupCount, false, pstruct_in.pGroups->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxRecursionDepth
    IndentSpaces(out, indent);
    *out += "maxRecursionDepth:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxRecursionDepth); // UYW
    *out += "\n"; // GDS

    // struct member: VkPipelineLayout layout
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.layout); // PAQ
    *out += "\n"; // GDS

    // struct member: VkPipeline basePipelineHandle
    IndentSpaces(out, indent);
    *out += "basePipelineHandle:             ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.basePipelineHandle); // PAQ
    *out += "\n"; // GDS

    // struct member: int32_t basePipelineIndex
    IndentSpaces(out, indent);
    *out += "basePipelineIndex:              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->basePipelineIndex); //EQA
}

template <>
void StructureToString<Decoded_VkGeometryNV>(std::string* out, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryNV *pstruct = (const VkGeometryNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkGeometryTypeNV geometryType
    IndentSpaces(out, indent);
    *out += "geometryType:                   ";
    *out += "VkGeometryTypeNV = "; // TEQ
    EnumToStringVkGeometryTypeNV(out, pstruct->geometryType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->geometryType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkGeometryDataNV geometry
    IndentSpaces(out, indent);
    *out += "geometry:                       ";
    *out += "VkGeometryDataNV = "; // TEQ
    StructureToString<Decoded_VkGeometryDataNV>(out, *pstruct_in.geometry, indent+1,  base_addr + offsetof(VkGeometryNV, geometry)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkGeometryFlagsNV flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkGeometryFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkGeometryFlagBitsNV); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceRayTracingPropertiesNV *pstruct = (const VkPhysicalDeviceRayTracingPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t shaderGroupHandleSize
    IndentSpaces(out, indent);
    *out += "shaderGroupHandleSize:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shaderGroupHandleSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxRecursionDepth
    IndentSpaces(out, indent);
    *out += "maxRecursionDepth:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxRecursionDepth); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxShaderGroupStride
    IndentSpaces(out, indent);
    *out += "maxShaderGroupStride:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxShaderGroupStride); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t shaderGroupBaseAlignment
    IndentSpaces(out, indent);
    *out += "shaderGroupBaseAlignment:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shaderGroupBaseAlignment); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t maxGeometryCount
    IndentSpaces(out, indent);
    *out += "maxGeometryCount:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t maxInstanceCount
    IndentSpaces(out, indent);
    *out += "maxInstanceCount:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxInstanceCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t maxTriangleCount
    IndentSpaces(out, indent);
    *out += "maxTriangleCount:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTriangleCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxDescriptorSetAccelerationStructures
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetAccelerationStructures: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetAccelerationStructures); // UYW
}

template <>
void StructureToString<Decoded_VkAccelerationStructureInfoNV>(std::string* out, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAccelerationStructureInfoNV *pstruct = (const VkAccelerationStructureInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAccelerationStructureTypeNV type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkAccelerationStructureTypeNV = "; // TEQ
    EnumToStringVkAccelerationStructureTypeNV(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBuildAccelerationStructureFlagsNV flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBuildAccelerationStructureFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkBuildAccelerationStructureFlagBitsNV); // URW
    *out += "\n"; // GDS

    // struct member: uint32_t instanceCount
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->instanceCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t geometryCount
    IndentSpaces(out, indent);
    *out += "geometryCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->geometryCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkGeometryNV* pGeometries
    IndentSpaces(out, indent);
    *out += "pGeometries:                    ";
    *out += "const VkGeometryNV* = "; // TEQ
    if (pstruct->pGeometries == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pGeometries->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkGeometryNV>(out, indent+1, 1, "VkGeometryNV", pstruct_in.pGeometries->GetMetaStructPointer(), "pGeometries", pstruct->geometryCount, false, pstruct_in.pGeometries->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkGeometryTrianglesNV>(std::string* out, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryTrianglesNV *pstruct = (const VkGeometryTrianglesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBuffer vertexData
    IndentSpaces(out, indent);
    *out += "vertexData:                     ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.vertexData); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize vertexOffset
    IndentSpaces(out, indent);
    *out += "vertexOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexOffset); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t vertexCount
    IndentSpaces(out, indent);
    *out += "vertexCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize vertexStride
    IndentSpaces(out, indent);
    *out += "vertexStride:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexStride); //EQA
    *out += "\n"; // GDS

    // struct member: VkFormat vertexFormat
    IndentSpaces(out, indent);
    *out += "vertexFormat:                   ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->vertexFormat); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->vertexFormat);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBuffer indexData
    IndentSpaces(out, indent);
    *out += "indexData:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.indexData); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize indexOffset
    IndentSpaces(out, indent);
    *out += "indexOffset:                    ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->indexOffset); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t indexCount
    IndentSpaces(out, indent);
    *out += "indexCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->indexCount); // UYW
    *out += "\n"; // GDS

    // struct member: VkIndexType indexType
    IndentSpaces(out, indent);
    *out += "indexType:                      ";
    *out += "VkIndexType = "; // TEQ
    EnumToStringVkIndexType(out, pstruct->indexType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->indexType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBuffer transformData
    IndentSpaces(out, indent);
    *out += "transformData:                  ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.transformData); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize transformOffset
    IndentSpaces(out, indent);
    *out += "transformOffset:                ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->transformOffset); //EQA
}

template <>
void StructureToString<Decoded_VkGeometryDataNV>(std::string* out, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryDataNV *pstruct = (const VkGeometryDataNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkGeometryTrianglesNV triangles
    IndentSpaces(out, indent);
    *out += "triangles:                      ";
    *out += "VkGeometryTrianglesNV = "; // TEQ
    StructureToString<Decoded_VkGeometryTrianglesNV>(out, *pstruct_in.triangles, indent+1,  base_addr + offsetof(VkGeometryDataNV, triangles)); // AZJ
    *out += "\n"; // GDS

    // struct member: VkGeometryAABBNV aabbs
    IndentSpaces(out, indent);
    *out += "aabbs:                          ";
    *out += "VkGeometryAABBNV = "; // TEQ
    StructureToString<Decoded_VkGeometryAABBNV>(out, *pstruct_in.aabbs, indent+1,  base_addr + offsetof(VkGeometryDataNV, aabbs)); // AZJ
}

template <>
void StructureToString<Decoded_VkWriteDescriptorSetAccelerationStructureNV>(std::string* out, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWriteDescriptorSetAccelerationStructureNV *pstruct = (const VkWriteDescriptorSetAccelerationStructureNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t accelerationStructureCount
    IndentSpaces(out, indent);
    *out += "accelerationStructureCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->accelerationStructureCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkAccelerationStructureNV* pAccelerationStructures
    IndentSpaces(out, indent);
    *out += "pAccelerationStructures:        ";
    *out += "const VkAccelerationStructureNV* = "; // TEQ
    if (pstruct->pAccelerationStructures == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAccelerationStructures.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAccelerationStructures = {true, false, false, nullptr};
        ArrayToString<const VkAccelerationStructureNV*>(out, indent, 1, "const VkAccelerationStructureNV*", reinterpret_cast<const VkAccelerationStructureNV*>(pstruct_in.pAccelerationStructures.GetPointer()), "pAccelerationStructures", pstruct->accelerationStructureCount,  vinfo_pAccelerationStructures);  // CXC
    }
}

template <>
void StructureToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(std::string* out, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRayTracingShaderGroupCreateInfoNV *pstruct = (const VkRayTracingShaderGroupCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkRayTracingShaderGroupTypeNV type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkRayTracingShaderGroupTypeNV = "; // TEQ
    EnumToStringVkRayTracingShaderGroupTypeNV(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: uint32_t generalShader
    IndentSpaces(out, indent);
    *out += "generalShader:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->generalShader); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t closestHitShader
    IndentSpaces(out, indent);
    *out += "closestHitShader:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->closestHitShader); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t anyHitShader
    IndentSpaces(out, indent);
    *out += "anyHitShader:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->anyHitShader); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t intersectionShader
    IndentSpaces(out, indent);
    *out += "intersectionShader:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->intersectionShader); // UYW
}

template <>
void StructureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(std::string* out, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAccelerationStructureMemoryRequirementsInfoNV *pstruct = (const VkAccelerationStructureMemoryRequirementsInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAccelerationStructureMemoryRequirementsTypeNV type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkAccelerationStructureMemoryRequirementsTypeNV = "; // TEQ
    EnumToStringVkAccelerationStructureMemoryRequirementsTypeNV(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkAccelerationStructureNV accelerationStructure
    IndentSpaces(out, indent);
    *out += "accelerationStructure:          ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, pstruct_in.accelerationStructure); // PAQ
}

template <>
void StructureToString<Decoded_VkGeometryAABBNV>(std::string* out, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryAABBNV *pstruct = (const VkGeometryAABBNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBuffer aabbData
    IndentSpaces(out, indent);
    *out += "aabbData:                       ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.aabbData); // PAQ
    *out += "\n"; // GDS

    // struct member: uint32_t numAABBs
    IndentSpaces(out, indent);
    *out += "numAABBs:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numAABBs); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stride); // UYW
    *out += "\n"; // GDS

    // struct member: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset); //EQA
}

template <>
void StructureToString<Decoded_VkAccelerationStructureCreateInfoNV>(std::string* out, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAccelerationStructureCreateInfoNV *pstruct = (const VkAccelerationStructureCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceSize compactedSize
    IndentSpaces(out, indent);
    *out += "compactedSize:                  ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->compactedSize); //EQA
    *out += "\n"; // GDS

    // struct member: VkAccelerationStructureInfoNV info
    IndentSpaces(out, indent);
    *out += "info:                           ";
    *out += "VkAccelerationStructureInfoNV = "; // TEQ
    StructureToString<Decoded_VkAccelerationStructureInfoNV>(out, *pstruct_in.info, indent+1,  base_addr + offsetof(VkAccelerationStructureCreateInfoNV, info)); // AZJ
}

template <>
void StructureToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(std::string* out, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindAccelerationStructureMemoryInfoNV *pstruct = (const VkBindAccelerationStructureMemoryInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkAccelerationStructureNV accelerationStructure
    IndentSpaces(out, indent);
    *out += "accelerationStructure:          ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, pstruct_in.accelerationStructure); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceMemory memory
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // struct member: VkDeviceSize memoryOffset
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t deviceIndexCount
    IndentSpaces(out, indent);
    *out += "deviceIndexCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceIndexCount); // UYW
    *out += "\n"; // GDS

    // struct member: const uint32_t* pDeviceIndices
    IndentSpaces(out, indent);
    *out += "pDeviceIndices:                 ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CXC
    }
}

void VulkanAsciiConsumer::Process_vkGetRayTracingShaderGroupHandlesNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pipeline); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstGroup
    IndentSpaces(out, indent);
    *out += "firstGroup:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstGroup); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t groupCount
    IndentSpaces(out, indent);
    *out += "groupCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, groupCount); // UYW
    outString += "\n";   // HHS

    // func arg: size_t dataSize
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, dataSize); // UYW
    outString += "\n";   // HHS

    // func arg: void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "void* = "; // TEQ
    if (pData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pData.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBuildAccelerationStructureNV(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkAccelerationStructureInfoNV>& pInfo,
    format::HandleId                            instanceData,
    VkDeviceSize                                instanceOffset,
    VkBool32                                    update,
    format::HandleId                            dst,
    format::HandleId                            src,
    format::HandleId                            scratch,
    VkDeviceSize                                scratchOffset)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAccelerationStructureInfoNV* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkAccelerationStructureInfoNV* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAccelerationStructureInfoNV>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkBuffer instanceData
    IndentSpaces(out, indent);
    *out += "instanceData:                   ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, instanceData); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize instanceOffset
    IndentSpaces(out, indent);
    *out += "instanceOffset:                 ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, instanceOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkBool32 update
    IndentSpaces(out, indent);
    *out += "update:                         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, update); //EQA
    outString += "\n";   // HHS

    // func arg: VkAccelerationStructureNV dst
    IndentSpaces(out, indent);
    *out += "dst:                            ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, dst); // PAQ
    outString += "\n";   // HHS

    // func arg: VkAccelerationStructureNV src
    IndentSpaces(out, indent);
    *out += "src:                            ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, src); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer scratch
    IndentSpaces(out, indent);
    *out += "scratch:                        ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, scratch); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize scratchOffset
    IndentSpaces(out, indent);
    *out += "scratchOffset:                  ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, scratchOffset); //EQA
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetAccelerationStructureHandleNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkAccelerationStructureNV accelerationStructure
    IndentSpaces(out, indent);
    *out += "accelerationStructure:          ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, accelerationStructure); // PAQ
    outString += "\n";   // HHS

    // func arg: size_t dataSize
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, dataSize); // UYW
    outString += "\n";   // HHS

    // func arg: void* pData
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "void* = "; // TEQ
    if (pData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pData.GetAddress()); // AHW
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdTraceRaysNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    format::HandleId                            missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    format::HandleId                            hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    format::HandleId                            callableShaderBindingTableBuffer,
    VkDeviceSize                                callableShaderBindingOffset,
    VkDeviceSize                                callableShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer raygenShaderBindingTableBuffer
    IndentSpaces(out, indent);
    *out += "raygenShaderBindingTableBuffer: ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, raygenShaderBindingTableBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize raygenShaderBindingOffset
    IndentSpaces(out, indent);
    *out += "raygenShaderBindingOffset:      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, raygenShaderBindingOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer missShaderBindingTableBuffer
    IndentSpaces(out, indent);
    *out += "missShaderBindingTableBuffer:   ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, missShaderBindingTableBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize missShaderBindingOffset
    IndentSpaces(out, indent);
    *out += "missShaderBindingOffset:        ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, missShaderBindingOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkDeviceSize missShaderBindingStride
    IndentSpaces(out, indent);
    *out += "missShaderBindingStride:        ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, missShaderBindingStride); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer hitShaderBindingTableBuffer
    IndentSpaces(out, indent);
    *out += "hitShaderBindingTableBuffer:    ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, hitShaderBindingTableBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize hitShaderBindingOffset
    IndentSpaces(out, indent);
    *out += "hitShaderBindingOffset:         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, hitShaderBindingOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkDeviceSize hitShaderBindingStride
    IndentSpaces(out, indent);
    *out += "hitShaderBindingStride:         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, hitShaderBindingStride); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer callableShaderBindingTableBuffer
    IndentSpaces(out, indent);
    *out += "callableShaderBindingTableBuffer: ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, callableShaderBindingTableBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize callableShaderBindingOffset
    IndentSpaces(out, indent);
    *out += "callableShaderBindingOffset:    ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, callableShaderBindingOffset); //EQA
    outString += "\n";   // HHS

    // func arg: VkDeviceSize callableShaderBindingStride
    IndentSpaces(out, indent);
    *out += "callableShaderBindingStride:    ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, callableShaderBindingStride); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t width
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, width); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t height
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, height); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t depth
    IndentSpaces(out, indent);
    *out += "depth:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, depth); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateRayTracingPipelinesNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkRayTracingPipelineCreateInfoNV>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineCache pipelineCache
    IndentSpaces(out, indent);
    *out += "pipelineCache:                  ";
    *out += "VkPipelineCache = "; // TEQ
    AddrToString(out, pipelineCache); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t createInfoCount
    IndentSpaces(out, indent);
    *out += "createInfoCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, createInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkRayTracingPipelineCreateInfoNV* pCreateInfos
    IndentSpaces(out, indent);
    *out += "pCreateInfos:                   ";
    *out += "const VkRayTracingPipelineCreateInfoNV* = "; // TEQ
    if (pCreateInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRayTracingPipelineCreateInfoNV>(out, indent+1, 1, "VkRayTracingPipelineCreateInfoNV", pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkPipeline* pPipelines
    IndentSpaces(out, indent);
    *out += "pPipelines:                     ";
    *out += "VkPipeline* = "; // TEQ
    if (pPipelines.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPipelines.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        ArrayToString<VkPipeline*>(out, indent, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount,  vinfo_pPipelines);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCompileDeferredNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    shader)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCompileDeferredNV(device, pipeline, shader)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipeline pipeline
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pipeline); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t shader
    IndentSpaces(out, indent);
    *out += "shader:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, shader); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateAccelerationStructureNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAccelerationStructureCreateInfoNV>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkAccelerationStructureNV>& pAccelerationStructure)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAccelerationStructureCreateInfoNV* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkAccelerationStructureCreateInfoNV* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAccelerationStructureCreateInfoNV>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkAccelerationStructureNV* pAccelerationStructure
    IndentSpaces(out, indent);
    *out += "pAccelerationStructure:         ";
    *out += "VkAccelerationStructureNV* = "; // TEQ
    if (pAccelerationStructure.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pAccelerationStructure = {true, false, false, nullptr};
        ScalarValueToString(out, pAccelerationStructure.GetPointer(), vinfo_pAccelerationStructure); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyAccelerationStructureNV(
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkAccelerationStructureNV accelerationStructure
    IndentSpaces(out, indent);
    *out += "accelerationStructure:          ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, accelerationStructure); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindAccelerationStructureMemoryNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindAccelerationStructureMemoryInfoNV>& pBindInfos)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t bindInfoCount
    IndentSpaces(out, indent);
    *out += "bindInfoCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, bindInfoCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkBindAccelerationStructureMemoryInfoNV* pBindInfos
    IndentSpaces(out, indent);
    *out += "pBindInfos:                     ";
    *out += "const VkBindAccelerationStructureMemoryInfoNV* = "; // TEQ
    if (pBindInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pBindInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(out, indent+1, 1, "VkBindAccelerationStructureMemoryInfoNV", pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWriteAccelerationStructuresPropertiesNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    accelerationStructureCount,
    const HandlePointerDecoder<VkAccelerationStructureNV>& pAccelerationStructures,
    VkQueryType                                 queryType,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t accelerationStructureCount
    IndentSpaces(out, indent);
    *out += "accelerationStructureCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, accelerationStructureCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkAccelerationStructureNV* pAccelerationStructures
    IndentSpaces(out, indent);
    *out += "pAccelerationStructures:        ";
    *out += "const VkAccelerationStructureNV* = "; // TEQ
    if (pAccelerationStructures.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAccelerationStructures.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pAccelerationStructures = {true, false, false, nullptr};
        ArrayToString<const VkAccelerationStructureNV*>(out, indent, 1, "const VkAccelerationStructureNV*", reinterpret_cast<const VkAccelerationStructureNV*>(pAccelerationStructures.GetPointer()), "pAccelerationStructures", accelerationStructureCount,  vinfo_pAccelerationStructures);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: VkQueryType queryType
    IndentSpaces(out, indent);
    *out += "queryType:                      ";
    *out += "VkQueryType = "; // TEQ
    EnumToStringVkQueryType(out, queryType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, queryType);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstQuery
    IndentSpaces(out, indent);
    *out += "firstQuery:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstQuery); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyAccelerationStructureNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            dst,
    format::HandleId                            src,
    VkCopyAccelerationStructureModeNV           mode)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkAccelerationStructureNV dst
    IndentSpaces(out, indent);
    *out += "dst:                            ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, dst); // PAQ
    outString += "\n";   // HHS

    // func arg: VkAccelerationStructureNV src
    IndentSpaces(out, indent);
    *out += "src:                            ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, src); // PAQ
    outString += "\n";   // HHS

    // func arg: VkCopyAccelerationStructureModeNV mode
    IndentSpaces(out, indent);
    *out += "mode:                           ";
    *out += "VkCopyAccelerationStructureModeNV = "; // TEQ
    EnumToStringVkCopyAccelerationStructureModeNV(out, mode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, mode);
    *out += ")";
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetAccelerationStructureMemoryRequirementsNV(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2KHR>& pMemoryRequirements)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkAccelerationStructureMemoryRequirementsInfoNV* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkMemoryRequirements2KHR* pMemoryRequirements
    IndentSpaces(out, indent);
    *out += "pMemoryRequirements:            ";
    *out += "VkMemoryRequirements2KHR* = "; // TEQ
    if (pMemoryRequirements.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryRequirements.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryRequirements2KHR>(out, *pMemoryRequirements.GetMetaStructPointer(), indent+1,pMemoryRequirements.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(std::string* out, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImportMemoryHostPointerInfoEXT>(std::string* out, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(std::string* out, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryHostPointerPropertiesEXT *pstruct = (const VkMemoryHostPointerPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t memoryTypeBits
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits); // UYW
}

template <>
void StructureToString<Decoded_VkImportMemoryHostPointerInfoEXT>(std::string* out, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryHostPointerInfoEXT *pstruct = (const VkImportMemoryHostPointerInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pHostPointer
    IndentSpaces(out, indent);
    *out += "pHostPointer:                   ";
    *out += "void* = "; // TEQ
    if (pstruct->pHostPointer == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pHostPointer); // PWR
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *pstruct = (const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceSize minImportedHostPointerAlignment
    IndentSpaces(out, indent);
    *out += "minImportedHostPointerAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minImportedHostPointerAlignment); //EQA
}

void VulkanAsciiConsumer::Process_vkGetMemoryHostPointerPropertiesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    pHostPointer,
    const StructPointerDecoder<Decoded_VkMemoryHostPointerPropertiesEXT>& pMemoryHostPointerProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkExternalMemoryHandleTypeFlagBits handleType
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, handleType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, handleType);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: const void* pHostPointer
    IndentSpaces(out, indent);
    *out += "pHostPointer:                   ";
    *out += "const void* = "; // TEQ
    if ( !pHostPointer) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pHostPointer); // PWR
    }
    outString += "\n";   // HHS

    // func arg: VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties
    IndentSpaces(out, indent);
    *out += "pMemoryHostPointerProperties:   ";
    *out += "VkMemoryHostPointerPropertiesEXT* = "; // TEQ
    if (pMemoryHostPointerProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMemoryHostPointerProperties.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(out, *pMemoryHostPointerProperties.GetMetaStructPointer(), indent+1,pMemoryHostPointerProperties.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdWriteBufferMarkerAMD(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPipelineStageFlagBits pipelineStage
    IndentSpaces(out, indent);
    *out += "pipelineStage:                  ";
    *out += "VkPipelineStageFlagBits = "; // TEQ
    EnumToStringVkPipelineStageFlagBits(out, pipelineStage); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pipelineStage);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkBuffer dstBuffer
    IndentSpaces(out, indent);
    *out += "dstBuffer:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, dstBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize dstOffset
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, dstOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t marker
    IndentSpaces(out, indent);
    *out += "marker:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, marker); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkCalibratedTimestampInfoEXT>(std::string* out, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkCalibratedTimestampInfoEXT>(std::string* out, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCalibratedTimestampInfoEXT *pstruct = (const VkCalibratedTimestampInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkTimeDomainEXT timeDomain
    IndentSpaces(out, indent);
    *out += "timeDomain:                     ";
    *out += "VkTimeDomainEXT = "; // TEQ
    EnumToStringVkTimeDomainEXT(out, pstruct->timeDomain); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->timeDomain);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pTimeDomainCount,
    const PointerDecoder<VkTimeDomainEXT>&      pTimeDomains)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pTimeDomainCount
    IndentSpaces(out, indent);
    *out += "pTimeDomainCount:               ";
    *out += "uint32_t* = "; // TEQ
    if (pTimeDomainCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pTimeDomainCount = {false, false, false, nullptr};
        ScalarValueToString(out, pTimeDomainCount.GetPointer(), vinfo_pTimeDomainCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkTimeDomainEXT* pTimeDomains
    IndentSpaces(out, indent);
    *out += "pTimeDomains:                   ";
    *out += "VkTimeDomainEXT* = "; // TEQ
    if (pTimeDomains.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pTimeDomains.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pTimeDomains = {false, true, false, EnumToStringVkTimeDomainEXT};
        ArrayToString<VkTimeDomainEXT*>(out, indent, 1, "VkTimeDomainEXT*", reinterpret_cast<VkTimeDomainEXT*>(pTimeDomains.GetPointer()), "pTimeDomains", *pTimeDomainCount.GetPointer(),  vinfo_pTimeDomains);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetCalibratedTimestampsEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    timestampCount,
    const StructPointerDecoder<Decoded_VkCalibratedTimestampInfoEXT>& pTimestampInfos,
    const PointerDecoder<uint64_t>&             pTimestamps,
    const PointerDecoder<uint64_t>&             pMaxDeviation)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t timestampCount
    IndentSpaces(out, indent);
    *out += "timestampCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, timestampCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkCalibratedTimestampInfoEXT* pTimestampInfos
    IndentSpaces(out, indent);
    *out += "pTimestampInfos:                ";
    *out += "const VkCalibratedTimestampInfoEXT* = "; // TEQ
    if (pTimestampInfos.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pTimestampInfos.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkCalibratedTimestampInfoEXT>(out, indent+1, 1, "VkCalibratedTimestampInfoEXT", pTimestampInfos.GetMetaStructPointer(), "pTimestampInfos", timestampCount, false, pTimestampInfos.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    // func arg: uint64_t* pTimestamps
    IndentSpaces(out, indent);
    *out += "pTimestamps:                    ";
    *out += "uint64_t* = "; // TEQ
    if (pTimestamps.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pTimestamps.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pTimestamps = {false, false, false, nullptr};
        ArrayToString<uint64_t*>(out, indent, 1, "uint64_t*", reinterpret_cast<uint64_t*>(pTimestamps.GetPointer()), "pTimestamps", timestampCount,  vinfo_pTimestamps);  // CXC
    }
    outString += "\n";   // HHS

    // func arg: uint64_t* pMaxDeviation
    IndentSpaces(out, indent);
    *out += "pMaxDeviation:                  ";
    *out += "uint64_t* = "; // TEQ
    if (pMaxDeviation.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pMaxDeviation = {false, false, false, nullptr};
        ScalarValueToString(out, pMaxDeviation.GetPointer(), vinfo_pMaxDeviation); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrawMeshTasksIndirectCommandNV>(std::string* out, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMeshShaderPropertiesNV *pstruct = (const VkPhysicalDeviceMeshShaderPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t maxDrawMeshTasksCount
    IndentSpaces(out, indent);
    *out += "maxDrawMeshTasksCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDrawMeshTasksCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTaskWorkGroupInvocations
    IndentSpaces(out, indent);
    *out += "maxTaskWorkGroupInvocations:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTaskWorkGroupInvocations); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTaskWorkGroupSize
    IndentSpaces(out, indent);
    *out += "maxTaskWorkGroupSize:           ";
    *out += "uint32_t[";
    *out += "3"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupSize)); // IYY
    ScalarValueToStringStruct vinfo_maxTaskWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxTaskWorkGroupSize), "maxTaskWorkGroupSize", 3, vinfo_maxTaskWorkGroupSize); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t maxTaskTotalMemorySize
    IndentSpaces(out, indent);
    *out += "maxTaskTotalMemorySize:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTaskTotalMemorySize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxTaskOutputCount
    IndentSpaces(out, indent);
    *out += "maxTaskOutputCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTaskOutputCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxMeshWorkGroupInvocations
    IndentSpaces(out, indent);
    *out += "maxMeshWorkGroupInvocations:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshWorkGroupInvocations); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxMeshWorkGroupSize
    IndentSpaces(out, indent);
    *out += "maxMeshWorkGroupSize:           ";
    *out += "uint32_t[";
    *out += "3"; // TPK
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupSize)); // IYY
    ScalarValueToStringStruct vinfo_maxMeshWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxMeshWorkGroupSize), "maxMeshWorkGroupSize", 3, vinfo_maxMeshWorkGroupSize); // JPA
    *out += "\n"; // GDS

    // struct member: uint32_t maxMeshTotalMemorySize
    IndentSpaces(out, indent);
    *out += "maxMeshTotalMemorySize:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshTotalMemorySize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxMeshOutputVertices
    IndentSpaces(out, indent);
    *out += "maxMeshOutputVertices:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshOutputVertices); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxMeshOutputPrimitives
    IndentSpaces(out, indent);
    *out += "maxMeshOutputPrimitives:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshOutputPrimitives); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t maxMeshMultiviewViewCount
    IndentSpaces(out, indent);
    *out += "maxMeshMultiviewViewCount:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshMultiviewViewCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t meshOutputPerVertexGranularity
    IndentSpaces(out, indent);
    *out += "meshOutputPerVertexGranularity: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->meshOutputPerVertexGranularity); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t meshOutputPerPrimitiveGranularity
    IndentSpaces(out, indent);
    *out += "meshOutputPerPrimitiveGranularity: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->meshOutputPerPrimitiveGranularity); // UYW
}

template <>
void StructureToString<Decoded_VkDrawMeshTasksIndirectCommandNV>(std::string* out, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrawMeshTasksIndirectCommandNV *pstruct = (const VkDrawMeshTasksIndirectCommandNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t taskCount
    IndentSpaces(out, indent);
    *out += "taskCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->taskCount); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t firstTask
    IndentSpaces(out, indent);
    *out += "firstTask:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstTask); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMeshShaderFeaturesNV *pstruct = (const VkPhysicalDeviceMeshShaderFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 taskShader
    IndentSpaces(out, indent);
    *out += "taskShader:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->taskShader); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 meshShader
    IndentSpaces(out, indent);
    *out += "meshShader:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->meshShader); //EQA
}

void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksIndirectNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t drawCount
    IndentSpaces(out, indent);
    *out += "drawCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, drawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksIndirectCountNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, buffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize offset
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, offset); //EQA
    outString += "\n";   // HHS

    // func arg: VkBuffer countBuffer
    IndentSpaces(out, indent);
    *out += "countBuffer:                    ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, countBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: VkDeviceSize countBufferOffset
    IndentSpaces(out, indent);
    *out += "countBufferOffset:              ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, countBufferOffset); //EQA
    outString += "\n";   // HHS

    // func arg: uint32_t maxDrawCount
    IndentSpaces(out, indent);
    *out += "maxDrawCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, maxDrawCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t stride
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, stride); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    taskCount,
    uint32_t                                    firstTask)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t taskCount
    IndentSpaces(out, indent);
    *out += "taskCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, taskCount); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t firstTask
    IndentSpaces(out, indent);
    *out += "firstTask:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstTask); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV *pstruct = (const VkPipelineViewportExclusiveScissorStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t exclusiveScissorCount
    IndentSpaces(out, indent);
    *out += "exclusiveScissorCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->exclusiveScissorCount); // UYW
    *out += "\n"; // GDS

    // struct member: const VkRect2D* pExclusiveScissors
    IndentSpaces(out, indent);
    *out += "pExclusiveScissors:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pExclusiveScissors == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pExclusiveScissors->GetAddress()); // WUT
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pExclusiveScissors->GetMetaStructPointer(), "pExclusiveScissors", pstruct->exclusiveScissorCount, false, pstruct_in.pExclusiveScissors->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExclusiveScissorFeaturesNV *pstruct = (const VkPhysicalDeviceExclusiveScissorFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 exclusiveScissor
    IndentSpaces(out, indent);
    *out += "exclusiveScissor:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->exclusiveScissor); //EQA
}

void VulkanAsciiConsumer::Process_vkCmdSetExclusiveScissorNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pExclusiveScissors)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstExclusiveScissor
    IndentSpaces(out, indent);
    *out += "firstExclusiveScissor:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstExclusiveScissor); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t exclusiveScissorCount
    IndentSpaces(out, indent);
    *out += "exclusiveScissorCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, exclusiveScissorCount); // UYW
    outString += "\n";   // HHS

    // func arg: const VkRect2D* pExclusiveScissors
    IndentSpaces(out, indent);
    *out += "pExclusiveScissors:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pExclusiveScissors.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pExclusiveScissors.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pExclusiveScissors.GetMetaStructPointer(), "pExclusiveScissors", exclusiveScissorCount, false, pExclusiveScissors.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkCheckpointDataNV>(std::string* out, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueueFamilyCheckpointPropertiesNV>(std::string* out, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkCheckpointDataNV>(std::string* out, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCheckpointDataNV *pstruct = (const VkCheckpointDataNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineStageFlagBits stage
    IndentSpaces(out, indent);
    *out += "stage:                          ";
    *out += "VkPipelineStageFlagBits = "; // TEQ
    EnumToStringVkPipelineStageFlagBits(out, pstruct->stage); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stage);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pCheckpointMarker
    IndentSpaces(out, indent);
    *out += "pCheckpointMarker:              ";
    *out += "void* = "; // TEQ
    if (pstruct->pCheckpointMarker == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCheckpointMarker); // PWR
    }
}

template <>
void StructureToString<Decoded_VkQueueFamilyCheckpointPropertiesNV>(std::string* out, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueueFamilyCheckpointPropertiesNV *pstruct = (const VkQueueFamilyCheckpointPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineStageFlags checkpointExecutionStageMask
    IndentSpaces(out, indent);
    *out += "checkpointExecutionStageMask:   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->checkpointExecutionStageMask, EnumToStringVkPipelineStageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkCmdSetCheckpointNV(
    format::HandleId                            commandBuffer,
    uint64_t                                    pCheckpointMarker)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const void* pCheckpointMarker
    IndentSpaces(out, indent);
    *out += "pCheckpointMarker:              ";
    *out += "const void* = "; // TEQ
    if ( !pCheckpointMarker) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCheckpointMarker); // PWR
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetQueueCheckpointDataNV(
    format::HandleId                            queue,
    const PointerDecoder<uint32_t>&             pCheckpointDataCount,
    const StructPointerDecoder<Decoded_VkCheckpointDataNV>& pCheckpointData)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pCheckpointDataCount
    IndentSpaces(out, indent);
    *out += "pCheckpointDataCount:           ";
    *out += "uint32_t* = "; // TEQ
    if (pCheckpointDataCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pCheckpointDataCount = {false, false, false, nullptr};
        ScalarValueToString(out, pCheckpointDataCount.GetPointer(), vinfo_pCheckpointDataCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkCheckpointDataNV* pCheckpointData
    IndentSpaces(out, indent);
    *out += "pCheckpointData:                ";
    *out += "VkCheckpointDataNV* = "; // TEQ
    if (pCheckpointData.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCheckpointData.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkCheckpointDataNV>(out, indent+1, 1, "VkCheckpointDataNV", pCheckpointData.GetMetaStructPointer(), "pCheckpointData", *pCheckpointDataCount.GetPointer(), false, pCheckpointData.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceValueDataINTEL>(std::string* out, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceOverrideInfoINTEL>(std::string* out, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueryPoolCreateInfoINTEL>(std::string* out, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(std::string* out, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceValueINTEL>(std::string* out, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(std::string* out, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceStreamMarkerInfoINTEL *pstruct = (const VkPerformanceStreamMarkerInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t marker
    IndentSpaces(out, indent);
    *out += "marker:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->marker); // UYW
}

template <>
void StructureToString<Decoded_VkPerformanceMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceMarkerInfoINTEL *pstruct = (const VkPerformanceMarkerInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint64_t marker
    IndentSpaces(out, indent);
    *out += "marker:                         ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->marker); // UYW
}

template <>
void StructureToString<Decoded_VkPerformanceValueDataINTEL>(std::string* out, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceValueDataINTEL *pstruct = (const VkPerformanceValueDataINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: uint32_t value32
    IndentSpaces(out, indent);
    *out += "value32:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->value32); // UYW
    *out += "\n"; // GDS

    // struct member: uint64_t value64
    IndentSpaces(out, indent);
    *out += "value64:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->value64); // UYW
    *out += "\n"; // GDS

    // struct member: float valueFloat
    IndentSpaces(out, indent);
    *out += "valueFloat:                     ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->valueFloat); // PEZ
    *out += "\n"; // GDS

    // struct member: VkBool32 valueBool
    IndentSpaces(out, indent);
    *out += "valueBool:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->valueBool); //EQA
    *out += "\n"; // GDS

    // struct member: const char* valueString
    IndentSpaces(out, indent);
    *out += "valueString:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->valueString); // TGI
}

template <>
void StructureToString<Decoded_VkPerformanceOverrideInfoINTEL>(std::string* out, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceOverrideInfoINTEL *pstruct = (const VkPerformanceOverrideInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPerformanceOverrideTypeINTEL type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkPerformanceOverrideTypeINTEL = "; // TEQ
    EnumToStringVkPerformanceOverrideTypeINTEL(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 enable
    IndentSpaces(out, indent);
    *out += "enable:                         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->enable); //EQA
    *out += "\n"; // GDS

    // struct member: uint64_t parameter
    IndentSpaces(out, indent);
    *out += "parameter:                      ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->parameter); // UYW
}

template <>
void StructureToString<Decoded_VkQueryPoolCreateInfoINTEL>(std::string* out, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueryPoolCreateInfoINTEL *pstruct = (const VkQueryPoolCreateInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkQueryPoolSamplingModeINTEL performanceCountersSampling
    IndentSpaces(out, indent);
    *out += "performanceCountersSampling:    ";
    *out += "VkQueryPoolSamplingModeINTEL = "; // TEQ
    EnumToStringVkQueryPoolSamplingModeINTEL(out, pstruct->performanceCountersSampling); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->performanceCountersSampling);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(std::string* out, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceConfigurationAcquireInfoINTEL *pstruct = (const VkPerformanceConfigurationAcquireInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPerformanceConfigurationTypeINTEL type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkPerformanceConfigurationTypeINTEL = "; // TEQ
    EnumToStringVkPerformanceConfigurationTypeINTEL(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPerformanceValueINTEL>(std::string* out, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceValueINTEL *pstruct = (const VkPerformanceValueINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkPerformanceValueTypeINTEL type
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkPerformanceValueTypeINTEL = "; // TEQ
    EnumToStringVkPerformanceValueTypeINTEL(out, pstruct->type); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkPerformanceValueDataINTEL data
    IndentSpaces(out, indent);
    *out += "data:                           ";
    *out += "VkPerformanceValueDataINTEL = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkPerformanceValueDataINTEL>(out, *pstruct_in.data, indent+1,  base_addr + offsetof(VkPerformanceValueINTEL, data)); // AZJ
}

template <>
void StructureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(std::string* out, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkInitializePerformanceApiInfoINTEL *pstruct = (const VkInitializePerformanceApiInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: void* pUserData
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkQueueSetPerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    format::HandleId                            configuration)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkQueueSetPerformanceConfigurationINTEL(queue, configuration)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkQueue queue
    IndentSpaces(out, indent);
    *out += "queue:                          ";
    *out += "VkQueue = "; // TEQ
    AddrToString(out, queue); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPerformanceConfigurationINTEL configuration
    IndentSpaces(out, indent);
    *out += "configuration:                  ";
    *out += "VkPerformanceConfigurationINTEL = "; // TEQ
    AddrToString(out, configuration); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkReleasePerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            configuration)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkReleasePerformanceConfigurationINTEL(device, configuration)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPerformanceConfigurationINTEL configuration
    IndentSpaces(out, indent);
    *out += "configuration:                  ";
    *out += "VkPerformanceConfigurationINTEL = "; // TEQ
    AddrToString(out, configuration); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquirePerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>& pAcquireInfo,
    const HandlePointerDecoder<VkPerformanceConfigurationINTEL>& pConfiguration)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo
    IndentSpaces(out, indent);
    *out += "pAcquireInfo:                   ";
    *out += "const VkPerformanceConfigurationAcquireInfoINTEL* = "; // TEQ
    if (pAcquireInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAcquireInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(out, *pAcquireInfo.GetMetaStructPointer(), indent+1,pAcquireInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkPerformanceConfigurationINTEL* pConfiguration
    IndentSpaces(out, indent);
    *out += "pConfiguration:                 ";
    *out += "VkPerformanceConfigurationINTEL* = "; // TEQ
    if (pConfiguration.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pConfiguration = {true, false, false, nullptr};
        ScalarValueToString(out, pConfiguration.GetPointer(), vinfo_pConfiguration); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceStreamMarkerINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceStreamMarkerInfoINTEL>& pMarkerInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo
    IndentSpaces(out, indent);
    *out += "pMarkerInfo:                    ";
    *out += "const VkPerformanceStreamMarkerInfoINTEL* = "; // TEQ
    if (pMarkerInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMarkerInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(out, *pMarkerInfo.GetMetaStructPointer(), indent+1,pMarkerInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPerformanceParameterINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkPerformanceParameterTypeINTEL             parameter,
    const StructPointerDecoder<Decoded_VkPerformanceValueINTEL>& pValue)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPerformanceParameterINTEL(device, parameter, pValue)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkPerformanceParameterTypeINTEL parameter
    IndentSpaces(out, indent);
    *out += "parameter:                      ";
    *out += "VkPerformanceParameterTypeINTEL = "; // TEQ
    EnumToStringVkPerformanceParameterTypeINTEL(out, parameter); // VSA
    *out += " (";
    UnsignedDecimalToString(out, parameter);
    *out += ")";
    outString += "\n";   // HHS

    // func arg: VkPerformanceValueINTEL* pValue
    IndentSpaces(out, indent);
    *out += "pValue:                         ";
    *out += "VkPerformanceValueINTEL* = "; // TEQ
    if (pValue.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pValue.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPerformanceValueINTEL>(out, *pValue.GetMetaStructPointer(), indent+1,pValue.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceMarkerINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceMarkerInfoINTEL>& pMarkerInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPerformanceMarkerInfoINTEL* pMarkerInfo
    IndentSpaces(out, indent);
    *out += "pMarkerInfo:                    ";
    *out += "const VkPerformanceMarkerInfoINTEL* = "; // TEQ
    if (pMarkerInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pMarkerInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPerformanceMarkerInfoINTEL>(out, *pMarkerInfo.GetMetaStructPointer(), indent+1,pMarkerInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkUninitializePerformanceApiINTEL(
    format::HandleId                            device)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkUninitializePerformanceApiINTEL(device)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceOverrideINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceOverrideInfoINTEL>& pOverrideInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPerformanceOverrideInfoINTEL* pOverrideInfo
    IndentSpaces(out, indent);
    *out += "pOverrideInfo:                  ";
    *out += "const VkPerformanceOverrideInfoINTEL* = "; // TEQ
    if (pOverrideInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pOverrideInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPerformanceOverrideInfoINTEL>(out, *pOverrideInfo.GetMetaStructPointer(), indent+1,pOverrideInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkInitializePerformanceApiINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkInitializePerformanceApiInfoINTEL>& pInitializeInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkInitializePerformanceApiINTEL(device, pInitializeInfo)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkInitializePerformanceApiInfoINTEL* pInitializeInfo
    IndentSpaces(out, indent);
    *out += "pInitializeInfo:                ";
    *out += "const VkInitializePerformanceApiInfoINTEL* = "; // TEQ
    if (pInitializeInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInitializeInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(out, *pInitializeInfo.GetMetaStructPointer(), indent+1,pInitializeInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>(std::string* out, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>(std::string* out, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>(std::string* out, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD *pstruct = (const VkDisplayNativeHdrSurfaceCapabilitiesAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 localDimmingSupport
    IndentSpaces(out, indent);
    *out += "localDimmingSupport:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->localDimmingSupport); //EQA
}

template <>
void StructureToString<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>(std::string* out, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSwapchainDisplayNativeHdrCreateInfoAMD *pstruct = (const VkSwapchainDisplayNativeHdrCreateInfoAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 localDimmingEnable
    IndentSpaces(out, indent);
    *out += "localDimmingEnable:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->localDimmingEnable); //EQA
}

void VulkanAsciiConsumer::Process_vkSetLocalDimmingAMD(
    format::HandleId                            device,
    format::HandleId                            swapChain,
    VkBool32                                    localDimmingEnable)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapChain
    IndentSpaces(out, indent);
    *out += "swapChain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapChain); // PAQ
    outString += "\n";   // HHS

    // func arg: VkBool32 localDimmingEnable
    IndentSpaces(out, indent);
    *out += "localDimmingEnable:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, localDimmingEnable); //EQA
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(std::string* out, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(std::string* out, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImagePipeSurfaceCreateInfoFUCHSIA *pstruct = (const VkImagePipeSurfaceCreateInfoFUCHSIA *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkImagePipeSurfaceCreateFlagsFUCHSIA flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImagePipeSurfaceCreateFlagsFUCHSIA = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t imagePipeHandle
    IndentSpaces(out, indent);
    *out += "imagePipeHandle:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imagePipeHandle); // UYW
}

void VulkanAsciiConsumer::Process_vkCreateImagePipeSurfaceFUCHSIA(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkImagePipeSurfaceCreateInfoFUCHSIA* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMetalSurfaceCreateInfoEXT *pstruct = (const VkMetalSurfaceCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkMetalSurfaceCreateFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMetalSurfaceCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: const void* pLayer
    IndentSpaces(out, indent);
    *out += "pLayer:                         ";
    *out += "const void* = "; // TEQ
    if (pstruct->pLayer == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pLayer); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateMetalSurfaceEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkMetalSurfaceCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkMetalSurfaceCreateInfoEXT* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkMetalSurfaceCreateInfoEXT* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkBufferDeviceAddressInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferDeviceAddressCreateInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkBufferDeviceAddressInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferDeviceAddressInfoEXT *pstruct = (const VkBufferDeviceAddressInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBuffer buffer
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkBufferDeviceAddressCreateInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferDeviceAddressCreateInfoEXT *pstruct = (const VkBufferDeviceAddressCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkDeviceAddress deviceAddress
    IndentSpaces(out, indent);
    *out += "deviceAddress:                  ";
    *out += "VkDeviceAddress = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceAddress); // UYW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *pstruct = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 bufferDeviceAddress
    IndentSpaces(out, indent);
    *out += "bufferDeviceAddress:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferDeviceAddress); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 bufferDeviceAddressCaptureReplay
    IndentSpaces(out, indent);
    *out += "bufferDeviceAddressCaptureReplay: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferDeviceAddressCaptureReplay); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 bufferDeviceAddressMultiDevice
    IndentSpaces(out, indent);
    *out += "bufferDeviceAddressMultiDevice: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferDeviceAddressMultiDevice); //EQA
}

void VulkanAsciiConsumer::Process_vkGetBufferDeviceAddressEXT(
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferDeviceAddressInfoEXT>& pInfo)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetBufferDeviceAddressEXT(device, pInfo)");
    fprintf(GetFile(), " returns 0x%" PRIx64 ":\n", returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkBufferDeviceAddressInfoEXT* pInfo
    IndentSpaces(out, indent);
    *out += "pInfo:                          ";
    *out += "const VkBufferDeviceAddressInfoEXT* = "; // TEQ
    if (pInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkBufferDeviceAddressInfoEXT>(out, *pInfo.GetMetaStructPointer(), indent+1,pInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCooperativeMatrixPropertiesNV *pstruct = (const VkCooperativeMatrixPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t MSize
    IndentSpaces(out, indent);
    *out += "MSize:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->MSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t NSize
    IndentSpaces(out, indent);
    *out += "NSize:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->NSize); // UYW
    *out += "\n"; // GDS

    // struct member: uint32_t KSize
    IndentSpaces(out, indent);
    *out += "KSize:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->KSize); // UYW
    *out += "\n"; // GDS

    // struct member: VkComponentTypeNV AType
    IndentSpaces(out, indent);
    *out += "AType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->AType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->AType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentTypeNV BType
    IndentSpaces(out, indent);
    *out += "BType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->BType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->BType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentTypeNV CType
    IndentSpaces(out, indent);
    *out += "CType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->CType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->CType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkComponentTypeNV DType
    IndentSpaces(out, indent);
    *out += "DType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->DType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->DType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkScopeNV scope
    IndentSpaces(out, indent);
    *out += "scope:                          ";
    *out += "VkScopeNV = "; // TEQ
    EnumToStringVkScopeNV(out, pstruct->scope); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->scope);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV *pstruct = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 cooperativeMatrix
    IndentSpaces(out, indent);
    *out += "cooperativeMatrix:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->cooperativeMatrix); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 cooperativeMatrixRobustBufferAccess
    IndentSpaces(out, indent);
    *out += "cooperativeMatrixRobustBufferAccess: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->cooperativeMatrixRobustBufferAccess); //EQA
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV *pstruct = (const VkPhysicalDeviceCooperativeMatrixPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkShaderStageFlags cooperativeMatrixSupportedStages
    IndentSpaces(out, indent);
    *out += "cooperativeMatrixSupportedStages: ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->cooperativeMatrixSupportedStages, EnumToStringVkShaderStageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkCooperativeMatrixPropertiesNV>& pProperties)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pPropertyCount
    IndentSpaces(out, indent);
    *out += "pPropertyCount:                 ";
    *out += "uint32_t* = "; // TEQ
    if (pPropertyCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPropertyCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPropertyCount.GetPointer(), vinfo_pPropertyCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkCooperativeMatrixPropertiesNV* pProperties
    IndentSpaces(out, indent);
    *out += "pProperties:                    ";
    *out += "VkCooperativeMatrixPropertiesNV* = "; // TEQ
    if (pProperties.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pProperties.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkCooperativeMatrixPropertiesNV>(out, indent+1, 1, "VkCooperativeMatrixPropertiesNV", pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(std::string* out, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV *pstruct = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 coverageReductionMode
    IndentSpaces(out, indent);
    *out += "coverageReductionMode:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->coverageReductionMode); //EQA
}

template <>
void StructureToString<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineCoverageReductionStateCreateInfoNV *pstruct = (const VkPipelineCoverageReductionStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkPipelineCoverageReductionStateCreateFlagsNV flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCoverageReductionStateCreateFlagsNV = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
    *out += "\n"; // GDS

    // struct member: VkCoverageReductionModeNV coverageReductionMode
    IndentSpaces(out, indent);
    *out += "coverageReductionMode:          ";
    *out += "VkCoverageReductionModeNV = "; // TEQ
    EnumToStringVkCoverageReductionModeNV(out, pstruct->coverageReductionMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->coverageReductionMode);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(std::string* out, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFramebufferMixedSamplesCombinationNV *pstruct = (const VkFramebufferMixedSamplesCombinationNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkCoverageReductionModeNV coverageReductionMode
    IndentSpaces(out, indent);
    *out += "coverageReductionMode:          ";
    *out += "VkCoverageReductionModeNV = "; // TEQ
    EnumToStringVkCoverageReductionModeNV(out, pstruct->coverageReductionMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->coverageReductionMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlagBits rasterizationSamples
    IndentSpaces(out, indent);
    *out += "rasterizationSamples:           ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->rasterizationSamples); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->rasterizationSamples);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags depthStencilSamples
    IndentSpaces(out, indent);
    *out += "depthStencilSamples:            ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->depthStencilSamples, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // struct member: VkSampleCountFlags colorSamples
    IndentSpaces(out, indent);
    *out += "colorSamples:                   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->colorSamples, EnumToStringVkSampleCountFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pCombinationCount,
    const StructPointerDecoder<Decoded_VkFramebufferMixedSamplesCombinationNV>& pCombinations)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t* pCombinationCount
    IndentSpaces(out, indent);
    *out += "pCombinationCount:              ";
    *out += "uint32_t* = "; // TEQ
    if (pCombinationCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pCombinationCount = {false, false, false, nullptr};
        ScalarValueToString(out, pCombinationCount.GetPointer(), vinfo_pCombinationCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkFramebufferMixedSamplesCombinationNV* pCombinations
    IndentSpaces(out, indent);
    *out += "pCombinations:                  ";
    *out += "VkFramebufferMixedSamplesCombinationNV* = "; // TEQ
    if (pCombinations.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCombinations.GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(out, indent+1, 1, "VkFramebufferMixedSamplesCombinationNV", pCombinations.GetMetaStructPointer(), "pCombinations", *pCombinationCount.GetPointer(), false, pCombinations.GetAddress());  // CCO
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>(std::string* out, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>(std::string* out, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT *pstruct = (const VkSurfaceCapabilitiesFullScreenExclusiveEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 fullScreenExclusiveSupported
    IndentSpaces(out, indent);
    *out += "fullScreenExclusiveSupported:   ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fullScreenExclusiveSupported); //EQA
}

template <>
void StructureToString<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFullScreenExclusiveWin32InfoEXT *pstruct = (const VkSurfaceFullScreenExclusiveWin32InfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: void* hmonitor
    IndentSpaces(out, indent);
    *out += "hmonitor:                       ";
    *out += "void* = "; // TEQ
    if (pstruct->hmonitor == nullptr) // WWX
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.hmonitor); // PWR
    }
}

template <>
void StructureToString<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFullScreenExclusiveInfoEXT *pstruct = (const VkSurfaceFullScreenExclusiveInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkFullScreenExclusiveEXT fullScreenExclusive
    IndentSpaces(out, indent);
    *out += "fullScreenExclusive:            ";
    *out += "VkFullScreenExclusiveEXT = "; // TEQ
    EnumToStringVkFullScreenExclusiveEXT(out, pstruct->fullScreenExclusive); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->fullScreenExclusive);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfacePresentModes2EXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<uint32_t>&             pPresentModeCount,
    const PointerDecoder<VkPresentModeKHR>&     pPresentModes)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkPhysicalDevice physicalDevice
    IndentSpaces(out, indent);
    *out += "physicalDevice:                 ";
    *out += "VkPhysicalDevice = "; // TEQ
    AddrToString(out, physicalDevice); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo
    IndentSpaces(out, indent);
    *out += "pSurfaceInfo:                   ";
    *out += "const VkPhysicalDeviceSurfaceInfo2KHR* = "; // TEQ
    if (pSurfaceInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(out, *pSurfaceInfo.GetMetaStructPointer(), indent+1,pSurfaceInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: uint32_t* pPresentModeCount
    IndentSpaces(out, indent);
    *out += "pPresentModeCount:              ";
    *out += "uint32_t* = "; // TEQ
    if (pPresentModeCount.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pPresentModeCount = {false, false, false, nullptr};
        ScalarValueToString(out, pPresentModeCount.GetPointer(), vinfo_pPresentModeCount); // PWS
    }
    outString += "\n";   // HHS

    // func arg: VkPresentModeKHR* pPresentModes
    IndentSpaces(out, indent);
    *out += "pPresentModes:                  ";
    *out += "VkPresentModeKHR* = "; // TEQ
    if (pPresentModes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pPresentModes.GetAddress()); // PAZ
        ScalarValueToStringStruct vinfo_pPresentModes = {false, true, false, EnumToStringVkPresentModeKHR};
        ArrayToString<VkPresentModeKHR*>(out, indent, 1, "VkPresentModeKHR*", reinterpret_cast<VkPresentModeKHR*>(pPresentModes.GetPointer()), "pPresentModes", *pPresentModeCount.GetPointer(),  vinfo_pPresentModes);  // CXC
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupSurfacePresentModes2EXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>& pModes)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo
    IndentSpaces(out, indent);
    *out += "pSurfaceInfo:                   ";
    *out += "const VkPhysicalDeviceSurfaceInfo2KHR* = "; // TEQ
    if (pSurfaceInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pSurfaceInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(out, *pSurfaceInfo.GetMetaStructPointer(), indent+1,pSurfaceInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkDeviceGroupPresentModeFlagsKHR* pModes
    IndentSpaces(out, indent);
    *out += "pModes:                         ";
    *out += "VkDeviceGroupPresentModeFlagsKHR* = "; // TEQ
    if (pModes.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pModes = {false, false, true, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR};
        ScalarValueToString(out, pModes.GetPointer(), vinfo_pModes); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireFullScreenExclusiveModeEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkAcquireFullScreenExclusiveModeEXT(device, swapchain)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
void VulkanAsciiConsumer::Process_vkReleaseFullScreenExclusiveModeEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkReleaseFullScreenExclusiveModeEXT(device, swapchain)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkSwapchainKHR swapchain
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, swapchain); // PAQ
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkHeadlessSurfaceCreateInfoEXT *pstruct = (const VkHeadlessSurfaceCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkHeadlessSurfaceCreateFlagsEXT flags
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkHeadlessSurfaceCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags); // UYW
}

void VulkanAsciiConsumer::Process_vkCreateHeadlessSurfaceEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkHeadlessSurfaceCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)");
    EnumToStringVkResult(&outString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", outString.c_str(), returnValue);
    outString = "";

    // func arg: VkInstance instance
    IndentSpaces(out, indent);
    *out += "instance:                       ";
    *out += "VkInstance = "; // TEQ
    AddrToString(out, instance); // PAQ
    outString += "\n";   // HHS

    // func arg: const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo
    IndentSpaces(out, indent);
    *out += "pCreateInfo:                    ";
    *out += "const VkHeadlessSurfaceCreateInfoEXT* = "; // TEQ
    if (pCreateInfo.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pCreateInfo.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(out, *pCreateInfo.GetMetaStructPointer(), indent+1,pCreateInfo.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: const VkAllocationCallbacks* pAllocator
    IndentSpaces(out, indent);
    *out += "pAllocator:                     ";
    *out += "const VkAllocationCallbacks* = "; // TEQ
    if (pAllocator.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pAllocator.GetAddress()); // JHI
        *out += ":";
        StructureToString<Decoded_VkAllocationCallbacks>(out, *pAllocator.GetMetaStructPointer(), indent+1,pAllocator.GetAddress()); // GLM
    }
    outString += "\n";   // HHS

    // func arg: VkSurfaceKHR* pSurface
    IndentSpaces(out, indent);
    *out += "pSurface:                       ";
    *out += "VkSurfaceKHR* = "; // TEQ
    if (pSurface.GetPointer() == nullptr) // WWY
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pSurface = {true, false, false, nullptr};
        ScalarValueToString(out, pSurface.GetPointer(), vinfo_pSurface); // PWS
    }
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineRasterizationLineStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceLineRasterizationFeaturesEXT *pstruct = (const VkPhysicalDeviceLineRasterizationFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 rectangularLines
    IndentSpaces(out, indent);
    *out += "rectangularLines:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->rectangularLines); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 bresenhamLines
    IndentSpaces(out, indent);
    *out += "bresenhamLines:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bresenhamLines); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 smoothLines
    IndentSpaces(out, indent);
    *out += "smoothLines:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->smoothLines); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 stippledRectangularLines
    IndentSpaces(out, indent);
    *out += "stippledRectangularLines:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledRectangularLines); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 stippledBresenhamLines
    IndentSpaces(out, indent);
    *out += "stippledBresenhamLines:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledBresenhamLines); //EQA
    *out += "\n"; // GDS

    // struct member: VkBool32 stippledSmoothLines
    IndentSpaces(out, indent);
    *out += "stippledSmoothLines:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledSmoothLines); //EQA
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceLineRasterizationPropertiesEXT *pstruct = (const VkPhysicalDeviceLineRasterizationPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: uint32_t lineSubPixelPrecisionBits
    IndentSpaces(out, indent);
    *out += "lineSubPixelPrecisionBits:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->lineSubPixelPrecisionBits); // UYW
}

template <>
void StructureToString<Decoded_VkPipelineRasterizationLineStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineRasterizationLineStateCreateInfoEXT *pstruct = (const VkPipelineRasterizationLineStateCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: const void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkLineRasterizationModeEXT lineRasterizationMode
    IndentSpaces(out, indent);
    *out += "lineRasterizationMode:          ";
    *out += "VkLineRasterizationModeEXT = "; // TEQ
    EnumToStringVkLineRasterizationModeEXT(out, pstruct->lineRasterizationMode); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->lineRasterizationMode);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: VkBool32 stippledLineEnable
    IndentSpaces(out, indent);
    *out += "stippledLineEnable:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledLineEnable); //EQA
    *out += "\n"; // GDS

    // struct member: uint32_t lineStippleFactor
    IndentSpaces(out, indent);
    *out += "lineStippleFactor:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->lineStippleFactor); // UYW
    *out += "\n"; // GDS

    // struct member: uint16_t lineStipplePattern
    IndentSpaces(out, indent);
    *out += "lineStipplePattern:             ";
    *out += "uint16_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->lineStipplePattern); // UYW
}

void VulkanAsciiConsumer::Process_vkCmdSetLineStippleEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    lineStippleFactor,
    uint16_t                                    lineStipplePattern)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkCommandBuffer commandBuffer
    IndentSpaces(out, indent);
    *out += "commandBuffer:                  ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, commandBuffer); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t lineStippleFactor
    IndentSpaces(out, indent);
    *out += "lineStippleFactor:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, lineStippleFactor); // UYW
    outString += "\n";   // HHS

    // func arg: uint16_t lineStipplePattern
    IndentSpaces(out, indent);
    *out += "lineStipplePattern:             ";
    *out += "uint16_t = "; // TEQ
    UnsignedDecimalToString(out, lineStipplePattern); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceHostQueryResetFeaturesEXT *pstruct = (const VkPhysicalDeviceHostQueryResetFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // struct member: VkStructureType sType
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType); // VSA
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // struct member: void* pNext
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWZ
    {
        *out += "NULL";
    }
    else
    {
        ScalarValueToStringStruct vinfo_pNext = {true, false, false, nullptr};
        uint64_t pnextLocal = pstruct_in.pNext->GetAddress(); // PNX
        ScalarValueToString(out, &pnextLocal, vinfo_pNext);
    }
    *out += "\n"; // GDS

    // struct member: VkBool32 hostQueryReset
    IndentSpaces(out, indent);
    *out += "hostQueryReset:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->hostQueryReset); //EQA
}

void VulkanAsciiConsumer::Process_vkResetQueryPoolEXT(
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    std::string outString = "";
    std::string *out = &outString;
    uint32_t indent = 1;
    fprintf(GetFile(), "vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount)");
    fprintf(GetFile(), " returns void:\n");
    outString = "";

    // func arg: VkDevice device
    IndentSpaces(out, indent);
    *out += "device:                         ";
    *out += "VkDevice = "; // TEQ
    AddrToString(out, device); // PAQ
    outString += "\n";   // HHS

    // func arg: VkQueryPool queryPool
    IndentSpaces(out, indent);
    *out += "queryPool:                      ";
    *out += "VkQueryPool = "; // TEQ
    AddrToString(out, queryPool); // PAQ
    outString += "\n";   // HHS

    // func arg: uint32_t firstQuery
    IndentSpaces(out, indent);
    *out += "firstQuery:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, firstQuery); // UYW
    outString += "\n";   // HHS

    // func arg: uint32_t queryCount
    IndentSpaces(out, indent);
    *out += "queryCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, queryCount); // UYW
    outString += "\n";   // HHS

    outString += "\n";   // HDS
    fprintf(GetFile(), "%s", outString.c_str());
}
GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)
