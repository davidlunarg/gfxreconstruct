/*
** Copyright (c) 2018-2019 Valve Corporation
** Copyright (c) 2018-2019 LunarG, Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "generated/generated_vulkan_ascii_consumer.h"
#include "decode/vulkan_enum_util.h"
#include "format/platform_types.h"
#include "util/defines.h"
#include "vulkan/vulkan.h"
#include <functional>
#include <inttypes.h>
#include <string>

extern int  kIndentSize;
extern bool kNoAddr;
extern bool kPrintShaderCode;

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

typedef std::function<void(std::string *, uint32_t)> EnumToStringFuncPtr;

typedef struct ValueToStringStruct {
   bool is_handle_or_addr;
   bool is_enum;
   bool is_flags;
   EnumToStringFuncPtr enum_to_string_func;
} ValueToStringStruct;

void SignedDecimalToString(std::string* out, int64_t n)
{
    char tmp[30];
    assert(out != nullptr);
    snprintf(tmp, sizeof(tmp), "%" PRId64, n);
    snprintf(tmp, sizeof(tmp), "%" PRId64, n);
    *out += tmp;
}

void UnsignedDecimalToString(std::string* out, uint64_t n)
{
    char tmp[30];
    assert(out != nullptr);
    snprintf(tmp, sizeof(tmp), "%" PRIu64, n);
    *out += tmp;
}

void DoubleToString(std::string* out, double d)
{
    char tmp[30];
    snprintf(tmp, sizeof(tmp), "%g", d);
    *out += tmp;
}

void AddrToString(std::string* out, uint64_t a)
{
    assert(out != nullptr);
    if (kNoAddr)
    {
        *out += "address";
    }
    else
    {
        char tmp[30];
        snprintf(tmp, sizeof(tmp), "0x%" PRIx64, a);
        *out += tmp;
    }
}

void IndentSpaces(std::string* out, int indent)
{
    assert(out != nullptr);
    out->insert(out->end(), indent * kIndentSize, ' ');
}

void FlagsToString(std::string* out, VkFlags flags, EnumToStringFuncPtr enum_to_string_func)
{
    VkFlags m = 1;
    assert(out != nullptr);
    UnsignedDecimalToString(out, flags);
    if (flags != 0)
    {
        *out += " (";
        while (flags)
        {
            if (m & flags)
            {
                enum_to_string_func(out, (m & flags));
                flags = flags & ~m;
                if (flags & ~m)
                {
                    *out += " | ";
                }
            }
            else
            {
                flags &= ~m;
            }
            m <<= 1;
        }
        *out += ")";
    }
    return;
}


template <typename T>
void ValueToString(std::string* out, T value, const ValueToStringStruct &vinfo)
{
    assert(out != nullptr);
    assert((vinfo.is_handle_or_addr + vinfo.is_enum  + vinfo.is_flags) <= 1);
    assert(vinfo.is_enum ? vinfo.enum_to_string_func != nullptr : true);
    assert(vinfo.is_flags ? vinfo.enum_to_string_func != nullptr : true);
    if (vinfo.is_handle_or_addr)
    {
        uint64_t v = *((uint64_t*)value);
        AddrToString(out, v);
    }
    else if (vinfo.is_flags)
    {
        uint32_t v = *((uint32_t*)value);
        FlagsToString(out, v, vinfo.enum_to_string_func);
    }
    else if (vinfo.is_enum)
    {
        uint32_t v = *((uint32_t*)value);
        vinfo.enum_to_string_func(out, v);
    }
    else if (std::is_same<T, float*>::value || std::is_same<T, const float*>::value)
    {
        double v = *((float*)value);
        DoubleToString(out, v);
    }
    else if (std::is_same<T, double*>::value || std::is_same<T, const double*>::value)
    {
        DoubleToString(out, *((double*)value));
    }
    else if (std::is_same<T, int32_t*>::value || std::is_same<T, const int32_t*>::value)
    {
        int32_t v = *((int32_t*)value);
        SignedDecimalToString(out, v);
    }
    else if (std::is_same<T, uint32_t*>::value || std::is_same<T, const uint32_t*>::value)
    {
        uint32_t v = *((uint32_t*)value);
        UnsignedDecimalToString(out, v);
    }
    else if (std::is_same<T, int64_t*>::value || std::is_same<T, const int64_t*>::value)
    {
        int64_t v = *((int64_t*)value);
        SignedDecimalToString(out, v);
    }
    else if (std::is_same<T, unsigned int*>::value || std::is_same<T, const unsigned int*>::value)
    {
        unsigned int v = *((unsigned int*)value);
        UnsignedDecimalToString(out, v);
    }
    else if (std::is_same<T, unsigned char*>::value || std::is_same<T, const unsigned char*>::value)
    {
        unsigned char v = *((unsigned char*)value);
        UnsignedDecimalToString(out, v);
    }
    else
    {
        uint64_t v = *((uint64_t*)value);
        UnsignedDecimalToString(out, v);
    }
}
void StringToQuotedString(std::string* out, const char* s)
{
    assert(out != nullptr);
    if (s != nullptr)
    {
        *out += "\"";
        *out += s;
        *out += "\"";
    }
    else
    {
        *out += "NULL";
    }
}

void PadString(std::string* s, size_t len)
{
    assert(s != nullptr);
    if (s->length() < len)
    {
        s->insert(s->end(), len - s->length(), ' ');
    }
}

template <typename T>
void StructureToString(std::string* out, const T& pstruct_in, int indent, uint64_t base_addr);

template <typename T>
void ArrayToString(std::string*              out,
                   int                       indent,
                   const int                 pointer_count,
                   const char*               full_type_name,
                   T                         array,
                   const char*               array_name,
                   const size_t              array_length,
                   const ValueToStringStruct &vinfo)
{
    assert(out != nullptr);
    assert((vinfo.is_handle_or_addr + vinfo.is_enum  + vinfo.is_flags) <= 1);
    assert(vinfo.is_enum ? vinfo.enum_to_string_func != nullptr : true);
    assert(vinfo.is_flags ? vinfo.enum_to_string_func != nullptr : true);
    if (array_length == 0 || array == nullptr)
    {
        return;
    }
    if (pointer_count <= 1 &&
        (std::is_same<T, const char>::value || std::is_same<T, const char>::value || std::is_same<T, char>::value ||
         std::is_same<T, const char*>::value || std::is_same<T, char*>::value))
    {
        StringToQuotedString(out, *((const char**)&array));
    }
    else
    {
        std::string full_type_name_str = full_type_name;
        if (*full_type_name_str.rbegin() == '*')
        {
            full_type_name_str.pop_back();
        }
        *out += "\n";
        for (uint64_t j = 0; j < array_length; j++)
        {
            IndentSpaces(out, indent + 1);
            std::string name_and_index;
            name_and_index += array_name;
            name_and_index += "[";
            UnsignedDecimalToString(&name_and_index, j);
            name_and_index += "]: ";
            PadString(&name_and_index, 32);
            *out += name_and_index;
            *out += full_type_name_str;
            *out += " = ";
            if (pointer_count > 1)
            {
                if (pointer_count == 2 && strstr(full_type_name, "char"))
                {
                    StringToQuotedString(out, ((const char**)array)[j]);
                }
                else
                {
                    fprintf(stderr, "ERROR: ArrayToString arrays of non-strings not implemented\n");
                }
            }
            else
            {
                ValueToString<T>(out, &array[j], vinfo);
            }
            if (j < array_length - 1)
            {
                *out += "\n";
            }
        }
    }
}

template <typename T>
void ArrayOfStructsToString(std::string* out,
                            int          indent,
                            const int    pointer_count,
                            const char*  base_type_name,
                            T*           array,
                            const char*  array_name,
                            const size_t array_length,
                            bool         is_union,
                            uint64_t     base_addr)
{
    assert(out != nullptr);
    if (array_length == 0 || array == nullptr)
    {
        return;
    }
    *out += "\n";
    for (uint64_t j = 0; j < array_length; j++)
    {
        IndentSpaces(out, indent);
        std::string name_and_index;
        name_and_index += array_name;
        name_and_index += "[";
        UnsignedDecimalToString(&name_and_index, j);
        name_and_index += "]: ";
        PadString(&name_and_index, 32);
        *out += name_and_index;
        *out += base_type_name;
        *out += " = ";
        AddrToString(out, base_addr + j * sizeof(T)); // UEW
        if (is_union)
        {
            *out += " (Union)";
        }
        *out += ":";
        if (pointer_count > 1)
        {
            fprintf(stderr, "ERROR: ArrayOfStructsToString cannot handle arrays of arrays\n");
        }
        else
        {
            StructureToString<T>(out, array[j], indent + 1, base_addr + j * sizeof(T)); // YQS
        }
        if (j < array_length - 1)
        {
            *out += "\n"; // AZC
        }
    }
}



void EnumToStringVkDynamicState(std::string* out, uint32_t enum_uint32)
{
    VkDynamicState e = static_cast<VkDynamicState>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DYNAMIC_STATE_DEPTH_BIAS:
            *out += std::string("VK_DYNAMIC_STATE_DEPTH_BIAS");
            return;
        case VK_DYNAMIC_STATE_BLEND_CONSTANTS:
            *out += std::string("VK_DYNAMIC_STATE_BLEND_CONSTANTS");
            return;
        case VK_DYNAMIC_STATE_VIEWPORT:
            *out += std::string("VK_DYNAMIC_STATE_VIEWPORT");
            return;
        case VK_DYNAMIC_STATE_STENCIL_REFERENCE:
            *out += std::string("VK_DYNAMIC_STATE_STENCIL_REFERENCE");
            return;
        case VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT:
            *out += std::string("VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT");
            return;
        case VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV:
            *out += std::string("VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV");
            return;
        case VK_DYNAMIC_STATE_LINE_WIDTH:
            *out += std::string("VK_DYNAMIC_STATE_LINE_WIDTH");
            return;
        case VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV:
            *out += std::string("VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV");
            return;
        case VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK:
            *out += std::string("VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK");
            return;
        case VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT:
            *out += std::string("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT");
            return;
        case VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV:
            *out += std::string("VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV");
            return;
        case VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV:
            *out += std::string("VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV");
            return;
        case VK_DYNAMIC_STATE_SCISSOR:
            *out += std::string("VK_DYNAMIC_STATE_SCISSOR");
            return;
        case VK_DYNAMIC_STATE_DEPTH_BOUNDS:
            *out += std::string("VK_DYNAMIC_STATE_DEPTH_BOUNDS");
            return;
        case VK_DYNAMIC_STATE_STENCIL_WRITE_MASK:
            *out += std::string("VK_DYNAMIC_STATE_STENCIL_WRITE_MASK");
            return;
        case VK_DYNAMIC_STATE_LINE_STIPPLE_EXT:
            *out += std::string("VK_DYNAMIC_STATE_LINE_STIPPLE_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkIndexType(std::string* out, uint32_t enum_uint32)
{
    VkIndexType e = static_cast<VkIndexType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_INDEX_TYPE_UINT32:
            *out += std::string("VK_INDEX_TYPE_UINT32");
            return;
        case VK_INDEX_TYPE_UINT8_EXT:
            *out += std::string("VK_INDEX_TYPE_UINT8_EXT");
            return;
        case VK_INDEX_TYPE_UINT16:
            *out += std::string("VK_INDEX_TYPE_UINT16");
            return;
        case VK_INDEX_TYPE_NONE_NV:
            *out += std::string("VK_INDEX_TYPE_NONE_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkImageUsageFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkImageUsageFlagBits e = static_cast<VkImageUsageFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT:
            *out += std::string("VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV:
            *out += std::string("VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV");
            return;
        case VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT:
            *out += std::string("VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT");
            return;
        case VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT:
            *out += std::string("VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_TRANSFER_DST_BIT:
            *out += std::string("VK_IMAGE_USAGE_TRANSFER_DST_BIT");
            return;
        case VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT:
            *out += std::string("VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT:
            *out += std::string("VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_SAMPLED_BIT:
            *out += std::string("VK_IMAGE_USAGE_SAMPLED_BIT");
            return;
        case VK_IMAGE_USAGE_STORAGE_BIT:
            *out += std::string("VK_IMAGE_USAGE_STORAGE_BIT");
            return;
        case VK_IMAGE_USAGE_TRANSFER_SRC_BIT:
            *out += std::string("VK_IMAGE_USAGE_TRANSFER_SRC_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkImageAspectFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkImageAspectFlagBits e = static_cast<VkImageAspectFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_ASPECT_PLANE_1_BIT:
            *out += std::string("VK_IMAGE_ASPECT_PLANE_1_BIT");
            return;
        case VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT:
            *out += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT");
            return;
        case VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT:
            *out += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT");
            return;
        case VK_IMAGE_ASPECT_DEPTH_BIT:
            *out += std::string("VK_IMAGE_ASPECT_DEPTH_BIT");
            return;
        case VK_IMAGE_ASPECT_PLANE_2_BIT:
            *out += std::string("VK_IMAGE_ASPECT_PLANE_2_BIT");
            return;
        case VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT:
            *out += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT");
            return;
        case VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT:
            *out += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT");
            return;
        case VK_IMAGE_ASPECT_STENCIL_BIT:
            *out += std::string("VK_IMAGE_ASPECT_STENCIL_BIT");
            return;
        case VK_IMAGE_ASPECT_PLANE_0_BIT:
            *out += std::string("VK_IMAGE_ASPECT_PLANE_0_BIT");
            return;
        case VK_IMAGE_ASPECT_METADATA_BIT:
            *out += std::string("VK_IMAGE_ASPECT_METADATA_BIT");
            return;
        case VK_IMAGE_ASPECT_COLOR_BIT:
            *out += std::string("VK_IMAGE_ASPECT_COLOR_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkFenceCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkFenceCreateFlagBits e = static_cast<VkFenceCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FENCE_CREATE_SIGNALED_BIT:
            *out += std::string("VK_FENCE_CREATE_SIGNALED_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkMemoryPropertyFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkMemoryPropertyFlagBits e = static_cast<VkMemoryPropertyFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD:
            *out += std::string("VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD");
            return;
        case VK_MEMORY_PROPERTY_PROTECTED_BIT:
            *out += std::string("VK_MEMORY_PROPERTY_PROTECTED_BIT");
            return;
        case VK_MEMORY_PROPERTY_HOST_CACHED_BIT:
            *out += std::string("VK_MEMORY_PROPERTY_HOST_CACHED_BIT");
            return;
        case VK_MEMORY_PROPERTY_HOST_COHERENT_BIT:
            *out += std::string("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT");
            return;
        case VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT:
            *out += std::string("VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT");
            return;
        case VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT:
            *out += std::string("VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT");
            return;
        case VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT:
            *out += std::string("VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT");
            return;
        case VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD:
            *out += std::string("VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkShaderModuleCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkShaderModuleCreateFlagBits e = static_cast<VkShaderModuleCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    *out += std::string("UNKNOWN");
};


void EnumToStringVkImageType(std::string* out, uint32_t enum_uint32)
{
    VkImageType e = static_cast<VkImageType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_TYPE_2D:
            *out += std::string("VK_IMAGE_TYPE_2D");
            return;
        case VK_IMAGE_TYPE_1D:
            *out += std::string("VK_IMAGE_TYPE_1D");
            return;
        case VK_IMAGE_TYPE_3D:
            *out += std::string("VK_IMAGE_TYPE_3D");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkLogicOp(std::string* out, uint32_t enum_uint32)
{
    VkLogicOp e = static_cast<VkLogicOp>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_LOGIC_OP_INVERT:
            *out += std::string("VK_LOGIC_OP_INVERT");
            return;
        case VK_LOGIC_OP_AND_REVERSE:
            *out += std::string("VK_LOGIC_OP_AND_REVERSE");
            return;
        case VK_LOGIC_OP_OR_INVERTED:
            *out += std::string("VK_LOGIC_OP_OR_INVERTED");
            return;
        case VK_LOGIC_OP_AND:
            *out += std::string("VK_LOGIC_OP_AND");
            return;
        case VK_LOGIC_OP_AND_INVERTED:
            *out += std::string("VK_LOGIC_OP_AND_INVERTED");
            return;
        case VK_LOGIC_OP_OR_REVERSE:
            *out += std::string("VK_LOGIC_OP_OR_REVERSE");
            return;
        case VK_LOGIC_OP_NO_OP:
            *out += std::string("VK_LOGIC_OP_NO_OP");
            return;
        case VK_LOGIC_OP_OR:
            *out += std::string("VK_LOGIC_OP_OR");
            return;
        case VK_LOGIC_OP_NAND:
            *out += std::string("VK_LOGIC_OP_NAND");
            return;
        case VK_LOGIC_OP_SET:
            *out += std::string("VK_LOGIC_OP_SET");
            return;
        case VK_LOGIC_OP_COPY_INVERTED:
            *out += std::string("VK_LOGIC_OP_COPY_INVERTED");
            return;
        case VK_LOGIC_OP_COPY:
            *out += std::string("VK_LOGIC_OP_COPY");
            return;
        case VK_LOGIC_OP_XOR:
            *out += std::string("VK_LOGIC_OP_XOR");
            return;
        case VK_LOGIC_OP_EQUIVALENT:
            *out += std::string("VK_LOGIC_OP_EQUIVALENT");
            return;
        case VK_LOGIC_OP_NOR:
            *out += std::string("VK_LOGIC_OP_NOR");
            return;
        case VK_LOGIC_OP_CLEAR:
            *out += std::string("VK_LOGIC_OP_CLEAR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkResult(std::string* out, uint32_t enum_uint32)
{
    VkResult e = static_cast<VkResult>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_ERROR_LAYER_NOT_PRESENT:
            *out += std::string("VK_ERROR_LAYER_NOT_PRESENT");
            return;
        case VK_ERROR_FEATURE_NOT_PRESENT:
            *out += std::string("VK_ERROR_FEATURE_NOT_PRESENT");
            return;
        case VK_ERROR_FORMAT_NOT_SUPPORTED:
            *out += std::string("VK_ERROR_FORMAT_NOT_SUPPORTED");
            return;
        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:
            *out += std::string("VK_ERROR_NATIVE_WINDOW_IN_USE_KHR");
            return;
        case VK_ERROR_NOT_PERMITTED_EXT:
            *out += std::string("VK_ERROR_NOT_PERMITTED_EXT");
            return;
        case VK_ERROR_EXTENSION_NOT_PRESENT:
            *out += std::string("VK_ERROR_EXTENSION_NOT_PRESENT");
            return;
        case VK_ERROR_INITIALIZATION_FAILED:
            *out += std::string("VK_ERROR_INITIALIZATION_FAILED");
            return;
        case VK_ERROR_MEMORY_MAP_FAILED:
            *out += std::string("VK_ERROR_MEMORY_MAP_FAILED");
            return;
        case VK_ERROR_INCOMPATIBLE_DRIVER:
            *out += std::string("VK_ERROR_INCOMPATIBLE_DRIVER");
            return;
        case VK_EVENT_RESET:
            *out += std::string("VK_EVENT_RESET");
            return;
        case VK_ERROR_OUT_OF_HOST_MEMORY:
            *out += std::string("VK_ERROR_OUT_OF_HOST_MEMORY");
            return;
        case VK_ERROR_TOO_MANY_OBJECTS:
            *out += std::string("VK_ERROR_TOO_MANY_OBJECTS");
            return;
        case VK_ERROR_INVALID_EXTERNAL_HANDLE:
            *out += std::string("VK_ERROR_INVALID_EXTERNAL_HANDLE");
            return;
        case VK_INCOMPLETE:
            *out += std::string("VK_INCOMPLETE");
            return;
        case VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT:
            *out += std::string("VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT");
            return;
        case VK_ERROR_OUT_OF_DATE_KHR:
            *out += std::string("VK_ERROR_OUT_OF_DATE_KHR");
            return;
        case VK_ERROR_FRAGMENTED_POOL:
            *out += std::string("VK_ERROR_FRAGMENTED_POOL");
            return;
        case VK_ERROR_OUT_OF_DEVICE_MEMORY:
            *out += std::string("VK_ERROR_OUT_OF_DEVICE_MEMORY");
            return;
        case VK_ERROR_SURFACE_LOST_KHR:
            *out += std::string("VK_ERROR_SURFACE_LOST_KHR");
            return;
        case VK_NOT_READY:
            *out += std::string("VK_NOT_READY");
            return;
        case VK_ERROR_OUT_OF_POOL_MEMORY:
            *out += std::string("VK_ERROR_OUT_OF_POOL_MEMORY");
            return;
        case VK_SUBOPTIMAL_KHR:
            *out += std::string("VK_SUBOPTIMAL_KHR");
            return;
        case VK_ERROR_INVALID_SHADER_NV:
            *out += std::string("VK_ERROR_INVALID_SHADER_NV");
            return;
        case VK_TIMEOUT:
            *out += std::string("VK_TIMEOUT");
            return;
        case VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT:
            *out += std::string("VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT");
            return;
        case VK_ERROR_INVALID_DEVICE_ADDRESS_EXT:
            *out += std::string("VK_ERROR_INVALID_DEVICE_ADDRESS_EXT");
            return;
        case VK_ERROR_FRAGMENTATION_EXT:
            *out += std::string("VK_ERROR_FRAGMENTATION_EXT");
            return;
        case VK_SUCCESS:
            *out += std::string("VK_SUCCESS");
            return;
        case VK_ERROR_DEVICE_LOST:
            *out += std::string("VK_ERROR_DEVICE_LOST");
            return;
        case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:
            *out += std::string("VK_ERROR_INCOMPATIBLE_DISPLAY_KHR");
            return;
        case VK_EVENT_SET:
            *out += std::string("VK_EVENT_SET");
            return;
        case VK_ERROR_VALIDATION_FAILED_EXT:
            *out += std::string("VK_ERROR_VALIDATION_FAILED_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSharingMode(std::string* out, uint32_t enum_uint32)
{
    VkSharingMode e = static_cast<VkSharingMode>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SHARING_MODE_EXCLUSIVE:
            *out += std::string("VK_SHARING_MODE_EXCLUSIVE");
            return;
        case VK_SHARING_MODE_CONCURRENT:
            *out += std::string("VK_SHARING_MODE_CONCURRENT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPolygonMode(std::string* out, uint32_t enum_uint32)
{
    VkPolygonMode e = static_cast<VkPolygonMode>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_POLYGON_MODE_LINE:
            *out += std::string("VK_POLYGON_MODE_LINE");
            return;
        case VK_POLYGON_MODE_FILL_RECTANGLE_NV:
            *out += std::string("VK_POLYGON_MODE_FILL_RECTANGLE_NV");
            return;
        case VK_POLYGON_MODE_POINT:
            *out += std::string("VK_POLYGON_MODE_POINT");
            return;
        case VK_POLYGON_MODE_FILL:
            *out += std::string("VK_POLYGON_MODE_FILL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSparseMemoryBindFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkSparseMemoryBindFlagBits e = static_cast<VkSparseMemoryBindFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SPARSE_MEMORY_BIND_METADATA_BIT:
            *out += std::string("VK_SPARSE_MEMORY_BIND_METADATA_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkShaderStageFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkShaderStageFlagBits e = static_cast<VkShaderStageFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV");
            return;
        case VK_SHADER_STAGE_CALLABLE_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_CALLABLE_BIT_NV");
            return;
        case VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT:
            *out += std::string("VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT");
            return;
        case VK_SHADER_STAGE_RAYGEN_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_RAYGEN_BIT_NV");
            return;
        case VK_SHADER_STAGE_COMPUTE_BIT:
            *out += std::string("VK_SHADER_STAGE_COMPUTE_BIT");
            return;
        case VK_SHADER_STAGE_VERTEX_BIT:
            *out += std::string("VK_SHADER_STAGE_VERTEX_BIT");
            return;
        case VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT:
            *out += std::string("VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT");
            return;
        case VK_SHADER_STAGE_INTERSECTION_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_INTERSECTION_BIT_NV");
            return;
        case VK_SHADER_STAGE_MESH_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_MESH_BIT_NV");
            return;
        case VK_SHADER_STAGE_ALL:
            *out += std::string("VK_SHADER_STAGE_ALL");
            return;
        case VK_SHADER_STAGE_ANY_HIT_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_ANY_HIT_BIT_NV");
            return;
        case VK_SHADER_STAGE_MISS_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_MISS_BIT_NV");
            return;
        case VK_SHADER_STAGE_TASK_BIT_NV:
            *out += std::string("VK_SHADER_STAGE_TASK_BIT_NV");
            return;
        case VK_SHADER_STAGE_GEOMETRY_BIT:
            *out += std::string("VK_SHADER_STAGE_GEOMETRY_BIT");
            return;
        case VK_SHADER_STAGE_FRAGMENT_BIT:
            *out += std::string("VK_SHADER_STAGE_FRAGMENT_BIT");
            return;
        case VK_SHADER_STAGE_ALL_GRAPHICS:
            *out += std::string("VK_SHADER_STAGE_ALL_GRAPHICS");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkImageCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkImageCreateFlagBits e = static_cast<VkImageCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT:
            *out += std::string("VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT");
            return;
        case VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV:
            *out += std::string("VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV");
            return;
        case VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT:
            *out += std::string("VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT");
            return;
        case VK_IMAGE_CREATE_ALIAS_BIT:
            *out += std::string("VK_IMAGE_CREATE_ALIAS_BIT");
            return;
        case VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT:
            *out += std::string("VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT");
            return;
        case VK_IMAGE_CREATE_PROTECTED_BIT:
            *out += std::string("VK_IMAGE_CREATE_PROTECTED_BIT");
            return;
        case VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT:
            *out += std::string("VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT");
            return;
        case VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT:
            *out += std::string("VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT");
            return;
        case VK_IMAGE_CREATE_EXTENDED_USAGE_BIT:
            *out += std::string("VK_IMAGE_CREATE_EXTENDED_USAGE_BIT");
            return;
        case VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT:
            *out += std::string("VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT");
            return;
        case VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT:
            *out += std::string("VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT");
            return;
        case VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT:
            *out += std::string("VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT");
            return;
        case VK_IMAGE_CREATE_DISJOINT_BIT:
            *out += std::string("VK_IMAGE_CREATE_DISJOINT_BIT");
            return;
        case VK_IMAGE_CREATE_SPARSE_ALIASED_BIT:
            *out += std::string("VK_IMAGE_CREATE_SPARSE_ALIASED_BIT");
            return;
        case VK_IMAGE_CREATE_SPARSE_BINDING_BIT:
            *out += std::string("VK_IMAGE_CREATE_SPARSE_BINDING_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSystemAllocationScope(std::string* out, uint32_t enum_uint32)
{
    VkSystemAllocationScope e = static_cast<VkSystemAllocationScope>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE:
            *out += std::string("VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_CACHE:
            *out += std::string("VK_SYSTEM_ALLOCATION_SCOPE_CACHE");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_DEVICE:
            *out += std::string("VK_SYSTEM_ALLOCATION_SCOPE_DEVICE");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_COMMAND:
            *out += std::string("VK_SYSTEM_ALLOCATION_SCOPE_COMMAND");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_OBJECT:
            *out += std::string("VK_SYSTEM_ALLOCATION_SCOPE_OBJECT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkImageViewCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkImageViewCreateFlagBits e = static_cast<VkImageViewCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT:
            *out += std::string("VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkBlendOp(std::string* out, uint32_t enum_uint32)
{
    VkBlendOp e = static_cast<VkBlendOp>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_BLEND_OP_HSL_SATURATION_EXT:
            *out += std::string("VK_BLEND_OP_HSL_SATURATION_EXT");
            return;
        case VK_BLEND_OP_DIFFERENCE_EXT:
            *out += std::string("VK_BLEND_OP_DIFFERENCE_EXT");
            return;
        case VK_BLEND_OP_HSL_COLOR_EXT:
            *out += std::string("VK_BLEND_OP_HSL_COLOR_EXT");
            return;
        case VK_BLEND_OP_CONTRAST_EXT:
            *out += std::string("VK_BLEND_OP_CONTRAST_EXT");
            return;
        case VK_BLEND_OP_MAX:
            *out += std::string("VK_BLEND_OP_MAX");
            return;
        case VK_BLEND_OP_REVERSE_SUBTRACT:
            *out += std::string("VK_BLEND_OP_REVERSE_SUBTRACT");
            return;
        case VK_BLEND_OP_HARDLIGHT_EXT:
            *out += std::string("VK_BLEND_OP_HARDLIGHT_EXT");
            return;
        case VK_BLEND_OP_OVERLAY_EXT:
            *out += std::string("VK_BLEND_OP_OVERLAY_EXT");
            return;
        case VK_BLEND_OP_LINEARLIGHT_EXT:
            *out += std::string("VK_BLEND_OP_LINEARLIGHT_EXT");
            return;
        case VK_BLEND_OP_PLUS_DARKER_EXT:
            *out += std::string("VK_BLEND_OP_PLUS_DARKER_EXT");
            return;
        case VK_BLEND_OP_DST_OUT_EXT:
            *out += std::string("VK_BLEND_OP_DST_OUT_EXT");
            return;
        case VK_BLEND_OP_INVERT_OVG_EXT:
            *out += std::string("VK_BLEND_OP_INVERT_OVG_EXT");
            return;
        case VK_BLEND_OP_DST_OVER_EXT:
            *out += std::string("VK_BLEND_OP_DST_OVER_EXT");
            return;
        case VK_BLEND_OP_DARKEN_EXT:
            *out += std::string("VK_BLEND_OP_DARKEN_EXT");
            return;
        case VK_BLEND_OP_PINLIGHT_EXT:
            *out += std::string("VK_BLEND_OP_PINLIGHT_EXT");
            return;
        case VK_BLEND_OP_MINUS_CLAMPED_EXT:
            *out += std::string("VK_BLEND_OP_MINUS_CLAMPED_EXT");
            return;
        case VK_BLEND_OP_INVERT_EXT:
            *out += std::string("VK_BLEND_OP_INVERT_EXT");
            return;
        case VK_BLEND_OP_DST_ATOP_EXT:
            *out += std::string("VK_BLEND_OP_DST_ATOP_EXT");
            return;
        case VK_BLEND_OP_SRC_ATOP_EXT:
            *out += std::string("VK_BLEND_OP_SRC_ATOP_EXT");
            return;
        case VK_BLEND_OP_BLUE_EXT:
            *out += std::string("VK_BLEND_OP_BLUE_EXT");
            return;
        case VK_BLEND_OP_ZERO_EXT:
            *out += std::string("VK_BLEND_OP_ZERO_EXT");
            return;
        case VK_BLEND_OP_EXCLUSION_EXT:
            *out += std::string("VK_BLEND_OP_EXCLUSION_EXT");
            return;
        case VK_BLEND_OP_GREEN_EXT:
            *out += std::string("VK_BLEND_OP_GREEN_EXT");
            return;
        case VK_BLEND_OP_MIN:
            *out += std::string("VK_BLEND_OP_MIN");
            return;
        case VK_BLEND_OP_HSL_LUMINOSITY_EXT:
            *out += std::string("VK_BLEND_OP_HSL_LUMINOSITY_EXT");
            return;
        case VK_BLEND_OP_PLUS_EXT:
            *out += std::string("VK_BLEND_OP_PLUS_EXT");
            return;
        case VK_BLEND_OP_MULTIPLY_EXT:
            *out += std::string("VK_BLEND_OP_MULTIPLY_EXT");
            return;
        case VK_BLEND_OP_LINEARBURN_EXT:
            *out += std::string("VK_BLEND_OP_LINEARBURN_EXT");
            return;
        case VK_BLEND_OP_DST_IN_EXT:
            *out += std::string("VK_BLEND_OP_DST_IN_EXT");
            return;
        case VK_BLEND_OP_XOR_EXT:
            *out += std::string("VK_BLEND_OP_XOR_EXT");
            return;
        case VK_BLEND_OP_LIGHTEN_EXT:
            *out += std::string("VK_BLEND_OP_LIGHTEN_EXT");
            return;
        case VK_BLEND_OP_SOFTLIGHT_EXT:
            *out += std::string("VK_BLEND_OP_SOFTLIGHT_EXT");
            return;
        case VK_BLEND_OP_DST_EXT:
            *out += std::string("VK_BLEND_OP_DST_EXT");
            return;
        case VK_BLEND_OP_SCREEN_EXT:
            *out += std::string("VK_BLEND_OP_SCREEN_EXT");
            return;
        case VK_BLEND_OP_SRC_OUT_EXT:
            *out += std::string("VK_BLEND_OP_SRC_OUT_EXT");
            return;
        case VK_BLEND_OP_SRC_IN_EXT:
            *out += std::string("VK_BLEND_OP_SRC_IN_EXT");
            return;
        case VK_BLEND_OP_PLUS_CLAMPED_EXT:
            *out += std::string("VK_BLEND_OP_PLUS_CLAMPED_EXT");
            return;
        case VK_BLEND_OP_HSL_HUE_EXT:
            *out += std::string("VK_BLEND_OP_HSL_HUE_EXT");
            return;
        case VK_BLEND_OP_VIVIDLIGHT_EXT:
            *out += std::string("VK_BLEND_OP_VIVIDLIGHT_EXT");
            return;
        case VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT:
            *out += std::string("VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT");
            return;
        case VK_BLEND_OP_SUBTRACT:
            *out += std::string("VK_BLEND_OP_SUBTRACT");
            return;
        case VK_BLEND_OP_HARDMIX_EXT:
            *out += std::string("VK_BLEND_OP_HARDMIX_EXT");
            return;
        case VK_BLEND_OP_LINEARDODGE_EXT:
            *out += std::string("VK_BLEND_OP_LINEARDODGE_EXT");
            return;
        case VK_BLEND_OP_SRC_OVER_EXT:
            *out += std::string("VK_BLEND_OP_SRC_OVER_EXT");
            return;
        case VK_BLEND_OP_COLORDODGE_EXT:
            *out += std::string("VK_BLEND_OP_COLORDODGE_EXT");
            return;
        case VK_BLEND_OP_INVERT_RGB_EXT:
            *out += std::string("VK_BLEND_OP_INVERT_RGB_EXT");
            return;
        case VK_BLEND_OP_ADD:
            *out += std::string("VK_BLEND_OP_ADD");
            return;
        case VK_BLEND_OP_COLORBURN_EXT:
            *out += std::string("VK_BLEND_OP_COLORBURN_EXT");
            return;
        case VK_BLEND_OP_MINUS_EXT:
            *out += std::string("VK_BLEND_OP_MINUS_EXT");
            return;
        case VK_BLEND_OP_SRC_EXT:
            *out += std::string("VK_BLEND_OP_SRC_EXT");
            return;
        case VK_BLEND_OP_RED_EXT:
            *out += std::string("VK_BLEND_OP_RED_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkFormatFeatureFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkFormatFeatureFlagBits e = static_cast<VkFormatFeatureFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT:
            *out += std::string("VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT");
            return;
        case VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:
            *out += std::string("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT");
            return;
        case VK_FORMAT_FEATURE_TRANSFER_SRC_BIT:
            *out += std::string("VK_FORMAT_FEATURE_TRANSFER_SRC_BIT");
            return;
        case VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT:
            *out += std::string("VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT");
            return;
        case VK_FORMAT_FEATURE_BLIT_SRC_BIT:
            *out += std::string("VK_FORMAT_FEATURE_BLIT_SRC_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT");
            return;
        case VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT:
            *out += std::string("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT");
            return;
        case VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT:
            *out += std::string("VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT");
            return;
        case VK_FORMAT_FEATURE_DISJOINT_BIT:
            *out += std::string("VK_FORMAT_FEATURE_DISJOINT_BIT");
            return;
        case VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:
            *out += std::string("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT");
            return;
        case VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT:
            *out += std::string("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT");
            return;
        case VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT:
            *out += std::string("VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT");
            return;
        case VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT:
            *out += std::string("VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG");
            return;
        case VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT:
            *out += std::string("VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT");
            return;
        case VK_FORMAT_FEATURE_BLIT_DST_BIT:
            *out += std::string("VK_FORMAT_FEATURE_BLIT_DST_BIT");
            return;
        case VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT:
            *out += std::string("VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT");
            return;
        case VK_FORMAT_FEATURE_TRANSFER_DST_BIT:
            *out += std::string("VK_FORMAT_FEATURE_TRANSFER_DST_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT");
            return;
        case VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:
            *out += std::string("VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:
            *out += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkQueryResultFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkQueryResultFlagBits e = static_cast<VkQueryResultFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_QUERY_RESULT_PARTIAL_BIT:
            *out += std::string("VK_QUERY_RESULT_PARTIAL_BIT");
            return;
        case VK_QUERY_RESULT_WITH_AVAILABILITY_BIT:
            *out += std::string("VK_QUERY_RESULT_WITH_AVAILABILITY_BIT");
            return;
        case VK_QUERY_RESULT_WAIT_BIT:
            *out += std::string("VK_QUERY_RESULT_WAIT_BIT");
            return;
        case VK_QUERY_RESULT_64_BIT:
            *out += std::string("VK_QUERY_RESULT_64_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkQueueFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkQueueFlagBits e = static_cast<VkQueueFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_QUEUE_COMPUTE_BIT:
            *out += std::string("VK_QUEUE_COMPUTE_BIT");
            return;
        case VK_QUEUE_GRAPHICS_BIT:
            *out += std::string("VK_QUEUE_GRAPHICS_BIT");
            return;
        case VK_QUEUE_TRANSFER_BIT:
            *out += std::string("VK_QUEUE_TRANSFER_BIT");
            return;
        case VK_QUEUE_SPARSE_BINDING_BIT:
            *out += std::string("VK_QUEUE_SPARSE_BINDING_BIT");
            return;
        case VK_QUEUE_PROTECTED_BIT:
            *out += std::string("VK_QUEUE_PROTECTED_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkVertexInputRate(std::string* out, uint32_t enum_uint32)
{
    VkVertexInputRate e = static_cast<VkVertexInputRate>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_VERTEX_INPUT_RATE_VERTEX:
            *out += std::string("VK_VERTEX_INPUT_RATE_VERTEX");
            return;
        case VK_VERTEX_INPUT_RATE_INSTANCE:
            *out += std::string("VK_VERTEX_INPUT_RATE_INSTANCE");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDescriptorSetLayoutCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkDescriptorSetLayoutCreateFlagBits e = static_cast<VkDescriptorSetLayoutCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT:
            *out += std::string("VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT");
            return;
        case VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR:
            *out += std::string("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSubpassContents(std::string* out, uint32_t enum_uint32)
{
    VkSubpassContents e = static_cast<VkSubpassContents>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS:
            *out += std::string("VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS");
            return;
        case VK_SUBPASS_CONTENTS_INLINE:
            *out += std::string("VK_SUBPASS_CONTENTS_INLINE");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPrimitiveTopology(std::string* out, uint32_t enum_uint32)
{
    VkPrimitiveTopology e = static_cast<VkPrimitiveTopology>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_PATCH_LIST");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_LIST:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_LIST");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_STRIP:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY");
            return;
        case VK_PRIMITIVE_TOPOLOGY_POINT_LIST:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_POINT_LIST");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY:
            *out += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSparseImageFormatFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkSparseImageFormatFlagBits e = static_cast<VkSparseImageFormatFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT:
            *out += std::string("VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT");
            return;
        case VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT:
            *out += std::string("VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT");
            return;
        case VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT:
            *out += std::string("VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCommandBufferLevel(std::string* out, uint32_t enum_uint32)
{
    VkCommandBufferLevel e = static_cast<VkCommandBufferLevel>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMMAND_BUFFER_LEVEL_SECONDARY:
            *out += std::string("VK_COMMAND_BUFFER_LEVEL_SECONDARY");
            return;
        case VK_COMMAND_BUFFER_LEVEL_PRIMARY:
            *out += std::string("VK_COMMAND_BUFFER_LEVEL_PRIMARY");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPipelineShaderStageCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkPipelineShaderStageCreateFlagBits e = static_cast<VkPipelineShaderStageCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT:
            *out += std::string("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT");
            return;
        case VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT:
            *out += std::string("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSamplerMipmapMode(std::string* out, uint32_t enum_uint32)
{
    VkSamplerMipmapMode e = static_cast<VkSamplerMipmapMode>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SAMPLER_MIPMAP_MODE_NEAREST:
            *out += std::string("VK_SAMPLER_MIPMAP_MODE_NEAREST");
            return;
        case VK_SAMPLER_MIPMAP_MODE_LINEAR:
            *out += std::string("VK_SAMPLER_MIPMAP_MODE_LINEAR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCompareOp(std::string* out, uint32_t enum_uint32)
{
    VkCompareOp e = static_cast<VkCompareOp>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMPARE_OP_EQUAL:
            *out += std::string("VK_COMPARE_OP_EQUAL");
            return;
        case VK_COMPARE_OP_GREATER_OR_EQUAL:
            *out += std::string("VK_COMPARE_OP_GREATER_OR_EQUAL");
            return;
        case VK_COMPARE_OP_GREATER:
            *out += std::string("VK_COMPARE_OP_GREATER");
            return;
        case VK_COMPARE_OP_ALWAYS:
            *out += std::string("VK_COMPARE_OP_ALWAYS");
            return;
        case VK_COMPARE_OP_LESS_OR_EQUAL:
            *out += std::string("VK_COMPARE_OP_LESS_OR_EQUAL");
            return;
        case VK_COMPARE_OP_NEVER:
            *out += std::string("VK_COMPARE_OP_NEVER");
            return;
        case VK_COMPARE_OP_NOT_EQUAL:
            *out += std::string("VK_COMPARE_OP_NOT_EQUAL");
            return;
        case VK_COMPARE_OP_LESS:
            *out += std::string("VK_COMPARE_OP_LESS");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSubpassDescriptionFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkSubpassDescriptionFlagBits e = static_cast<VkSubpassDescriptionFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX:
            *out += std::string("VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX");
            return;
        case VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX:
            *out += std::string("VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkObjectType(std::string* out, uint32_t enum_uint32)
{
    VkObjectType e = static_cast<VkObjectType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_OBJECT_TYPE_QUERY_POOL:
            *out += std::string("VK_OBJECT_TYPE_QUERY_POOL");
            return;
        case VK_OBJECT_TYPE_DISPLAY_MODE_KHR:
            *out += std::string("VK_OBJECT_TYPE_DISPLAY_MODE_KHR");
            return;
        case VK_OBJECT_TYPE_RENDER_PASS:
            *out += std::string("VK_OBJECT_TYPE_RENDER_PASS");
            return;
        case VK_OBJECT_TYPE_BUFFER:
            *out += std::string("VK_OBJECT_TYPE_BUFFER");
            return;
        case VK_OBJECT_TYPE_IMAGE:
            *out += std::string("VK_OBJECT_TYPE_IMAGE");
            return;
        case VK_OBJECT_TYPE_FRAMEBUFFER:
            *out += std::string("VK_OBJECT_TYPE_FRAMEBUFFER");
            return;
        case VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV:
            *out += std::string("VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV");
            return;
        case VK_OBJECT_TYPE_COMMAND_BUFFER:
            *out += std::string("VK_OBJECT_TYPE_COMMAND_BUFFER");
            return;
        case VK_OBJECT_TYPE_DEVICE:
            *out += std::string("VK_OBJECT_TYPE_DEVICE");
            return;
        case VK_OBJECT_TYPE_EVENT:
            *out += std::string("VK_OBJECT_TYPE_EVENT");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT:
            *out += std::string("VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT");
            return;
        case VK_OBJECT_TYPE_SEMAPHORE:
            *out += std::string("VK_OBJECT_TYPE_SEMAPHORE");
            return;
        case VK_OBJECT_TYPE_QUEUE:
            *out += std::string("VK_OBJECT_TYPE_QUEUE");
            return;
        case VK_OBJECT_TYPE_SWAPCHAIN_KHR:
            *out += std::string("VK_OBJECT_TYPE_SWAPCHAIN_KHR");
            return;
        case VK_OBJECT_TYPE_INSTANCE:
            *out += std::string("VK_OBJECT_TYPE_INSTANCE");
            return;
        case VK_OBJECT_TYPE_VALIDATION_CACHE_EXT:
            *out += std::string("VK_OBJECT_TYPE_VALIDATION_CACHE_EXT");
            return;
        case VK_OBJECT_TYPE_COMMAND_POOL:
            *out += std::string("VK_OBJECT_TYPE_COMMAND_POOL");
            return;
        case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
            *out += std::string("VK_OBJECT_TYPE_PHYSICAL_DEVICE");
            return;
        case VK_OBJECT_TYPE_DISPLAY_KHR:
            *out += std::string("VK_OBJECT_TYPE_DISPLAY_KHR");
            return;
        case VK_OBJECT_TYPE_DEVICE_MEMORY:
            *out += std::string("VK_OBJECT_TYPE_DEVICE_MEMORY");
            return;
        case VK_OBJECT_TYPE_OBJECT_TABLE_NVX:
            *out += std::string("VK_OBJECT_TYPE_OBJECT_TABLE_NVX");
            return;
        case VK_OBJECT_TYPE_PIPELINE:
            *out += std::string("VK_OBJECT_TYPE_PIPELINE");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_POOL:
            *out += std::string("VK_OBJECT_TYPE_DESCRIPTOR_POOL");
            return;
        case VK_OBJECT_TYPE_SHADER_MODULE:
            *out += std::string("VK_OBJECT_TYPE_SHADER_MODULE");
            return;
        case VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT:
            *out += std::string("VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT");
            return;
        case VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX:
            *out += std::string("VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX");
            return;
        case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
            *out += std::string("VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT");
            return;
        case VK_OBJECT_TYPE_BUFFER_VIEW:
            *out += std::string("VK_OBJECT_TYPE_BUFFER_VIEW");
            return;
        case VK_OBJECT_TYPE_SURFACE_KHR:
            *out += std::string("VK_OBJECT_TYPE_SURFACE_KHR");
            return;
        case VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL:
            *out += std::string("VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL");
            return;
        case VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION:
            *out += std::string("VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION");
            return;
        case VK_OBJECT_TYPE_UNKNOWN:
            *out += std::string("VK_OBJECT_TYPE_UNKNOWN");
            return;
        case VK_OBJECT_TYPE_SAMPLER:
            *out += std::string("VK_OBJECT_TYPE_SAMPLER");
            return;
        case VK_OBJECT_TYPE_PIPELINE_CACHE:
            *out += std::string("VK_OBJECT_TYPE_PIPELINE_CACHE");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_SET:
            *out += std::string("VK_OBJECT_TYPE_DESCRIPTOR_SET");
            return;
        case VK_OBJECT_TYPE_FENCE:
            *out += std::string("VK_OBJECT_TYPE_FENCE");
            return;
        case VK_OBJECT_TYPE_PIPELINE_LAYOUT:
            *out += std::string("VK_OBJECT_TYPE_PIPELINE_LAYOUT");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE:
            *out += std::string("VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE");
            return;
        case VK_OBJECT_TYPE_IMAGE_VIEW:
            *out += std::string("VK_OBJECT_TYPE_IMAGE_VIEW");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSampleCountFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkSampleCountFlagBits e = static_cast<VkSampleCountFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SAMPLE_COUNT_8_BIT:
            *out += std::string("VK_SAMPLE_COUNT_8_BIT");
            return;
        case VK_SAMPLE_COUNT_4_BIT:
            *out += std::string("VK_SAMPLE_COUNT_4_BIT");
            return;
        case VK_SAMPLE_COUNT_2_BIT:
            *out += std::string("VK_SAMPLE_COUNT_2_BIT");
            return;
        case VK_SAMPLE_COUNT_32_BIT:
            *out += std::string("VK_SAMPLE_COUNT_32_BIT");
            return;
        case VK_SAMPLE_COUNT_1_BIT:
            *out += std::string("VK_SAMPLE_COUNT_1_BIT");
            return;
        case VK_SAMPLE_COUNT_16_BIT:
            *out += std::string("VK_SAMPLE_COUNT_16_BIT");
            return;
        case VK_SAMPLE_COUNT_64_BIT:
            *out += std::string("VK_SAMPLE_COUNT_64_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkBorderColor(std::string* out, uint32_t enum_uint32)
{
    VkBorderColor e = static_cast<VkBorderColor>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_BORDER_COLOR_INT_OPAQUE_WHITE:
            *out += std::string("VK_BORDER_COLOR_INT_OPAQUE_WHITE");
            return;
        case VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE:
            *out += std::string("VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE");
            return;
        case VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK:
            *out += std::string("VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK");
            return;
        case VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK:
            *out += std::string("VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK");
            return;
        case VK_BORDER_COLOR_INT_TRANSPARENT_BLACK:
            *out += std::string("VK_BORDER_COLOR_INT_TRANSPARENT_BLACK");
            return;
        case VK_BORDER_COLOR_INT_OPAQUE_BLACK:
            *out += std::string("VK_BORDER_COLOR_INT_OPAQUE_BLACK");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkAttachmentStoreOp(std::string* out, uint32_t enum_uint32)
{
    VkAttachmentStoreOp e = static_cast<VkAttachmentStoreOp>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_ATTACHMENT_STORE_OP_DONT_CARE:
            *out += std::string("VK_ATTACHMENT_STORE_OP_DONT_CARE");
            return;
        case VK_ATTACHMENT_STORE_OP_STORE:
            *out += std::string("VK_ATTACHMENT_STORE_OP_STORE");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDependencyFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkDependencyFlagBits e = static_cast<VkDependencyFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEPENDENCY_VIEW_LOCAL_BIT:
            *out += std::string("VK_DEPENDENCY_VIEW_LOCAL_BIT");
            return;
        case VK_DEPENDENCY_DEVICE_GROUP_BIT:
            *out += std::string("VK_DEPENDENCY_DEVICE_GROUP_BIT");
            return;
        case VK_DEPENDENCY_BY_REGION_BIT:
            *out += std::string("VK_DEPENDENCY_BY_REGION_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkVendorId(std::string* out, uint32_t enum_uint32)
{
    VkVendorId e = static_cast<VkVendorId>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_VENDOR_ID_VIV:
            *out += std::string("VK_VENDOR_ID_VIV");
            return;
        case VK_VENDOR_ID_KAZAN:
            *out += std::string("VK_VENDOR_ID_KAZAN");
            return;
        case VK_VENDOR_ID_VSI:
            *out += std::string("VK_VENDOR_ID_VSI");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDeviceQueueCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkDeviceQueueCreateFlagBits e = static_cast<VkDeviceQueueCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT:
            *out += std::string("VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPipelineCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkPipelineCreateFlagBits e = static_cast<VkPipelineCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT:
            *out += std::string("VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT");
            return;
        case VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT:
            *out += std::string("VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT");
            return;
        case VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT:
            *out += std::string("VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT");
            return;
        case VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV:
            *out += std::string("VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV");
            return;
        case VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR:
            *out += std::string("VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR");
            return;
        case VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR:
            *out += std::string("VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR");
            return;
        case VK_PIPELINE_CREATE_DISPATCH_BASE:
            *out += std::string("VK_PIPELINE_CREATE_DISPATCH_BASE");
            return;
        case VK_PIPELINE_CREATE_DERIVATIVE_BIT:
            *out += std::string("VK_PIPELINE_CREATE_DERIVATIVE_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkFrontFace(std::string* out, uint32_t enum_uint32)
{
    VkFrontFace e = static_cast<VkFrontFace>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FRONT_FACE_CLOCKWISE:
            *out += std::string("VK_FRONT_FACE_CLOCKWISE");
            return;
        case VK_FRONT_FACE_COUNTER_CLOCKWISE:
            *out += std::string("VK_FRONT_FACE_COUNTER_CLOCKWISE");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkRenderPassCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkRenderPassCreateFlagBits e = static_cast<VkRenderPassCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    *out += std::string("UNKNOWN");
};


void EnumToStringVkInternalAllocationType(std::string* out, uint32_t enum_uint32)
{
    VkInternalAllocationType e = static_cast<VkInternalAllocationType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE:
            *out += std::string("VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkBufferCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkBufferCreateFlagBits e = static_cast<VkBufferCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_BUFFER_CREATE_SPARSE_BINDING_BIT:
            *out += std::string("VK_BUFFER_CREATE_SPARSE_BINDING_BIT");
            return;
        case VK_BUFFER_CREATE_PROTECTED_BIT:
            *out += std::string("VK_BUFFER_CREATE_PROTECTED_BIT");
            return;
        case VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT:
            *out += std::string("VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT");
            return;
        case VK_BUFFER_CREATE_SPARSE_ALIASED_BIT:
            *out += std::string("VK_BUFFER_CREATE_SPARSE_ALIASED_BIT");
            return;
        case VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT:
            *out += std::string("VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkImageTiling(std::string* out, uint32_t enum_uint32)
{
    VkImageTiling e = static_cast<VkImageTiling>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT:
            *out += std::string("VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT");
            return;
        case VK_IMAGE_TILING_LINEAR:
            *out += std::string("VK_IMAGE_TILING_LINEAR");
            return;
        case VK_IMAGE_TILING_OPTIMAL:
            *out += std::string("VK_IMAGE_TILING_OPTIMAL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPipelineCacheHeaderVersion(std::string* out, uint32_t enum_uint32)
{
    VkPipelineCacheHeaderVersion e = static_cast<VkPipelineCacheHeaderVersion>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PIPELINE_CACHE_HEADER_VERSION_ONE:
            *out += std::string("VK_PIPELINE_CACHE_HEADER_VERSION_ONE");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSamplerCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkSamplerCreateFlagBits e = static_cast<VkSamplerCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT:
            *out += std::string("VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT");
            return;
        case VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT:
            *out += std::string("VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkStencilOp(std::string* out, uint32_t enum_uint32)
{
    VkStencilOp e = static_cast<VkStencilOp>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_STENCIL_OP_INVERT:
            *out += std::string("VK_STENCIL_OP_INVERT");
            return;
        case VK_STENCIL_OP_INCREMENT_AND_CLAMP:
            *out += std::string("VK_STENCIL_OP_INCREMENT_AND_CLAMP");
            return;
        case VK_STENCIL_OP_DECREMENT_AND_WRAP:
            *out += std::string("VK_STENCIL_OP_DECREMENT_AND_WRAP");
            return;
        case VK_STENCIL_OP_ZERO:
            *out += std::string("VK_STENCIL_OP_ZERO");
            return;
        case VK_STENCIL_OP_REPLACE:
            *out += std::string("VK_STENCIL_OP_REPLACE");
            return;
        case VK_STENCIL_OP_KEEP:
            *out += std::string("VK_STENCIL_OP_KEEP");
            return;
        case VK_STENCIL_OP_INCREMENT_AND_WRAP:
            *out += std::string("VK_STENCIL_OP_INCREMENT_AND_WRAP");
            return;
        case VK_STENCIL_OP_DECREMENT_AND_CLAMP:
            *out += std::string("VK_STENCIL_OP_DECREMENT_AND_CLAMP");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSamplerAddressMode(std::string* out, uint32_t enum_uint32)
{
    VkSamplerAddressMode e = static_cast<VkSamplerAddressMode>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE:
            *out += std::string("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE");
            return;
        case VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER:
            *out += std::string("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER");
            return;
        case VK_SAMPLER_ADDRESS_MODE_REPEAT:
            *out += std::string("VK_SAMPLER_ADDRESS_MODE_REPEAT");
            return;
        case VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE:
            *out += std::string("VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE");
            return;
        case VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT:
            *out += std::string("VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkFramebufferCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkFramebufferCreateFlagBits e = static_cast<VkFramebufferCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR:
            *out += std::string("VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkMemoryHeapFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkMemoryHeapFlagBits e = static_cast<VkMemoryHeapFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_MEMORY_HEAP_MULTI_INSTANCE_BIT:
            *out += std::string("VK_MEMORY_HEAP_MULTI_INSTANCE_BIT");
            return;
        case VK_MEMORY_HEAP_DEVICE_LOCAL_BIT:
            *out += std::string("VK_MEMORY_HEAP_DEVICE_LOCAL_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkBlendFactor(std::string* out, uint32_t enum_uint32)
{
    VkBlendFactor e = static_cast<VkBlendFactor>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
            *out += std::string("VK_BLEND_FACTOR_SRC_ALPHA_SATURATE");
            return;
        case VK_BLEND_FACTOR_SRC_COLOR:
            *out += std::string("VK_BLEND_FACTOR_SRC_COLOR");
            return;
        case VK_BLEND_FACTOR_SRC1_COLOR:
            *out += std::string("VK_BLEND_FACTOR_SRC1_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA");
            return;
        case VK_BLEND_FACTOR_SRC_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_SRC_ALPHA");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA");
            return;
        case VK_BLEND_FACTOR_ZERO:
            *out += std::string("VK_BLEND_FACTOR_ZERO");
            return;
        case VK_BLEND_FACTOR_CONSTANT_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_CONSTANT_ALPHA");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA");
            return;
        case VK_BLEND_FACTOR_CONSTANT_COLOR:
            *out += std::string("VK_BLEND_FACTOR_CONSTANT_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR");
            return;
        case VK_BLEND_FACTOR_SRC1_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_SRC1_ALPHA");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR");
            return;
        case VK_BLEND_FACTOR_DST_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_DST_ALPHA");
            return;
        case VK_BLEND_FACTOR_ONE:
            *out += std::string("VK_BLEND_FACTOR_ONE");
            return;
        case VK_BLEND_FACTOR_DST_COLOR:
            *out += std::string("VK_BLEND_FACTOR_DST_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:
            *out += std::string("VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCommandPoolCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkCommandPoolCreateFlagBits e = static_cast<VkCommandPoolCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT:
            *out += std::string("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT");
            return;
        case VK_COMMAND_POOL_CREATE_PROTECTED_BIT:
            *out += std::string("VK_COMMAND_POOL_CREATE_PROTECTED_BIT");
            return;
        case VK_COMMAND_POOL_CREATE_TRANSIENT_BIT:
            *out += std::string("VK_COMMAND_POOL_CREATE_TRANSIENT_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkQueryPipelineStatisticFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkQueryPipelineStatisticFlagBits e = static_cast<VkQueryPipelineStatisticFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT:
            *out += std::string("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkBufferUsageFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkBufferUsageFlagBits e = static_cast<VkBufferUsageFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT:
            *out += std::string("VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_TRANSFER_SRC_BIT:
            *out += std::string("VK_BUFFER_USAGE_TRANSFER_SRC_BIT");
            return;
        case VK_BUFFER_USAGE_VERTEX_BUFFER_BIT:
            *out += std::string("VK_BUFFER_USAGE_VERTEX_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT:
            *out += std::string("VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT:
            *out += std::string("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT:
            *out += std::string("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT:
            *out += std::string("VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT:
            *out += std::string("VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_INDEX_BUFFER_BIT:
            *out += std::string("VK_BUFFER_USAGE_INDEX_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_RAY_TRACING_BIT_NV:
            *out += std::string("VK_BUFFER_USAGE_RAY_TRACING_BIT_NV");
            return;
        case VK_BUFFER_USAGE_STORAGE_BUFFER_BIT:
            *out += std::string("VK_BUFFER_USAGE_STORAGE_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT:
            *out += std::string("VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT:
            *out += std::string("VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_TRANSFER_DST_BIT:
            *out += std::string("VK_BUFFER_USAGE_TRANSFER_DST_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPipelineBindPoint(std::string* out, uint32_t enum_uint32)
{
    VkPipelineBindPoint e = static_cast<VkPipelineBindPoint>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PIPELINE_BIND_POINT_RAY_TRACING_NV:
            *out += std::string("VK_PIPELINE_BIND_POINT_RAY_TRACING_NV");
            return;
        case VK_PIPELINE_BIND_POINT_COMPUTE:
            *out += std::string("VK_PIPELINE_BIND_POINT_COMPUTE");
            return;
        case VK_PIPELINE_BIND_POINT_GRAPHICS:
            *out += std::string("VK_PIPELINE_BIND_POINT_GRAPHICS");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkQueryControlFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkQueryControlFlagBits e = static_cast<VkQueryControlFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_QUERY_CONTROL_PRECISE_BIT:
            *out += std::string("VK_QUERY_CONTROL_PRECISE_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkImageViewType(std::string* out, uint32_t enum_uint32)
{
    VkImageViewType e = static_cast<VkImageViewType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_VIEW_TYPE_2D_ARRAY:
            *out += std::string("VK_IMAGE_VIEW_TYPE_2D_ARRAY");
            return;
        case VK_IMAGE_VIEW_TYPE_1D_ARRAY:
            *out += std::string("VK_IMAGE_VIEW_TYPE_1D_ARRAY");
            return;
        case VK_IMAGE_VIEW_TYPE_3D:
            *out += std::string("VK_IMAGE_VIEW_TYPE_3D");
            return;
        case VK_IMAGE_VIEW_TYPE_1D:
            *out += std::string("VK_IMAGE_VIEW_TYPE_1D");
            return;
        case VK_IMAGE_VIEW_TYPE_CUBE:
            *out += std::string("VK_IMAGE_VIEW_TYPE_CUBE");
            return;
        case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY:
            *out += std::string("VK_IMAGE_VIEW_TYPE_CUBE_ARRAY");
            return;
        case VK_IMAGE_VIEW_TYPE_2D:
            *out += std::string("VK_IMAGE_VIEW_TYPE_2D");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDescriptorPoolCreateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkDescriptorPoolCreateFlagBits e = static_cast<VkDescriptorPoolCreateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT:
            *out += std::string("VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT");
            return;
        case VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT:
            *out += std::string("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkFilter(std::string* out, uint32_t enum_uint32)
{
    VkFilter e = static_cast<VkFilter>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FILTER_NEAREST:
            *out += std::string("VK_FILTER_NEAREST");
            return;
        case VK_FILTER_LINEAR:
            *out += std::string("VK_FILTER_LINEAR");
            return;
        case VK_FILTER_CUBIC_IMG:
            *out += std::string("VK_FILTER_CUBIC_IMG");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkQueryType(std::string* out, uint32_t enum_uint32)
{
    VkQueryType e = static_cast<VkQueryType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_QUERY_TYPE_PIPELINE_STATISTICS:
            *out += std::string("VK_QUERY_TYPE_PIPELINE_STATISTICS");
            return;
        case VK_QUERY_TYPE_OCCLUSION:
            *out += std::string("VK_QUERY_TYPE_OCCLUSION");
            return;
        case VK_QUERY_TYPE_TIMESTAMP:
            *out += std::string("VK_QUERY_TYPE_TIMESTAMP");
            return;
        case VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL:
            *out += std::string("VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL");
            return;
        case VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV:
            *out += std::string("VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV");
            return;
        case VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT:
            *out += std::string("VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkAttachmentDescriptionFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkAttachmentDescriptionFlagBits e = static_cast<VkAttachmentDescriptionFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT:
            *out += std::string("VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkComponentSwizzle(std::string* out, uint32_t enum_uint32)
{
    VkComponentSwizzle e = static_cast<VkComponentSwizzle>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMPONENT_SWIZZLE_ONE:
            *out += std::string("VK_COMPONENT_SWIZZLE_ONE");
            return;
        case VK_COMPONENT_SWIZZLE_IDENTITY:
            *out += std::string("VK_COMPONENT_SWIZZLE_IDENTITY");
            return;
        case VK_COMPONENT_SWIZZLE_ZERO:
            *out += std::string("VK_COMPONENT_SWIZZLE_ZERO");
            return;
        case VK_COMPONENT_SWIZZLE_B:
            *out += std::string("VK_COMPONENT_SWIZZLE_B");
            return;
        case VK_COMPONENT_SWIZZLE_R:
            *out += std::string("VK_COMPONENT_SWIZZLE_R");
            return;
        case VK_COMPONENT_SWIZZLE_G:
            *out += std::string("VK_COMPONENT_SWIZZLE_G");
            return;
        case VK_COMPONENT_SWIZZLE_A:
            *out += std::string("VK_COMPONENT_SWIZZLE_A");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCommandPoolResetFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkCommandPoolResetFlagBits e = static_cast<VkCommandPoolResetFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT:
            *out += std::string("VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkStructureType(std::string* out, uint32_t enum_uint32)
{
    VkStructureType e = static_cast<VkStructureType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_GEOMETRY_NV:
            *out += std::string("VK_STRUCTURE_TYPE_GEOMETRY_NV");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO");
            return;
        case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_BARRIER");
            return;
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
            *out += std::string("VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_SUBMIT_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_SUBMIT_INFO");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
            *out += std::string("VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
            *out += std::string("VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS");
            return;
        case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PRESENT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
            *out += std::string("VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP");
            return;
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
            *out += std::string("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
            *out += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN:
            *out += std::string("VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD");
            return;
        case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_HDR_METADATA_EXT");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
            *out += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
            *out += std::string("VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO");
            return;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
            *out += std::string("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_SPARSE_INFO");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX");
            return;
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
            *out += std::string("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
            *out += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
            *out += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
            *out += std::string("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
            *out += std::string("VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
            *out += std::string("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA");
            return;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
            *out += std::string("VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
            *out += std::string("VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
            *out += std::string("VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR");
            return;
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
            *out += std::string("VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
            *out += std::string("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV");
            return;
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
            *out += std::string("VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO");
            return;
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_EVENT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX:
            *out += std::string("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK:
            *out += std::string("VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            *out += std::string("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
            *out += std::string("VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP");
            return;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
            *out += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK:
            *out += std::string("VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO");
            return;
        case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
            *out += std::string("VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR:
            *out += std::string("VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_APPLICATION_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_APPLICATION_INFO");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
            *out += std::string("VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
            *out += std::string("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_FENCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            *out += std::string("VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL:
            *out += std::string("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
            *out += std::string("VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
            *out += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkColorComponentFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkColorComponentFlagBits e = static_cast<VkColorComponentFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COLOR_COMPONENT_A_BIT:
            *out += std::string("VK_COLOR_COMPONENT_A_BIT");
            return;
        case VK_COLOR_COMPONENT_R_BIT:
            *out += std::string("VK_COLOR_COMPONENT_R_BIT");
            return;
        case VK_COLOR_COMPONENT_B_BIT:
            *out += std::string("VK_COLOR_COMPONENT_B_BIT");
            return;
        case VK_COLOR_COMPONENT_G_BIT:
            *out += std::string("VK_COLOR_COMPONENT_G_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDescriptorType(std::string* out, uint32_t enum_uint32)
{
    VkDescriptorType e = static_cast<VkDescriptorType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
            *out += std::string("VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE");
            return;
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
            *out += std::string("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER");
            return;
        case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
            *out += std::string("VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER");
            return;
        case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV:
            *out += std::string("VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV");
            return;
        case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
            *out += std::string("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER");
            return;
        case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
            *out += std::string("VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT");
            return;
        case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
            *out += std::string("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC");
            return;
        case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
            *out += std::string("VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER");
            return;
        case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT:
            *out += std::string("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT");
            return;
        case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
            *out += std::string("VK_DESCRIPTOR_TYPE_STORAGE_IMAGE");
            return;
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
            *out += std::string("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC");
            return;
        case VK_DESCRIPTOR_TYPE_SAMPLER:
            *out += std::string("VK_DESCRIPTOR_TYPE_SAMPLER");
            return;
        case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
            *out += std::string("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkAttachmentLoadOp(std::string* out, uint32_t enum_uint32)
{
    VkAttachmentLoadOp e = static_cast<VkAttachmentLoadOp>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_ATTACHMENT_LOAD_OP_CLEAR:
            *out += std::string("VK_ATTACHMENT_LOAD_OP_CLEAR");
            return;
        case VK_ATTACHMENT_LOAD_OP_DONT_CARE:
            *out += std::string("VK_ATTACHMENT_LOAD_OP_DONT_CARE");
            return;
        case VK_ATTACHMENT_LOAD_OP_LOAD:
            *out += std::string("VK_ATTACHMENT_LOAD_OP_LOAD");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkFormat(std::string* out, uint32_t enum_uint32)
{
    VkFormat e = static_cast<VkFormat>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FORMAT_B8G8R8_SNORM:
            *out += std::string("VK_FORMAT_B8G8R8_SNORM");
            return;
        case VK_FORMAT_A8B8G8R8_SSCALED_PACK32:
            *out += std::string("VK_FORMAT_A8B8G8R8_SSCALED_PACK32");
            return;
        case VK_FORMAT_A8B8G8R8_SINT_PACK32:
            *out += std::string("VK_FORMAT_A8B8G8R8_SINT_PACK32");
            return;
        case VK_FORMAT_R8G8B8_SNORM:
            *out += std::string("VK_FORMAT_R8G8B8_SNORM");
            return;
        case VK_FORMAT_R8G8B8A8_SSCALED:
            *out += std::string("VK_FORMAT_R8G8B8A8_SSCALED");
            return;
        case VK_FORMAT_B16G16R16G16_422_UNORM:
            *out += std::string("VK_FORMAT_B16G16R16G16_422_UNORM");
            return;
        case VK_FORMAT_R32G32_UINT:
            *out += std::string("VK_FORMAT_R32G32_UINT");
            return;
        case VK_FORMAT_R8G8B8_SSCALED:
            *out += std::string("VK_FORMAT_R8G8B8_SSCALED");
            return;
        case VK_FORMAT_ASTC_10x6_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x6_UNORM_BLOCK");
            return;
        case VK_FORMAT_B8G8R8_USCALED:
            *out += std::string("VK_FORMAT_B8G8R8_USCALED");
            return;
        case VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK");
            return;
        case VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_5x4_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_5x4_UNORM_BLOCK");
            return;
        case VK_FORMAT_R8G8B8_UINT:
            *out += std::string("VK_FORMAT_R8G8B8_UINT");
            return;
        case VK_FORMAT_R32G32B32A32_SINT:
            *out += std::string("VK_FORMAT_R32G32B32A32_SINT");
            return;
        case VK_FORMAT_R16G16B16A16_SFLOAT:
            *out += std::string("VK_FORMAT_R16G16B16A16_SFLOAT");
            return;
        case VK_FORMAT_R8_SINT:
            *out += std::string("VK_FORMAT_R8_SINT");
            return;
        case VK_FORMAT_R8G8_UNORM:
            *out += std::string("VK_FORMAT_R8G8_UNORM");
            return;
        case VK_FORMAT_A2R10G10B10_USCALED_PACK32:
            *out += std::string("VK_FORMAT_A2R10G10B10_USCALED_PACK32");
            return;
        case VK_FORMAT_R32G32_SFLOAT:
            *out += std::string("VK_FORMAT_R32G32_SFLOAT");
            return;
        case VK_FORMAT_D32_SFLOAT:
            *out += std::string("VK_FORMAT_D32_SFLOAT");
            return;
        case VK_FORMAT_D16_UNORM_S8_UINT:
            *out += std::string("VK_FORMAT_D16_UNORM_S8_UINT");
            return;
        case VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R16_SFLOAT:
            *out += std::string("VK_FORMAT_R16_SFLOAT");
            return;
        case VK_FORMAT_BC1_RGBA_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_BC1_RGBA_SRGB_BLOCK");
            return;
        case VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
            *out += std::string("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM");
            return;
        case VK_FORMAT_R16G16_UINT:
            *out += std::string("VK_FORMAT_R16G16_UINT");
            return;
        case VK_FORMAT_G16B16G16R16_422_UNORM:
            *out += std::string("VK_FORMAT_G16B16G16R16_422_UNORM");
            return;
        case VK_FORMAT_R16G16B16A16_UNORM:
            *out += std::string("VK_FORMAT_R16G16B16A16_UNORM");
            return;
        case VK_FORMAT_B8G8R8_SINT:
            *out += std::string("VK_FORMAT_B8G8R8_SINT");
            return;
        case VK_FORMAT_R16G16_UNORM:
            *out += std::string("VK_FORMAT_R16G16_UNORM");
            return;
        case VK_FORMAT_D32_SFLOAT_S8_UINT:
            *out += std::string("VK_FORMAT_D32_SFLOAT_S8_UINT");
            return;
        case VK_FORMAT_ASTC_10x6_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x6_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_10x10_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x10_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_10x8_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x8_SRGB_BLOCK");
            return;
        case VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:
            *out += std::string("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM");
            return;
        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_R32G32B32A32_UINT:
            *out += std::string("VK_FORMAT_R32G32B32A32_UINT");
            return;
        case VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
            *out += std::string("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM");
            return;
        case VK_FORMAT_BC6H_SFLOAT_BLOCK:
            *out += std::string("VK_FORMAT_BC6H_SFLOAT_BLOCK");
            return;
        case VK_FORMAT_BC1_RGBA_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC1_RGBA_UNORM_BLOCK");
            return;
        case VK_FORMAT_R16_SSCALED:
            *out += std::string("VK_FORMAT_R16_SSCALED");
            return;
        case VK_FORMAT_BC4_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC4_UNORM_BLOCK");
            return;
        case VK_FORMAT_R32G32_SINT:
            *out += std::string("VK_FORMAT_R32G32_SINT");
            return;
        case VK_FORMAT_BC5_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC5_UNORM_BLOCK");
            return;
        case VK_FORMAT_X8_D24_UNORM_PACK32:
            *out += std::string("VK_FORMAT_X8_D24_UNORM_PACK32");
            return;
        case VK_FORMAT_R10X6G10X6_UNORM_2PACK16:
            *out += std::string("VK_FORMAT_R10X6G10X6_UNORM_2PACK16");
            return;
        case VK_FORMAT_R8G8_SNORM:
            *out += std::string("VK_FORMAT_R8G8_SNORM");
            return;
        case VK_FORMAT_R16G16B16_USCALED:
            *out += std::string("VK_FORMAT_R16G16B16_USCALED");
            return;
        case VK_FORMAT_ASTC_10x8_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x8_UNORM_BLOCK");
            return;
        case VK_FORMAT_R8G8_SINT:
            *out += std::string("VK_FORMAT_R8G8_SINT");
            return;
        case VK_FORMAT_ASTC_6x5_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_6x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_R5G5B5A1_UNORM_PACK16:
            *out += std::string("VK_FORMAT_R5G5B5A1_UNORM_PACK16");
            return;
        case VK_FORMAT_A2R10G10B10_SINT_PACK32:
            *out += std::string("VK_FORMAT_A2R10G10B10_SINT_PACK32");
            return;
        case VK_FORMAT_ASTC_10x10_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x10_UNORM_BLOCK");
            return;
        case VK_FORMAT_B8G8R8A8_SRGB:
            *out += std::string("VK_FORMAT_B8G8R8A8_SRGB");
            return;
        case VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_B8G8R8_UNORM:
            *out += std::string("VK_FORMAT_B8G8R8_UNORM");
            return;
        case VK_FORMAT_R16G16B16_SSCALED:
            *out += std::string("VK_FORMAT_R16G16B16_SSCALED");
            return;
        case VK_FORMAT_R16G16_SINT:
            *out += std::string("VK_FORMAT_R16G16_SINT");
            return;
        case VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
            *out += std::string("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_R64G64_SFLOAT:
            *out += std::string("VK_FORMAT_R64G64_SFLOAT");
            return;
        case VK_FORMAT_B5G6R5_UNORM_PACK16:
            *out += std::string("VK_FORMAT_B5G6R5_UNORM_PACK16");
            return;
        case VK_FORMAT_ASTC_8x6_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_8x6_UNORM_BLOCK");
            return;
        case VK_FORMAT_A2B10G10R10_UNORM_PACK32:
            *out += std::string("VK_FORMAT_A2B10G10R10_UNORM_PACK32");
            return;
        case VK_FORMAT_R64G64B64_UINT:
            *out += std::string("VK_FORMAT_R64G64B64_UINT");
            return;
        case VK_FORMAT_ASTC_10x5_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_ASTC_6x6_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_6x6_UNORM_BLOCK");
            return;
        case VK_FORMAT_A2B10G10R10_SSCALED_PACK32:
            *out += std::string("VK_FORMAT_A2B10G10R10_SSCALED_PACK32");
            return;
        case VK_FORMAT_EAC_R11G11_SNORM_BLOCK:
            *out += std::string("VK_FORMAT_EAC_R11G11_SNORM_BLOCK");
            return;
        case VK_FORMAT_R8_UNORM:
            *out += std::string("VK_FORMAT_R8_UNORM");
            return;
        case VK_FORMAT_R64G64_UINT:
            *out += std::string("VK_FORMAT_R64G64_UINT");
            return;
        case VK_FORMAT_BC1_RGB_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_BC1_RGB_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_5x5_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_5x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_R16G16B16A16_SSCALED:
            *out += std::string("VK_FORMAT_R16G16B16A16_SSCALED");
            return;
        case VK_FORMAT_R8G8_UINT:
            *out += std::string("VK_FORMAT_R8G8_UINT");
            return;
        case VK_FORMAT_R12X4_UNORM_PACK16:
            *out += std::string("VK_FORMAT_R12X4_UNORM_PACK16");
            return;
        case VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_ASTC_6x6_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_6x6_SRGB_BLOCK");
            return;
        case VK_FORMAT_B8G8R8A8_SINT:
            *out += std::string("VK_FORMAT_B8G8R8A8_SINT");
            return;
        case VK_FORMAT_ASTC_8x5_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_8x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:
            *out += std::string("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM");
            return;
        case VK_FORMAT_R8G8B8A8_UINT:
            *out += std::string("VK_FORMAT_R8G8B8A8_UINT");
            return;
        case VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:
            *out += std::string("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM");
            return;
        case VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:
            *out += std::string("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM");
            return;
        case VK_FORMAT_A2R10G10B10_UNORM_PACK32:
            *out += std::string("VK_FORMAT_A2R10G10B10_UNORM_PACK32");
            return;
        case VK_FORMAT_BC2_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC2_UNORM_BLOCK");
            return;
        case VK_FORMAT_R8G8B8_UNORM:
            *out += std::string("VK_FORMAT_R8G8B8_UNORM");
            return;
        case VK_FORMAT_B8G8R8A8_SSCALED:
            *out += std::string("VK_FORMAT_B8G8R8A8_SSCALED");
            return;
        case VK_FORMAT_R16G16B16_UINT:
            *out += std::string("VK_FORMAT_R16G16B16_UINT");
            return;
        case VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_A2B10G10R10_UINT_PACK32:
            *out += std::string("VK_FORMAT_A2B10G10R10_UINT_PACK32");
            return;
        case VK_FORMAT_R64G64B64A64_UINT:
            *out += std::string("VK_FORMAT_R64G64B64A64_UINT");
            return;
        case VK_FORMAT_R32G32B32_UINT:
            *out += std::string("VK_FORMAT_R32G32B32_UINT");
            return;
        case VK_FORMAT_R8G8B8_SINT:
            *out += std::string("VK_FORMAT_R8G8B8_SINT");
            return;
        case VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R16_SINT:
            *out += std::string("VK_FORMAT_R16_SINT");
            return;
        case VK_FORMAT_ASTC_12x12_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_12x12_UNORM_BLOCK");
            return;
        case VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:
            *out += std::string("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM");
            return;
        case VK_FORMAT_R32G32B32_SFLOAT:
            *out += std::string("VK_FORMAT_R32G32B32_SFLOAT");
            return;
        case VK_FORMAT_UNDEFINED:
            *out += std::string("VK_FORMAT_UNDEFINED");
            return;
        case VK_FORMAT_R16G16B16A16_SNORM:
            *out += std::string("VK_FORMAT_R16G16B16A16_SNORM");
            return;
        case VK_FORMAT_R16G16B16_SFLOAT:
            *out += std::string("VK_FORMAT_R16G16B16_SFLOAT");
            return;
        case VK_FORMAT_BC3_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_BC3_SRGB_BLOCK");
            return;
        case VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_R64_SINT:
            *out += std::string("VK_FORMAT_R64_SINT");
            return;
        case VK_FORMAT_ASTC_12x12_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_12x12_SRGB_BLOCK");
            return;
        case VK_FORMAT_R8G8B8A8_UNORM:
            *out += std::string("VK_FORMAT_R8G8B8A8_UNORM");
            return;
        case VK_FORMAT_BC5_SNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC5_SNORM_BLOCK");
            return;
        case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
            *out += std::string("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM");
            return;
        case VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_D24_UNORM_S8_UINT:
            *out += std::string("VK_FORMAT_D24_UNORM_S8_UINT");
            return;
        case VK_FORMAT_A2R10G10B10_SSCALED_PACK32:
            *out += std::string("VK_FORMAT_A2R10G10B10_SSCALED_PACK32");
            return;
        case VK_FORMAT_R16G16B16A16_UINT:
            *out += std::string("VK_FORMAT_R16G16B16A16_UINT");
            return;
        case VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_ASTC_6x5_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_6x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_R16_SNORM:
            *out += std::string("VK_FORMAT_R16_SNORM");
            return;
        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_A8B8G8R8_SRGB_PACK32:
            *out += std::string("VK_FORMAT_A8B8G8R8_SRGB_PACK32");
            return;
        case VK_FORMAT_ASTC_4x4_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_4x4_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_8x8_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_8x8_SRGB_BLOCK");
            return;
        case VK_FORMAT_S8_UINT:
            *out += std::string("VK_FORMAT_S8_UINT");
            return;
        case VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R64G64B64A64_SINT:
            *out += std::string("VK_FORMAT_R64G64B64A64_SINT");
            return;
        case VK_FORMAT_A8B8G8R8_UNORM_PACK32:
            *out += std::string("VK_FORMAT_A8B8G8R8_UNORM_PACK32");
            return;
        case VK_FORMAT_R8G8_SSCALED:
            *out += std::string("VK_FORMAT_R8G8_SSCALED");
            return;
        case VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:
            *out += std::string("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16");
            return;
        case VK_FORMAT_B8G8R8A8_USCALED:
            *out += std::string("VK_FORMAT_B8G8R8A8_USCALED");
            return;
        case VK_FORMAT_B5G5R5A1_UNORM_PACK16:
            *out += std::string("VK_FORMAT_B5G5R5A1_UNORM_PACK16");
            return;
        case VK_FORMAT_B8G8R8_SSCALED:
            *out += std::string("VK_FORMAT_B8G8R8_SSCALED");
            return;
        case VK_FORMAT_A2B10G10R10_SNORM_PACK32:
            *out += std::string("VK_FORMAT_A2B10G10R10_SNORM_PACK32");
            return;
        case VK_FORMAT_R16_UINT:
            *out += std::string("VK_FORMAT_R16_UINT");
            return;
        case VK_FORMAT_R32_SFLOAT:
            *out += std::string("VK_FORMAT_R32_SFLOAT");
            return;
        case VK_FORMAT_R64G64B64_SFLOAT:
            *out += std::string("VK_FORMAT_R64G64B64_SFLOAT");
            return;
        case VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:
            *out += std::string("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM");
            return;
        case VK_FORMAT_BC6H_UFLOAT_BLOCK:
            *out += std::string("VK_FORMAT_BC6H_UFLOAT_BLOCK");
            return;
        case VK_FORMAT_R8G8B8A8_SNORM:
            *out += std::string("VK_FORMAT_R8G8B8A8_SNORM");
            return;
        case VK_FORMAT_BC3_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC3_UNORM_BLOCK");
            return;
        case VK_FORMAT_B8G8R8A8_UNORM:
            *out += std::string("VK_FORMAT_B8G8R8A8_UNORM");
            return;
        case VK_FORMAT_B4G4R4A4_UNORM_PACK16:
            *out += std::string("VK_FORMAT_B4G4R4A4_UNORM_PACK16");
            return;
        case VK_FORMAT_R4G4B4A4_UNORM_PACK16:
            *out += std::string("VK_FORMAT_R4G4B4A4_UNORM_PACK16");
            return;
        case VK_FORMAT_R8G8B8A8_USCALED:
            *out += std::string("VK_FORMAT_R8G8B8A8_USCALED");
            return;
        case VK_FORMAT_ASTC_8x8_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_8x8_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_12x10_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_12x10_UNORM_BLOCK");
            return;
        case VK_FORMAT_EAC_R11_SNORM_BLOCK:
            *out += std::string("VK_FORMAT_EAC_R11_SNORM_BLOCK");
            return;
        case VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:
            *out += std::string("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16");
            return;
        case VK_FORMAT_ASTC_5x4_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_5x4_SRGB_BLOCK");
            return;
        case VK_FORMAT_EAC_R11_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_EAC_R11_UNORM_BLOCK");
            return;
        case VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
            *out += std::string("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM");
            return;
        case VK_FORMAT_BC1_RGB_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC1_RGB_UNORM_BLOCK");
            return;
        case VK_FORMAT_R8G8B8A8_SRGB:
            *out += std::string("VK_FORMAT_R8G8B8A8_SRGB");
            return;
        case VK_FORMAT_R16G16_USCALED:
            *out += std::string("VK_FORMAT_R16G16_USCALED");
            return;
        case VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
            *out += std::string("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_B10G11R11_UFLOAT_PACK32:
            *out += std::string("VK_FORMAT_B10G11R11_UFLOAT_PACK32");
            return;
        case VK_FORMAT_R5G6B5_UNORM_PACK16:
            *out += std::string("VK_FORMAT_R5G6B5_UNORM_PACK16");
            return;
        case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_A8B8G8R8_UINT_PACK32:
            *out += std::string("VK_FORMAT_A8B8G8R8_UINT_PACK32");
            return;
        case VK_FORMAT_R32_UINT:
            *out += std::string("VK_FORMAT_R32_UINT");
            return;
        case VK_FORMAT_A1R5G5B5_UNORM_PACK16:
            *out += std::string("VK_FORMAT_A1R5G5B5_UNORM_PACK16");
            return;
        case VK_FORMAT_R64G64B64A64_SFLOAT:
            *out += std::string("VK_FORMAT_R64G64B64A64_SFLOAT");
            return;
        case VK_FORMAT_R16G16_SNORM:
            *out += std::string("VK_FORMAT_R16G16_SNORM");
            return;
        case VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
            *out += std::string("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_R12X4G12X4_UNORM_2PACK16:
            *out += std::string("VK_FORMAT_R12X4G12X4_UNORM_2PACK16");
            return;
        case VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_8x6_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_8x6_SRGB_BLOCK");
            return;
        case VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_12x10_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_12x10_SRGB_BLOCK");
            return;
        case VK_FORMAT_EAC_R11G11_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_EAC_R11G11_UNORM_BLOCK");
            return;
        case VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_BC2_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_BC2_SRGB_BLOCK");
            return;
        case VK_FORMAT_R16G16_SSCALED:
            *out += std::string("VK_FORMAT_R16G16_SSCALED");
            return;
        case VK_FORMAT_R16G16B16_UNORM:
            *out += std::string("VK_FORMAT_R16G16B16_UNORM");
            return;
        case VK_FORMAT_R16G16B16_SINT:
            *out += std::string("VK_FORMAT_R16G16B16_SINT");
            return;
        case VK_FORMAT_R10X6_UNORM_PACK16:
            *out += std::string("VK_FORMAT_R10X6_UNORM_PACK16");
            return;
        case VK_FORMAT_R32_SINT:
            *out += std::string("VK_FORMAT_R32_SINT");
            return;
        case VK_FORMAT_R8G8B8A8_SINT:
            *out += std::string("VK_FORMAT_R8G8B8A8_SINT");
            return;
        case VK_FORMAT_R16G16B16A16_USCALED:
            *out += std::string("VK_FORMAT_R16G16B16A16_USCALED");
            return;
        case VK_FORMAT_R64_UINT:
            *out += std::string("VK_FORMAT_R64_UINT");
            return;
        case VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK");
            return;
        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16");
            return;
        case VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_ASTC_10x5_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_10x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_B8G8R8A8_SNORM:
            *out += std::string("VK_FORMAT_B8G8R8A8_SNORM");
            return;
        case VK_FORMAT_R4G4_UNORM_PACK8:
            *out += std::string("VK_FORMAT_R4G4_UNORM_PACK8");
            return;
        case VK_FORMAT_BC7_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_BC7_SRGB_BLOCK");
            return;
        case VK_FORMAT_R8_UINT:
            *out += std::string("VK_FORMAT_R8_UINT");
            return;
        case VK_FORMAT_B8G8R8G8_422_UNORM:
            *out += std::string("VK_FORMAT_B8G8R8G8_422_UNORM");
            return;
        case VK_FORMAT_A2R10G10B10_UINT_PACK32:
            *out += std::string("VK_FORMAT_A2R10G10B10_UINT_PACK32");
            return;
        case VK_FORMAT_R8G8_USCALED:
            *out += std::string("VK_FORMAT_R8G8_USCALED");
            return;
        case VK_FORMAT_ASTC_8x5_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_8x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG:
            *out += std::string("VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R8G8_SRGB:
            *out += std::string("VK_FORMAT_R8G8_SRGB");
            return;
        case VK_FORMAT_R32G32B32A32_SFLOAT:
            *out += std::string("VK_FORMAT_R32G32B32A32_SFLOAT");
            return;
        case VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
            *out += std::string("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_A8B8G8R8_USCALED_PACK32:
            *out += std::string("VK_FORMAT_A8B8G8R8_USCALED_PACK32");
            return;
        case VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R32G32B32_SINT:
            *out += std::string("VK_FORMAT_R32G32B32_SINT");
            return;
        case VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK");
            return;
        case VK_FORMAT_R16_USCALED:
            *out += std::string("VK_FORMAT_R16_USCALED");
            return;
        case VK_FORMAT_B8G8R8A8_UINT:
            *out += std::string("VK_FORMAT_B8G8R8A8_UINT");
            return;
        case VK_FORMAT_A8B8G8R8_SNORM_PACK32:
            *out += std::string("VK_FORMAT_A8B8G8R8_SNORM_PACK32");
            return;
        case VK_FORMAT_R16G16B16_SNORM:
            *out += std::string("VK_FORMAT_R16G16B16_SNORM");
            return;
        case VK_FORMAT_D16_UNORM:
            *out += std::string("VK_FORMAT_D16_UNORM");
            return;
        case VK_FORMAT_R64_SFLOAT:
            *out += std::string("VK_FORMAT_R64_SFLOAT");
            return;
        case VK_FORMAT_ASTC_5x5_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_5x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_R64G64_SINT:
            *out += std::string("VK_FORMAT_R64G64_SINT");
            return;
        case VK_FORMAT_R8_SSCALED:
            *out += std::string("VK_FORMAT_R8_SSCALED");
            return;
        case VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:
            *out += std::string("VK_FORMAT_E5B9G9R9_UFLOAT_PACK32");
            return;
        case VK_FORMAT_R16G16_SFLOAT:
            *out += std::string("VK_FORMAT_R16G16_SFLOAT");
            return;
        case VK_FORMAT_BC4_SNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC4_SNORM_BLOCK");
            return;
        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_R8G8B8_USCALED:
            *out += std::string("VK_FORMAT_R8G8B8_USCALED");
            return;
        case VK_FORMAT_R16G16B16A16_SINT:
            *out += std::string("VK_FORMAT_R16G16B16A16_SINT");
            return;
        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_R8_USCALED:
            *out += std::string("VK_FORMAT_R8_USCALED");
            return;
        case VK_FORMAT_G8B8G8R8_422_UNORM:
            *out += std::string("VK_FORMAT_G8B8G8R8_422_UNORM");
            return;
        case VK_FORMAT_ASTC_4x4_SRGB_BLOCK:
            *out += std::string("VK_FORMAT_ASTC_4x4_SRGB_BLOCK");
            return;
        case VK_FORMAT_R8_SRGB:
            *out += std::string("VK_FORMAT_R8_SRGB");
            return;
        case VK_FORMAT_A2R10G10B10_SNORM_PACK32:
            *out += std::string("VK_FORMAT_A2R10G10B10_SNORM_PACK32");
            return;
        case VK_FORMAT_A2B10G10R10_USCALED_PACK32:
            *out += std::string("VK_FORMAT_A2B10G10R10_USCALED_PACK32");
            return;
        case VK_FORMAT_R16_UNORM:
            *out += std::string("VK_FORMAT_R16_UNORM");
            return;
        case VK_FORMAT_R64G64B64_SINT:
            *out += std::string("VK_FORMAT_R64G64B64_SINT");
            return;
        case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16");
            return;
        case VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT:
            *out += std::string("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_B8G8R8_UINT:
            *out += std::string("VK_FORMAT_B8G8R8_UINT");
            return;
        case VK_FORMAT_R8_SNORM:
            *out += std::string("VK_FORMAT_R8_SNORM");
            return;
        case VK_FORMAT_A2B10G10R10_SINT_PACK32:
            *out += std::string("VK_FORMAT_A2B10G10R10_SINT_PACK32");
            return;
        case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
            *out += std::string("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_R8G8B8_SRGB:
            *out += std::string("VK_FORMAT_R8G8B8_SRGB");
            return;
        case VK_FORMAT_B8G8R8_SRGB:
            *out += std::string("VK_FORMAT_B8G8R8_SRGB");
            return;
        case VK_FORMAT_BC7_UNORM_BLOCK:
            *out += std::string("VK_FORMAT_BC7_UNORM_BLOCK");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPipelineStageFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkPipelineStageFlagBits e = static_cast<VkPipelineStageFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PIPELINE_STAGE_VERTEX_INPUT_BIT:
            *out += std::string("VK_PIPELINE_STAGE_VERTEX_INPUT_BIT");
            return;
        case VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT:
            *out += std::string("VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT");
            return;
        case VK_PIPELINE_STAGE_VERTEX_SHADER_BIT:
            *out += std::string("VK_PIPELINE_STAGE_VERTEX_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV:
            *out += std::string("VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT:
            *out += std::string("VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT");
            return;
        case VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT:
            *out += std::string("VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT");
            return;
        case VK_PIPELINE_STAGE_TRANSFER_BIT:
            *out += std::string("VK_PIPELINE_STAGE_TRANSFER_BIT");
            return;
        case VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV:
            *out += std::string("VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT:
            *out += std::string("VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_HOST_BIT:
            *out += std::string("VK_PIPELINE_STAGE_HOST_BIT");
            return;
        case VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT:
            *out += std::string("VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT");
            return;
        case VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT:
            *out += std::string("VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT:
            *out += std::string("VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT");
            return;
        case VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT:
            *out += std::string("VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT");
            return;
        case VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX:
            *out += std::string("VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX");
            return;
        case VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT:
            *out += std::string("VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT:
            *out += std::string("VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT:
            *out += std::string("VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT:
            *out += std::string("VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT");
            return;
        case VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT:
            *out += std::string("VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT");
            return;
        case VK_PIPELINE_STAGE_ALL_COMMANDS_BIT:
            *out += std::string("VK_PIPELINE_STAGE_ALL_COMMANDS_BIT");
            return;
        case VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV:
            *out += std::string("VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT:
            *out += std::string("VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT");
            return;
        case VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT:
            *out += std::string("VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT");
            return;
        case VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV:
            *out += std::string("VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV:
            *out += std::string("VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCullModeFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkCullModeFlagBits e = static_cast<VkCullModeFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_CULL_MODE_FRONT_AND_BACK:
            *out += std::string("VK_CULL_MODE_FRONT_AND_BACK");
            return;
        case VK_CULL_MODE_BACK_BIT:
            *out += std::string("VK_CULL_MODE_BACK_BIT");
            return;
        case VK_CULL_MODE_FRONT_BIT:
            *out += std::string("VK_CULL_MODE_FRONT_BIT");
            return;
        case VK_CULL_MODE_NONE:
            *out += std::string("VK_CULL_MODE_NONE");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkStencilFaceFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkStencilFaceFlagBits e = static_cast<VkStencilFaceFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_STENCIL_FACE_FRONT_AND_BACK:
            *out += std::string("VK_STENCIL_FACE_FRONT_AND_BACK");
            return;
        case VK_STENCIL_FACE_FRONT_BIT:
            *out += std::string("VK_STENCIL_FACE_FRONT_BIT");
            return;
        case VK_STENCIL_FACE_BACK_BIT:
            *out += std::string("VK_STENCIL_FACE_BACK_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkImageLayout(std::string* out, uint32_t enum_uint32)
{
    VkImageLayout e = static_cast<VkImageLayout>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV:
            *out += std::string("VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV");
            return;
        case VK_IMAGE_LAYOUT_PREINITIALIZED:
            *out += std::string("VK_IMAGE_LAYOUT_PREINITIALIZED");
            return;
        case VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR:
            *out += std::string("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR");
            return;
        case VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT:
            *out += std::string("VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT");
            return;
        case VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:
            *out += std::string("VK_IMAGE_LAYOUT_PRESENT_SRC_KHR");
            return;
        case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:
            *out += std::string("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_UNDEFINED:
            *out += std::string("VK_IMAGE_LAYOUT_UNDEFINED");
            return;
        case VK_IMAGE_LAYOUT_GENERAL:
            *out += std::string("VK_IMAGE_LAYOUT_GENERAL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkAccessFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkAccessFlagBits e = static_cast<VkAccessFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_ACCESS_COLOR_ATTACHMENT_READ_BIT:
            *out += std::string("VK_ACCESS_COLOR_ATTACHMENT_READ_BIT");
            return;
        case VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT:
            *out += std::string("VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT");
            return;
        case VK_ACCESS_TRANSFER_WRITE_BIT:
            *out += std::string("VK_ACCESS_TRANSFER_WRITE_BIT");
            return;
        case VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT:
            *out += std::string("VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT");
            return;
        case VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV:
            *out += std::string("VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV");
            return;
        case VK_ACCESS_HOST_WRITE_BIT:
            *out += std::string("VK_ACCESS_HOST_WRITE_BIT");
            return;
        case VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT:
            *out += std::string("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT");
            return;
        case VK_ACCESS_MEMORY_READ_BIT:
            *out += std::string("VK_ACCESS_MEMORY_READ_BIT");
            return;
        case VK_ACCESS_SHADER_READ_BIT:
            *out += std::string("VK_ACCESS_SHADER_READ_BIT");
            return;
        case VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT:
            *out += std::string("VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT");
            return;
        case VK_ACCESS_UNIFORM_READ_BIT:
            *out += std::string("VK_ACCESS_UNIFORM_READ_BIT");
            return;
        case VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT:
            *out += std::string("VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT");
            return;
        case VK_ACCESS_SHADER_WRITE_BIT:
            *out += std::string("VK_ACCESS_SHADER_WRITE_BIT");
            return;
        case VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT:
            *out += std::string("VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT");
            return;
        case VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT:
            *out += std::string("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT");
            return;
        case VK_ACCESS_HOST_READ_BIT:
            *out += std::string("VK_ACCESS_HOST_READ_BIT");
            return;
        case VK_ACCESS_MEMORY_WRITE_BIT:
            *out += std::string("VK_ACCESS_MEMORY_WRITE_BIT");
            return;
        case VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT:
            *out += std::string("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT");
            return;
        case VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX:
            *out += std::string("VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX");
            return;
        case VK_ACCESS_TRANSFER_READ_BIT:
            *out += std::string("VK_ACCESS_TRANSFER_READ_BIT");
            return;
        case VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT:
            *out += std::string("VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT");
            return;
        case VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV:
            *out += std::string("VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV");
            return;
        case VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX:
            *out += std::string("VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX");
            return;
        case VK_ACCESS_INDIRECT_COMMAND_READ_BIT:
            *out += std::string("VK_ACCESS_INDIRECT_COMMAND_READ_BIT");
            return;
        case VK_ACCESS_INPUT_ATTACHMENT_READ_BIT:
            *out += std::string("VK_ACCESS_INPUT_ATTACHMENT_READ_BIT");
            return;
        case VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV:
            *out += std::string("VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV");
            return;
        case VK_ACCESS_INDEX_READ_BIT:
            *out += std::string("VK_ACCESS_INDEX_READ_BIT");
            return;
        case VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT:
            *out += std::string("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCommandBufferResetFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkCommandBufferResetFlagBits e = static_cast<VkCommandBufferResetFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT:
            *out += std::string("VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCommandBufferUsageFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkCommandBufferUsageFlagBits e = static_cast<VkCommandBufferUsageFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:
            *out += std::string("VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT");
            return;
        case VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT:
            *out += std::string("VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT");
            return;
        case VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:
            *out += std::string("VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPhysicalDeviceType(std::string* out, uint32_t enum_uint32)
{
    VkPhysicalDeviceType e = static_cast<VkPhysicalDeviceType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
            *out += std::string("VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_OTHER:
            *out += std::string("VK_PHYSICAL_DEVICE_TYPE_OTHER");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
            *out += std::string("VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
            *out += std::string("VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_CPU:
            *out += std::string("VK_PHYSICAL_DEVICE_TYPE_CPU");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkApplicationInfo>(std::string* out, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkInstanceCreateInfo>(std::string* out, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAllocationCallbacks>(std::string* out, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceFeatures>(std::string* out, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFormatProperties>(std::string* out, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExtent3D>(std::string* out, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageFormatProperties>(std::string* out, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceLimits>(std::string* out, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSparseProperties>(std::string* out, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProperties>(std::string* out, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueueFamilyProperties>(std::string* out, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryType>(std::string* out, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryHeap>(std::string* out, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceQueueCreateInfo>(std::string* out, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExtensionProperties>(std::string* out, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkLayerProperties>(std::string* out, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubmitInfo>(std::string* out, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryAllocateInfo>(std::string* out, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMappedMemoryRange>(std::string* out, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryRequirements>(std::string* out, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageFormatProperties>(std::string* out, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryRequirements>(std::string* out, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseMemoryBind>(std::string* out, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseBufferMemoryBindInfo>(std::string* out, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSubresource>(std::string* out, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkOffset3D>(std::string* out, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryBind>(std::string* out, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindSparseInfo>(std::string* out, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFenceCreateInfo>(std::string* out, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreCreateInfo>(std::string* out, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkEventCreateInfo>(std::string* out, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueryPoolCreateInfo>(std::string* out, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferCreateInfo>(std::string* out, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferViewCreateInfo>(std::string* out, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageCreateInfo>(std::string* out, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubresourceLayout>(std::string* out, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkComponentMapping>(std::string* out, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSubresourceRange>(std::string* out, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageViewCreateInfo>(std::string* out, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkShaderModuleCreateInfo>(std::string* out, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineCacheCreateInfo>(std::string* out, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSpecializationMapEntry>(std::string* out, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSpecializationInfo>(std::string* out, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineShaderStageCreateInfo>(std::string* out, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkVertexInputBindingDescription>(std::string* out, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkVertexInputAttributeDescription>(std::string* out, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(std::string* out, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(std::string* out, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineTessellationStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkViewport>(std::string* out, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkOffset2D>(std::string* out, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExtent2D>(std::string* out, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRect2D>(std::string* out, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportStateCreateInfo>(std::string* out, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(std::string* out, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(std::string* out, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkStencilOpState>(std::string* out, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(std::string* out, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineColorBlendAttachmentState>(std::string* out, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(std::string* out, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineDynamicStateCreateInfo>(std::string* out, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGraphicsPipelineCreateInfo>(std::string* out, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkComputePipelineCreateInfo>(std::string* out, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPushConstantRange>(std::string* out, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineLayoutCreateInfo>(std::string* out, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerCreateInfo>(std::string* out, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetLayoutBinding>(std::string* out, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(std::string* out, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorPoolSize>(std::string* out, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorPoolCreateInfo>(std::string* out, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetAllocateInfo>(std::string* out, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorImageInfo>(std::string* out, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorBufferInfo>(std::string* out, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkWriteDescriptorSet>(std::string* out, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCopyDescriptorSet>(std::string* out, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFramebufferCreateInfo>(std::string* out, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentDescription>(std::string* out, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentReference>(std::string* out, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDescription>(std::string* out, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDependency>(std::string* out, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassCreateInfo>(std::string* out, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandPoolCreateInfo>(std::string* out, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferAllocateInfo>(std::string* out, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferInheritanceInfo>(std::string* out, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferBeginInfo>(std::string* out, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferCopy>(std::string* out, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSubresourceLayers>(std::string* out, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageCopy>(std::string* out, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageBlit>(std::string* out, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferImageCopy>(std::string* out, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearColorValue>(std::string* out, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearDepthStencilValue>(std::string* out, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearValue>(std::string* out, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearAttachment>(std::string* out, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkClearRect>(std::string* out, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageResolve>(std::string* out, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryBarrier>(std::string* out, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferMemoryBarrier>(std::string* out, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageMemoryBarrier>(std::string* out, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassBeginInfo>(std::string* out, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDispatchIndirectCommand>(std::string* out, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrawIndexedIndirectCommand>(std::string* out, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrawIndirectCommand>(std::string* out, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkApplicationInfo>(std::string* out, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkApplicationInfo *pstruct = (const VkApplicationInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // const char* pApplicationName // SMB
    IndentSpaces(out, indent);
    *out += "pApplicationName:               ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pApplicationName); // TGH
    *out += "\n"; // GDS

    // uint32_t applicationVersion // SMB
    IndentSpaces(out, indent);
    *out += "applicationVersion:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->applicationVersion);
    *out += "\n"; // GDS

    // const char* pEngineName // SMB
    IndentSpaces(out, indent);
    *out += "pEngineName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pEngineName); // TGH
    *out += "\n"; // GDS

    // uint32_t engineVersion // SMB
    IndentSpaces(out, indent);
    *out += "engineVersion:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->engineVersion);
    *out += "\n"; // GDS

    // uint32_t apiVersion // SMB
    IndentSpaces(out, indent);
    *out += "apiVersion:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->apiVersion);
}

template <>
void StructureToString<Decoded_VkInstanceCreateInfo>(std::string* out, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkInstanceCreateInfo *pstruct = (const VkInstanceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkInstanceCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkInstanceCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // const VkApplicationInfo* pApplicationInfo // SMB
    IndentSpaces(out, indent);
    *out += "pApplicationInfo:               ";
    *out += "const VkApplicationInfo* = "; // TEQ
    if (pstruct->pApplicationInfo == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pApplicationInfo->GetAddress()); // JHI
        StructureToString<Decoded_VkApplicationInfo>(out, *pstruct_in.pApplicationInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkInstanceCreateInfo, pApplicationInfo)); // GLM
    }
    *out += "\n"; // GDS

    // uint32_t enabledLayerCount // SMB
    IndentSpaces(out, indent);
    *out += "enabledLayerCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledLayerCount);
    *out += "\n"; // GDS

    // const char* const* ppEnabledLayerNames // SMB
    IndentSpaces(out, indent);
    *out += "ppEnabledLayerNames:            ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledLayerNames == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledLayerNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pstruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t enabledExtensionCount // SMB
    IndentSpaces(out, indent);
    *out += "enabledExtensionCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledExtensionCount);
    *out += "\n"; // GDS

    // const char* const* ppEnabledExtensionNames // SMB
    IndentSpaces(out, indent);
    *out += "ppEnabledExtensionNames:        ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledExtensionNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pstruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkAllocationCallbacks>(std::string* out, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAllocationCallbacks *pstruct = (const VkAllocationCallbacks *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // void* pUserData // SMB
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
    *out += "\n"; // GDS

    // PFN_vkAllocationFunction pfnAllocation // SMB
    IndentSpaces(out, indent);
    *out += "pfnAllocation:                  ";
    *out += "PFN_vkAllocationFunction = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnAllocation)); // WRX
    *out += "\n"; // GDS

    // PFN_vkReallocationFunction pfnReallocation // SMB
    IndentSpaces(out, indent);
    *out += "pfnReallocation:                ";
    *out += "PFN_vkReallocationFunction = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnReallocation)); // WRX
    *out += "\n"; // GDS

    // PFN_vkFreeFunction pfnFree // SMB
    IndentSpaces(out, indent);
    *out += "pfnFree:                        ";
    *out += "PFN_vkFreeFunction = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnFree)); // WRX
    *out += "\n"; // GDS

    // PFN_vkInternalAllocationNotification pfnInternalAllocation // SMB
    IndentSpaces(out, indent);
    *out += "pfnInternalAllocation:          ";
    *out += "PFN_vkInternalAllocationNotification = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnInternalAllocation)); // WRX
    *out += "\n"; // GDS

    // PFN_vkInternalFreeNotification pfnInternalFree // SMB
    IndentSpaces(out, indent);
    *out += "pfnInternalFree:                ";
    *out += "PFN_vkInternalFreeNotification = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnInternalFree)); // WRX
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceFeatures>(std::string* out, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceFeatures *pstruct = (const VkPhysicalDeviceFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkBool32 robustBufferAccess // SMB
    IndentSpaces(out, indent);
    *out += "robustBufferAccess:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->robustBufferAccess);
    *out += "\n"; // GDS

    // VkBool32 fullDrawIndexUint32 // SMB
    IndentSpaces(out, indent);
    *out += "fullDrawIndexUint32:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fullDrawIndexUint32);
    *out += "\n"; // GDS

    // VkBool32 imageCubeArray // SMB
    IndentSpaces(out, indent);
    *out += "imageCubeArray:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->imageCubeArray);
    *out += "\n"; // GDS

    // VkBool32 independentBlend // SMB
    IndentSpaces(out, indent);
    *out += "independentBlend:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->independentBlend);
    *out += "\n"; // GDS

    // VkBool32 geometryShader // SMB
    IndentSpaces(out, indent);
    *out += "geometryShader:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->geometryShader);
    *out += "\n"; // GDS

    // VkBool32 tessellationShader // SMB
    IndentSpaces(out, indent);
    *out += "tessellationShader:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->tessellationShader);
    *out += "\n"; // GDS

    // VkBool32 sampleRateShading // SMB
    IndentSpaces(out, indent);
    *out += "sampleRateShading:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sampleRateShading);
    *out += "\n"; // GDS

    // VkBool32 dualSrcBlend // SMB
    IndentSpaces(out, indent);
    *out += "dualSrcBlend:                   ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->dualSrcBlend);
    *out += "\n"; // GDS

    // VkBool32 logicOp // SMB
    IndentSpaces(out, indent);
    *out += "logicOp:                        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->logicOp);
    *out += "\n"; // GDS

    // VkBool32 multiDrawIndirect // SMB
    IndentSpaces(out, indent);
    *out += "multiDrawIndirect:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiDrawIndirect);
    *out += "\n"; // GDS

    // VkBool32 drawIndirectFirstInstance // SMB
    IndentSpaces(out, indent);
    *out += "drawIndirectFirstInstance:      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->drawIndirectFirstInstance);
    *out += "\n"; // GDS

    // VkBool32 depthClamp // SMB
    IndentSpaces(out, indent);
    *out += "depthClamp:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthClamp);
    *out += "\n"; // GDS

    // VkBool32 depthBiasClamp // SMB
    IndentSpaces(out, indent);
    *out += "depthBiasClamp:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBiasClamp);
    *out += "\n"; // GDS

    // VkBool32 fillModeNonSolid // SMB
    IndentSpaces(out, indent);
    *out += "fillModeNonSolid:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fillModeNonSolid);
    *out += "\n"; // GDS

    // VkBool32 depthBounds // SMB
    IndentSpaces(out, indent);
    *out += "depthBounds:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBounds);
    *out += "\n"; // GDS

    // VkBool32 wideLines // SMB
    IndentSpaces(out, indent);
    *out += "wideLines:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->wideLines);
    *out += "\n"; // GDS

    // VkBool32 largePoints // SMB
    IndentSpaces(out, indent);
    *out += "largePoints:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->largePoints);
    *out += "\n"; // GDS

    // VkBool32 alphaToOne // SMB
    IndentSpaces(out, indent);
    *out += "alphaToOne:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->alphaToOne);
    *out += "\n"; // GDS

    // VkBool32 multiViewport // SMB
    IndentSpaces(out, indent);
    *out += "multiViewport:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiViewport);
    *out += "\n"; // GDS

    // VkBool32 samplerAnisotropy // SMB
    IndentSpaces(out, indent);
    *out += "samplerAnisotropy:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->samplerAnisotropy);
    *out += "\n"; // GDS

    // VkBool32 textureCompressionETC2 // SMB
    IndentSpaces(out, indent);
    *out += "textureCompressionETC2:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->textureCompressionETC2);
    *out += "\n"; // GDS

    // VkBool32 textureCompressionASTC_LDR // SMB
    IndentSpaces(out, indent);
    *out += "textureCompressionASTC_LDR:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->textureCompressionASTC_LDR);
    *out += "\n"; // GDS

    // VkBool32 textureCompressionBC // SMB
    IndentSpaces(out, indent);
    *out += "textureCompressionBC:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->textureCompressionBC);
    *out += "\n"; // GDS

    // VkBool32 occlusionQueryPrecise // SMB
    IndentSpaces(out, indent);
    *out += "occlusionQueryPrecise:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->occlusionQueryPrecise);
    *out += "\n"; // GDS

    // VkBool32 pipelineStatisticsQuery // SMB
    IndentSpaces(out, indent);
    *out += "pipelineStatisticsQuery:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->pipelineStatisticsQuery);
    *out += "\n"; // GDS

    // VkBool32 vertexPipelineStoresAndAtomics // SMB
    IndentSpaces(out, indent);
    *out += "vertexPipelineStoresAndAtomics: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexPipelineStoresAndAtomics);
    *out += "\n"; // GDS

    // VkBool32 fragmentStoresAndAtomics // SMB
    IndentSpaces(out, indent);
    *out += "fragmentStoresAndAtomics:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fragmentStoresAndAtomics);
    *out += "\n"; // GDS

    // VkBool32 shaderTessellationAndGeometryPointSize // SMB
    IndentSpaces(out, indent);
    *out += "shaderTessellationAndGeometryPointSize: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderTessellationAndGeometryPointSize);
    *out += "\n"; // GDS

    // VkBool32 shaderImageGatherExtended // SMB
    IndentSpaces(out, indent);
    *out += "shaderImageGatherExtended:      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderImageGatherExtended);
    *out += "\n"; // GDS

    // VkBool32 shaderStorageImageExtendedFormats // SMB
    IndentSpaces(out, indent);
    *out += "shaderStorageImageExtendedFormats: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageExtendedFormats);
    *out += "\n"; // GDS

    // VkBool32 shaderStorageImageMultisample // SMB
    IndentSpaces(out, indent);
    *out += "shaderStorageImageMultisample:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageMultisample);
    *out += "\n"; // GDS

    // VkBool32 shaderStorageImageReadWithoutFormat // SMB
    IndentSpaces(out, indent);
    *out += "shaderStorageImageReadWithoutFormat: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageReadWithoutFormat);
    *out += "\n"; // GDS

    // VkBool32 shaderStorageImageWriteWithoutFormat // SMB
    IndentSpaces(out, indent);
    *out += "shaderStorageImageWriteWithoutFormat: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageWriteWithoutFormat);
    *out += "\n"; // GDS

    // VkBool32 shaderUniformBufferArrayDynamicIndexing // SMB
    IndentSpaces(out, indent);
    *out += "shaderUniformBufferArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderUniformBufferArrayDynamicIndexing);
    *out += "\n"; // GDS

    // VkBool32 shaderSampledImageArrayDynamicIndexing // SMB
    IndentSpaces(out, indent);
    *out += "shaderSampledImageArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderSampledImageArrayDynamicIndexing);
    *out += "\n"; // GDS

    // VkBool32 shaderStorageBufferArrayDynamicIndexing // SMB
    IndentSpaces(out, indent);
    *out += "shaderStorageBufferArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageBufferArrayDynamicIndexing);
    *out += "\n"; // GDS

    // VkBool32 shaderStorageImageArrayDynamicIndexing // SMB
    IndentSpaces(out, indent);
    *out += "shaderStorageImageArrayDynamicIndexing: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderStorageImageArrayDynamicIndexing);
    *out += "\n"; // GDS

    // VkBool32 shaderClipDistance // SMB
    IndentSpaces(out, indent);
    *out += "shaderClipDistance:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderClipDistance);
    *out += "\n"; // GDS

    // VkBool32 shaderCullDistance // SMB
    IndentSpaces(out, indent);
    *out += "shaderCullDistance:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderCullDistance);
    *out += "\n"; // GDS

    // VkBool32 shaderFloat64 // SMB
    IndentSpaces(out, indent);
    *out += "shaderFloat64:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderFloat64);
    *out += "\n"; // GDS

    // VkBool32 shaderInt64 // SMB
    IndentSpaces(out, indent);
    *out += "shaderInt64:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderInt64);
    *out += "\n"; // GDS

    // VkBool32 shaderInt16 // SMB
    IndentSpaces(out, indent);
    *out += "shaderInt16:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderInt16);
    *out += "\n"; // GDS

    // VkBool32 shaderResourceResidency // SMB
    IndentSpaces(out, indent);
    *out += "shaderResourceResidency:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderResourceResidency);
    *out += "\n"; // GDS

    // VkBool32 shaderResourceMinLod // SMB
    IndentSpaces(out, indent);
    *out += "shaderResourceMinLod:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderResourceMinLod);
    *out += "\n"; // GDS

    // VkBool32 sparseBinding // SMB
    IndentSpaces(out, indent);
    *out += "sparseBinding:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseBinding);
    *out += "\n"; // GDS

    // VkBool32 sparseResidencyBuffer // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidencyBuffer:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyBuffer);
    *out += "\n"; // GDS

    // VkBool32 sparseResidencyImage2D // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidencyImage2D:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyImage2D);
    *out += "\n"; // GDS

    // VkBool32 sparseResidencyImage3D // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidencyImage3D:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyImage3D);
    *out += "\n"; // GDS

    // VkBool32 sparseResidency2Samples // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidency2Samples:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency2Samples);
    *out += "\n"; // GDS

    // VkBool32 sparseResidency4Samples // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidency4Samples:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency4Samples);
    *out += "\n"; // GDS

    // VkBool32 sparseResidency8Samples // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidency8Samples:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency8Samples);
    *out += "\n"; // GDS

    // VkBool32 sparseResidency16Samples // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidency16Samples:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidency16Samples);
    *out += "\n"; // GDS

    // VkBool32 sparseResidencyAliased // SMB
    IndentSpaces(out, indent);
    *out += "sparseResidencyAliased:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseResidencyAliased);
    *out += "\n"; // GDS

    // VkBool32 variableMultisampleRate // SMB
    IndentSpaces(out, indent);
    *out += "variableMultisampleRate:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variableMultisampleRate);
    *out += "\n"; // GDS

    // VkBool32 inheritedQueries // SMB
    IndentSpaces(out, indent);
    *out += "inheritedQueries:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->inheritedQueries);
}

template <>
void StructureToString<Decoded_VkFormatProperties>(std::string* out, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFormatProperties *pstruct = (const VkFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkFormatFeatureFlags linearTilingFeatures // SMB
    IndentSpaces(out, indent);
    *out += "linearTilingFeatures:           ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->linearTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // VkFormatFeatureFlags optimalTilingFeatures // SMB
    IndentSpaces(out, indent);
    *out += "optimalTilingFeatures:          ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->optimalTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // VkFormatFeatureFlags bufferFeatures // SMB
    IndentSpaces(out, indent);
    *out += "bufferFeatures:                 ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->bufferFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkExtent3D>(std::string* out, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExtent3D *pstruct = (const VkExtent3D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t width // SMB
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->width);
    *out += "\n"; // GDS

    // uint32_t height // SMB
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->height);
    *out += "\n"; // GDS

    // uint32_t depth // SMB
    IndentSpaces(out, indent);
    *out += "depth:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->depth);
}

template <>
void StructureToString<Decoded_VkImageFormatProperties>(std::string* out, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageFormatProperties *pstruct = (const VkImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkExtent3D maxExtent // SMB
    IndentSpaces(out, indent);
    *out += "maxExtent:                      ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.maxExtent, indent+1,  base_addr + offsetof(VkImageFormatProperties, maxExtent)); // AZJ
    *out += "\n"; // GDS

    // uint32_t maxMipLevels // SMB
    IndentSpaces(out, indent);
    *out += "maxMipLevels:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMipLevels);
    *out += "\n"; // GDS

    // uint32_t maxArrayLayers // SMB
    IndentSpaces(out, indent);
    *out += "maxArrayLayers:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxArrayLayers);
    *out += "\n"; // GDS

    // VkSampleCountFlags sampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "sampleCounts:                   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkDeviceSize maxResourceSize // SMB
    IndentSpaces(out, indent);
    *out += "maxResourceSize:                ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->maxResourceSize);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceLimits>(std::string* out, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceLimits *pstruct = (const VkPhysicalDeviceLimits *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t maxImageDimension1D // SMB
    IndentSpaces(out, indent);
    *out += "maxImageDimension1D:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimension1D);
    *out += "\n"; // GDS

    // uint32_t maxImageDimension2D // SMB
    IndentSpaces(out, indent);
    *out += "maxImageDimension2D:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimension2D);
    *out += "\n"; // GDS

    // uint32_t maxImageDimension3D // SMB
    IndentSpaces(out, indent);
    *out += "maxImageDimension3D:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimension3D);
    *out += "\n"; // GDS

    // uint32_t maxImageDimensionCube // SMB
    IndentSpaces(out, indent);
    *out += "maxImageDimensionCube:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageDimensionCube);
    *out += "\n"; // GDS

    // uint32_t maxImageArrayLayers // SMB
    IndentSpaces(out, indent);
    *out += "maxImageArrayLayers:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageArrayLayers);
    *out += "\n"; // GDS

    // uint32_t maxTexelBufferElements // SMB
    IndentSpaces(out, indent);
    *out += "maxTexelBufferElements:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTexelBufferElements);
    *out += "\n"; // GDS

    // uint32_t maxUniformBufferRange // SMB
    IndentSpaces(out, indent);
    *out += "maxUniformBufferRange:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxUniformBufferRange);
    *out += "\n"; // GDS

    // uint32_t maxStorageBufferRange // SMB
    IndentSpaces(out, indent);
    *out += "maxStorageBufferRange:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxStorageBufferRange);
    *out += "\n"; // GDS

    // uint32_t maxPushConstantsSize // SMB
    IndentSpaces(out, indent);
    *out += "maxPushConstantsSize:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPushConstantsSize);
    *out += "\n"; // GDS

    // uint32_t maxMemoryAllocationCount // SMB
    IndentSpaces(out, indent);
    *out += "maxMemoryAllocationCount:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMemoryAllocationCount);
    *out += "\n"; // GDS

    // uint32_t maxSamplerAllocationCount // SMB
    IndentSpaces(out, indent);
    *out += "maxSamplerAllocationCount:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSamplerAllocationCount);
    *out += "\n"; // GDS

    // VkDeviceSize bufferImageGranularity // SMB
    IndentSpaces(out, indent);
    *out += "bufferImageGranularity:         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferImageGranularity);
    *out += "\n"; // GDS

    // VkDeviceSize sparseAddressSpaceSize // SMB
    IndentSpaces(out, indent);
    *out += "sparseAddressSpaceSize:         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->sparseAddressSpaceSize);
    *out += "\n"; // GDS

    // uint32_t maxBoundDescriptorSets // SMB
    IndentSpaces(out, indent);
    *out += "maxBoundDescriptorSets:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxBoundDescriptorSets);
    *out += "\n"; // GDS

    // uint32_t maxPerStageDescriptorSamplers // SMB
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorSamplers:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorSamplers);
    *out += "\n"; // GDS

    // uint32_t maxPerStageDescriptorUniformBuffers // SMB
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorUniformBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorUniformBuffers);
    *out += "\n"; // GDS

    // uint32_t maxPerStageDescriptorStorageBuffers // SMB
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorStorageBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorStorageBuffers);
    *out += "\n"; // GDS

    // uint32_t maxPerStageDescriptorSampledImages // SMB
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorSampledImages: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorSampledImages);
    *out += "\n"; // GDS

    // uint32_t maxPerStageDescriptorStorageImages // SMB
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorStorageImages: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorStorageImages);
    *out += "\n"; // GDS

    // uint32_t maxPerStageDescriptorInputAttachments // SMB
    IndentSpaces(out, indent);
    *out += "maxPerStageDescriptorInputAttachments: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageDescriptorInputAttachments);
    *out += "\n"; // GDS

    // uint32_t maxPerStageResources // SMB
    IndentSpaces(out, indent);
    *out += "maxPerStageResources:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerStageResources);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetSamplers // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetSamplers:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetSamplers);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetUniformBuffers // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetUniformBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetUniformBuffers);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetUniformBuffersDynamic // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetUniformBuffersDynamic: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetUniformBuffersDynamic);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetStorageBuffers // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetStorageBuffers: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetStorageBuffers);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetStorageBuffersDynamic // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetStorageBuffersDynamic: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetStorageBuffersDynamic);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetSampledImages // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetSampledImages:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetSampledImages);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetStorageImages // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetStorageImages:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetStorageImages);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetInputAttachments // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetInputAttachments: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetInputAttachments);
    *out += "\n"; // GDS

    // uint32_t maxVertexInputAttributes // SMB
    IndentSpaces(out, indent);
    *out += "maxVertexInputAttributes:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputAttributes);
    *out += "\n"; // GDS

    // uint32_t maxVertexInputBindings // SMB
    IndentSpaces(out, indent);
    *out += "maxVertexInputBindings:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputBindings);
    *out += "\n"; // GDS

    // uint32_t maxVertexInputAttributeOffset // SMB
    IndentSpaces(out, indent);
    *out += "maxVertexInputAttributeOffset:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputAttributeOffset);
    *out += "\n"; // GDS

    // uint32_t maxVertexInputBindingStride // SMB
    IndentSpaces(out, indent);
    *out += "maxVertexInputBindingStride:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexInputBindingStride);
    *out += "\n"; // GDS

    // uint32_t maxVertexOutputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxVertexOutputComponents:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxVertexOutputComponents);
    *out += "\n"; // GDS

    // uint32_t maxTessellationGenerationLevel // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationGenerationLevel: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationGenerationLevel);
    *out += "\n"; // GDS

    // uint32_t maxTessellationPatchSize // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationPatchSize:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationPatchSize);
    *out += "\n"; // GDS

    // uint32_t maxTessellationControlPerVertexInputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationControlPerVertexInputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlPerVertexInputComponents);
    *out += "\n"; // GDS

    // uint32_t maxTessellationControlPerVertexOutputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationControlPerVertexOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlPerVertexOutputComponents);
    *out += "\n"; // GDS

    // uint32_t maxTessellationControlPerPatchOutputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationControlPerPatchOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlPerPatchOutputComponents);
    *out += "\n"; // GDS

    // uint32_t maxTessellationControlTotalOutputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationControlTotalOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationControlTotalOutputComponents);
    *out += "\n"; // GDS

    // uint32_t maxTessellationEvaluationInputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationEvaluationInputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationEvaluationInputComponents);
    *out += "\n"; // GDS

    // uint32_t maxTessellationEvaluationOutputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxTessellationEvaluationOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTessellationEvaluationOutputComponents);
    *out += "\n"; // GDS

    // uint32_t maxGeometryShaderInvocations // SMB
    IndentSpaces(out, indent);
    *out += "maxGeometryShaderInvocations:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryShaderInvocations);
    *out += "\n"; // GDS

    // uint32_t maxGeometryInputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxGeometryInputComponents:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryInputComponents);
    *out += "\n"; // GDS

    // uint32_t maxGeometryOutputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxGeometryOutputComponents:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryOutputComponents);
    *out += "\n"; // GDS

    // uint32_t maxGeometryOutputVertices // SMB
    IndentSpaces(out, indent);
    *out += "maxGeometryOutputVertices:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryOutputVertices);
    *out += "\n"; // GDS

    // uint32_t maxGeometryTotalOutputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxGeometryTotalOutputComponents: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryTotalOutputComponents);
    *out += "\n"; // GDS

    // uint32_t maxFragmentInputComponents // SMB
    IndentSpaces(out, indent);
    *out += "maxFragmentInputComponents:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentInputComponents);
    *out += "\n"; // GDS

    // uint32_t maxFragmentOutputAttachments // SMB
    IndentSpaces(out, indent);
    *out += "maxFragmentOutputAttachments:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentOutputAttachments);
    *out += "\n"; // GDS

    // uint32_t maxFragmentDualSrcAttachments // SMB
    IndentSpaces(out, indent);
    *out += "maxFragmentDualSrcAttachments:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentDualSrcAttachments);
    *out += "\n"; // GDS

    // uint32_t maxFragmentCombinedOutputResources // SMB
    IndentSpaces(out, indent);
    *out += "maxFragmentCombinedOutputResources: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFragmentCombinedOutputResources);
    *out += "\n"; // GDS

    // uint32_t maxComputeSharedMemorySize // SMB
    IndentSpaces(out, indent);
    *out += "maxComputeSharedMemorySize:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxComputeSharedMemorySize);
    *out += "\n"; // GDS

    // uint32_t maxComputeWorkGroupCount // SMB
    IndentSpaces(out, indent);
    *out += "maxComputeWorkGroupCount:       ";
    *out += "uint32_t[";
    *out += "3";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupCount)); // IYY
    ValueToStringStruct vinfo_maxComputeWorkGroupCount = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxComputeWorkGroupCount), "maxComputeWorkGroupCount", 3, vinfo_maxComputeWorkGroupCount); // JPA
    *out += "\n"; // GDS

    // uint32_t maxComputeWorkGroupInvocations // SMB
    IndentSpaces(out, indent);
    *out += "maxComputeWorkGroupInvocations: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxComputeWorkGroupInvocations);
    *out += "\n"; // GDS

    // uint32_t maxComputeWorkGroupSize // SMB
    IndentSpaces(out, indent);
    *out += "maxComputeWorkGroupSize:        ";
    *out += "uint32_t[";
    *out += "3";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_maxComputeWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxComputeWorkGroupSize), "maxComputeWorkGroupSize", 3, vinfo_maxComputeWorkGroupSize); // JPA
    *out += "\n"; // GDS

    // uint32_t subPixelPrecisionBits // SMB
    IndentSpaces(out, indent);
    *out += "subPixelPrecisionBits:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subPixelPrecisionBits);
    *out += "\n"; // GDS

    // uint32_t subTexelPrecisionBits // SMB
    IndentSpaces(out, indent);
    *out += "subTexelPrecisionBits:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subTexelPrecisionBits);
    *out += "\n"; // GDS

    // uint32_t mipmapPrecisionBits // SMB
    IndentSpaces(out, indent);
    *out += "mipmapPrecisionBits:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipmapPrecisionBits);
    *out += "\n"; // GDS

    // uint32_t maxDrawIndexedIndexValue // SMB
    IndentSpaces(out, indent);
    *out += "maxDrawIndexedIndexValue:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDrawIndexedIndexValue);
    *out += "\n"; // GDS

    // uint32_t maxDrawIndirectCount // SMB
    IndentSpaces(out, indent);
    *out += "maxDrawIndirectCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDrawIndirectCount);
    *out += "\n"; // GDS

    // float maxSamplerLodBias // SMB
    IndentSpaces(out, indent);
    *out += "maxSamplerLodBias:              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxSamplerLodBias);
    *out += "\n"; // GDS

    // float maxSamplerAnisotropy // SMB
    IndentSpaces(out, indent);
    *out += "maxSamplerAnisotropy:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxSamplerAnisotropy);
    *out += "\n"; // GDS

    // uint32_t maxViewports // SMB
    IndentSpaces(out, indent);
    *out += "maxViewports:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxViewports);
    *out += "\n"; // GDS

    // uint32_t maxViewportDimensions // SMB
    IndentSpaces(out, indent);
    *out += "maxViewportDimensions:          ";
    *out += "uint32_t[";
    *out += "2";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, maxViewportDimensions)); // IYY
    ValueToStringStruct vinfo_maxViewportDimensions = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxViewportDimensions), "maxViewportDimensions", 2, vinfo_maxViewportDimensions); // JPA
    *out += "\n"; // GDS

    // float viewportBoundsRange // SMB
    IndentSpaces(out, indent);
    *out += "viewportBoundsRange:            ";
    *out += "float[";
    *out += "2";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, viewportBoundsRange)); // IYY
    ValueToStringStruct vinfo_viewportBoundsRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->viewportBoundsRange), "viewportBoundsRange", 2, vinfo_viewportBoundsRange); // JPA
    *out += "\n"; // GDS

    // uint32_t viewportSubPixelBits // SMB
    IndentSpaces(out, indent);
    *out += "viewportSubPixelBits:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportSubPixelBits);
    *out += "\n"; // GDS

    // size_t minMemoryMapAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minMemoryMapAlignment:          ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minMemoryMapAlignment);
    *out += "\n"; // GDS

    // VkDeviceSize minTexelBufferOffsetAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minTexelBufferOffsetAlignment:  ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minTexelBufferOffsetAlignment);
    *out += "\n"; // GDS

    // VkDeviceSize minUniformBufferOffsetAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minUniformBufferOffsetAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minUniformBufferOffsetAlignment);
    *out += "\n"; // GDS

    // VkDeviceSize minStorageBufferOffsetAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minStorageBufferOffsetAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minStorageBufferOffsetAlignment);
    *out += "\n"; // GDS

    // int32_t minTexelOffset // SMB
    IndentSpaces(out, indent);
    *out += "minTexelOffset:                 ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->minTexelOffset);
    *out += "\n"; // GDS

    // uint32_t maxTexelOffset // SMB
    IndentSpaces(out, indent);
    *out += "maxTexelOffset:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTexelOffset);
    *out += "\n"; // GDS

    // int32_t minTexelGatherOffset // SMB
    IndentSpaces(out, indent);
    *out += "minTexelGatherOffset:           ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->minTexelGatherOffset);
    *out += "\n"; // GDS

    // uint32_t maxTexelGatherOffset // SMB
    IndentSpaces(out, indent);
    *out += "maxTexelGatherOffset:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTexelGatherOffset);
    *out += "\n"; // GDS

    // float minInterpolationOffset // SMB
    IndentSpaces(out, indent);
    *out += "minInterpolationOffset:         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minInterpolationOffset);
    *out += "\n"; // GDS

    // float maxInterpolationOffset // SMB
    IndentSpaces(out, indent);
    *out += "maxInterpolationOffset:         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxInterpolationOffset);
    *out += "\n"; // GDS

    // uint32_t subPixelInterpolationOffsetBits // SMB
    IndentSpaces(out, indent);
    *out += "subPixelInterpolationOffsetBits: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subPixelInterpolationOffsetBits);
    *out += "\n"; // GDS

    // uint32_t maxFramebufferWidth // SMB
    IndentSpaces(out, indent);
    *out += "maxFramebufferWidth:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFramebufferWidth);
    *out += "\n"; // GDS

    // uint32_t maxFramebufferHeight // SMB
    IndentSpaces(out, indent);
    *out += "maxFramebufferHeight:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFramebufferHeight);
    *out += "\n"; // GDS

    // uint32_t maxFramebufferLayers // SMB
    IndentSpaces(out, indent);
    *out += "maxFramebufferLayers:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxFramebufferLayers);
    *out += "\n"; // GDS

    // VkSampleCountFlags framebufferColorSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "framebufferColorSampleCounts:   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferColorSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags framebufferDepthSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "framebufferDepthSampleCounts:   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferDepthSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags framebufferStencilSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "framebufferStencilSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferStencilSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags framebufferNoAttachmentsSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "framebufferNoAttachmentsSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->framebufferNoAttachmentsSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t maxColorAttachments // SMB
    IndentSpaces(out, indent);
    *out += "maxColorAttachments:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxColorAttachments);
    *out += "\n"; // GDS

    // VkSampleCountFlags sampledImageColorSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "sampledImageColorSampleCounts:  ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageColorSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags sampledImageIntegerSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "sampledImageIntegerSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageIntegerSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags sampledImageDepthSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "sampledImageDepthSampleCounts:  ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageDepthSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags sampledImageStencilSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "sampledImageStencilSampleCounts: ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampledImageStencilSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags storageImageSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "storageImageSampleCounts:       ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->storageImageSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t maxSampleMaskWords // SMB
    IndentSpaces(out, indent);
    *out += "maxSampleMaskWords:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSampleMaskWords);
    *out += "\n"; // GDS

    // VkBool32 timestampComputeAndGraphics // SMB
    IndentSpaces(out, indent);
    *out += "timestampComputeAndGraphics:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->timestampComputeAndGraphics);
    *out += "\n"; // GDS

    // float timestampPeriod // SMB
    IndentSpaces(out, indent);
    *out += "timestampPeriod:                ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->timestampPeriod);
    *out += "\n"; // GDS

    // uint32_t maxClipDistances // SMB
    IndentSpaces(out, indent);
    *out += "maxClipDistances:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxClipDistances);
    *out += "\n"; // GDS

    // uint32_t maxCullDistances // SMB
    IndentSpaces(out, indent);
    *out += "maxCullDistances:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxCullDistances);
    *out += "\n"; // GDS

    // uint32_t maxCombinedClipAndCullDistances // SMB
    IndentSpaces(out, indent);
    *out += "maxCombinedClipAndCullDistances: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxCombinedClipAndCullDistances);
    *out += "\n"; // GDS

    // uint32_t discreteQueuePriorities // SMB
    IndentSpaces(out, indent);
    *out += "discreteQueuePriorities:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->discreteQueuePriorities);
    *out += "\n"; // GDS

    // float pointSizeRange // SMB
    IndentSpaces(out, indent);
    *out += "pointSizeRange:                 ";
    *out += "float[";
    *out += "2";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, pointSizeRange)); // IYY
    ValueToStringStruct vinfo_pointSizeRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->pointSizeRange), "pointSizeRange", 2, vinfo_pointSizeRange); // JPA
    *out += "\n"; // GDS

    // float lineWidthRange // SMB
    IndentSpaces(out, indent);
    *out += "lineWidthRange:                 ";
    *out += "float[";
    *out += "2";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceLimits, lineWidthRange)); // IYY
    ValueToStringStruct vinfo_lineWidthRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->lineWidthRange), "lineWidthRange", 2, vinfo_lineWidthRange); // JPA
    *out += "\n"; // GDS

    // float pointSizeGranularity // SMB
    IndentSpaces(out, indent);
    *out += "pointSizeGranularity:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->pointSizeGranularity);
    *out += "\n"; // GDS

    // float lineWidthGranularity // SMB
    IndentSpaces(out, indent);
    *out += "lineWidthGranularity:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->lineWidthGranularity);
    *out += "\n"; // GDS

    // VkBool32 strictLines // SMB
    IndentSpaces(out, indent);
    *out += "strictLines:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->strictLines);
    *out += "\n"; // GDS

    // VkBool32 standardSampleLocations // SMB
    IndentSpaces(out, indent);
    *out += "standardSampleLocations:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->standardSampleLocations);
    *out += "\n"; // GDS

    // VkDeviceSize optimalBufferCopyOffsetAlignment // SMB
    IndentSpaces(out, indent);
    *out += "optimalBufferCopyOffsetAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->optimalBufferCopyOffsetAlignment);
    *out += "\n"; // GDS

    // VkDeviceSize optimalBufferCopyRowPitchAlignment // SMB
    IndentSpaces(out, indent);
    *out += "optimalBufferCopyRowPitchAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->optimalBufferCopyRowPitchAlignment);
    *out += "\n"; // GDS

    // VkDeviceSize nonCoherentAtomSize // SMB
    IndentSpaces(out, indent);
    *out += "nonCoherentAtomSize:            ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->nonCoherentAtomSize);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSparseProperties>(std::string* out, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSparseProperties *pstruct = (const VkPhysicalDeviceSparseProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkBool32 residencyStandard2DBlockShape // SMB
    IndentSpaces(out, indent);
    *out += "residencyStandard2DBlockShape:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyStandard2DBlockShape);
    *out += "\n"; // GDS

    // VkBool32 residencyStandard2DMultisampleBlockShape // SMB
    IndentSpaces(out, indent);
    *out += "residencyStandard2DMultisampleBlockShape: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyStandard2DMultisampleBlockShape);
    *out += "\n"; // GDS

    // VkBool32 residencyStandard3DBlockShape // SMB
    IndentSpaces(out, indent);
    *out += "residencyStandard3DBlockShape:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyStandard3DBlockShape);
    *out += "\n"; // GDS

    // VkBool32 residencyAlignedMipSize // SMB
    IndentSpaces(out, indent);
    *out += "residencyAlignedMipSize:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyAlignedMipSize);
    *out += "\n"; // GDS

    // VkBool32 residencyNonResidentStrict // SMB
    IndentSpaces(out, indent);
    *out += "residencyNonResidentStrict:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->residencyNonResidentStrict);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProperties>(std::string* out, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProperties *pstruct = (const VkPhysicalDeviceProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t apiVersion // SMB
    IndentSpaces(out, indent);
    *out += "apiVersion:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->apiVersion);
    *out += "\n"; // GDS

    // uint32_t driverVersion // SMB
    IndentSpaces(out, indent);
    *out += "driverVersion:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->driverVersion);
    *out += "\n"; // GDS

    // uint32_t vendorID // SMB
    IndentSpaces(out, indent);
    *out += "vendorID:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vendorID);
    *out += "\n"; // GDS

    // uint32_t deviceID // SMB
    IndentSpaces(out, indent);
    *out += "deviceID:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceID);
    *out += "\n"; // GDS

    // VkPhysicalDeviceType deviceType // SMB
    IndentSpaces(out, indent);
    *out += "deviceType:                     ";
    *out += "VkPhysicalDeviceType = "; // TEQ
    EnumToStringVkPhysicalDeviceType(out, pstruct->deviceType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->deviceType);
    *out += ")";
    *out += "\n"; // GDS

    // char deviceName // SMB
    IndentSpaces(out, indent);
    *out += "deviceName:                     ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_deviceName = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->deviceName), "deviceName", VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, vinfo_deviceName); // JPA
    *out += "\n"; // GDS

    // uint8_t pipelineCacheUUID // SMB
    IndentSpaces(out, indent);
    *out += "pipelineCacheUUID:              ";
    *out += "uint8_t[";
    *out += "VK_UUID_SIZE";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceProperties, pipelineCacheUUID)); // IYY
    ValueToStringStruct vinfo_pipelineCacheUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->pipelineCacheUUID), "pipelineCacheUUID", VK_UUID_SIZE, vinfo_pipelineCacheUUID); // JPA
    *out += "\n"; // GDS

    // VkPhysicalDeviceLimits limits // SMB
    IndentSpaces(out, indent);
    *out += "limits:                         ";
    *out += "VkPhysicalDeviceLimits = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceLimits>(out, *pstruct_in.limits, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties, limits)); // AZJ
    *out += "\n"; // GDS

    // VkPhysicalDeviceSparseProperties sparseProperties // SMB
    IndentSpaces(out, indent);
    *out += "sparseProperties:               ";
    *out += "VkPhysicalDeviceSparseProperties = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceSparseProperties>(out, *pstruct_in.sparseProperties, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties, sparseProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkQueueFamilyProperties>(std::string* out, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueueFamilyProperties *pstruct = (const VkQueueFamilyProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkQueueFlags queueFlags // SMB
    IndentSpaces(out, indent);
    *out += "queueFlags:                     ";
    *out += "VkQueueFlags = "; // TEQ
    FlagsToString(out, pstruct->queueFlags, EnumToStringVkQueueFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t queueCount // SMB
    IndentSpaces(out, indent);
    *out += "queueCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueCount);
    *out += "\n"; // GDS

    // uint32_t timestampValidBits // SMB
    IndentSpaces(out, indent);
    *out += "timestampValidBits:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->timestampValidBits);
    *out += "\n"; // GDS

    // VkExtent3D minImageTransferGranularity // SMB
    IndentSpaces(out, indent);
    *out += "minImageTransferGranularity:    ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.minImageTransferGranularity, indent+1,  base_addr + offsetof(VkQueueFamilyProperties, minImageTransferGranularity)); // AZJ
}

template <>
void StructureToString<Decoded_VkMemoryType>(std::string* out, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryType *pstruct = (const VkMemoryType *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkMemoryPropertyFlags propertyFlags // SMB
    IndentSpaces(out, indent);
    *out += "propertyFlags:                  ";
    *out += "VkMemoryPropertyFlags = "; // TEQ
    FlagsToString(out, pstruct->propertyFlags, EnumToStringVkMemoryPropertyFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t heapIndex // SMB
    IndentSpaces(out, indent);
    *out += "heapIndex:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->heapIndex);
}

template <>
void StructureToString<Decoded_VkMemoryHeap>(std::string* out, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryHeap *pstruct = (const VkMemoryHeap *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
    *out += "\n"; // GDS

    // VkMemoryHeapFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMemoryHeapFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkMemoryHeapFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMemoryProperties *pstruct = (const VkPhysicalDeviceMemoryProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t memoryTypeCount // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypeCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeCount);
    *out += "\n"; // GDS

    // VkMemoryType memoryTypes // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypes:                    ";
    *out += "VkMemoryType[";
    UnsignedDecimalToString(out, pstruct->memoryTypeCount);
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMemoryProperties, memoryTypes)); // IYY
    ArrayOfStructsToString<Decoded_VkMemoryType>(out, indent+1, 0, "VkMemoryType", pstruct_in.memoryTypes->GetMetaStructPointer(), "memoryTypes", pstruct->memoryTypeCount , false, pstruct_in.memoryTypes->GetAddress()); // EPB
    *out += "\n"; // GDS

    // uint32_t memoryHeapCount // SMB
    IndentSpaces(out, indent);
    *out += "memoryHeapCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryHeapCount);
    *out += "\n"; // GDS

    // VkMemoryHeap memoryHeaps // SMB
    IndentSpaces(out, indent);
    *out += "memoryHeaps:                    ";
    *out += "VkMemoryHeap[";
    UnsignedDecimalToString(out, pstruct->memoryHeapCount);
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMemoryProperties, memoryHeaps)); // IYY
    ArrayOfStructsToString<Decoded_VkMemoryHeap>(out, indent+1, 0, "VkMemoryHeap", pstruct_in.memoryHeaps->GetMetaStructPointer(), "memoryHeaps", pstruct->memoryHeapCount , false, pstruct_in.memoryHeaps->GetAddress()); // EPB
}

template <>
void StructureToString<Decoded_VkDeviceQueueCreateInfo>(std::string* out, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceQueueCreateInfo *pstruct = (const VkDeviceQueueCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceQueueCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDeviceQueueCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDeviceQueueCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t queueFamilyIndex // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndex);
    *out += "\n"; // GDS

    // uint32_t queueCount // SMB
    IndentSpaces(out, indent);
    *out += "queueCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueCount);
    *out += "\n"; // GDS

    // const float* pQueuePriorities // SMB
    IndentSpaces(out, indent);
    *out += "pQueuePriorities:               ";
    *out += "const float* = "; // TEQ
    if (pstruct->pQueuePriorities == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueuePriorities.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueuePriorities = {false, false, false, nullptr};
        ArrayToString<const float*>(out, indent, 1, "const float*", reinterpret_cast<const float*>(pstruct_in.pQueuePriorities.GetPointer()), "pQueuePriorities", pstruct->queueCount,  vinfo_pQueuePriorities);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceCreateInfo *pstruct = (const VkDeviceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDeviceCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t queueCreateInfoCount // SMB
    IndentSpaces(out, indent);
    *out += "queueCreateInfoCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueCreateInfoCount);
    *out += "\n"; // GDS

    // const VkDeviceQueueCreateInfo* pQueueCreateInfos // SMB
    IndentSpaces(out, indent);
    *out += "pQueueCreateInfos:              ";
    *out += "const VkDeviceQueueCreateInfo* = "; // TEQ
    if (pstruct->pQueueCreateInfos == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueCreateInfos->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDeviceQueueCreateInfo>(out, indent+1, 1, "VkDeviceQueueCreateInfo", pstruct_in.pQueueCreateInfos->GetMetaStructPointer(), "pQueueCreateInfos", pstruct->queueCreateInfoCount, false, pstruct_in.pQueueCreateInfos->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t enabledLayerCount // SMB
    IndentSpaces(out, indent);
    *out += "enabledLayerCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledLayerCount);
    *out += "\n"; // GDS

    // const char* const* ppEnabledLayerNames // SMB
    IndentSpaces(out, indent);
    *out += "ppEnabledLayerNames:            ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledLayerNames == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledLayerNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pstruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t enabledExtensionCount // SMB
    IndentSpaces(out, indent);
    *out += "enabledExtensionCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->enabledExtensionCount);
    *out += "\n"; // GDS

    // const char* const* ppEnabledExtensionNames // SMB
    IndentSpaces(out, indent);
    *out += "ppEnabledExtensionNames:        ";
    *out += "const char* const* = "; // TEQ
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.ppEnabledExtensionNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        ArrayToString<const char* const*>(out, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pstruct_in.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pstruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CCQ
    }
    *out += "\n"; // GDS

    // const VkPhysicalDeviceFeatures* pEnabledFeatures // SMB
    IndentSpaces(out, indent);
    *out += "pEnabledFeatures:               ";
    *out += "const VkPhysicalDeviceFeatures* = "; // TEQ
    if (pstruct->pEnabledFeatures == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pEnabledFeatures->GetAddress()); // JHI
        StructureToString<Decoded_VkPhysicalDeviceFeatures>(out, *pstruct_in.pEnabledFeatures->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkDeviceCreateInfo, pEnabledFeatures)); // GLM
    }
}

template <>
void StructureToString<Decoded_VkExtensionProperties>(std::string* out, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExtensionProperties *pstruct = (const VkExtensionProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // char extensionName // SMB
    IndentSpaces(out, indent);
    *out += "extensionName:                  ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_extensionName = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->extensionName), "extensionName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_extensionName); // JPA
    *out += "\n"; // GDS

    // uint32_t specVersion // SMB
    IndentSpaces(out, indent);
    *out += "specVersion:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->specVersion);
}

template <>
void StructureToString<Decoded_VkLayerProperties>(std::string* out, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkLayerProperties *pstruct = (const VkLayerProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // char layerName // SMB
    IndentSpaces(out, indent);
    *out += "layerName:                      ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_layerName = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->layerName), "layerName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_layerName); // JPA
    *out += "\n"; // GDS

    // uint32_t specVersion // SMB
    IndentSpaces(out, indent);
    *out += "specVersion:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->specVersion);
    *out += "\n"; // GDS

    // uint32_t implementationVersion // SMB
    IndentSpaces(out, indent);
    *out += "implementationVersion:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->implementationVersion);
    *out += "\n"; // GDS

    // char description // SMB
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
}

template <>
void StructureToString<Decoded_VkSubmitInfo>(std::string* out, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubmitInfo *pstruct = (const VkSubmitInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount);
    *out += "\n"; // GDS

    // const VkSemaphore* pWaitSemaphores // SMB
    IndentSpaces(out, indent);
    *out += "pWaitSemaphores:                ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CCQ
    }
    *out += "\n"; // GDS

    // const VkPipelineStageFlags* pWaitDstStageMask // SMB
    IndentSpaces(out, indent);
    *out += "pWaitDstStageMask:              ";
    *out += "const VkPipelineStageFlags* = "; // TEQ
    if (pstruct->pWaitDstStageMask == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitDstStageMask.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitDstStageMask = {false, false, true, EnumToStringVkPipelineStageFlagBits};
        ArrayToString<const VkPipelineStageFlags*>(out, indent, 1, "const VkPipelineStageFlags*", reinterpret_cast<const VkPipelineStageFlags*>(pstruct_in.pWaitDstStageMask.GetPointer()), "pWaitDstStageMask", pstruct->waitSemaphoreCount,  vinfo_pWaitDstStageMask);  // CCR
    }
    *out += "\n"; // GDS

    // uint32_t commandBufferCount // SMB
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->commandBufferCount);
    *out += "\n"; // GDS

    // const VkCommandBuffer* pCommandBuffers // SMB
    IndentSpaces(out, indent);
    *out += "pCommandBuffers:                ";
    *out += "const VkCommandBuffer* = "; // TEQ
    if (pstruct->pCommandBuffers == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCommandBuffers.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<const VkCommandBuffer*>(out, indent, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pstruct_in.pCommandBuffers.GetPointer()), "pCommandBuffers", pstruct->commandBufferCount,  vinfo_pCommandBuffers);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t signalSemaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "signalSemaphoreCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreCount);
    *out += "\n"; // GDS

    // const VkSemaphore* pSignalSemaphores // SMB
    IndentSpaces(out, indent);
    *out += "pSignalSemaphores:              ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pSignalSemaphores == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkMemoryAllocateInfo>(std::string* out, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryAllocateInfo *pstruct = (const VkMemoryAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceSize allocationSize // SMB
    IndentSpaces(out, indent);
    *out += "allocationSize:                 ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->allocationSize);
    *out += "\n"; // GDS

    // uint32_t memoryTypeIndex // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypeIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeIndex);
}

template <>
void StructureToString<Decoded_VkMappedMemoryRange>(std::string* out, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMappedMemoryRange *pstruct = (const VkMappedMemoryRange *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
}

template <>
void StructureToString<Decoded_VkMemoryRequirements>(std::string* out, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryRequirements *pstruct = (const VkMemoryRequirements *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
    *out += "\n"; // GDS

    // VkDeviceSize alignment // SMB
    IndentSpaces(out, indent);
    *out += "alignment:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->alignment);
    *out += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits);
}

template <>
void StructureToString<Decoded_VkSparseImageFormatProperties>(std::string* out, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageFormatProperties *pstruct = (const VkSparseImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // VkExtent3D imageGranularity // SMB
    IndentSpaces(out, indent);
    *out += "imageGranularity:               ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.imageGranularity, indent+1,  base_addr + offsetof(VkSparseImageFormatProperties, imageGranularity)); // AZJ
    *out += "\n"; // GDS

    // VkSparseImageFormatFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSparseImageFormatFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSparseImageFormatFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryRequirements>(std::string* out, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryRequirements *pstruct = (const VkSparseImageMemoryRequirements *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkSparseImageFormatProperties formatProperties // SMB
    IndentSpaces(out, indent);
    *out += "formatProperties:               ";
    *out += "VkSparseImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkSparseImageFormatProperties>(out, *pstruct_in.formatProperties, indent+1,  base_addr + offsetof(VkSparseImageMemoryRequirements, formatProperties)); // AZJ
    *out += "\n"; // GDS

    // uint32_t imageMipTailFirstLod // SMB
    IndentSpaces(out, indent);
    *out += "imageMipTailFirstLod:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageMipTailFirstLod);
    *out += "\n"; // GDS

    // VkDeviceSize imageMipTailSize // SMB
    IndentSpaces(out, indent);
    *out += "imageMipTailSize:               ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->imageMipTailSize);
    *out += "\n"; // GDS

    // VkDeviceSize imageMipTailOffset // SMB
    IndentSpaces(out, indent);
    *out += "imageMipTailOffset:             ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->imageMipTailOffset);
    *out += "\n"; // GDS

    // VkDeviceSize imageMipTailStride // SMB
    IndentSpaces(out, indent);
    *out += "imageMipTailStride:             ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->imageMipTailStride);
}

template <>
void StructureToString<Decoded_VkSparseMemoryBind>(std::string* out, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseMemoryBind *pstruct = (const VkSparseMemoryBind *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDeviceSize resourceOffset // SMB
    IndentSpaces(out, indent);
    *out += "resourceOffset:                 ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->resourceOffset);
    *out += "\n"; // GDS

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset);
    *out += "\n"; // GDS

    // VkSparseMemoryBindFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSparseMemoryBindFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSparseMemoryBindFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSparseBufferMemoryBindInfo>(std::string* out, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseBufferMemoryBindInfo *pstruct = (const VkSparseBufferMemoryBindInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // uint32_t bindCount // SMB
    IndentSpaces(out, indent);
    *out += "bindCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindCount);
    *out += "\n"; // GDS

    // const VkSparseMemoryBind* pBinds // SMB
    IndentSpaces(out, indent);
    *out += "pBinds:                         ";
    *out += "const VkSparseMemoryBind* = "; // TEQ
    if (pstruct->pBinds == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBinds->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseMemoryBind>(out, indent+1, 1, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageOpaqueMemoryBindInfo *pstruct = (const VkSparseImageOpaqueMemoryBindInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // uint32_t bindCount // SMB
    IndentSpaces(out, indent);
    *out += "bindCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindCount);
    *out += "\n"; // GDS

    // const VkSparseMemoryBind* pBinds // SMB
    IndentSpaces(out, indent);
    *out += "pBinds:                         ";
    *out += "const VkSparseMemoryBind* = "; // TEQ
    if (pstruct->pBinds == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBinds->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseMemoryBind>(out, indent+1, 1, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkImageSubresource>(std::string* out, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSubresource *pstruct = (const VkImageSubresource *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t mipLevel // SMB
    IndentSpaces(out, indent);
    *out += "mipLevel:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipLevel);
    *out += "\n"; // GDS

    // uint32_t arrayLayer // SMB
    IndentSpaces(out, indent);
    *out += "arrayLayer:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->arrayLayer);
}

template <>
void StructureToString<Decoded_VkOffset3D>(std::string* out, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkOffset3D *pstruct = (const VkOffset3D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // int32_t x // SMB
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->x);
    *out += "\n"; // GDS

    // int32_t y // SMB
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->y);
    *out += "\n"; // GDS

    // int32_t z // SMB
    IndentSpaces(out, indent);
    *out += "z:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->z);
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryBind>(std::string* out, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryBind *pstruct = (const VkSparseImageMemoryBind *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageSubresource subresource // SMB
    IndentSpaces(out, indent);
    *out += "subresource:                    ";
    *out += "VkImageSubresource = "; // TEQ
    StructureToString<Decoded_VkImageSubresource>(out, *pstruct_in.subresource, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, subresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.offset, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, offset)); // AZJ
    *out += "\n"; // GDS

    // VkExtent3D extent // SMB
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkSparseImageMemoryBind, extent)); // AZJ
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset);
    *out += "\n"; // GDS

    // VkSparseMemoryBindFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSparseMemoryBindFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSparseMemoryBindFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryBindInfo>(std::string* out, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryBindInfo *pstruct = (const VkSparseImageMemoryBindInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // uint32_t bindCount // SMB
    IndentSpaces(out, indent);
    *out += "bindCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindCount);
    *out += "\n"; // GDS

    // const VkSparseImageMemoryBind* pBinds // SMB
    IndentSpaces(out, indent);
    *out += "pBinds:                         ";
    *out += "const VkSparseImageMemoryBind* = "; // TEQ
    if (pstruct->pBinds == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBinds->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryBind>(out, indent+1, 1, "VkSparseImageMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkBindSparseInfo>(std::string* out, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindSparseInfo *pstruct = (const VkBindSparseInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount);
    *out += "\n"; // GDS

    // const VkSemaphore* pWaitSemaphores // SMB
    IndentSpaces(out, indent);
    *out += "pWaitSemaphores:                ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t bufferBindCount // SMB
    IndentSpaces(out, indent);
    *out += "bufferBindCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bufferBindCount);
    *out += "\n"; // GDS

    // const VkSparseBufferMemoryBindInfo* pBufferBinds // SMB
    IndentSpaces(out, indent);
    *out += "pBufferBinds:                   ";
    *out += "const VkSparseBufferMemoryBindInfo* = "; // TEQ
    if (pstruct->pBufferBinds == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBufferBinds->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseBufferMemoryBindInfo>(out, indent+1, 1, "VkSparseBufferMemoryBindInfo", pstruct_in.pBufferBinds->GetMetaStructPointer(), "pBufferBinds", pstruct->bufferBindCount, false, pstruct_in.pBufferBinds->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t imageOpaqueBindCount // SMB
    IndentSpaces(out, indent);
    *out += "imageOpaqueBindCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageOpaqueBindCount);
    *out += "\n"; // GDS

    // const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds // SMB
    IndentSpaces(out, indent);
    *out += "pImageOpaqueBinds:              ";
    *out += "const VkSparseImageOpaqueMemoryBindInfo* = "; // TEQ
    if (pstruct->pImageOpaqueBinds == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageOpaqueBinds->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(out, indent+1, 1, "VkSparseImageOpaqueMemoryBindInfo", pstruct_in.pImageOpaqueBinds->GetMetaStructPointer(), "pImageOpaqueBinds", pstruct->imageOpaqueBindCount, false, pstruct_in.pImageOpaqueBinds->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t imageBindCount // SMB
    IndentSpaces(out, indent);
    *out += "imageBindCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageBindCount);
    *out += "\n"; // GDS

    // const VkSparseImageMemoryBindInfo* pImageBinds // SMB
    IndentSpaces(out, indent);
    *out += "pImageBinds:                    ";
    *out += "const VkSparseImageMemoryBindInfo* = "; // TEQ
    if (pstruct->pImageBinds == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageBinds->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryBindInfo>(out, indent+1, 1, "VkSparseImageMemoryBindInfo", pstruct_in.pImageBinds->GetMetaStructPointer(), "pImageBinds", pstruct->imageBindCount, false, pstruct_in.pImageBinds->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t signalSemaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "signalSemaphoreCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreCount);
    *out += "\n"; // GDS

    // const VkSemaphore* pSignalSemaphores // SMB
    IndentSpaces(out, indent);
    *out += "pSignalSemaphores:              ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pSignalSemaphores == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkFenceCreateInfo>(std::string* out, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFenceCreateInfo *pstruct = (const VkFenceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFenceCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFenceCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFenceCreateFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSemaphoreCreateInfo>(std::string* out, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreCreateInfo *pstruct = (const VkSemaphoreCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphoreCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
}

template <>
void StructureToString<Decoded_VkEventCreateInfo>(std::string* out, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkEventCreateInfo *pstruct = (const VkEventCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkEventCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkEventCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
}

template <>
void StructureToString<Decoded_VkQueryPoolCreateInfo>(std::string* out, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueryPoolCreateInfo *pstruct = (const VkQueryPoolCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkQueryPoolCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkQueryPoolCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkQueryType queryType // SMB
    IndentSpaces(out, indent);
    *out += "queryType:                      ";
    *out += "VkQueryType = "; // TEQ
    EnumToStringVkQueryType(out, pstruct->queryType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->queryType);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t queryCount // SMB
    IndentSpaces(out, indent);
    *out += "queryCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queryCount);
    *out += "\n"; // GDS

    // VkQueryPipelineStatisticFlags pipelineStatistics // SMB
    IndentSpaces(out, indent);
    *out += "pipelineStatistics:             ";
    *out += "VkQueryPipelineStatisticFlags = "; // TEQ
    FlagsToString(out, pstruct->pipelineStatistics, EnumToStringVkQueryPipelineStatisticFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkBufferCreateInfo>(std::string* out, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferCreateInfo *pstruct = (const VkBufferCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBufferCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBufferCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkBufferCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
    *out += "\n"; // GDS

    // VkBufferUsageFlags usage // SMB
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkBufferUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkBufferUsageFlagBits); // URW
    *out += "\n"; // GDS

    // VkSharingMode sharingMode // SMB
    IndentSpaces(out, indent);
    *out += "sharingMode:                    ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->sharingMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount);
    *out += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkBufferViewCreateInfo>(std::string* out, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferViewCreateInfo *pstruct = (const VkBufferViewCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBufferViewCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBufferViewCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // VkDeviceSize range // SMB
    IndentSpaces(out, indent);
    *out += "range:                          ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->range);
}

template <>
void StructureToString<Decoded_VkImageCreateInfo>(std::string* out, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageCreateInfo *pstruct = (const VkImageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkImageCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkImageType imageType // SMB
    IndentSpaces(out, indent);
    *out += "imageType:                      ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, pstruct->imageType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageType);
    *out += ")";
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkExtent3D extent // SMB
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageCreateInfo, extent)); // AZJ
    *out += "\n"; // GDS

    // uint32_t mipLevels // SMB
    IndentSpaces(out, indent);
    *out += "mipLevels:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipLevels);
    *out += "\n"; // GDS

    // uint32_t arrayLayers // SMB
    IndentSpaces(out, indent);
    *out += "arrayLayers:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->arrayLayers);
    *out += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageTiling tiling // SMB
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, pstruct->tiling);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tiling);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // VkSharingMode sharingMode // SMB
    IndentSpaces(out, indent);
    *out += "sharingMode:                    ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->sharingMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount);
    *out += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
    *out += "\n"; // GDS

    // VkImageLayout initialLayout // SMB
    IndentSpaces(out, indent);
    *out += "initialLayout:                  ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->initialLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->initialLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSubresourceLayout>(std::string* out, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubresourceLayout *pstruct = (const VkSubresourceLayout *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
    *out += "\n"; // GDS

    // VkDeviceSize rowPitch // SMB
    IndentSpaces(out, indent);
    *out += "rowPitch:                       ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->rowPitch);
    *out += "\n"; // GDS

    // VkDeviceSize arrayPitch // SMB
    IndentSpaces(out, indent);
    *out += "arrayPitch:                     ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->arrayPitch);
    *out += "\n"; // GDS

    // VkDeviceSize depthPitch // SMB
    IndentSpaces(out, indent);
    *out += "depthPitch:                     ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->depthPitch);
}

template <>
void StructureToString<Decoded_VkComponentMapping>(std::string* out, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkComponentMapping *pstruct = (const VkComponentMapping *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkComponentSwizzle r // SMB
    IndentSpaces(out, indent);
    *out += "r:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->r);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->r);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentSwizzle g // SMB
    IndentSpaces(out, indent);
    *out += "g:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->g);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->g);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentSwizzle b // SMB
    IndentSpaces(out, indent);
    *out += "b:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->b);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->b);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentSwizzle a // SMB
    IndentSpaces(out, indent);
    *out += "a:                              ";
    *out += "VkComponentSwizzle = "; // TEQ
    EnumToStringVkComponentSwizzle(out, pstruct->a);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->a);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkImageSubresourceRange>(std::string* out, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSubresourceRange *pstruct = (const VkImageSubresourceRange *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t baseMipLevel // SMB
    IndentSpaces(out, indent);
    *out += "baseMipLevel:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseMipLevel);
    *out += "\n"; // GDS

    // uint32_t levelCount // SMB
    IndentSpaces(out, indent);
    *out += "levelCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->levelCount);
    *out += "\n"; // GDS

    // uint32_t baseArrayLayer // SMB
    IndentSpaces(out, indent);
    *out += "baseArrayLayer:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseArrayLayer);
    *out += "\n"; // GDS

    // uint32_t layerCount // SMB
    IndentSpaces(out, indent);
    *out += "layerCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layerCount);
}

template <>
void StructureToString<Decoded_VkImageViewCreateInfo>(std::string* out, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageViewCreateInfo *pstruct = (const VkImageViewCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageViewCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageViewCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkImageViewCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // VkImageViewType viewType // SMB
    IndentSpaces(out, indent);
    *out += "viewType:                       ";
    *out += "VkImageViewType = "; // TEQ
    EnumToStringVkImageViewType(out, pstruct->viewType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->viewType);
    *out += ")";
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentMapping components // SMB
    IndentSpaces(out, indent);
    *out += "components:                     ";
    *out += "VkComponentMapping = "; // TEQ
    StructureToString<Decoded_VkComponentMapping>(out, *pstruct_in.components, indent+1,  base_addr + offsetof(VkImageViewCreateInfo, components)); // AZJ
    *out += "\n"; // GDS

    // VkImageSubresourceRange subresourceRange // SMB
    IndentSpaces(out, indent);
    *out += "subresourceRange:               ";
    *out += "VkImageSubresourceRange = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceRange>(out, *pstruct_in.subresourceRange, indent+1,  base_addr + offsetof(VkImageViewCreateInfo, subresourceRange)); // AZJ
}

template <>
void StructureToString<Decoded_VkShaderModuleCreateInfo>(std::string* out, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderModuleCreateInfo *pstruct = (const VkShaderModuleCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkShaderModuleCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkShaderModuleCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkShaderModuleCreateFlagBits); // URW
    *out += "\n"; // GDS

    // size_t codeSize // SMB
    IndentSpaces(out, indent);
    *out += "codeSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->codeSize);
    *out += "\n"; // GDS

    // const uint32_t* pCode // SMB
    IndentSpaces(out, indent);
    *out += "pCode:                          ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCode == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCode.GetAddress()); // WUX
        if (kPrintShaderCode)
        {
            ValueToStringStruct vinfo_pCode = {false, false, false, nullptr};
            ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCode.GetPointer()), "pCode", pstruct->codeSize / 4, vinfo_pCode);  // CCY
        }
    }
}

template <>
void StructureToString<Decoded_VkPipelineCacheCreateInfo>(std::string* out, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineCacheCreateInfo *pstruct = (const VkPipelineCacheCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineCacheCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCacheCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // size_t initialDataSize // SMB
    IndentSpaces(out, indent);
    *out += "initialDataSize:                ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->initialDataSize);
    *out += "\n"; // GDS

    // const void* pInitialData // SMB
    IndentSpaces(out, indent);
    *out += "pInitialData:                   ";
    *out += "const void* = "; // TEQ
    if (pstruct->pInitialData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInitialData.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkSpecializationMapEntry>(std::string* out, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSpecializationMapEntry *pstruct = (const VkSpecializationMapEntry *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t constantID // SMB
    IndentSpaces(out, indent);
    *out += "constantID:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->constantID);
    *out += "\n"; // GDS

    // uint32_t offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // size_t size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->size);
}

template <>
void StructureToString<Decoded_VkSpecializationInfo>(std::string* out, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSpecializationInfo *pstruct = (const VkSpecializationInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t mapEntryCount // SMB
    IndentSpaces(out, indent);
    *out += "mapEntryCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mapEntryCount);
    *out += "\n"; // GDS

    // const VkSpecializationMapEntry* pMapEntries // SMB
    IndentSpaces(out, indent);
    *out += "pMapEntries:                    ";
    *out += "const VkSpecializationMapEntry* = "; // TEQ
    if (pstruct->pMapEntries == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pMapEntries->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSpecializationMapEntry>(out, indent+1, 1, "VkSpecializationMapEntry", pstruct_in.pMapEntries->GetMetaStructPointer(), "pMapEntries", pstruct->mapEntryCount, false, pstruct_in.pMapEntries->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // size_t dataSize // SMB
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dataSize);
    *out += "\n"; // GDS

    // const void* pData // SMB
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pData.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkPipelineShaderStageCreateInfo>(std::string* out, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineShaderStageCreateInfo *pstruct = (const VkPipelineShaderStageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineShaderStageCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineShaderStageCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineShaderStageCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkShaderStageFlagBits stage // SMB
    IndentSpaces(out, indent);
    *out += "stage:                          ";
    *out += "VkShaderStageFlagBits = "; // TEQ
    EnumToStringVkShaderStageFlagBits(out, pstruct->stage);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stage);
    *out += ")";
    *out += "\n"; // GDS

    // VkShaderModule module // SMB
    IndentSpaces(out, indent);
    *out += "module:                         ";
    *out += "VkShaderModule = "; // TEQ
    AddrToString(out, pstruct_in.module); // PAQ
    *out += "\n"; // GDS

    // const char* pName // SMB
    IndentSpaces(out, indent);
    *out += "pName:                          ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pName); // TGH
    *out += "\n"; // GDS

    // const VkSpecializationInfo* pSpecializationInfo // SMB
    IndentSpaces(out, indent);
    *out += "pSpecializationInfo:            ";
    *out += "const VkSpecializationInfo* = "; // TEQ
    if (pstruct->pSpecializationInfo == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSpecializationInfo->GetAddress()); // JHI
        StructureToString<Decoded_VkSpecializationInfo>(out, *pstruct_in.pSpecializationInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkPipelineShaderStageCreateInfo, pSpecializationInfo)); // GLM
    }
}

template <>
void StructureToString<Decoded_VkVertexInputBindingDescription>(std::string* out, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkVertexInputBindingDescription *pstruct = (const VkVertexInputBindingDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t binding // SMB
    IndentSpaces(out, indent);
    *out += "binding:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->binding);
    *out += "\n"; // GDS

    // uint32_t stride // SMB
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stride);
    *out += "\n"; // GDS

    // VkVertexInputRate inputRate // SMB
    IndentSpaces(out, indent);
    *out += "inputRate:                      ";
    *out += "VkVertexInputRate = "; // TEQ
    EnumToStringVkVertexInputRate(out, pstruct->inputRate);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->inputRate);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkVertexInputAttributeDescription>(std::string* out, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkVertexInputAttributeDescription *pstruct = (const VkVertexInputAttributeDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t location // SMB
    IndentSpaces(out, indent);
    *out += "location:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->location);
    *out += "\n"; // GDS

    // uint32_t binding // SMB
    IndentSpaces(out, indent);
    *out += "binding:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->binding);
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset);
}

template <>
void StructureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(std::string* out, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineVertexInputStateCreateInfo *pstruct = (const VkPipelineVertexInputStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineVertexInputStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineVertexInputStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t vertexBindingDescriptionCount // SMB
    IndentSpaces(out, indent);
    *out += "vertexBindingDescriptionCount:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexBindingDescriptionCount);
    *out += "\n"; // GDS

    // const VkVertexInputBindingDescription* pVertexBindingDescriptions // SMB
    IndentSpaces(out, indent);
    *out += "pVertexBindingDescriptions:     ";
    *out += "const VkVertexInputBindingDescription* = "; // TEQ
    if (pstruct->pVertexBindingDescriptions == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pVertexBindingDescriptions->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkVertexInputBindingDescription>(out, indent+1, 1, "VkVertexInputBindingDescription", pstruct_in.pVertexBindingDescriptions->GetMetaStructPointer(), "pVertexBindingDescriptions", pstruct->vertexBindingDescriptionCount, false, pstruct_in.pVertexBindingDescriptions->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t vertexAttributeDescriptionCount // SMB
    IndentSpaces(out, indent);
    *out += "vertexAttributeDescriptionCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexAttributeDescriptionCount);
    *out += "\n"; // GDS

    // const VkVertexInputAttributeDescription* pVertexAttributeDescriptions // SMB
    IndentSpaces(out, indent);
    *out += "pVertexAttributeDescriptions:   ";
    *out += "const VkVertexInputAttributeDescription* = "; // TEQ
    if (pstruct->pVertexAttributeDescriptions == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pVertexAttributeDescriptions->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkVertexInputAttributeDescription>(out, indent+1, 1, "VkVertexInputAttributeDescription", pstruct_in.pVertexAttributeDescriptions->GetMetaStructPointer(), "pVertexAttributeDescriptions", pstruct->vertexAttributeDescriptionCount, false, pstruct_in.pVertexAttributeDescriptions->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(std::string* out, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineInputAssemblyStateCreateInfo *pstruct = (const VkPipelineInputAssemblyStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineInputAssemblyStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineInputAssemblyStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkPrimitiveTopology topology // SMB
    IndentSpaces(out, indent);
    *out += "topology:                       ";
    *out += "VkPrimitiveTopology = "; // TEQ
    EnumToStringVkPrimitiveTopology(out, pstruct->topology);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->topology);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 primitiveRestartEnable // SMB
    IndentSpaces(out, indent);
    *out += "primitiveRestartEnable:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->primitiveRestartEnable);
}

template <>
void StructureToString<Decoded_VkPipelineTessellationStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineTessellationStateCreateInfo *pstruct = (const VkPipelineTessellationStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineTessellationStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineTessellationStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t patchControlPoints // SMB
    IndentSpaces(out, indent);
    *out += "patchControlPoints:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->patchControlPoints);
}

template <>
void StructureToString<Decoded_VkViewport>(std::string* out, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkViewport *pstruct = (const VkViewport *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // float x // SMB
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->x);
    *out += "\n"; // GDS

    // float y // SMB
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->y);
    *out += "\n"; // GDS

    // float width // SMB
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->width);
    *out += "\n"; // GDS

    // float height // SMB
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->height);
    *out += "\n"; // GDS

    // float minDepth // SMB
    IndentSpaces(out, indent);
    *out += "minDepth:                       ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minDepth);
    *out += "\n"; // GDS

    // float maxDepth // SMB
    IndentSpaces(out, indent);
    *out += "maxDepth:                       ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxDepth);
}

template <>
void StructureToString<Decoded_VkOffset2D>(std::string* out, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkOffset2D *pstruct = (const VkOffset2D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // int32_t x // SMB
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->x);
    *out += "\n"; // GDS

    // int32_t y // SMB
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->y);
}

template <>
void StructureToString<Decoded_VkExtent2D>(std::string* out, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExtent2D *pstruct = (const VkExtent2D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t width // SMB
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->width);
    *out += "\n"; // GDS

    // uint32_t height // SMB
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->height);
}

template <>
void StructureToString<Decoded_VkRect2D>(std::string* out, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRect2D *pstruct = (const VkRect2D *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkOffset2D offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.offset, indent+1,  base_addr + offsetof(VkRect2D, offset)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D extent // SMB
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkRect2D, extent)); // AZJ
}

template <>
void StructureToString<Decoded_VkPipelineViewportStateCreateInfo>(std::string* out, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportStateCreateInfo *pstruct = (const VkPipelineViewportStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineViewportStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineViewportStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t viewportCount // SMB
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportCount);
    *out += "\n"; // GDS

    // const VkViewport* pViewports // SMB
    IndentSpaces(out, indent);
    *out += "pViewports:                     ";
    *out += "const VkViewport* = "; // TEQ
    if (pstruct->pViewports == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewports->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkViewport>(out, indent+1, 1, "VkViewport", pstruct_in.pViewports->GetMetaStructPointer(), "pViewports", pstruct->viewportCount, false, pstruct_in.pViewports->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t scissorCount // SMB
    IndentSpaces(out, indent);
    *out += "scissorCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->scissorCount);
    *out += "\n"; // GDS

    // const VkRect2D* pScissors // SMB
    IndentSpaces(out, indent);
    *out += "pScissors:                      ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pScissors == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pScissors->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pScissors->GetMetaStructPointer(), "pScissors", pstruct->scissorCount, false, pstruct_in.pScissors->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(std::string* out, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineRasterizationStateCreateInfo *pstruct = (const VkPipelineRasterizationStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineRasterizationStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineRasterizationStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkBool32 depthClampEnable // SMB
    IndentSpaces(out, indent);
    *out += "depthClampEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthClampEnable);
    *out += "\n"; // GDS

    // VkBool32 rasterizerDiscardEnable // SMB
    IndentSpaces(out, indent);
    *out += "rasterizerDiscardEnable:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->rasterizerDiscardEnable);
    *out += "\n"; // GDS

    // VkPolygonMode polygonMode // SMB
    IndentSpaces(out, indent);
    *out += "polygonMode:                    ";
    *out += "VkPolygonMode = "; // TEQ
    EnumToStringVkPolygonMode(out, pstruct->polygonMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->polygonMode);
    *out += ")";
    *out += "\n"; // GDS

    // VkCullModeFlags cullMode // SMB
    IndentSpaces(out, indent);
    *out += "cullMode:                       ";
    *out += "VkCullModeFlags = "; // TEQ
    FlagsToString(out, pstruct->cullMode, EnumToStringVkCullModeFlagBits); // URW
    *out += "\n"; // GDS

    // VkFrontFace frontFace // SMB
    IndentSpaces(out, indent);
    *out += "frontFace:                      ";
    *out += "VkFrontFace = "; // TEQ
    EnumToStringVkFrontFace(out, pstruct->frontFace);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->frontFace);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 depthBiasEnable // SMB
    IndentSpaces(out, indent);
    *out += "depthBiasEnable:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBiasEnable);
    *out += "\n"; // GDS

    // float depthBiasConstantFactor // SMB
    IndentSpaces(out, indent);
    *out += "depthBiasConstantFactor:        ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depthBiasConstantFactor);
    *out += "\n"; // GDS

    // float depthBiasClamp // SMB
    IndentSpaces(out, indent);
    *out += "depthBiasClamp:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depthBiasClamp);
    *out += "\n"; // GDS

    // float depthBiasSlopeFactor // SMB
    IndentSpaces(out, indent);
    *out += "depthBiasSlopeFactor:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depthBiasSlopeFactor);
    *out += "\n"; // GDS

    // float lineWidth // SMB
    IndentSpaces(out, indent);
    *out += "lineWidth:                      ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->lineWidth);
}

template <>
void StructureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(std::string* out, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineMultisampleStateCreateInfo *pstruct = (const VkPipelineMultisampleStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineMultisampleStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineMultisampleStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkSampleCountFlagBits rasterizationSamples // SMB
    IndentSpaces(out, indent);
    *out += "rasterizationSamples:           ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->rasterizationSamples);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->rasterizationSamples);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 sampleShadingEnable // SMB
    IndentSpaces(out, indent);
    *out += "sampleShadingEnable:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sampleShadingEnable);
    *out += "\n"; // GDS

    // float minSampleShading // SMB
    IndentSpaces(out, indent);
    *out += "minSampleShading:               ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minSampleShading);
    *out += "\n"; // GDS

    // const VkSampleMask* pSampleMask // SMB
    IndentSpaces(out, indent);
    *out += "pSampleMask:                    ";
    *out += "const VkSampleMask* = "; // TEQ
    if (pstruct->pSampleMask == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSampleMask.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSampleMask = {false, false, false, nullptr};
        ArrayToString<const VkSampleMask*>(out, indent, 1, "const VkSampleMask*", reinterpret_cast<const VkSampleMask*>(pstruct_in.pSampleMask.GetPointer()), "pSampleMask", pstruct->rasterizationSamples,  vinfo_pSampleMask);  // CCQ
    }
    *out += "\n"; // GDS

    // VkBool32 alphaToCoverageEnable // SMB
    IndentSpaces(out, indent);
    *out += "alphaToCoverageEnable:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->alphaToCoverageEnable);
    *out += "\n"; // GDS

    // VkBool32 alphaToOneEnable // SMB
    IndentSpaces(out, indent);
    *out += "alphaToOneEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->alphaToOneEnable);
}

template <>
void StructureToString<Decoded_VkStencilOpState>(std::string* out, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkStencilOpState *pstruct = (const VkStencilOpState *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStencilOp failOp // SMB
    IndentSpaces(out, indent);
    *out += "failOp:                         ";
    *out += "VkStencilOp = "; // TEQ
    EnumToStringVkStencilOp(out, pstruct->failOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->failOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkStencilOp passOp // SMB
    IndentSpaces(out, indent);
    *out += "passOp:                         ";
    *out += "VkStencilOp = "; // TEQ
    EnumToStringVkStencilOp(out, pstruct->passOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->passOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkStencilOp depthFailOp // SMB
    IndentSpaces(out, indent);
    *out += "depthFailOp:                    ";
    *out += "VkStencilOp = "; // TEQ
    EnumToStringVkStencilOp(out, pstruct->depthFailOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->depthFailOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkCompareOp compareOp // SMB
    IndentSpaces(out, indent);
    *out += "compareOp:                      ";
    *out += "VkCompareOp = "; // TEQ
    EnumToStringVkCompareOp(out, pstruct->compareOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->compareOp);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t compareMask // SMB
    IndentSpaces(out, indent);
    *out += "compareMask:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->compareMask);
    *out += "\n"; // GDS

    // uint32_t writeMask // SMB
    IndentSpaces(out, indent);
    *out += "writeMask:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->writeMask);
    *out += "\n"; // GDS

    // uint32_t reference // SMB
    IndentSpaces(out, indent);
    *out += "reference:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->reference);
}

template <>
void StructureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(std::string* out, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineDepthStencilStateCreateInfo *pstruct = (const VkPipelineDepthStencilStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineDepthStencilStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineDepthStencilStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkBool32 depthTestEnable // SMB
    IndentSpaces(out, indent);
    *out += "depthTestEnable:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthTestEnable);
    *out += "\n"; // GDS

    // VkBool32 depthWriteEnable // SMB
    IndentSpaces(out, indent);
    *out += "depthWriteEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthWriteEnable);
    *out += "\n"; // GDS

    // VkCompareOp depthCompareOp // SMB
    IndentSpaces(out, indent);
    *out += "depthCompareOp:                 ";
    *out += "VkCompareOp = "; // TEQ
    EnumToStringVkCompareOp(out, pstruct->depthCompareOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->depthCompareOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 depthBoundsTestEnable // SMB
    IndentSpaces(out, indent);
    *out += "depthBoundsTestEnable:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->depthBoundsTestEnable);
    *out += "\n"; // GDS

    // VkBool32 stencilTestEnable // SMB
    IndentSpaces(out, indent);
    *out += "stencilTestEnable:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stencilTestEnable);
    *out += "\n"; // GDS

    // VkStencilOpState front // SMB
    IndentSpaces(out, indent);
    *out += "front:                          ";
    *out += "VkStencilOpState = "; // TEQ
    StructureToString<Decoded_VkStencilOpState>(out, *pstruct_in.front, indent+1,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, front)); // AZJ
    *out += "\n"; // GDS

    // VkStencilOpState back // SMB
    IndentSpaces(out, indent);
    *out += "back:                           ";
    *out += "VkStencilOpState = "; // TEQ
    StructureToString<Decoded_VkStencilOpState>(out, *pstruct_in.back, indent+1,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, back)); // AZJ
    *out += "\n"; // GDS

    // float minDepthBounds // SMB
    IndentSpaces(out, indent);
    *out += "minDepthBounds:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minDepthBounds);
    *out += "\n"; // GDS

    // float maxDepthBounds // SMB
    IndentSpaces(out, indent);
    *out += "maxDepthBounds:                 ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxDepthBounds);
}

template <>
void StructureToString<Decoded_VkPipelineColorBlendAttachmentState>(std::string* out, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineColorBlendAttachmentState *pstruct = (const VkPipelineColorBlendAttachmentState *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkBool32 blendEnable // SMB
    IndentSpaces(out, indent);
    *out += "blendEnable:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->blendEnable);
    *out += "\n"; // GDS

    // VkBlendFactor srcColorBlendFactor // SMB
    IndentSpaces(out, indent);
    *out += "srcColorBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->srcColorBlendFactor);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->srcColorBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // VkBlendFactor dstColorBlendFactor // SMB
    IndentSpaces(out, indent);
    *out += "dstColorBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->dstColorBlendFactor);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->dstColorBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // VkBlendOp colorBlendOp // SMB
    IndentSpaces(out, indent);
    *out += "colorBlendOp:                   ";
    *out += "VkBlendOp = "; // TEQ
    EnumToStringVkBlendOp(out, pstruct->colorBlendOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->colorBlendOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkBlendFactor srcAlphaBlendFactor // SMB
    IndentSpaces(out, indent);
    *out += "srcAlphaBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->srcAlphaBlendFactor);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->srcAlphaBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // VkBlendFactor dstAlphaBlendFactor // SMB
    IndentSpaces(out, indent);
    *out += "dstAlphaBlendFactor:            ";
    *out += "VkBlendFactor = "; // TEQ
    EnumToStringVkBlendFactor(out, pstruct->dstAlphaBlendFactor);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->dstAlphaBlendFactor);
    *out += ")";
    *out += "\n"; // GDS

    // VkBlendOp alphaBlendOp // SMB
    IndentSpaces(out, indent);
    *out += "alphaBlendOp:                   ";
    *out += "VkBlendOp = "; // TEQ
    EnumToStringVkBlendOp(out, pstruct->alphaBlendOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->alphaBlendOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkColorComponentFlags colorWriteMask // SMB
    IndentSpaces(out, indent);
    *out += "colorWriteMask:                 ";
    *out += "VkColorComponentFlags = "; // TEQ
    FlagsToString(out, pstruct->colorWriteMask, EnumToStringVkColorComponentFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(std::string* out, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineColorBlendStateCreateInfo *pstruct = (const VkPipelineColorBlendStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineColorBlendStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineColorBlendStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkBool32 logicOpEnable // SMB
    IndentSpaces(out, indent);
    *out += "logicOpEnable:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->logicOpEnable);
    *out += "\n"; // GDS

    // VkLogicOp logicOp // SMB
    IndentSpaces(out, indent);
    *out += "logicOp:                        ";
    *out += "VkLogicOp = "; // TEQ
    EnumToStringVkLogicOp(out, pstruct->logicOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->logicOp);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount);
    *out += "\n"; // GDS

    // const VkPipelineColorBlendAttachmentState* pAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkPipelineColorBlendAttachmentState* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPipelineColorBlendAttachmentState>(out, indent+1, 1, "VkPipelineColorBlendAttachmentState", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // float blendConstants // SMB
    IndentSpaces(out, indent);
    *out += "blendConstants:                 ";
    *out += "float[";
    *out += "4";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPipelineColorBlendStateCreateInfo, blendConstants)); // IYY
    ValueToStringStruct vinfo_blendConstants = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->blendConstants), "blendConstants", 4, vinfo_blendConstants); // JPA
}

template <>
void StructureToString<Decoded_VkPipelineDynamicStateCreateInfo>(std::string* out, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineDynamicStateCreateInfo *pstruct = (const VkPipelineDynamicStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineDynamicStateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineDynamicStateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t dynamicStateCount // SMB
    IndentSpaces(out, indent);
    *out += "dynamicStateCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dynamicStateCount);
    *out += "\n"; // GDS

    // const VkDynamicState* pDynamicStates // SMB
    IndentSpaces(out, indent);
    *out += "pDynamicStates:                 ";
    *out += "const VkDynamicState* = "; // TEQ
    if (pstruct->pDynamicStates == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDynamicStates.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDynamicStates = {false, true, false, EnumToStringVkDynamicState};
        ArrayToString<const VkDynamicState*>(out, indent, 1, "const VkDynamicState*", reinterpret_cast<const VkDynamicState*>(pstruct_in.pDynamicStates.GetPointer()), "pDynamicStates", pstruct->dynamicStateCount,  vinfo_pDynamicStates);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkGraphicsPipelineCreateInfo>(std::string* out, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGraphicsPipelineCreateInfo *pstruct = (const VkGraphicsPipelineCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t stageCount // SMB
    IndentSpaces(out, indent);
    *out += "stageCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stageCount);
    *out += "\n"; // GDS

    // const VkPipelineShaderStageCreateInfo* pStages // SMB
    IndentSpaces(out, indent);
    *out += "pStages:                        ";
    *out += "const VkPipelineShaderStageCreateInfo* = "; // TEQ
    if (pstruct->pStages == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pStages->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(out, indent+1, 1, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // const VkPipelineVertexInputStateCreateInfo* pVertexInputState // SMB
    IndentSpaces(out, indent);
    *out += "pVertexInputState:              ";
    *out += "const VkPipelineVertexInputStateCreateInfo* = "; // TEQ
    if (pstruct->pVertexInputState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pVertexInputState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(out, *pstruct_in.pVertexInputState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pVertexInputState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState // SMB
    IndentSpaces(out, indent);
    *out += "pInputAssemblyState:            ";
    *out += "const VkPipelineInputAssemblyStateCreateInfo* = "; // TEQ
    if (pstruct->pInputAssemblyState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInputAssemblyState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(out, *pstruct_in.pInputAssemblyState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pInputAssemblyState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineTessellationStateCreateInfo* pTessellationState // SMB
    IndentSpaces(out, indent);
    *out += "pTessellationState:             ";
    *out += "const VkPipelineTessellationStateCreateInfo* = "; // TEQ
    if (pstruct->pTessellationState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTessellationState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineTessellationStateCreateInfo>(out, *pstruct_in.pTessellationState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pTessellationState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineViewportStateCreateInfo* pViewportState // SMB
    IndentSpaces(out, indent);
    *out += "pViewportState:                 ";
    *out += "const VkPipelineViewportStateCreateInfo* = "; // TEQ
    if (pstruct->pViewportState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewportState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineViewportStateCreateInfo>(out, *pstruct_in.pViewportState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pViewportState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineRasterizationStateCreateInfo* pRasterizationState // SMB
    IndentSpaces(out, indent);
    *out += "pRasterizationState:            ";
    *out += "const VkPipelineRasterizationStateCreateInfo* = "; // TEQ
    if (pstruct->pRasterizationState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pRasterizationState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(out, *pstruct_in.pRasterizationState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pRasterizationState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineMultisampleStateCreateInfo* pMultisampleState // SMB
    IndentSpaces(out, indent);
    *out += "pMultisampleState:              ";
    *out += "const VkPipelineMultisampleStateCreateInfo* = "; // TEQ
    if (pstruct->pMultisampleState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pMultisampleState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(out, *pstruct_in.pMultisampleState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pMultisampleState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineDepthStencilStateCreateInfo* pDepthStencilState // SMB
    IndentSpaces(out, indent);
    *out += "pDepthStencilState:             ";
    *out += "const VkPipelineDepthStencilStateCreateInfo* = "; // TEQ
    if (pstruct->pDepthStencilState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDepthStencilState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(out, *pstruct_in.pDepthStencilState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDepthStencilState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineColorBlendStateCreateInfo* pColorBlendState // SMB
    IndentSpaces(out, indent);
    *out += "pColorBlendState:               ";
    *out += "const VkPipelineColorBlendStateCreateInfo* = "; // TEQ
    if (pstruct->pColorBlendState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pColorBlendState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(out, *pstruct_in.pColorBlendState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pColorBlendState)); // GLM
    }
    *out += "\n"; // GDS

    // const VkPipelineDynamicStateCreateInfo* pDynamicState // SMB
    IndentSpaces(out, indent);
    *out += "pDynamicState:                  ";
    *out += "const VkPipelineDynamicStateCreateInfo* = "; // TEQ
    if (pstruct->pDynamicState == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDynamicState->GetAddress()); // JHI
        StructureToString<Decoded_VkPipelineDynamicStateCreateInfo>(out, *pstruct_in.pDynamicState->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDynamicState)); // GLM
    }
    *out += "\n"; // GDS

    // VkPipelineLayout layout // SMB
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.layout); // PAQ
    *out += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // uint32_t subpass // SMB
    IndentSpaces(out, indent);
    *out += "subpass:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpass);
    *out += "\n"; // GDS

    // VkPipeline basePipelineHandle // SMB
    IndentSpaces(out, indent);
    *out += "basePipelineHandle:             ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.basePipelineHandle); // PAQ
    *out += "\n"; // GDS

    // int32_t basePipelineIndex // SMB
    IndentSpaces(out, indent);
    *out += "basePipelineIndex:              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->basePipelineIndex);
}

template <>
void StructureToString<Decoded_VkComputePipelineCreateInfo>(std::string* out, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkComputePipelineCreateInfo *pstruct = (const VkComputePipelineCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkPipelineShaderStageCreateInfo stage // SMB
    IndentSpaces(out, indent);
    *out += "stage:                          ";
    *out += "VkPipelineShaderStageCreateInfo = "; // TEQ
    StructureToString<Decoded_VkPipelineShaderStageCreateInfo>(out, *pstruct_in.stage, indent+1,  base_addr + offsetof(VkComputePipelineCreateInfo, stage)); // AZJ
    *out += "\n"; // GDS

    // VkPipelineLayout layout // SMB
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.layout); // PAQ
    *out += "\n"; // GDS

    // VkPipeline basePipelineHandle // SMB
    IndentSpaces(out, indent);
    *out += "basePipelineHandle:             ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.basePipelineHandle); // PAQ
    *out += "\n"; // GDS

    // int32_t basePipelineIndex // SMB
    IndentSpaces(out, indent);
    *out += "basePipelineIndex:              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->basePipelineIndex);
}

template <>
void StructureToString<Decoded_VkPushConstantRange>(std::string* out, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPushConstantRange *pstruct = (const VkPushConstantRange *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkShaderStageFlags stageFlags // SMB
    IndentSpaces(out, indent);
    *out += "stageFlags:                     ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // uint32_t size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->size);
}

template <>
void StructureToString<Decoded_VkPipelineLayoutCreateInfo>(std::string* out, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineLayoutCreateInfo *pstruct = (const VkPipelineLayoutCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineLayoutCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineLayoutCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t setLayoutCount // SMB
    IndentSpaces(out, indent);
    *out += "setLayoutCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->setLayoutCount);
    *out += "\n"; // GDS

    // const VkDescriptorSetLayout* pSetLayouts // SMB
    IndentSpaces(out, indent);
    *out += "pSetLayouts:                    ";
    *out += "const VkDescriptorSetLayout* = "; // TEQ
    if (pstruct->pSetLayouts == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSetLayouts.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSetLayout*>(out, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pstruct_in.pSetLayouts.GetPointer()), "pSetLayouts", pstruct->setLayoutCount,  vinfo_pSetLayouts);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t pushConstantRangeCount // SMB
    IndentSpaces(out, indent);
    *out += "pushConstantRangeCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->pushConstantRangeCount);
    *out += "\n"; // GDS

    // const VkPushConstantRange* pPushConstantRanges // SMB
    IndentSpaces(out, indent);
    *out += "pPushConstantRanges:            ";
    *out += "const VkPushConstantRange* = "; // TEQ
    if (pstruct->pPushConstantRanges == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPushConstantRanges->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPushConstantRange>(out, indent+1, 1, "VkPushConstantRange", pstruct_in.pPushConstantRanges->GetMetaStructPointer(), "pPushConstantRanges", pstruct->pushConstantRangeCount, false, pstruct_in.pPushConstantRanges->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkSamplerCreateInfo>(std::string* out, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerCreateInfo *pstruct = (const VkSamplerCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSamplerCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSamplerCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSamplerCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkFilter magFilter // SMB
    IndentSpaces(out, indent);
    *out += "magFilter:                      ";
    *out += "VkFilter = "; // TEQ
    EnumToStringVkFilter(out, pstruct->magFilter);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->magFilter);
    *out += ")";
    *out += "\n"; // GDS

    // VkFilter minFilter // SMB
    IndentSpaces(out, indent);
    *out += "minFilter:                      ";
    *out += "VkFilter = "; // TEQ
    EnumToStringVkFilter(out, pstruct->minFilter);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->minFilter);
    *out += ")";
    *out += "\n"; // GDS

    // VkSamplerMipmapMode mipmapMode // SMB
    IndentSpaces(out, indent);
    *out += "mipmapMode:                     ";
    *out += "VkSamplerMipmapMode = "; // TEQ
    EnumToStringVkSamplerMipmapMode(out, pstruct->mipmapMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->mipmapMode);
    *out += ")";
    *out += "\n"; // GDS

    // VkSamplerAddressMode addressModeU // SMB
    IndentSpaces(out, indent);
    *out += "addressModeU:                   ";
    *out += "VkSamplerAddressMode = "; // TEQ
    EnumToStringVkSamplerAddressMode(out, pstruct->addressModeU);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->addressModeU);
    *out += ")";
    *out += "\n"; // GDS

    // VkSamplerAddressMode addressModeV // SMB
    IndentSpaces(out, indent);
    *out += "addressModeV:                   ";
    *out += "VkSamplerAddressMode = "; // TEQ
    EnumToStringVkSamplerAddressMode(out, pstruct->addressModeV);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->addressModeV);
    *out += ")";
    *out += "\n"; // GDS

    // VkSamplerAddressMode addressModeW // SMB
    IndentSpaces(out, indent);
    *out += "addressModeW:                   ";
    *out += "VkSamplerAddressMode = "; // TEQ
    EnumToStringVkSamplerAddressMode(out, pstruct->addressModeW);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->addressModeW);
    *out += ")";
    *out += "\n"; // GDS

    // float mipLodBias // SMB
    IndentSpaces(out, indent);
    *out += "mipLodBias:                     ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->mipLodBias);
    *out += "\n"; // GDS

    // VkBool32 anisotropyEnable // SMB
    IndentSpaces(out, indent);
    *out += "anisotropyEnable:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->anisotropyEnable);
    *out += "\n"; // GDS

    // float maxAnisotropy // SMB
    IndentSpaces(out, indent);
    *out += "maxAnisotropy:                  ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxAnisotropy);
    *out += "\n"; // GDS

    // VkBool32 compareEnable // SMB
    IndentSpaces(out, indent);
    *out += "compareEnable:                  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->compareEnable);
    *out += "\n"; // GDS

    // VkCompareOp compareOp // SMB
    IndentSpaces(out, indent);
    *out += "compareOp:                      ";
    *out += "VkCompareOp = "; // TEQ
    EnumToStringVkCompareOp(out, pstruct->compareOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->compareOp);
    *out += ")";
    *out += "\n"; // GDS

    // float minLod // SMB
    IndentSpaces(out, indent);
    *out += "minLod:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minLod);
    *out += "\n"; // GDS

    // float maxLod // SMB
    IndentSpaces(out, indent);
    *out += "maxLod:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxLod);
    *out += "\n"; // GDS

    // VkBorderColor borderColor // SMB
    IndentSpaces(out, indent);
    *out += "borderColor:                    ";
    *out += "VkBorderColor = "; // TEQ
    EnumToStringVkBorderColor(out, pstruct->borderColor);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->borderColor);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 unnormalizedCoordinates // SMB
    IndentSpaces(out, indent);
    *out += "unnormalizedCoordinates:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->unnormalizedCoordinates);
}

template <>
void StructureToString<Decoded_VkDescriptorSetLayoutBinding>(std::string* out, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetLayoutBinding *pstruct = (const VkDescriptorSetLayoutBinding *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t binding // SMB
    IndentSpaces(out, indent);
    *out += "binding:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->binding);
    *out += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount);
    *out += "\n"; // GDS

    // VkShaderStageFlags stageFlags // SMB
    IndentSpaces(out, indent);
    *out += "stageFlags:                     ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // const VkSampler* pImmutableSamplers // SMB
    IndentSpaces(out, indent);
    *out += "pImmutableSamplers:             ";
    *out += "const VkSampler* = "; // TEQ
    if (pstruct->pImmutableSamplers == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImmutableSamplers.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pImmutableSamplers = {true, false, false, nullptr};
        ArrayToString<const VkSampler*>(out, indent, 1, "const VkSampler*", reinterpret_cast<const VkSampler*>(pstruct_in.pImmutableSamplers.GetPointer()), "pImmutableSamplers", pstruct->descriptorCount,  vinfo_pImmutableSamplers);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(std::string* out, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetLayoutCreateInfo *pstruct = (const VkDescriptorSetLayoutCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDescriptorSetLayoutCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDescriptorSetLayoutCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDescriptorSetLayoutCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t bindingCount // SMB
    IndentSpaces(out, indent);
    *out += "bindingCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindingCount);
    *out += "\n"; // GDS

    // const VkDescriptorSetLayoutBinding* pBindings // SMB
    IndentSpaces(out, indent);
    *out += "pBindings:                      ";
    *out += "const VkDescriptorSetLayoutBinding* = "; // TEQ
    if (pstruct->pBindings == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBindings->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDescriptorSetLayoutBinding>(out, indent+1, 1, "VkDescriptorSetLayoutBinding", pstruct_in.pBindings->GetMetaStructPointer(), "pBindings", pstruct->bindingCount, false, pstruct_in.pBindings->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDescriptorPoolSize>(std::string* out, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorPoolSize *pstruct = (const VkDescriptorPoolSize *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDescriptorType type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount);
}

template <>
void StructureToString<Decoded_VkDescriptorPoolCreateInfo>(std::string* out, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorPoolCreateInfo *pstruct = (const VkDescriptorPoolCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDescriptorPoolCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDescriptorPoolCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDescriptorPoolCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t maxSets // SMB
    IndentSpaces(out, indent);
    *out += "maxSets:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSets);
    *out += "\n"; // GDS

    // uint32_t poolSizeCount // SMB
    IndentSpaces(out, indent);
    *out += "poolSizeCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->poolSizeCount);
    *out += "\n"; // GDS

    // const VkDescriptorPoolSize* pPoolSizes // SMB
    IndentSpaces(out, indent);
    *out += "pPoolSizes:                     ";
    *out += "const VkDescriptorPoolSize* = "; // TEQ
    if (pstruct->pPoolSizes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPoolSizes->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDescriptorPoolSize>(out, indent+1, 1, "VkDescriptorPoolSize", pstruct_in.pPoolSizes->GetMetaStructPointer(), "pPoolSizes", pstruct->poolSizeCount, false, pstruct_in.pPoolSizes->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDescriptorSetAllocateInfo>(std::string* out, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetAllocateInfo *pstruct = (const VkDescriptorSetAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDescriptorPool descriptorPool // SMB
    IndentSpaces(out, indent);
    *out += "descriptorPool:                 ";
    *out += "VkDescriptorPool = "; // TEQ
    AddrToString(out, pstruct_in.descriptorPool); // PAQ
    *out += "\n"; // GDS

    // uint32_t descriptorSetCount // SMB
    IndentSpaces(out, indent);
    *out += "descriptorSetCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorSetCount);
    *out += "\n"; // GDS

    // const VkDescriptorSetLayout* pSetLayouts // SMB
    IndentSpaces(out, indent);
    *out += "pSetLayouts:                    ";
    *out += "const VkDescriptorSetLayout* = "; // TEQ
    if (pstruct->pSetLayouts == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSetLayouts.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSetLayout*>(out, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pstruct_in.pSetLayouts.GetPointer()), "pSetLayouts", pstruct->descriptorSetCount,  vinfo_pSetLayouts);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkDescriptorImageInfo>(std::string* out, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorImageInfo *pstruct = (const VkDescriptorImageInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkSampler sampler // SMB
    IndentSpaces(out, indent);
    *out += "sampler:                        ";
    *out += "VkSampler = "; // TEQ
    AddrToString(out, pstruct_in.sampler); // PAQ
    *out += "\n"; // GDS

    // VkImageView imageView // SMB
    IndentSpaces(out, indent);
    *out += "imageView:                      ";
    *out += "VkImageView = "; // TEQ
    AddrToString(out, pstruct_in.imageView); // PAQ
    *out += "\n"; // GDS

    // VkImageLayout imageLayout // SMB
    IndentSpaces(out, indent);
    *out += "imageLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->imageLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkDescriptorBufferInfo>(std::string* out, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorBufferInfo *pstruct = (const VkDescriptorBufferInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // VkDeviceSize range // SMB
    IndentSpaces(out, indent);
    *out += "range:                          ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->range);
}

template <>
void StructureToString<Decoded_VkWriteDescriptorSet>(std::string* out, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWriteDescriptorSet *pstruct = (const VkWriteDescriptorSet *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDescriptorSet dstSet // SMB
    IndentSpaces(out, indent);
    *out += "dstSet:                         ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.dstSet); // PAQ
    *out += "\n"; // GDS

    // uint32_t dstBinding // SMB
    IndentSpaces(out, indent);
    *out += "dstBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstBinding);
    *out += "\n"; // GDS

    // uint32_t dstArrayElement // SMB
    IndentSpaces(out, indent);
    *out += "dstArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstArrayElement);
    *out += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount);
    *out += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // const VkDescriptorImageInfo* pImageInfo // SMB
    IndentSpaces(out, indent);
    *out += "pImageInfo:                     ";
    *out += "const VkDescriptorImageInfo* = "; // TEQ
    if (pstruct->pImageInfo == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageInfo->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDescriptorImageInfo>(out, indent+1, 1, "VkDescriptorImageInfo", pstruct_in.pImageInfo->GetMetaStructPointer(), "pImageInfo", pstruct->descriptorCount, false, pstruct_in.pImageInfo->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // const VkDescriptorBufferInfo* pBufferInfo // SMB
    IndentSpaces(out, indent);
    *out += "pBufferInfo:                    ";
    *out += "const VkDescriptorBufferInfo* = "; // TEQ
    if (pstruct->pBufferInfo == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pBufferInfo->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDescriptorBufferInfo>(out, indent+1, 1, "VkDescriptorBufferInfo", pstruct_in.pBufferInfo->GetMetaStructPointer(), "pBufferInfo", pstruct->descriptorCount, false, pstruct_in.pBufferInfo->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // const VkBufferView* pTexelBufferView // SMB
    IndentSpaces(out, indent);
    *out += "pTexelBufferView:               ";
    *out += "const VkBufferView* = "; // TEQ
    if (pstruct->pTexelBufferView == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTexelBufferView.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pTexelBufferView = {true, false, false, nullptr};
        ArrayToString<const VkBufferView*>(out, indent, 1, "const VkBufferView*", reinterpret_cast<const VkBufferView*>(pstruct_in.pTexelBufferView.GetPointer()), "pTexelBufferView", pstruct->descriptorCount,  vinfo_pTexelBufferView);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkCopyDescriptorSet>(std::string* out, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCopyDescriptorSet *pstruct = (const VkCopyDescriptorSet *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDescriptorSet srcSet // SMB
    IndentSpaces(out, indent);
    *out += "srcSet:                         ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.srcSet); // PAQ
    *out += "\n"; // GDS

    // uint32_t srcBinding // SMB
    IndentSpaces(out, indent);
    *out += "srcBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcBinding);
    *out += "\n"; // GDS

    // uint32_t srcArrayElement // SMB
    IndentSpaces(out, indent);
    *out += "srcArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcArrayElement);
    *out += "\n"; // GDS

    // VkDescriptorSet dstSet // SMB
    IndentSpaces(out, indent);
    *out += "dstSet:                         ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.dstSet); // PAQ
    *out += "\n"; // GDS

    // uint32_t dstBinding // SMB
    IndentSpaces(out, indent);
    *out += "dstBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstBinding);
    *out += "\n"; // GDS

    // uint32_t dstArrayElement // SMB
    IndentSpaces(out, indent);
    *out += "dstArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstArrayElement);
    *out += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount);
}

template <>
void StructureToString<Decoded_VkFramebufferCreateInfo>(std::string* out, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFramebufferCreateInfo *pstruct = (const VkFramebufferCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFramebufferCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFramebufferCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFramebufferCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount);
    *out += "\n"; // GDS

    // const VkImageView* pAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkImageView* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pAttachments = {true, false, false, nullptr};
        ArrayToString<const VkImageView*>(out, indent, 1, "const VkImageView*", reinterpret_cast<const VkImageView*>(pstruct_in.pAttachments.GetPointer()), "pAttachments", pstruct->attachmentCount,  vinfo_pAttachments);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t width // SMB
    IndentSpaces(out, indent);
    *out += "width:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->width);
    *out += "\n"; // GDS

    // uint32_t height // SMB
    IndentSpaces(out, indent);
    *out += "height:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->height);
    *out += "\n"; // GDS

    // uint32_t layers // SMB
    IndentSpaces(out, indent);
    *out += "layers:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layers);
}

template <>
void StructureToString<Decoded_VkAttachmentDescription>(std::string* out, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentDescription *pstruct = (const VkAttachmentDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkAttachmentDescriptionFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkAttachmentDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkAttachmentDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentLoadOp loadOp // SMB
    IndentSpaces(out, indent);
    *out += "loadOp:                         ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->loadOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->loadOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentStoreOp storeOp // SMB
    IndentSpaces(out, indent);
    *out += "storeOp:                        ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->storeOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->storeOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentLoadOp stencilLoadOp // SMB
    IndentSpaces(out, indent);
    *out += "stencilLoadOp:                  ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->stencilLoadOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilLoadOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentStoreOp stencilStoreOp // SMB
    IndentSpaces(out, indent);
    *out += "stencilStoreOp:                 ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->stencilStoreOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilStoreOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageLayout initialLayout // SMB
    IndentSpaces(out, indent);
    *out += "initialLayout:                  ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->initialLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->initialLayout);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageLayout finalLayout // SMB
    IndentSpaces(out, indent);
    *out += "finalLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->finalLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->finalLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkAttachmentReference>(std::string* out, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentReference *pstruct = (const VkAttachmentReference *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t attachment // SMB
    IndentSpaces(out, indent);
    *out += "attachment:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachment);
    *out += "\n"; // GDS

    // VkImageLayout layout // SMB
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->layout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->layout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSubpassDescription>(std::string* out, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDescription *pstruct = (const VkSubpassDescription *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkSubpassDescriptionFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSubpassDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSubpassDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t inputAttachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "inputAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->inputAttachmentCount);
    *out += "\n"; // GDS

    // const VkAttachmentReference* pInputAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pInputAttachments:              ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pInputAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInputAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(out, indent+1, 1, "VkAttachmentReference", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t colorAttachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "colorAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->colorAttachmentCount);
    *out += "\n"; // GDS

    // const VkAttachmentReference* pColorAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pColorAttachments:              ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pColorAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pColorAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(out, indent+1, 1, "VkAttachmentReference", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // const VkAttachmentReference* pResolveAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pResolveAttachments:            ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pResolveAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pResolveAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentReference>(out, indent+1, 1, "VkAttachmentReference", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // const VkAttachmentReference* pDepthStencilAttachment // SMB
    IndentSpaces(out, indent);
    *out += "pDepthStencilAttachment:        ";
    *out += "const VkAttachmentReference* = "; // TEQ
    if (pstruct->pDepthStencilAttachment == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDepthStencilAttachment->GetAddress()); // JHI
        StructureToString<Decoded_VkAttachmentReference>(out, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkSubpassDescription, pDepthStencilAttachment)); // GLM
    }
    *out += "\n"; // GDS

    // uint32_t preserveAttachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "preserveAttachmentCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->preserveAttachmentCount);
    *out += "\n"; // GDS

    // const uint32_t* pPreserveAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pPreserveAttachments:           ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pPreserveAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPreserveAttachments.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pstruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkSubpassDependency>(std::string* out, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDependency *pstruct = (const VkSubpassDependency *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t srcSubpass // SMB
    IndentSpaces(out, indent);
    *out += "srcSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcSubpass);
    *out += "\n"; // GDS

    // uint32_t dstSubpass // SMB
    IndentSpaces(out, indent);
    *out += "dstSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstSubpass);
    *out += "\n"; // GDS

    // VkPipelineStageFlags srcStageMask // SMB
    IndentSpaces(out, indent);
    *out += "srcStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // VkPipelineStageFlags dstStageMask // SMB
    IndentSpaces(out, indent);
    *out += "dstStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkDependencyFlags dependencyFlags // SMB
    IndentSpaces(out, indent);
    *out += "dependencyFlags:                ";
    *out += "VkDependencyFlags = "; // TEQ
    FlagsToString(out, pstruct->dependencyFlags, EnumToStringVkDependencyFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkRenderPassCreateInfo>(std::string* out, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassCreateInfo *pstruct = (const VkRenderPassCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkRenderPassCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkRenderPassCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkRenderPassCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount);
    *out += "\n"; // GDS

    // const VkAttachmentDescription* pAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkAttachmentDescription* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentDescription>(out, indent+1, 1, "VkAttachmentDescription", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t subpassCount // SMB
    IndentSpaces(out, indent);
    *out += "subpassCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassCount);
    *out += "\n"; // GDS

    // const VkSubpassDescription* pSubpasses // SMB
    IndentSpaces(out, indent);
    *out += "pSubpasses:                     ";
    *out += "const VkSubpassDescription* = "; // TEQ
    if (pstruct->pSubpasses == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSubpasses->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSubpassDescription>(out, indent+1, 1, "VkSubpassDescription", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t dependencyCount // SMB
    IndentSpaces(out, indent);
    *out += "dependencyCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dependencyCount);
    *out += "\n"; // GDS

    // const VkSubpassDependency* pDependencies // SMB
    IndentSpaces(out, indent);
    *out += "pDependencies:                  ";
    *out += "const VkSubpassDependency* = "; // TEQ
    if (pstruct->pDependencies == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDependencies->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSubpassDependency>(out, indent+1, 1, "VkSubpassDependency", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkCommandPoolCreateInfo>(std::string* out, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandPoolCreateInfo *pstruct = (const VkCommandPoolCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkCommandPoolCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandPoolCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkCommandPoolCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t queueFamilyIndex // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndex);
}

template <>
void StructureToString<Decoded_VkCommandBufferAllocateInfo>(std::string* out, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferAllocateInfo *pstruct = (const VkCommandBufferAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkCommandPool commandPool // SMB
    IndentSpaces(out, indent);
    *out += "commandPool:                    ";
    *out += "VkCommandPool = "; // TEQ
    AddrToString(out, pstruct_in.commandPool); // PAQ
    *out += "\n"; // GDS

    // VkCommandBufferLevel level // SMB
    IndentSpaces(out, indent);
    *out += "level:                          ";
    *out += "VkCommandBufferLevel = "; // TEQ
    EnumToStringVkCommandBufferLevel(out, pstruct->level);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->level);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t commandBufferCount // SMB
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->commandBufferCount);
}

template <>
void StructureToString<Decoded_VkCommandBufferInheritanceInfo>(std::string* out, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferInheritanceInfo *pstruct = (const VkCommandBufferInheritanceInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // uint32_t subpass // SMB
    IndentSpaces(out, indent);
    *out += "subpass:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpass);
    *out += "\n"; // GDS

    // VkFramebuffer framebuffer // SMB
    IndentSpaces(out, indent);
    *out += "framebuffer:                    ";
    *out += "VkFramebuffer = "; // TEQ
    AddrToString(out, pstruct_in.framebuffer); // PAQ
    *out += "\n"; // GDS

    // VkBool32 occlusionQueryEnable // SMB
    IndentSpaces(out, indent);
    *out += "occlusionQueryEnable:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->occlusionQueryEnable);
    *out += "\n"; // GDS

    // VkQueryControlFlags queryFlags // SMB
    IndentSpaces(out, indent);
    *out += "queryFlags:                     ";
    *out += "VkQueryControlFlags = "; // TEQ
    FlagsToString(out, pstruct->queryFlags, EnumToStringVkQueryControlFlagBits); // URW
    *out += "\n"; // GDS

    // VkQueryPipelineStatisticFlags pipelineStatistics // SMB
    IndentSpaces(out, indent);
    *out += "pipelineStatistics:             ";
    *out += "VkQueryPipelineStatisticFlags = "; // TEQ
    FlagsToString(out, pstruct->pipelineStatistics, EnumToStringVkQueryPipelineStatisticFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkCommandBufferBeginInfo>(std::string* out, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferBeginInfo *pstruct = (const VkCommandBufferBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkCommandBufferUsageFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkCommandBufferUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkCommandBufferUsageFlagBits); // URW
    *out += "\n"; // GDS

    // const VkCommandBufferInheritanceInfo* pInheritanceInfo // SMB
    IndentSpaces(out, indent);
    *out += "pInheritanceInfo:               ";
    *out += "const VkCommandBufferInheritanceInfo* = "; // TEQ
    if (pstruct->pInheritanceInfo == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInheritanceInfo->GetAddress()); // JHI
        StructureToString<Decoded_VkCommandBufferInheritanceInfo>(out, *pstruct_in.pInheritanceInfo->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkCommandBufferBeginInfo, pInheritanceInfo)); // GLM
    }
}

template <>
void StructureToString<Decoded_VkBufferCopy>(std::string* out, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferCopy *pstruct = (const VkBufferCopy *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDeviceSize srcOffset // SMB
    IndentSpaces(out, indent);
    *out += "srcOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->srcOffset);
    *out += "\n"; // GDS

    // VkDeviceSize dstOffset // SMB
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->dstOffset);
    *out += "\n"; // GDS

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
}

template <>
void StructureToString<Decoded_VkImageSubresourceLayers>(std::string* out, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSubresourceLayers *pstruct = (const VkImageSubresourceLayers *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t mipLevel // SMB
    IndentSpaces(out, indent);
    *out += "mipLevel:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->mipLevel);
    *out += "\n"; // GDS

    // uint32_t baseArrayLayer // SMB
    IndentSpaces(out, indent);
    *out += "baseArrayLayer:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseArrayLayer);
    *out += "\n"; // GDS

    // uint32_t layerCount // SMB
    IndentSpaces(out, indent);
    *out += "layerCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layerCount);
}

template <>
void StructureToString<Decoded_VkImageCopy>(std::string* out, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageCopy *pstruct = (const VkImageCopy *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageSubresourceLayers srcSubresource // SMB
    IndentSpaces(out, indent);
    *out += "srcSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageCopy, srcSubresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D srcOffset // SMB
    IndentSpaces(out, indent);
    *out += "srcOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.srcOffset, indent+1,  base_addr + offsetof(VkImageCopy, srcOffset)); // AZJ
    *out += "\n"; // GDS

    // VkImageSubresourceLayers dstSubresource // SMB
    IndentSpaces(out, indent);
    *out += "dstSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageCopy, dstSubresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D dstOffset // SMB
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.dstOffset, indent+1,  base_addr + offsetof(VkImageCopy, dstOffset)); // AZJ
    *out += "\n"; // GDS

    // VkExtent3D extent // SMB
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageCopy, extent)); // AZJ
}

template <>
void StructureToString<Decoded_VkImageBlit>(std::string* out, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageBlit *pstruct = (const VkImageBlit *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageSubresourceLayers srcSubresource // SMB
    IndentSpaces(out, indent);
    *out += "srcSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageBlit, srcSubresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D srcOffsets // SMB
    IndentSpaces(out, indent);
    *out += "srcOffsets:                     ";
    *out += "VkOffset3D[";
    *out += "2";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkImageBlit, srcOffsets)); // IYY
    ArrayOfStructsToString<Decoded_VkOffset3D>(out, indent+1, 0, "VkOffset3D", pstruct_in.srcOffsets->GetMetaStructPointer(), "srcOffsets", 2 , false, pstruct_in.srcOffsets->GetAddress()); // EPB
    *out += "\n"; // GDS

    // VkImageSubresourceLayers dstSubresource // SMB
    IndentSpaces(out, indent);
    *out += "dstSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageBlit, dstSubresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D dstOffsets // SMB
    IndentSpaces(out, indent);
    *out += "dstOffsets:                     ";
    *out += "VkOffset3D[";
    *out += "2";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkImageBlit, dstOffsets)); // IYY
    ArrayOfStructsToString<Decoded_VkOffset3D>(out, indent+1, 0, "VkOffset3D", pstruct_in.dstOffsets->GetMetaStructPointer(), "dstOffsets", 2 , false, pstruct_in.dstOffsets->GetAddress()); // EPB
}

template <>
void StructureToString<Decoded_VkBufferImageCopy>(std::string* out, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferImageCopy *pstruct = (const VkBufferImageCopy *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDeviceSize bufferOffset // SMB
    IndentSpaces(out, indent);
    *out += "bufferOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferOffset);
    *out += "\n"; // GDS

    // uint32_t bufferRowLength // SMB
    IndentSpaces(out, indent);
    *out += "bufferRowLength:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bufferRowLength);
    *out += "\n"; // GDS

    // uint32_t bufferImageHeight // SMB
    IndentSpaces(out, indent);
    *out += "bufferImageHeight:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bufferImageHeight);
    *out += "\n"; // GDS

    // VkImageSubresourceLayers imageSubresource // SMB
    IndentSpaces(out, indent);
    *out += "imageSubresource:               ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.imageSubresource, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageSubresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D imageOffset // SMB
    IndentSpaces(out, indent);
    *out += "imageOffset:                    ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.imageOffset, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageOffset)); // AZJ
    *out += "\n"; // GDS

    // VkExtent3D imageExtent // SMB
    IndentSpaces(out, indent);
    *out += "imageExtent:                    ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkBufferImageCopy, imageExtent)); // AZJ
}

template <>
void StructureToString<Decoded_VkClearColorValue>(std::string* out, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearColorValue *pstruct = (const VkClearColorValue *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // float float32 // SMB
    IndentSpaces(out, indent);
    *out += "float32:                        ";
    *out += "float[";
    *out += "4";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkClearColorValue, float32)); // IYY
    ValueToStringStruct vinfo_float32 = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->float32), "float32", 4, vinfo_float32); // JPA
    *out += "\n"; // GDS

    // int32_t int32 // SMB
    IndentSpaces(out, indent);
    *out += "int32:                          ";
    *out += "int32_t[";
    *out += "4";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkClearColorValue, int32)); // IYY
    ValueToStringStruct vinfo_int32 = {false, false, false, nullptr};
    ArrayToString<int32_t*>(out, indent, 0, "int32_t", const_cast<int32_t*>(pstruct->int32), "int32", 4, vinfo_int32); // JPA
    *out += "\n"; // GDS

    // uint32_t uint32 // SMB
    IndentSpaces(out, indent);
    *out += "uint32:                         ";
    *out += "uint32_t[";
    *out += "4";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkClearColorValue, uint32)); // IYY
    ValueToStringStruct vinfo_uint32 = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->uint32), "uint32", 4, vinfo_uint32); // JPA
}

template <>
void StructureToString<Decoded_VkClearDepthStencilValue>(std::string* out, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearDepthStencilValue *pstruct = (const VkClearDepthStencilValue *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // float depth // SMB
    IndentSpaces(out, indent);
    *out += "depth:                          ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->depth);
    *out += "\n"; // GDS

    // uint32_t stencil // SMB
    IndentSpaces(out, indent);
    *out += "stencil:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stencil);
}

template <>
void StructureToString<Decoded_VkClearValue>(std::string* out, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearValue *pstruct = (const VkClearValue *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkClearColorValue color // SMB
    IndentSpaces(out, indent);
    *out += "color:                          ";
    *out += "VkClearColorValue = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkClearColorValue>(out, (Decoded_VkClearColorValue&)pstruct_in, indent+1,  base_addr + offsetof(VkClearValue, color)); // RLN
    *out += "\n"; // GDS

    // VkClearDepthStencilValue depthStencil // SMB
    IndentSpaces(out, indent);
    *out += "depthStencil:                   ";
    *out += "VkClearDepthStencilValue = "; // TEQ
    StructureToString<Decoded_VkClearDepthStencilValue>(out, (Decoded_VkClearDepthStencilValue&)pstruct_in, indent+1,  base_addr + offsetof(VkClearValue, depthStencil)); // RLN
}

template <>
void StructureToString<Decoded_VkClearAttachment>(std::string* out, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearAttachment *pstruct = (const VkClearAttachment *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t colorAttachment // SMB
    IndentSpaces(out, indent);
    *out += "colorAttachment:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->colorAttachment);
    *out += "\n"; // GDS

    // VkClearValue clearValue // SMB
    IndentSpaces(out, indent);
    *out += "clearValue:                     ";
    *out += "VkClearValue = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkClearValue>(out, *pstruct_in.clearValue, indent+1,  base_addr + offsetof(VkClearAttachment, clearValue)); // AZJ
}

template <>
void StructureToString<Decoded_VkClearRect>(std::string* out, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkClearRect *pstruct = (const VkClearRect *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkRect2D rect // SMB
    IndentSpaces(out, indent);
    *out += "rect:                           ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.rect, indent+1,  base_addr + offsetof(VkClearRect, rect)); // AZJ
    *out += "\n"; // GDS

    // uint32_t baseArrayLayer // SMB
    IndentSpaces(out, indent);
    *out += "baseArrayLayer:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->baseArrayLayer);
    *out += "\n"; // GDS

    // uint32_t layerCount // SMB
    IndentSpaces(out, indent);
    *out += "layerCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->layerCount);
}

template <>
void StructureToString<Decoded_VkImageResolve>(std::string* out, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageResolve *pstruct = (const VkImageResolve *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageSubresourceLayers srcSubresource // SMB
    IndentSpaces(out, indent);
    *out += "srcSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.srcSubresource, indent+1,  base_addr + offsetof(VkImageResolve, srcSubresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D srcOffset // SMB
    IndentSpaces(out, indent);
    *out += "srcOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.srcOffset, indent+1,  base_addr + offsetof(VkImageResolve, srcOffset)); // AZJ
    *out += "\n"; // GDS

    // VkImageSubresourceLayers dstSubresource // SMB
    IndentSpaces(out, indent);
    *out += "dstSubresource:                 ";
    *out += "VkImageSubresourceLayers = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceLayers>(out, *pstruct_in.dstSubresource, indent+1,  base_addr + offsetof(VkImageResolve, dstSubresource)); // AZJ
    *out += "\n"; // GDS

    // VkOffset3D dstOffset // SMB
    IndentSpaces(out, indent);
    *out += "dstOffset:                      ";
    *out += "VkOffset3D = "; // TEQ
    StructureToString<Decoded_VkOffset3D>(out, *pstruct_in.dstOffset, indent+1,  base_addr + offsetof(VkImageResolve, dstOffset)); // AZJ
    *out += "\n"; // GDS

    // VkExtent3D extent // SMB
    IndentSpaces(out, indent);
    *out += "extent:                         ";
    *out += "VkExtent3D = "; // TEQ
    StructureToString<Decoded_VkExtent3D>(out, *pstruct_in.extent, indent+1,  base_addr + offsetof(VkImageResolve, extent)); // AZJ
}

template <>
void StructureToString<Decoded_VkMemoryBarrier>(std::string* out, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryBarrier *pstruct = (const VkMemoryBarrier *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkBufferMemoryBarrier>(std::string* out, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferMemoryBarrier *pstruct = (const VkBufferMemoryBarrier *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t srcQueueFamilyIndex // SMB
    IndentSpaces(out, indent);
    *out += "srcQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcQueueFamilyIndex);
    *out += "\n"; // GDS

    // uint32_t dstQueueFamilyIndex // SMB
    IndentSpaces(out, indent);
    *out += "dstQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstQueueFamilyIndex);
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // VkDeviceSize size // SMB
    IndentSpaces(out, indent);
    *out += "size:                           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->size);
}

template <>
void StructureToString<Decoded_VkImageMemoryBarrier>(std::string* out, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageMemoryBarrier *pstruct = (const VkImageMemoryBarrier *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkImageLayout oldLayout // SMB
    IndentSpaces(out, indent);
    *out += "oldLayout:                      ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->oldLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->oldLayout);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageLayout newLayout // SMB
    IndentSpaces(out, indent);
    *out += "newLayout:                      ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->newLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->newLayout);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t srcQueueFamilyIndex // SMB
    IndentSpaces(out, indent);
    *out += "srcQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcQueueFamilyIndex);
    *out += "\n"; // GDS

    // uint32_t dstQueueFamilyIndex // SMB
    IndentSpaces(out, indent);
    *out += "dstQueueFamilyIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstQueueFamilyIndex);
    *out += "\n"; // GDS

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // VkImageSubresourceRange subresourceRange // SMB
    IndentSpaces(out, indent);
    *out += "subresourceRange:               ";
    *out += "VkImageSubresourceRange = "; // TEQ
    StructureToString<Decoded_VkImageSubresourceRange>(out, *pstruct_in.subresourceRange, indent+1,  base_addr + offsetof(VkImageMemoryBarrier, subresourceRange)); // AZJ
}

template <>
void StructureToString<Decoded_VkRenderPassBeginInfo>(std::string* out, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassBeginInfo *pstruct = (const VkRenderPassBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    IndentSpaces(out, indent);
    *out += "renderPass:                     ";
    *out += "VkRenderPass = "; // TEQ
    AddrToString(out, pstruct_in.renderPass); // PAQ
    *out += "\n"; // GDS

    // VkFramebuffer framebuffer // SMB
    IndentSpaces(out, indent);
    *out += "framebuffer:                    ";
    *out += "VkFramebuffer = "; // TEQ
    AddrToString(out, pstruct_in.framebuffer); // PAQ
    *out += "\n"; // GDS

    // VkRect2D renderArea // SMB
    IndentSpaces(out, indent);
    *out += "renderArea:                     ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.renderArea, indent+1,  base_addr + offsetof(VkRenderPassBeginInfo, renderArea)); // AZJ
    *out += "\n"; // GDS

    // uint32_t clearValueCount // SMB
    IndentSpaces(out, indent);
    *out += "clearValueCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->clearValueCount);
    *out += "\n"; // GDS

    // const VkClearValue* pClearValues // SMB
    IndentSpaces(out, indent);
    *out += "pClearValues:                   ";
    *out += "const VkClearValue* = "; // TEQ
    if (pstruct->pClearValues == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pClearValues->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkClearValue>(out, indent+1, 1, "VkClearValue", pstruct_in.pClearValues->GetMetaStructPointer(), "pClearValues", pstruct->clearValueCount, true, pstruct_in.pClearValues->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDispatchIndirectCommand>(std::string* out, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDispatchIndirectCommand *pstruct = (const VkDispatchIndirectCommand *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t x // SMB
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->x);
    *out += "\n"; // GDS

    // uint32_t y // SMB
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->y);
    *out += "\n"; // GDS

    // uint32_t z // SMB
    IndentSpaces(out, indent);
    *out += "z:                              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->z);
}

template <>
void StructureToString<Decoded_VkDrawIndexedIndirectCommand>(std::string* out, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrawIndexedIndirectCommand *pstruct = (const VkDrawIndexedIndirectCommand *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t indexCount // SMB
    IndentSpaces(out, indent);
    *out += "indexCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->indexCount);
    *out += "\n"; // GDS

    // uint32_t instanceCount // SMB
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->instanceCount);
    *out += "\n"; // GDS

    // uint32_t firstIndex // SMB
    IndentSpaces(out, indent);
    *out += "firstIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstIndex);
    *out += "\n"; // GDS

    // int32_t vertexOffset // SMB
    IndentSpaces(out, indent);
    *out += "vertexOffset:                   ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexOffset);
    *out += "\n"; // GDS

    // uint32_t firstInstance // SMB
    IndentSpaces(out, indent);
    *out += "firstInstance:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstInstance);
}

template <>
void StructureToString<Decoded_VkDrawIndirectCommand>(std::string* out, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrawIndirectCommand *pstruct = (const VkDrawIndirectCommand *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t vertexCount // SMB
    IndentSpaces(out, indent);
    *out += "vertexCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexCount);
    *out += "\n"; // GDS

    // uint32_t instanceCount // SMB
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->instanceCount);
    *out += "\n"; // GDS

    // uint32_t firstVertex // SMB
    IndentSpaces(out, indent);
    *out += "firstVertex:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstVertex);
    *out += "\n"; // GDS

    // uint32_t firstInstance // SMB
    IndentSpaces(out, indent);
    *out += "firstInstance:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstInstance);
}

void VulkanAsciiConsumer::Process_vkCreateInstance(
    VkResult                                    returnValue,
    const StructPointerDecoder<Decoded_VkInstanceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkInstance>&     pInstance)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateInstance(pCreateInfo, pAllocator, pInstance)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // const VkInstanceCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkInstanceCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkInstanceCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkInstanceCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkInstance* pInstance // ARG
    if (pInstance.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkInstance* = NULL", indent_string.c_str(), "pInstance:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkInstance* = ", indent_string.c_str(), "pInstance:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pInstance.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyInstance(
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyInstance(instance, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDevices(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceCount,
    const HandlePointerDecoder<VkPhysicalDevice>& pPhysicalDevices)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPhysicalDeviceCount // ARG
    if (pPhysicalDeviceCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPhysicalDeviceCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPhysicalDeviceCount:", static_cast<uint64_t>(*pPhysicalDeviceCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDevice* pPhysicalDevices // ARG
    if (pPhysicalDevices.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDevice* = NULL", indent_string.c_str(), "pPhysicalDevices:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDevice* = ", indent_string.c_str(), "pPhysicalDevices:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pPhysicalDevices.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pPhysicalDevices = {true, false, false, nullptr};
        ArrayToString<VkPhysicalDevice*>(&tmp_string, 1, 1, "VkPhysicalDevice*", reinterpret_cast<VkPhysicalDevice*>(pPhysicalDevices.GetPointer()), "pPhysicalDevices", *pPhysicalDeviceCount.GetPointer(), vinfo_pPhysicalDevices); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures>& pFeatures)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceFeatures* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures* = NULL", indent_string.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures* = ", indent_string.c_str(), "pFeatures:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceFeatures>(&tmp_string, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties>& pFormatProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmp_string = "";
    EnumToStringVkFormat(&tmp_string,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indent_string.c_str(), "format:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkFormatProperties* pFormatProperties // ARG
    if (pFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties* = NULL", indent_string.c_str(), "pFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties* = ", indent_string.c_str(), "pFormatProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkFormatProperties>(&tmp_string, *pFormatProperties.GetMetaStructPointer(), 2, pFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    const StructPointerDecoder<Decoded_VkImageFormatProperties>& pImageFormatProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmp_string = "";
    EnumToStringVkFormat(&tmp_string,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indent_string.c_str(), "format:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageType type // ARG
    tmp_string = "";
    EnumToStringVkImageType(&tmp_string,type); // EPW
    fprintf(GetFile(), "%s%-32sVkImageType = %s", indent_string.c_str(), "type:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageTiling tiling // ARG
    tmp_string = "";
    EnumToStringVkImageTiling(&tmp_string,tiling); // EPW
    fprintf(GetFile(), "%s%-32sVkImageTiling = %s", indent_string.c_str(), "tiling:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageUsageFlags usage // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, usage, EnumToStringVkImageUsageFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageUsageFlags = %s", indent_string.c_str(), "usage:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageCreateFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkImageCreateFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageCreateFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageFormatProperties* pImageFormatProperties // ARG
    if (pImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties* = NULL", indent_string.c_str(), "pImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties* = ", indent_string.c_str(), "pImageFormatProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageFormatProperties>(&tmp_string, *pImageFormatProperties.GetMetaStructPointer(), 2, pImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceProperties* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties* = NULL", indent_string.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties* = ", indent_string.c_str(), "pProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceProperties>(&tmp_string, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties>& pQueueFamilyProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pQueueFamilyPropertyCount // ARG
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pQueueFamilyPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pQueueFamilyPropertyCount:", static_cast<uint64_t>(*pQueueFamilyPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueueFamilyProperties* pQueueFamilyProperties // ARG
    if (pQueueFamilyProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties* = NULL", indent_string.c_str(), "pQueueFamilyProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties* = ", indent_string.c_str(), "pQueueFamilyProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pQueueFamilyProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkQueueFamilyProperties>(&tmp_string, 2, 1, "VkQueueFamilyProperties",
            pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties>& pMemoryProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceMemoryProperties* pMemoryProperties // ARG
    if (pMemoryProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties* = NULL", indent_string.c_str(), "pMemoryProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties* = ", indent_string.c_str(), "pMemoryProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(&tmp_string, *pMemoryProperties.GetMetaStructPointer(), 2, pMemoryProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDevice(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDeviceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDevice>&       pDevice)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDeviceCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDevice* pDevice // ARG
    if (pDevice.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDevice* = NULL", indent_string.c_str(), "pDevice:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDevice* = ", indent_string.c_str(), "pDevice:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pDevice.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDevice(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyDevice(device, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceQueue(
    format::HandleId                            device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    const HandlePointerDecoder<VkQueue>&        pQueue)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queueIndex:", queueIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueue* pQueue // ARG
    if (pQueue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = NULL", indent_string.c_str(), "pQueue:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = ", indent_string.c_str(), "pQueue:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pQueue.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueSubmit(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    submitCount,
    const StructPointerDecoder<Decoded_VkSubmitInfo>& pSubmits,
    format::HandleId                            fence)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueueSubmit(queue, submitCount, pSubmits, fence)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t submitCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "submitCount:", submitCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubmitInfo* pSubmits // ARG
    if (pSubmits.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubmitInfo* = NULL", indent_string.c_str(), "pSubmits:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubmitInfo* = ", indent_string.c_str(), "pSubmits:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pSubmits.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSubmitInfo>(&tmp_string, 2, 1, "VkSubmitInfo",
            pSubmits.GetMetaStructPointer(), "pSubmits", submitCount, false, pSubmits.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indent_string.c_str(), "fence:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, fence);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueWaitIdle(
    VkResult                                    returnValue,
    format::HandleId                            queue)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueueWaitIdle(queue)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDeviceWaitIdle(
    VkResult                                    returnValue,
    format::HandleId                            device)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDeviceWaitIdle(device)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryAllocateInfo>& pAllocateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDeviceMemory>& pMemory)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryAllocateInfo* pAllocateInfo // ARG
    if (pAllocateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryAllocateInfo* = NULL", indent_string.c_str(), "pAllocateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryAllocateInfo* = ", indent_string.c_str(), "pAllocateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryAllocateInfo>(&tmp_string, *pAllocateInfo.GetMetaStructPointer(), 2, pAllocateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory* pMemory // ARG
    if (pMemory.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceMemory* = NULL", indent_string.c_str(), "pMemory:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceMemory* = ", indent_string.c_str(), "pMemory:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pMemory.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeMemory(
    format::HandleId                            device,
    format::HandleId                            memory,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkFreeMemory(device, memory, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indent_string.c_str(), "memory:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, memory);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkMapMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    const PointerDecoder<uint64_t>&             ppData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkMapMemory(device, memory, offset, size, flags, ppData)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indent_string.c_str(), "memory:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, memory);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize size // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "size:", size); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryMapFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkMemoryMapFlags = %d", indent_string.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    // void** ppData // ARG
    if (ppData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indent_string.c_str(), "ppData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indent_string.c_str(), "ppData:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(ppData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkUnmapMemory(
    format::HandleId                            device,
    format::HandleId                            memory)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkUnmapMemory(device, memory)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indent_string.c_str(), "memory:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, memory);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkFlushMappedMemoryRanges(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    const StructPointerDecoder<Decoded_VkMappedMemoryRange>& pMemoryRanges)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryRangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "memoryRangeCount:", memoryRangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMappedMemoryRange* pMemoryRanges // ARG
    if (pMemoryRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = NULL", indent_string.c_str(), "pMemoryRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = ", indent_string.c_str(), "pMemoryRanges:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRanges.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkMappedMemoryRange>(&tmp_string, 2, 1, "VkMappedMemoryRange",
            pMemoryRanges.GetMetaStructPointer(), "pMemoryRanges", memoryRangeCount, false, pMemoryRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkInvalidateMappedMemoryRanges(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    const StructPointerDecoder<Decoded_VkMappedMemoryRange>& pMemoryRanges)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryRangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "memoryRangeCount:", memoryRangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMappedMemoryRange* pMemoryRanges // ARG
    if (pMemoryRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = NULL", indent_string.c_str(), "pMemoryRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = ", indent_string.c_str(), "pMemoryRanges:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRanges.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkMappedMemoryRange>(&tmp_string, 2, 1, "VkMappedMemoryRange",
            pMemoryRanges.GetMetaStructPointer(), "pMemoryRanges", memoryRangeCount, false, pMemoryRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceMemoryCommitment(
    format::HandleId                            device,
    format::HandleId                            memory,
    const PointerDecoder<VkDeviceSize>&         pCommittedMemoryInBytes)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indent_string.c_str(), "memory:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, memory);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize* pCommittedMemoryInBytes // ARG
    if (pCommittedMemoryInBytes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceSize* = NULL", indent_string.c_str(), "pCommittedMemoryInBytes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceSize* = %" PRId64 "", indent_string.c_str(), "pCommittedMemoryInBytes:", static_cast<uint64_t>(*pCommittedMemoryInBytes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkBindBufferMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            buffer,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBindBufferMemory(device, buffer, memory, memoryOffset)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indent_string.c_str(), "memory:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, memory);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize memoryOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "memoryOffset:", memoryOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBindImageMemory(device, image, memory, memoryOffset)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indent_string.c_str(), "memory:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, memory);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize memoryOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "memoryOffset:", memoryOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            buffer,
    const StructPointerDecoder<Decoded_VkMemoryRequirements>& pMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = NULL", indent_string.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = ", indent_string.c_str(), "pMemoryRequirements:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryRequirements>(&tmp_string, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkMemoryRequirements>& pMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageMemoryRequirements(device, image, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = NULL", indent_string.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = ", indent_string.c_str(), "pMemoryRequirements:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryRequirements>(&tmp_string, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            image,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements>& pSparseMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSparseMemoryRequirementCount // ARG
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pSparseMemoryRequirementCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pSparseMemoryRequirementCount:", static_cast<uint64_t>(*pSparseMemoryRequirementCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageMemoryRequirements* pSparseMemoryRequirements // ARG
    if (pSparseMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements* = NULL", indent_string.c_str(), "pSparseMemoryRequirements:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements* = ", indent_string.c_str(), "pSparseMemoryRequirements:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pSparseMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements>(&tmp_string, 2, 1, "VkSparseImageMemoryRequirements",
            pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmp_string = "";
    EnumToStringVkFormat(&tmp_string,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indent_string.c_str(), "format:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageType type // ARG
    tmp_string = "";
    EnumToStringVkImageType(&tmp_string,type); // EPW
    fprintf(GetFile(), "%s%-32sVkImageType = %s", indent_string.c_str(), "type:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkSampleCountFlagBits samples // ARG
    tmp_string = "";
    EnumToStringVkSampleCountFlagBits(&tmp_string,samples); // EPW
    fprintf(GetFile(), "%s%-32sVkSampleCountFlagBits = %s", indent_string.c_str(), "samples:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageUsageFlags usage // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, usage, EnumToStringVkImageUsageFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageUsageFlags = %s", indent_string.c_str(), "usage:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageTiling tiling // ARG
    tmp_string = "";
    EnumToStringVkImageTiling(&tmp_string,tiling); // EPW
    fprintf(GetFile(), "%s%-32sVkImageTiling = %s", indent_string.c_str(), "tiling:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageFormatProperties* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSparseImageFormatProperties>(&tmp_string, 2, 1, "VkSparseImageFormatProperties",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueBindSparse(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindSparseInfo>& pBindInfo,
    format::HandleId                            fence)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindSparseInfo* pBindInfo // ARG
    if (pBindInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindSparseInfo* = NULL", indent_string.c_str(), "pBindInfo:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindSparseInfo* = ", indent_string.c_str(), "pBindInfo:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBindInfo.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBindSparseInfo>(&tmp_string, 2, 1, "VkBindSparseInfo",
            pBindInfo.GetMetaStructPointer(), "pBindInfo", bindInfoCount, false, pBindInfo.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indent_string.c_str(), "fence:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, fence);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateFence(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateFence(device, pCreateInfo, pAllocator, pFence)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFenceCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkFenceCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence* pFence // ARG
    if (pFence.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFence* = NULL", indent_string.c_str(), "pFence:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFence* = ", indent_string.c_str(), "pFence:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pFence.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyFence(
    format::HandleId                            device,
    format::HandleId                            fence,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyFence(device, fence, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indent_string.c_str(), "fence:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, fence);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkResetFences(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    const HandlePointerDecoder<VkFence>&        pFences)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkResetFences(device, fenceCount, pFences)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t fenceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "fenceCount:", fenceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkFence* pFences // ARG
    if (pFences.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = NULL", indent_string.c_str(), "pFences:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = ", indent_string.c_str(), "pFences:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pFences.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pFences = {true, false, false, nullptr};
        ArrayToString<const VkFence*>(&tmp_string, 1, 1, "const VkFence*", reinterpret_cast<const VkFence*>(pFences.GetPointer()), "pFences", fenceCount, vinfo_pFences); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetFenceStatus(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            fence)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetFenceStatus(device, fence)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indent_string.c_str(), "fence:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, fence);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkWaitForFences(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    const HandlePointerDecoder<VkFence>&        pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkWaitForFences(device, fenceCount, pFences, waitAll, timeout)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t fenceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "fenceCount:", fenceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkFence* pFences // ARG
    if (pFences.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = NULL", indent_string.c_str(), "pFences:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = ", indent_string.c_str(), "pFences:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pFences.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pFences = {true, false, false, nullptr};
        ArrayToString<const VkFence*>(&tmp_string, 1, 1, "const VkFence*", reinterpret_cast<const VkFence*>(pFences.GetPointer()), "pFences", fenceCount, vinfo_pFences); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32 waitAll // ARG
    fprintf(GetFile(), "%s%-32sVkBool32 = %u", indent_string.c_str(), "waitAll:", waitAll); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t timeout // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indent_string.c_str(), "timeout:", timeout); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSemaphore(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSemaphore>&    pSemaphore)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSemaphoreCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore* pSemaphore // ARG
    if (pSemaphore.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSemaphore* = NULL", indent_string.c_str(), "pSemaphore:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSemaphore* = ", indent_string.c_str(), "pSemaphore:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSemaphore.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySemaphore(
    format::HandleId                            device,
    format::HandleId                            semaphore,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroySemaphore(device, semaphore, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore semaphore // ARG
    fprintf(GetFile(), "%s%-32sVkSemaphore = ", indent_string.c_str(), "semaphore:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, semaphore);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkEventCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkEvent>&        pEvent)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateEvent(device, pCreateInfo, pAllocator, pEvent)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkEventCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkEventCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkEventCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkEventCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent* pEvent // ARG
    if (pEvent.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkEvent* = NULL", indent_string.c_str(), "pEvent:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkEvent* = ", indent_string.c_str(), "pEvent:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pEvent.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyEvent(
    format::HandleId                            device,
    format::HandleId                            event,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyEvent(device, event, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indent_string.c_str(), "event:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, event);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetEventStatus(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetEventStatus(device, event)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indent_string.c_str(), "event:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, event);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkSetEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkSetEvent(device, event)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indent_string.c_str(), "event:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, event);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkResetEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkResetEvent(device, event)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indent_string.c_str(), "event:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, event);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateQueryPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkQueryPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkQueryPool>&    pQueryPool)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkQueryPoolCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkQueryPoolCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkQueryPoolCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkQueryPoolCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool* pQueryPool // ARG
    if (pQueryPool.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueryPool* = NULL", indent_string.c_str(), "pQueryPool:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueryPool* = ", indent_string.c_str(), "pQueryPool:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pQueryPool.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyQueryPool(
    format::HandleId                            device,
    format::HandleId                            queryPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyQueryPool(device, queryPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetQueryPoolResults(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // size_t dataSize // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indent_string.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indent_string.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indent_string.c_str(), "pData:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize stride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryResultFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkQueryResultFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryResultFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateBuffer(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkBuffer>&       pBuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkBufferCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer* pBuffer // ARG
    if (pBuffer.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkBuffer* = NULL", indent_string.c_str(), "pBuffer:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkBuffer* = ", indent_string.c_str(), "pBuffer:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pBuffer.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyBuffer(
    format::HandleId                            device,
    format::HandleId                            buffer,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyBuffer(device, buffer, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateBufferView(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferViewCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkBufferView>&   pView)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateBufferView(device, pCreateInfo, pAllocator, pView)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferViewCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferViewCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferViewCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkBufferViewCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBufferView* pView // ARG
    if (pView.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkBufferView* = NULL", indent_string.c_str(), "pView:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkBufferView* = ", indent_string.c_str(), "pView:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pView.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyBufferView(
    format::HandleId                            device,
    format::HandleId                            bufferView,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyBufferView(device, bufferView, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBufferView bufferView // ARG
    fprintf(GetFile(), "%s%-32sVkBufferView = ", indent_string.c_str(), "bufferView:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, bufferView);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateImage(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkImage>&        pImage)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateImage(device, pCreateInfo, pAllocator, pImage)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImage* pImage // ARG
    if (pImage.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImage* = NULL", indent_string.c_str(), "pImage:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImage* = ", indent_string.c_str(), "pImage:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pImage.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyImage(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyImage(device, image, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSubresourceLayout(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkImageSubresource>& pSubresource,
    const StructPointerDecoder<Decoded_VkSubresourceLayout>& pLayout)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageSubresourceLayout(device, image, pSubresource, pLayout)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSubresource* pSubresource // ARG
    if (pSubresource.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresource* = NULL", indent_string.c_str(), "pSubresource:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresource* = ", indent_string.c_str(), "pSubresource:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSubresource.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageSubresource>(&tmp_string, *pSubresource.GetMetaStructPointer(), 2, pSubresource.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSubresourceLayout* pLayout // ARG
    if (pLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSubresourceLayout* = NULL", indent_string.c_str(), "pLayout:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSubresourceLayout* = ", indent_string.c_str(), "pLayout:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pLayout.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSubresourceLayout>(&tmp_string, *pLayout.GetMetaStructPointer(), 2, pLayout.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateImageView(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageViewCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkImageView>&    pView)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateImageView(device, pCreateInfo, pAllocator, pView)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageViewCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageViewCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImageView* pView // ARG
    if (pView.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageView* = NULL", indent_string.c_str(), "pView:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageView* = ", indent_string.c_str(), "pView:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pView.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyImageView(
    format::HandleId                            device,
    format::HandleId                            imageView,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyImageView(device, imageView, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageView imageView // ARG
    fprintf(GetFile(), "%s%-32sVkImageView = ", indent_string.c_str(), "imageView:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, imageView);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateShaderModule(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkShaderModuleCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkShaderModule>& pShaderModule)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkShaderModuleCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkShaderModuleCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkShaderModuleCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkShaderModuleCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderModule* pShaderModule // ARG
    if (pShaderModule.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkShaderModule* = NULL", indent_string.c_str(), "pShaderModule:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkShaderModule* = ", indent_string.c_str(), "pShaderModule:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pShaderModule.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyShaderModule(
    format::HandleId                            device,
    format::HandleId                            shaderModule,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyShaderModule(device, shaderModule, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderModule shaderModule // ARG
    fprintf(GetFile(), "%s%-32sVkShaderModule = ", indent_string.c_str(), "shaderModule:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, shaderModule);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreatePipelineCache(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineCacheCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipelineCache>& pPipelineCache)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineCacheCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCacheCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCacheCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPipelineCacheCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache* pPipelineCache // ARG
    if (pPipelineCache.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineCache* = NULL", indent_string.c_str(), "pPipelineCache:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineCache* = ", indent_string.c_str(), "pPipelineCache:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pPipelineCache.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipelineCache(
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyPipelineCache(device, pipelineCache, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indent_string.c_str(), "pipelineCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipelineCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineCacheData(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    const PointerDecoder<size_t>&               pDataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indent_string.c_str(), "pipelineCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipelineCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // size_t* pDataSize // ARG
    if (pDataSize.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32ssize_t* = NULL", indent_string.c_str(), "pDataSize:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32ssize_t* = %" PRId64 "", indent_string.c_str(), "pDataSize:", static_cast<uint64_t>(*pDataSize.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indent_string.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indent_string.c_str(), "pData:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkMergePipelineCaches(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    const HandlePointerDecoder<VkPipelineCache>& pSrcCaches)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache dstCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indent_string.c_str(), "dstCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t srcCacheCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "srcCacheCount:", srcCacheCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineCache* pSrcCaches // ARG
    if (pSrcCaches.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCache* = NULL", indent_string.c_str(), "pSrcCaches:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCache* = ", indent_string.c_str(), "pSrcCaches:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pSrcCaches.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pSrcCaches = {true, false, false, nullptr};
        ArrayToString<const VkPipelineCache*>(&tmp_string, 1, 1, "const VkPipelineCache*", reinterpret_cast<const VkPipelineCache*>(pSrcCaches.GetPointer()), "pSrcCaches", srcCacheCount, vinfo_pSrcCaches); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateGraphicsPipelines(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkGraphicsPipelineCreateInfo>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indent_string.c_str(), "pipelineCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipelineCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t createInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "createInfoCount:", createInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkGraphicsPipelineCreateInfo* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkGraphicsPipelineCreateInfo* = NULL", indent_string.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkGraphicsPipelineCreateInfo* = ", indent_string.c_str(), "pCreateInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkGraphicsPipelineCreateInfo>(&tmp_string, 2, 1, "VkGraphicsPipelineCreateInfo",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline* pPipelines // ARG
    if (pPipelines.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = NULL", indent_string.c_str(), "pPipelines:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = ", indent_string.c_str(), "pPipelines:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pPipelines.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        ArrayToString<VkPipeline*>(&tmp_string, 1, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount, vinfo_pPipelines); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateComputePipelines(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkComputePipelineCreateInfo>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indent_string.c_str(), "pipelineCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipelineCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t createInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "createInfoCount:", createInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkComputePipelineCreateInfo* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkComputePipelineCreateInfo* = NULL", indent_string.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkComputePipelineCreateInfo* = ", indent_string.c_str(), "pCreateInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkComputePipelineCreateInfo>(&tmp_string, 2, 1, "VkComputePipelineCreateInfo",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline* pPipelines // ARG
    if (pPipelines.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = NULL", indent_string.c_str(), "pPipelines:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = ", indent_string.c_str(), "pPipelines:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pPipelines.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        ArrayToString<VkPipeline*>(&tmp_string, 1, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount, vinfo_pPipelines); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipeline(
    format::HandleId                            device,
    format::HandleId                            pipeline,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyPipeline(device, pipeline, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indent_string.c_str(), "pipeline:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipeline);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreatePipelineLayout(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipelineLayout>& pPipelineLayout)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineLayoutCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineLayoutCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPipelineLayoutCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout* pPipelineLayout // ARG
    if (pPipelineLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineLayout* = NULL", indent_string.c_str(), "pPipelineLayout:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineLayout* = ", indent_string.c_str(), "pPipelineLayout:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pPipelineLayout.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipelineLayout(
    format::HandleId                            device,
    format::HandleId                            pipelineLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyPipelineLayout(device, pipelineLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout pipelineLayout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indent_string.c_str(), "pipelineLayout:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipelineLayout);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSampler(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSampler>&      pSampler)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateSampler(device, pCreateInfo, pAllocator, pSampler)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSamplerCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSamplerCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSampler* pSampler // ARG
    if (pSampler.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSampler* = NULL", indent_string.c_str(), "pSampler:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSampler* = ", indent_string.c_str(), "pSampler:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSampler.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySampler(
    format::HandleId                            device,
    format::HandleId                            sampler,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroySampler(device, sampler, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSampler sampler // ARG
    fprintf(GetFile(), "%s%-32sVkSampler = ", indent_string.c_str(), "sampler:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, sampler);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorSetLayout(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorSetLayout>& pSetLayout)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayout* pSetLayout // ARG
    if (pSetLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayout* = NULL", indent_string.c_str(), "pSetLayout:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayout* = ", indent_string.c_str(), "pSetLayout:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSetLayout.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorSetLayout(
    format::HandleId                            device,
    format::HandleId                            descriptorSetLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayout descriptorSetLayout // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorSetLayout = ", indent_string.c_str(), "descriptorSetLayout:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, descriptorSetLayout);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorPool>& pDescriptorPool)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorPoolCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorPoolCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorPoolCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorPoolCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool* pDescriptorPool // ARG
    if (pDescriptorPool.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorPool* = NULL", indent_string.c_str(), "pDescriptorPool:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorPool* = ", indent_string.c_str(), "pDescriptorPool:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pDescriptorPool.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorPool(
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyDescriptorPool(device, descriptorPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool descriptorPool // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPool = ", indent_string.c_str(), "descriptorPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, descriptorPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkResetDescriptorPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkResetDescriptorPool(device, descriptorPool, flags)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool descriptorPool // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPool = ", indent_string.c_str(), "descriptorPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, descriptorPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPoolResetFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPoolResetFlags = %d", indent_string.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateDescriptorSets(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetAllocateInfo>& pAllocateInfo,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetAllocateInfo* pAllocateInfo // ARG
    if (pAllocateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetAllocateInfo* = NULL", indent_string.c_str(), "pAllocateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetAllocateInfo* = ", indent_string.c_str(), "pAllocateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorSetAllocateInfo>(&tmp_string, *pAllocateInfo.GetMetaStructPointer(), 2, pAllocateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSet* pDescriptorSets // ARG
    if (pDescriptorSets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSet* = NULL", indent_string.c_str(), "pDescriptorSets:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSet* = ", indent_string.c_str(), "pDescriptorSets:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pDescriptorSets.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        ArrayToString<VkDescriptorSet*>(&tmp_string, 1, 1, "VkDescriptorSet*", reinterpret_cast<VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", pAllocateInfo.GetPointer()->descriptorSetCount, vinfo_pDescriptorSets); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeDescriptorSets(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool descriptorPool // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPool = ", indent_string.c_str(), "descriptorPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, descriptorPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorSetCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "descriptorSetCount:", descriptorSetCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSet* pDescriptorSets // ARG
    if (pDescriptorSets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = NULL", indent_string.c_str(), "pDescriptorSets:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = ", indent_string.c_str(), "pDescriptorSets:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pDescriptorSets.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSet*>(&tmp_string, 1, 1, "const VkDescriptorSet*", reinterpret_cast<const VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", descriptorSetCount, vinfo_pDescriptorSets); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkUpdateDescriptorSets(
    format::HandleId                            device,
    uint32_t                                    descriptorWriteCount,
    const StructPointerDecoder<Decoded_VkWriteDescriptorSet>& pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const StructPointerDecoder<Decoded_VkCopyDescriptorSet>& pDescriptorCopies)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorWriteCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "descriptorWriteCount:", descriptorWriteCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkWriteDescriptorSet* pDescriptorWrites // ARG
    if (pDescriptorWrites.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = NULL", indent_string.c_str(), "pDescriptorWrites:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = ", indent_string.c_str(), "pDescriptorWrites:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pDescriptorWrites.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkWriteDescriptorSet>(&tmp_string, 2, 1, "VkWriteDescriptorSet",
            pDescriptorWrites.GetMetaStructPointer(), "pDescriptorWrites", descriptorWriteCount, false, pDescriptorWrites.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorCopyCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "descriptorCopyCount:", descriptorCopyCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCopyDescriptorSet* pDescriptorCopies // ARG
    if (pDescriptorCopies.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCopyDescriptorSet* = NULL", indent_string.c_str(), "pDescriptorCopies:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCopyDescriptorSet* = ", indent_string.c_str(), "pDescriptorCopies:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pDescriptorCopies.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkCopyDescriptorSet>(&tmp_string, 2, 1, "VkCopyDescriptorSet",
            pDescriptorCopies.GetMetaStructPointer(), "pDescriptorCopies", descriptorCopyCount, false, pDescriptorCopies.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateFramebuffer(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFramebufferCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFramebuffer>&  pFramebuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFramebufferCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFramebufferCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFramebufferCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkFramebufferCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFramebuffer* pFramebuffer // ARG
    if (pFramebuffer.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFramebuffer* = NULL", indent_string.c_str(), "pFramebuffer:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFramebuffer* = ", indent_string.c_str(), "pFramebuffer:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pFramebuffer.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyFramebuffer(
    format::HandleId                            device,
    format::HandleId                            framebuffer,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyFramebuffer(device, framebuffer, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFramebuffer framebuffer // ARG
    fprintf(GetFile(), "%s%-32sVkFramebuffer = ", indent_string.c_str(), "framebuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, framebuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateRenderPass(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkRenderPassCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkRenderPass>&   pRenderPass)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkRenderPassCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass* pRenderPass // ARG
    if (pRenderPass.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = NULL", indent_string.c_str(), "pRenderPass:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = ", indent_string.c_str(), "pRenderPass:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pRenderPass.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyRenderPass(
    format::HandleId                            device,
    format::HandleId                            renderPass,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyRenderPass(device, renderPass, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass renderPass // ARG
    fprintf(GetFile(), "%s%-32sVkRenderPass = ", indent_string.c_str(), "renderPass:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, renderPass);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRenderAreaGranularity(
    format::HandleId                            device,
    format::HandleId                            renderPass,
    const StructPointerDecoder<Decoded_VkExtent2D>& pGranularity)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetRenderAreaGranularity(device, renderPass, pGranularity)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass renderPass // ARG
    fprintf(GetFile(), "%s%-32sVkRenderPass = ", indent_string.c_str(), "renderPass:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, renderPass);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExtent2D* pGranularity // ARG
    if (pGranularity.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExtent2D* = NULL", indent_string.c_str(), "pGranularity:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExtent2D* = ", indent_string.c_str(), "pGranularity:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pGranularity.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExtent2D>(&tmp_string, *pGranularity.GetMetaStructPointer(), 2, pGranularity.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateCommandPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkCommandPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkCommandPool>&  pCommandPool)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandPoolCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandPoolCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandPoolCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkCommandPoolCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool* pCommandPool // ARG
    if (pCommandPool.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCommandPool* = NULL", indent_string.c_str(), "pCommandPool:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCommandPool* = ", indent_string.c_str(), "pCommandPool:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pCommandPool.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyCommandPool(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyCommandPool(device, commandPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indent_string.c_str(), "commandPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkResetCommandPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolResetFlags                     flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkResetCommandPool(device, commandPool, flags)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indent_string.c_str(), "commandPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPoolResetFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkCommandPoolResetFlagBits);
    fprintf(GetFile(), "%s%-32sVkCommandPoolResetFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateCommandBuffers(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkCommandBufferAllocateInfo>& pAllocateInfo,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBufferAllocateInfo* pAllocateInfo // ARG
    if (pAllocateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferAllocateInfo* = NULL", indent_string.c_str(), "pAllocateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferAllocateInfo* = ", indent_string.c_str(), "pAllocateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkCommandBufferAllocateInfo>(&tmp_string, *pAllocateInfo.GetMetaStructPointer(), 2, pAllocateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandBuffer* pCommandBuffers // ARG
    if (pCommandBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCommandBuffer* = NULL", indent_string.c_str(), "pCommandBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCommandBuffer* = ", indent_string.c_str(), "pCommandBuffers:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pCommandBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<VkCommandBuffer*>(&tmp_string, 1, 1, "VkCommandBuffer*", reinterpret_cast<VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", pAllocateInfo.GetPointer()->commandBufferCount, vinfo_pCommandBuffers); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeCommandBuffers(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    uint32_t                                    commandBufferCount,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indent_string.c_str(), "commandPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t commandBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "commandBufferCount:", commandBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBuffer* pCommandBuffers // ARG
    if (pCommandBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = NULL", indent_string.c_str(), "pCommandBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = ", indent_string.c_str(), "pCommandBuffers:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pCommandBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<const VkCommandBuffer*>(&tmp_string, 1, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", commandBufferCount, vinfo_pCommandBuffers); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkBeginCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCommandBufferBeginInfo>& pBeginInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBeginCommandBuffer(commandBuffer, pBeginInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBufferBeginInfo* pBeginInfo // ARG
    if (pBeginInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferBeginInfo* = NULL", indent_string.c_str(), "pBeginInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferBeginInfo* = ", indent_string.c_str(), "pBeginInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pBeginInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkCommandBufferBeginInfo>(&tmp_string, *pBeginInfo.GetMetaStructPointer(), 2, pBeginInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkEndCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkEndCommandBuffer(commandBuffer)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkResetCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    VkCommandBufferResetFlags                   flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkResetCommandBuffer(commandBuffer, flags)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandBufferResetFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkCommandBufferResetFlagBits);
    fprintf(GetFile(), "%s%-32sVkCommandBufferResetFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindPipeline(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            pipeline)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineBindPoint pipelineBindPoint // ARG
    tmp_string = "";
    EnumToStringVkPipelineBindPoint(&tmp_string,pipelineBindPoint); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineBindPoint = %s", indent_string.c_str(), "pipelineBindPoint:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indent_string.c_str(), "pipeline:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipeline);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetViewport(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkViewport>& pViewports)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstViewport // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstViewport:", firstViewport); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t viewportCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "viewportCount:", viewportCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkViewport* pViewports // ARG
    if (pViewports.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkViewport* = NULL", indent_string.c_str(), "pViewports:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkViewport* = ", indent_string.c_str(), "pViewports:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pViewports.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkViewport>(&tmp_string, 2, 1, "VkViewport",
            pViewports.GetMetaStructPointer(), "pViewports", viewportCount, false, pViewports.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetScissor(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pScissors)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstScissor // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstScissor:", firstScissor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t scissorCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "scissorCount:", scissorCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRect2D* pScissors // ARG
    if (pScissors.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = NULL", indent_string.c_str(), "pScissors:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = ", indent_string.c_str(), "pScissors:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pScissors.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkRect2D>(&tmp_string, 2, 1, "VkRect2D",
            pScissors.GetMetaStructPointer(), "pScissors", scissorCount, false, pScissors.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetLineWidth(
    format::HandleId                            commandBuffer,
    float                                       lineWidth)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetLineWidth(commandBuffer, lineWidth)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // float lineWidth // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indent_string.c_str(), "lineWidth:", lineWidth); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDepthBias(
    format::HandleId                            commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // float depthBiasConstantFactor // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indent_string.c_str(), "depthBiasConstantFactor:", depthBiasConstantFactor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // float depthBiasClamp // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indent_string.c_str(), "depthBiasClamp:", depthBiasClamp); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // float depthBiasSlopeFactor // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indent_string.c_str(), "depthBiasSlopeFactor:", depthBiasSlopeFactor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetBlendConstants(
    format::HandleId                            commandBuffer,
    const PointerDecoder<float>&                blendConstants)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetBlendConstants(commandBuffer, blendConstants)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const float blendConstants // ARG
    tmp_string = "";
    ValueToStringStruct vinfo_blendConstants = {false, false, false, nullptr};
    ArrayToString<const float*>(&tmp_string, 2, 0, "const float", blendConstants.GetPointer(), "blendConstants", 4, vinfo_blendConstants); // SFP
    fprintf(GetFile(), "%s", tmp_string.c_str());
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDepthBounds(
    format::HandleId                            commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // float minDepthBounds // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indent_string.c_str(), "minDepthBounds:", minDepthBounds); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // float maxDepthBounds // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indent_string.c_str(), "maxDepthBounds:", maxDepthBounds); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilCompareMask(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkStencilFaceFlags faceMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, faceMask, EnumToStringVkStencilFaceFlagBits);
    fprintf(GetFile(), "%s%-32sVkStencilFaceFlags = %s", indent_string.c_str(), "faceMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t compareMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "compareMask:", compareMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilWriteMask(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkStencilFaceFlags faceMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, faceMask, EnumToStringVkStencilFaceFlagBits);
    fprintf(GetFile(), "%s%-32sVkStencilFaceFlags = %s", indent_string.c_str(), "faceMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t writeMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "writeMask:", writeMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilReference(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetStencilReference(commandBuffer, faceMask, reference)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkStencilFaceFlags faceMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, faceMask, EnumToStringVkStencilFaceFlagBits);
    fprintf(GetFile(), "%s%-32sVkStencilFaceFlags = %s", indent_string.c_str(), "faceMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t reference // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "reference:", reference); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindDescriptorSets(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const PointerDecoder<uint32_t>&             pDynamicOffsets)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineBindPoint pipelineBindPoint // ARG
    tmp_string = "";
    EnumToStringVkPipelineBindPoint(&tmp_string,pipelineBindPoint); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineBindPoint = %s", indent_string.c_str(), "pipelineBindPoint:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout layout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indent_string.c_str(), "layout:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, layout);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstSet // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstSet:", firstSet); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorSetCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "descriptorSetCount:", descriptorSetCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSet* pDescriptorSets // ARG
    if (pDescriptorSets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = NULL", indent_string.c_str(), "pDescriptorSets:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = ", indent_string.c_str(), "pDescriptorSets:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pDescriptorSets.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        ArrayToString<const VkDescriptorSet*>(&tmp_string, 1, 1, "const VkDescriptorSet*", reinterpret_cast<const VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", descriptorSetCount, vinfo_pDescriptorSets); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t dynamicOffsetCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "dynamicOffsetCount:", dynamicOffsetCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const uint32_t* pDynamicOffsets // ARG
    if (pDynamicOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = NULL", indent_string.c_str(), "pDynamicOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = %" PRId64 "", indent_string.c_str(), "pDynamicOffsets:", static_cast<uint64_t>(*pDynamicOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindIndexBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkIndexType indexType // ARG
    tmp_string = "";
    EnumToStringVkIndexType(&tmp_string,indexType); // EPW
    fprintf(GetFile(), "%s%-32sVkIndexType = %s", indent_string.c_str(), "indexType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindVertexBuffers(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const HandlePointerDecoder<VkBuffer>&       pBuffers,
    const PointerDecoder<VkDeviceSize>&         pOffsets)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstBinding // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstBinding:", firstBinding); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindingCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindingCount:", bindingCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pBuffers // ARG
    if (pBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indent_string.c_str(), "pBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indent_string.c_str(), "pBuffers:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(&tmp_string, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pBuffers.GetPointer()), "pBuffers", bindingCount, vinfo_pBuffers); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pOffsets // ARG
    if (pOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indent_string.c_str(), "pOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indent_string.c_str(), "pOffsets:", static_cast<uint64_t>(*pOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDraw(
    format::HandleId                            commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t vertexCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "vertexCount:", vertexCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t instanceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "instanceCount:", instanceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstVertex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstVertex:", firstVertex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstInstance // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstInstance:", firstInstance); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexed(
    format::HandleId                            commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t indexCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "indexCount:", indexCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t instanceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "instanceCount:", instanceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstIndex:", firstIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // int32_t vertexOffset // ARG
    fprintf(GetFile(), "%s%-32sint32_t = %d", indent_string.c_str(), "vertexOffset:", vertexOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstInstance // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstInstance:", firstInstance); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t drawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "drawCount:", drawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t drawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "drawCount:", drawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatch(
    format::HandleId                            commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountX:", groupCountX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountY:", groupCountY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountZ:", groupCountZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDispatchIndirect(commandBuffer, buffer, offset)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferCopy>& pRegions)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer srcBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "srcBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, srcBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "dstBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCopy* = NULL", indent_string.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCopy* = ", indent_string.c_str(), "pRegions:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBufferCopy>(&tmp_string, 2, 1, "VkBufferCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageCopy>& pRegions)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "srcImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, srcImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "srcImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "dstImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "dstImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCopy* = NULL", indent_string.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCopy* = ", indent_string.c_str(), "pRegions:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkImageCopy>(&tmp_string, 2, 1, "VkImageCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBlitImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageBlit>& pRegions,
    VkFilter                                    filter)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "srcImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, srcImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "srcImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "dstImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "dstImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageBlit* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageBlit* = NULL", indent_string.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageBlit* = ", indent_string.c_str(), "pRegions:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkImageBlit>(&tmp_string, 2, 1, "VkImageBlit",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFilter filter // ARG
    tmp_string = "";
    EnumToStringVkFilter(&tmp_string,filter); // EPW
    fprintf(GetFile(), "%s%-32sVkFilter = %s", indent_string.c_str(), "filter:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyBufferToImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferImageCopy>& pRegions)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer srcBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "srcBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, srcBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "dstImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "dstImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferImageCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = NULL", indent_string.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = ", indent_string.c_str(), "pRegions:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBufferImageCopy>(&tmp_string, 2, 1, "VkBufferImageCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyImageToBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferImageCopy>& pRegions)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "srcImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, srcImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "srcImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "dstBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferImageCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = NULL", indent_string.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = ", indent_string.c_str(), "pRegions:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBufferImageCopy>(&tmp_string, 2, 1, "VkBufferImageCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdUpdateBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "dstBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dataSize // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst void* = NULL", indent_string.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst void* = ", indent_string.c_str(), "pData:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdFillBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "dstBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize size // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "size:", size); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t data // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "data:", data); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearColorImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    const StructPointerDecoder<Decoded_VkClearColorValue>& pColor,
    uint32_t                                    rangeCount,
    const StructPointerDecoder<Decoded_VkImageSubresourceRange>& pRanges)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout imageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,imageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "imageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearColorValue* pColor // ARG
    if (pColor.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearColorValue* = NULL", indent_string.c_str(), "pColor:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearColorValue* = ", indent_string.c_str(), "pColor:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pColor.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkClearColorValue>(&tmp_string, *pColor.GetMetaStructPointer(), 2, pColor.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t rangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "rangeCount:", rangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSubresourceRange* pRanges // ARG
    if (pRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = NULL", indent_string.c_str(), "pRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = ", indent_string.c_str(), "pRanges:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRanges.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkImageSubresourceRange>(&tmp_string, 2, 1, "VkImageSubresourceRange",
            pRanges.GetMetaStructPointer(), "pRanges", rangeCount, false, pRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearDepthStencilImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    const StructPointerDecoder<Decoded_VkClearDepthStencilValue>& pDepthStencil,
    uint32_t                                    rangeCount,
    const StructPointerDecoder<Decoded_VkImageSubresourceRange>& pRanges)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout imageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,imageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "imageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearDepthStencilValue* pDepthStencil // ARG
    if (pDepthStencil.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearDepthStencilValue* = NULL", indent_string.c_str(), "pDepthStencil:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearDepthStencilValue* = ", indent_string.c_str(), "pDepthStencil:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pDepthStencil.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkClearDepthStencilValue>(&tmp_string, *pDepthStencil.GetMetaStructPointer(), 2, pDepthStencil.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t rangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "rangeCount:", rangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSubresourceRange* pRanges // ARG
    if (pRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = NULL", indent_string.c_str(), "pRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = ", indent_string.c_str(), "pRanges:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRanges.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkImageSubresourceRange>(&tmp_string, 2, 1, "VkImageSubresourceRange",
            pRanges.GetMetaStructPointer(), "pRanges", rangeCount, false, pRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearAttachments(
    format::HandleId                            commandBuffer,
    uint32_t                                    attachmentCount,
    const StructPointerDecoder<Decoded_VkClearAttachment>& pAttachments,
    uint32_t                                    rectCount,
    const StructPointerDecoder<Decoded_VkClearRect>& pRects)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t attachmentCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "attachmentCount:", attachmentCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearAttachment* pAttachments // ARG
    if (pAttachments.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearAttachment* = NULL", indent_string.c_str(), "pAttachments:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearAttachment* = ", indent_string.c_str(), "pAttachments:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pAttachments.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkClearAttachment>(&tmp_string, 2, 1, "VkClearAttachment",
            pAttachments.GetMetaStructPointer(), "pAttachments", attachmentCount, false, pAttachments.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t rectCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "rectCount:", rectCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearRect* pRects // ARG
    if (pRects.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearRect* = NULL", indent_string.c_str(), "pRects:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearRect* = ", indent_string.c_str(), "pRects:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRects.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkClearRect>(&tmp_string, 2, 1, "VkClearRect",
            pRects.GetMetaStructPointer(), "pRects", rectCount, false, pRects.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResolveImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageResolve>& pRegions)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "srcImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, srcImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "srcImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "dstImage:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstImage);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "dstImageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageResolve* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageResolve* = NULL", indent_string.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageResolve* = ", indent_string.c_str(), "pRegions:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkImageResolve>(&tmp_string, 2, 1, "VkImageResolve",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetEvent(
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetEvent(commandBuffer, event, stageMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indent_string.c_str(), "event:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, event);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags stageMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, stageMask, EnumToStringVkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indent_string.c_str(), "stageMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResetEvent(
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdResetEvent(commandBuffer, event, stageMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indent_string.c_str(), "event:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, event);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags stageMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, stageMask, EnumToStringVkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indent_string.c_str(), "stageMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWaitEvents(
    format::HandleId                            commandBuffer,
    uint32_t                                    eventCount,
    const HandlePointerDecoder<VkEvent>&        pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const StructPointerDecoder<Decoded_VkMemoryBarrier>& pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkBufferMemoryBarrier>& pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkImageMemoryBarrier>& pImageMemoryBarriers)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t eventCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "eventCount:", eventCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkEvent* pEvents // ARG
    if (pEvents.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkEvent* = NULL", indent_string.c_str(), "pEvents:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkEvent* = ", indent_string.c_str(), "pEvents:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pEvents.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pEvents = {true, false, false, nullptr};
        ArrayToString<const VkEvent*>(&tmp_string, 1, 1, "const VkEvent*", reinterpret_cast<const VkEvent*>(pEvents.GetPointer()), "pEvents", eventCount, vinfo_pEvents); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags srcStageMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, srcStageMask, EnumToStringVkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indent_string.c_str(), "srcStageMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags dstStageMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, dstStageMask, EnumToStringVkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indent_string.c_str(), "dstStageMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "memoryBarrierCount:", memoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryBarrier* pMemoryBarriers // ARG
    if (pMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = NULL", indent_string.c_str(), "pMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = ", indent_string.c_str(), "pMemoryBarriers:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkMemoryBarrier>(&tmp_string, 2, 1, "VkMemoryBarrier",
            pMemoryBarriers.GetMetaStructPointer(), "pMemoryBarriers", memoryBarrierCount, false, pMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bufferMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bufferMemoryBarrierCount:", bufferMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryBarrier* pBufferMemoryBarriers // ARG
    if (pBufferMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = NULL", indent_string.c_str(), "pBufferMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = ", indent_string.c_str(), "pBufferMemoryBarriers:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBufferMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBufferMemoryBarrier>(&tmp_string, 2, 1, "VkBufferMemoryBarrier",
            pBufferMemoryBarriers.GetMetaStructPointer(), "pBufferMemoryBarriers", bufferMemoryBarrierCount, false, pBufferMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t imageMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "imageMemoryBarrierCount:", imageMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryBarrier* pImageMemoryBarriers // ARG
    if (pImageMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = NULL", indent_string.c_str(), "pImageMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = ", indent_string.c_str(), "pImageMemoryBarriers:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pImageMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkImageMemoryBarrier>(&tmp_string, 2, 1, "VkImageMemoryBarrier",
            pImageMemoryBarriers.GetMetaStructPointer(), "pImageMemoryBarriers", imageMemoryBarrierCount, false, pImageMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdPipelineBarrier(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const StructPointerDecoder<Decoded_VkMemoryBarrier>& pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkBufferMemoryBarrier>& pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkImageMemoryBarrier>& pImageMemoryBarriers)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags srcStageMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, srcStageMask, EnumToStringVkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indent_string.c_str(), "srcStageMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags dstStageMask // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, dstStageMask, EnumToStringVkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indent_string.c_str(), "dstStageMask:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDependencyFlags dependencyFlags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, dependencyFlags, EnumToStringVkDependencyFlagBits);
    fprintf(GetFile(), "%s%-32sVkDependencyFlags = %s", indent_string.c_str(), "dependencyFlags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "memoryBarrierCount:", memoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryBarrier* pMemoryBarriers // ARG
    if (pMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = NULL", indent_string.c_str(), "pMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = ", indent_string.c_str(), "pMemoryBarriers:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkMemoryBarrier>(&tmp_string, 2, 1, "VkMemoryBarrier",
            pMemoryBarriers.GetMetaStructPointer(), "pMemoryBarriers", memoryBarrierCount, false, pMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bufferMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bufferMemoryBarrierCount:", bufferMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryBarrier* pBufferMemoryBarriers // ARG
    if (pBufferMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = NULL", indent_string.c_str(), "pBufferMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = ", indent_string.c_str(), "pBufferMemoryBarriers:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBufferMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBufferMemoryBarrier>(&tmp_string, 2, 1, "VkBufferMemoryBarrier",
            pBufferMemoryBarriers.GetMetaStructPointer(), "pBufferMemoryBarriers", bufferMemoryBarrierCount, false, pBufferMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t imageMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "imageMemoryBarrierCount:", imageMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryBarrier* pImageMemoryBarriers // ARG
    if (pImageMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = NULL", indent_string.c_str(), "pImageMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = ", indent_string.c_str(), "pImageMemoryBarriers:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pImageMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkImageMemoryBarrier>(&tmp_string, 2, 1, "VkImageMemoryBarrier",
            pImageMemoryBarriers.GetMetaStructPointer(), "pImageMemoryBarriers", imageMemoryBarrierCount, false, pImageMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginQuery(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBeginQuery(commandBuffer, queryPool, query, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryControlFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkQueryControlFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryControlFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndQuery(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdEndQuery(commandBuffer, queryPool, query)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResetQueryPool(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWriteTimestamp(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlagBits pipelineStage // ARG
    tmp_string = "";
    EnumToStringVkPipelineStageFlagBits(&tmp_string,pipelineStage); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlagBits = %s", indent_string.c_str(), "pipelineStage:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyQueryPoolResults(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "dstBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize stride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryResultFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkQueryResultFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryResultFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdPushConstants(
    format::HandleId                            commandBuffer,
    format::HandleId                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const PointerDecoder<uint8_t>&              pValues)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout layout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indent_string.c_str(), "layout:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, layout);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderStageFlags stageFlags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, stageFlags, EnumToStringVkShaderStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkShaderStageFlags = %s", indent_string.c_str(), "stageFlags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t offset // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t size // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "size:", size); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const void* pValues // ARG
    if (pValues.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst void* = NULL", indent_string.c_str(), "pValues:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst void* = ", indent_string.c_str(), "pValues:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pValues.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginRenderPass(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkRenderPassBeginInfo>& pRenderPassBegin,
    VkSubpassContents                           contents)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassBeginInfo* pRenderPassBegin // ARG
    if (pRenderPassBegin.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = NULL", indent_string.c_str(), "pRenderPassBegin:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = ", indent_string.c_str(), "pRenderPassBegin:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pRenderPassBegin.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkRenderPassBeginInfo>(&tmp_string, *pRenderPassBegin.GetMetaStructPointer(), 2, pRenderPassBegin.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSubpassContents contents // ARG
    tmp_string = "";
    EnumToStringVkSubpassContents(&tmp_string,contents); // EPW
    fprintf(GetFile(), "%s%-32sVkSubpassContents = %s", indent_string.c_str(), "contents:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdNextSubpass(
    format::HandleId                            commandBuffer,
    VkSubpassContents                           contents)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdNextSubpass(commandBuffer, contents)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSubpassContents contents // ARG
    tmp_string = "";
    EnumToStringVkSubpassContents(&tmp_string,contents); // EPW
    fprintf(GetFile(), "%s%-32sVkSubpassContents = %s", indent_string.c_str(), "contents:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndRenderPass(
    format::HandleId                            commandBuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdEndRenderPass(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdExecuteCommands(
    format::HandleId                            commandBuffer,
    uint32_t                                    commandBufferCount,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t commandBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "commandBufferCount:", commandBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBuffer* pCommandBuffers // ARG
    if (pCommandBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = NULL", indent_string.c_str(), "pCommandBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = ", indent_string.c_str(), "pCommandBuffers:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pCommandBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        ArrayToString<const VkCommandBuffer*>(&tmp_string, 1, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", commandBufferCount, vinfo_pCommandBuffers); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkSemaphoreImportFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkSemaphoreImportFlagBits e = static_cast<VkSemaphoreImportFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SEMAPHORE_IMPORT_TEMPORARY_BIT:
            *out += std::string("VK_SEMAPHORE_IMPORT_TEMPORARY_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkChromaLocation(std::string* out, uint32_t enum_uint32)
{
    VkChromaLocation e = static_cast<VkChromaLocation>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_CHROMA_LOCATION_MIDPOINT:
            *out += std::string("VK_CHROMA_LOCATION_MIDPOINT");
            return;
        case VK_CHROMA_LOCATION_COSITED_EVEN:
            *out += std::string("VK_CHROMA_LOCATION_COSITED_EVEN");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkExternalMemoryHandleTypeFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkExternalMemoryHandleTypeFlagBits e = static_cast<VkExternalMemoryHandleTypeFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSubgroupFeatureFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkSubgroupFeatureFlagBits e = static_cast<VkSubgroupFeatureFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT");
            return;
        case VK_SUBGROUP_FEATURE_BASIC_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_BASIC_BIT");
            return;
        case VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV:
            *out += std::string("VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV");
            return;
        case VK_SUBGROUP_FEATURE_VOTE_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_VOTE_BIT");
            return;
        case VK_SUBGROUP_FEATURE_SHUFFLE_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_SHUFFLE_BIT");
            return;
        case VK_SUBGROUP_FEATURE_ARITHMETIC_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_ARITHMETIC_BIT");
            return;
        case VK_SUBGROUP_FEATURE_BALLOT_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_BALLOT_BIT");
            return;
        case VK_SUBGROUP_FEATURE_CLUSTERED_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_CLUSTERED_BIT");
            return;
        case VK_SUBGROUP_FEATURE_QUAD_BIT:
            *out += std::string("VK_SUBGROUP_FEATURE_QUAD_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSamplerYcbcrRange(std::string* out, uint32_t enum_uint32)
{
    VkSamplerYcbcrRange e = static_cast<VkSamplerYcbcrRange>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SAMPLER_YCBCR_RANGE_ITU_NARROW:
            *out += std::string("VK_SAMPLER_YCBCR_RANGE_ITU_NARROW");
            return;
        case VK_SAMPLER_YCBCR_RANGE_ITU_FULL:
            *out += std::string("VK_SAMPLER_YCBCR_RANGE_ITU_FULL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkFenceImportFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkFenceImportFlagBits e = static_cast<VkFenceImportFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FENCE_IMPORT_TEMPORARY_BIT:
            *out += std::string("VK_FENCE_IMPORT_TEMPORARY_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkExternalFenceHandleTypeFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkExternalFenceHandleTypeFlagBits e = static_cast<VkExternalFenceHandleTypeFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:
            *out += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT");
            return;
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
            *out += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT");
            return;
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
            *out += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
            return;
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
            *out += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkExternalFenceFeatureFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkExternalFenceFeatureFlagBits e = static_cast<VkExternalFenceFeatureFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT:
            *out += std::string("VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT");
            return;
        case VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT:
            *out += std::string("VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPeerMemoryFeatureFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkPeerMemoryFeatureFlagBits e = static_cast<VkPeerMemoryFeatureFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT:
            *out += std::string("VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT");
            return;
        case VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT:
            *out += std::string("VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT");
            return;
        case VK_PEER_MEMORY_FEATURE_COPY_DST_BIT:
            *out += std::string("VK_PEER_MEMORY_FEATURE_COPY_DST_BIT");
            return;
        case VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT:
            *out += std::string("VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkExternalSemaphoreFeatureFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkExternalSemaphoreFeatureFlagBits e = static_cast<VkExternalSemaphoreFeatureFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT:
            *out += std::string("VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT:
            *out += std::string("VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkMemoryAllocateFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkMemoryAllocateFlagBits e = static_cast<VkMemoryAllocateFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT:
            *out += std::string("VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPointClippingBehavior(std::string* out, uint32_t enum_uint32)
{
    VkPointClippingBehavior e = static_cast<VkPointClippingBehavior>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:
            *out += std::string("VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES");
            return;
        case VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY:
            *out += std::string("VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDescriptorUpdateTemplateType(std::string* out, uint32_t enum_uint32)
{
    VkDescriptorUpdateTemplateType e = static_cast<VkDescriptorUpdateTemplateType>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET:
            *out += std::string("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET");
            return;
        case VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR:
            *out += std::string("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkTessellationDomainOrigin(std::string* out, uint32_t enum_uint32)
{
    VkTessellationDomainOrigin e = static_cast<VkTessellationDomainOrigin>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT:
            *out += std::string("VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT");
            return;
        case VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT:
            *out += std::string("VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkExternalMemoryFeatureFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkExternalMemoryFeatureFlagBits e = static_cast<VkExternalMemoryFeatureFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT:
            *out += std::string("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSamplerYcbcrModelConversion(std::string* out, uint32_t enum_uint32)
{
    VkSamplerYcbcrModelConversion e = static_cast<VkSamplerYcbcrModelConversion>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY:
            *out += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601:
            *out += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY:
            *out += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709:
            *out += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020:
            *out += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkExternalSemaphoreHandleTypeFlagBits(std::string* out, uint32_t enum_uint32)
{
    VkExternalSemaphoreHandleTypeFlagBits e = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:
            *out += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
            *out += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT:
            *out += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
            *out += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
            *out += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPhysicalDeviceSubgroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindBufferMemoryInfo>(std::string* out, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImageMemoryInfo>(std::string* out, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDevice16BitStorageFeatures>(std::string* out, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryDedicatedRequirements>(std::string* out, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryDedicatedAllocateInfo>(std::string* out, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryAllocateFlagsInfo>(std::string* out, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupRenderPassBeginInfo>(std::string* out, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupCommandBufferBeginInfo>(std::string* out, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupSubmitInfo>(std::string* out, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupBindSparseInfo>(std::string* out, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindBufferMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImageMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceGroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(std::string* out, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryRequirements2>(std::string* out, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageMemoryRequirements2>(std::string* out, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceFeatures2>(std::string* out, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProperties2>(std::string* out, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFormatProperties2>(std::string* out, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageFormatProperties2>(std::string* out, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueueFamilyProperties2>(std::string* out, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSparseImageFormatProperties2>(std::string* out, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDevicePointClippingProperties>(std::string* out, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkInputAttachmentAspectReference>(std::string* out, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>(std::string* out, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageViewUsageCreateInfo>(std::string* out, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassMultiviewCreateInfo>(std::string* out, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMultiviewFeatures>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMultiviewProperties>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceVariablePointersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceQueueInfo2>(std::string* out, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkProtectedSubmitInfo>(std::string* out, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerYcbcrConversionInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImagePlaneMemoryInfo>(std::string* out, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImagePlaneMemoryRequirementsInfo>(std::string* out, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(std::string* out, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSamplerYcbcrConversionImageFormatProperties>(std::string* out, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorUpdateTemplateEntry>(std::string* out, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(std::string* out, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalMemoryProperties>(std::string* out, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalImageFormatInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalImageFormatProperties>(std::string* out, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalBufferProperties>(std::string* out, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceIDProperties>(std::string* out, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalMemoryImageCreateInfo>(std::string* out, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalMemoryBufferCreateInfo>(std::string* out, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportMemoryAllocateInfo>(std::string* out, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalFenceProperties>(std::string* out, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportFenceCreateInfo>(std::string* out, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportSemaphoreCreateInfo>(std::string* out, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalSemaphoreProperties>(std::string* out, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMaintenance3Properties>(std::string* out, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDescriptorSetLayoutSupport>(std::string* out, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceSubgroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSubgroupProperties *pstruct = (const VkPhysicalDeviceSubgroupProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t subgroupSize // SMB
    IndentSpaces(out, indent);
    *out += "subgroupSize:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subgroupSize);
    *out += "\n"; // GDS

    // VkShaderStageFlags supportedStages // SMB
    IndentSpaces(out, indent);
    *out += "supportedStages:                ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedStages, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // VkSubgroupFeatureFlags supportedOperations // SMB
    IndentSpaces(out, indent);
    *out += "supportedOperations:            ";
    *out += "VkSubgroupFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedOperations, EnumToStringVkSubgroupFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // VkBool32 quadOperationsInAllStages // SMB
    IndentSpaces(out, indent);
    *out += "quadOperationsInAllStages:      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->quadOperationsInAllStages);
}

template <>
void StructureToString<Decoded_VkBindBufferMemoryInfo>(std::string* out, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindBufferMemoryInfo *pstruct = (const VkBindBufferMemoryInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset);
}

template <>
void StructureToString<Decoded_VkBindImageMemoryInfo>(std::string* out, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImageMemoryInfo *pstruct = (const VkBindImageMemoryInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset);
}

template <>
void StructureToString<Decoded_VkPhysicalDevice16BitStorageFeatures>(std::string* out, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevice16BitStorageFeatures *pstruct = (const VkPhysicalDevice16BitStorageFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 storageBuffer16BitAccess // SMB
    IndentSpaces(out, indent);
    *out += "storageBuffer16BitAccess:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->storageBuffer16BitAccess);
    *out += "\n"; // GDS

    // VkBool32 uniformAndStorageBuffer16BitAccess // SMB
    IndentSpaces(out, indent);
    *out += "uniformAndStorageBuffer16BitAccess: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->uniformAndStorageBuffer16BitAccess);
    *out += "\n"; // GDS

    // VkBool32 storagePushConstant16 // SMB
    IndentSpaces(out, indent);
    *out += "storagePushConstant16:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->storagePushConstant16);
    *out += "\n"; // GDS

    // VkBool32 storageInputOutput16 // SMB
    IndentSpaces(out, indent);
    *out += "storageInputOutput16:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->storageInputOutput16);
}

template <>
void StructureToString<Decoded_VkMemoryDedicatedRequirements>(std::string* out, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryDedicatedRequirements *pstruct = (const VkMemoryDedicatedRequirements *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 prefersDedicatedAllocation // SMB
    IndentSpaces(out, indent);
    *out += "prefersDedicatedAllocation:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->prefersDedicatedAllocation);
    *out += "\n"; // GDS

    // VkBool32 requiresDedicatedAllocation // SMB
    IndentSpaces(out, indent);
    *out += "requiresDedicatedAllocation:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->requiresDedicatedAllocation);
}

template <>
void StructureToString<Decoded_VkMemoryDedicatedAllocateInfo>(std::string* out, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryDedicatedAllocateInfo *pstruct = (const VkMemoryDedicatedAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkMemoryAllocateFlagsInfo>(std::string* out, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryAllocateFlagsInfo *pstruct = (const VkMemoryAllocateFlagsInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkMemoryAllocateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMemoryAllocateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkMemoryAllocateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t deviceMask // SMB
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask);
}

template <>
void StructureToString<Decoded_VkDeviceGroupRenderPassBeginInfo>(std::string* out, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupRenderPassBeginInfo *pstruct = (const VkDeviceGroupRenderPassBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t deviceMask // SMB
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask);
    *out += "\n"; // GDS

    // uint32_t deviceRenderAreaCount // SMB
    IndentSpaces(out, indent);
    *out += "deviceRenderAreaCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceRenderAreaCount);
    *out += "\n"; // GDS

    // const VkRect2D* pDeviceRenderAreas // SMB
    IndentSpaces(out, indent);
    *out += "pDeviceRenderAreas:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pDeviceRenderAreas == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceRenderAreas->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pDeviceRenderAreas->GetMetaStructPointer(), "pDeviceRenderAreas", pstruct->deviceRenderAreaCount, false, pstruct_in.pDeviceRenderAreas->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDeviceGroupCommandBufferBeginInfo>(std::string* out, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupCommandBufferBeginInfo *pstruct = (const VkDeviceGroupCommandBufferBeginInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t deviceMask // SMB
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask);
}

template <>
void StructureToString<Decoded_VkDeviceGroupSubmitInfo>(std::string* out, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupSubmitInfo *pstruct = (const VkDeviceGroupSubmitInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount);
    *out += "\n"; // GDS

    // const uint32_t* pWaitSemaphoreDeviceIndices // SMB
    IndentSpaces(out, indent);
    *out += "pWaitSemaphoreDeviceIndices:    ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pWaitSemaphoreDeviceIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphoreDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphoreDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pWaitSemaphoreDeviceIndices.GetPointer()), "pWaitSemaphoreDeviceIndices", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphoreDeviceIndices);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t commandBufferCount // SMB
    IndentSpaces(out, indent);
    *out += "commandBufferCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->commandBufferCount);
    *out += "\n"; // GDS

    // const uint32_t* pCommandBufferDeviceMasks // SMB
    IndentSpaces(out, indent);
    *out += "pCommandBufferDeviceMasks:      ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCommandBufferDeviceMasks == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCommandBufferDeviceMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCommandBufferDeviceMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCommandBufferDeviceMasks.GetPointer()), "pCommandBufferDeviceMasks", pstruct->commandBufferCount,  vinfo_pCommandBufferDeviceMasks);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t signalSemaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "signalSemaphoreCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreCount);
    *out += "\n"; // GDS

    // const uint32_t* pSignalSemaphoreDeviceIndices // SMB
    IndentSpaces(out, indent);
    *out += "pSignalSemaphoreDeviceIndices:  ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pSignalSemaphoreDeviceIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphoreDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphoreDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pSignalSemaphoreDeviceIndices.GetPointer()), "pSignalSemaphoreDeviceIndices", pstruct->signalSemaphoreCount,  vinfo_pSignalSemaphoreDeviceIndices);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkDeviceGroupBindSparseInfo>(std::string* out, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupBindSparseInfo *pstruct = (const VkDeviceGroupBindSparseInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t resourceDeviceIndex // SMB
    IndentSpaces(out, indent);
    *out += "resourceDeviceIndex:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->resourceDeviceIndex);
    *out += "\n"; // GDS

    // uint32_t memoryDeviceIndex // SMB
    IndentSpaces(out, indent);
    *out += "memoryDeviceIndex:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryDeviceIndex);
}

template <>
void StructureToString<Decoded_VkBindBufferMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindBufferMemoryDeviceGroupInfo *pstruct = (const VkBindBufferMemoryDeviceGroupInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t deviceIndexCount // SMB
    IndentSpaces(out, indent);
    *out += "deviceIndexCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceIndexCount);
    *out += "\n"; // GDS

    // const uint32_t* pDeviceIndices // SMB
    IndentSpaces(out, indent);
    *out += "pDeviceIndices:                 ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkBindImageMemoryDeviceGroupInfo>(std::string* out, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImageMemoryDeviceGroupInfo *pstruct = (const VkBindImageMemoryDeviceGroupInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t deviceIndexCount // SMB
    IndentSpaces(out, indent);
    *out += "deviceIndexCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceIndexCount);
    *out += "\n"; // GDS

    // const uint32_t* pDeviceIndices // SMB
    IndentSpaces(out, indent);
    *out += "pDeviceIndices:                 ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t splitInstanceBindRegionCount // SMB
    IndentSpaces(out, indent);
    *out += "splitInstanceBindRegionCount:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->splitInstanceBindRegionCount);
    *out += "\n"; // GDS

    // const VkRect2D* pSplitInstanceBindRegions // SMB
    IndentSpaces(out, indent);
    *out += "pSplitInstanceBindRegions:      ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pSplitInstanceBindRegions == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSplitInstanceBindRegions->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pSplitInstanceBindRegions->GetMetaStructPointer(), "pSplitInstanceBindRegions", pstruct->splitInstanceBindRegionCount, false, pstruct_in.pSplitInstanceBindRegions->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceGroupProperties>(std::string* out, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceGroupProperties *pstruct = (const VkPhysicalDeviceGroupProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t physicalDeviceCount // SMB
    IndentSpaces(out, indent);
    *out += "physicalDeviceCount:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->physicalDeviceCount);
    *out += "\n"; // GDS

    // VkPhysicalDevice physicalDevices // SMB
    IndentSpaces(out, indent);
    *out += "physicalDevices:                ";
    *out += "VkPhysicalDevice[";
    UnsignedDecimalToString(out, pstruct->physicalDeviceCount);
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceGroupProperties, physicalDevices)); // IYY
    ValueToStringStruct vinfo_physicalDevices = {true, false, false, nullptr};
    ArrayToString<VkPhysicalDevice*>(out, indent, 0, "VkPhysicalDevice", const_cast<VkPhysicalDevice*>(pstruct->physicalDevices), "physicalDevices", pstruct->physicalDeviceCount, vinfo_physicalDevices); // JPA
    *out += "\n"; // GDS

    // VkBool32 subsetAllocation // SMB
    IndentSpaces(out, indent);
    *out += "subsetAllocation:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->subsetAllocation);
}

template <>
void StructureToString<Decoded_VkDeviceGroupDeviceCreateInfo>(std::string* out, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupDeviceCreateInfo *pstruct = (const VkDeviceGroupDeviceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t physicalDeviceCount // SMB
    IndentSpaces(out, indent);
    *out += "physicalDeviceCount:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->physicalDeviceCount);
    *out += "\n"; // GDS

    // const VkPhysicalDevice* pPhysicalDevices // SMB
    IndentSpaces(out, indent);
    *out += "pPhysicalDevices:               ";
    *out += "const VkPhysicalDevice* = "; // TEQ
    if (pstruct->pPhysicalDevices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPhysicalDevices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pPhysicalDevices = {true, false, false, nullptr};
        ArrayToString<const VkPhysicalDevice*>(out, indent, 1, "const VkPhysicalDevice*", reinterpret_cast<const VkPhysicalDevice*>(pstruct_in.pPhysicalDevices.GetPointer()), "pPhysicalDevices", pstruct->physicalDeviceCount,  vinfo_pPhysicalDevices);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(std::string* out, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferMemoryRequirementsInfo2 *pstruct = (const VkBufferMemoryRequirementsInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageMemoryRequirementsInfo2 *pstruct = (const VkImageMemoryRequirementsInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
}

template <>
void StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(std::string* out, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSparseMemoryRequirementsInfo2 *pstruct = (const VkImageSparseMemoryRequirementsInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImage image // SMB
    IndentSpaces(out, indent);
    *out += "image:                          ";
    *out += "VkImage = "; // TEQ
    AddrToString(out, pstruct_in.image); // PAQ
}

template <>
void StructureToString<Decoded_VkMemoryRequirements2>(std::string* out, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryRequirements2 *pstruct = (const VkMemoryRequirements2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkMemoryRequirements memoryRequirements // SMB
    IndentSpaces(out, indent);
    *out += "memoryRequirements:             ";
    *out += "VkMemoryRequirements = "; // TEQ
    StructureToString<Decoded_VkMemoryRequirements>(out, *pstruct_in.memoryRequirements, indent+1,  base_addr + offsetof(VkMemoryRequirements2, memoryRequirements)); // AZJ
}

template <>
void StructureToString<Decoded_VkSparseImageMemoryRequirements2>(std::string* out, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageMemoryRequirements2 *pstruct = (const VkSparseImageMemoryRequirements2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSparseImageMemoryRequirements memoryRequirements // SMB
    IndentSpaces(out, indent);
    *out += "memoryRequirements:             ";
    *out += "VkSparseImageMemoryRequirements = "; // TEQ
    StructureToString<Decoded_VkSparseImageMemoryRequirements>(out, *pstruct_in.memoryRequirements, indent+1,  base_addr + offsetof(VkSparseImageMemoryRequirements2, memoryRequirements)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceFeatures2>(std::string* out, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceFeatures2 *pstruct = (const VkPhysicalDeviceFeatures2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPhysicalDeviceFeatures features // SMB
    IndentSpaces(out, indent);
    *out += "features:                       ";
    *out += "VkPhysicalDeviceFeatures = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceFeatures>(out, *pstruct_in.features, indent+1,  base_addr + offsetof(VkPhysicalDeviceFeatures2, features)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProperties2>(std::string* out, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProperties2 *pstruct = (const VkPhysicalDeviceProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPhysicalDeviceProperties properties // SMB
    IndentSpaces(out, indent);
    *out += "properties:                     ";
    *out += "VkPhysicalDeviceProperties = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceProperties>(out, *pstruct_in.properties, indent+1,  base_addr + offsetof(VkPhysicalDeviceProperties2, properties)); // AZJ
}

template <>
void StructureToString<Decoded_VkFormatProperties2>(std::string* out, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFormatProperties2 *pstruct = (const VkFormatProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFormatProperties formatProperties // SMB
    IndentSpaces(out, indent);
    *out += "formatProperties:               ";
    *out += "VkFormatProperties = "; // TEQ
    StructureToString<Decoded_VkFormatProperties>(out, *pstruct_in.formatProperties, indent+1,  base_addr + offsetof(VkFormatProperties2, formatProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkImageFormatProperties2>(std::string* out, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageFormatProperties2 *pstruct = (const VkImageFormatProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageFormatProperties imageFormatProperties // SMB
    IndentSpaces(out, indent);
    *out += "imageFormatProperties:          ";
    *out += "VkImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkImageFormatProperties>(out, *pstruct_in.imageFormatProperties, indent+1,  base_addr + offsetof(VkImageFormatProperties2, imageFormatProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceImageFormatInfo2 *pstruct = (const VkPhysicalDeviceImageFormatInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageType type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageTiling tiling // SMB
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, pstruct->tiling);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tiling);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // VkImageCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImageCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkImageCreateFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkQueueFamilyProperties2>(std::string* out, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueueFamilyProperties2 *pstruct = (const VkQueueFamilyProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkQueueFamilyProperties queueFamilyProperties // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyProperties:          ";
    *out += "VkQueueFamilyProperties = "; // TEQ
    StructureToString<Decoded_VkQueueFamilyProperties>(out, *pstruct_in.queueFamilyProperties, indent+1,  base_addr + offsetof(VkQueueFamilyProperties2, queueFamilyProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(std::string* out, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMemoryProperties2 *pstruct = (const VkPhysicalDeviceMemoryProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPhysicalDeviceMemoryProperties memoryProperties // SMB
    IndentSpaces(out, indent);
    *out += "memoryProperties:               ";
    *out += "VkPhysicalDeviceMemoryProperties = "; // TEQ
    StructureToString<Decoded_VkPhysicalDeviceMemoryProperties>(out, *pstruct_in.memoryProperties, indent+1,  base_addr + offsetof(VkPhysicalDeviceMemoryProperties2, memoryProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkSparseImageFormatProperties2>(std::string* out, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSparseImageFormatProperties2 *pstruct = (const VkSparseImageFormatProperties2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSparseImageFormatProperties properties // SMB
    IndentSpaces(out, indent);
    *out += "properties:                     ";
    *out += "VkSparseImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkSparseImageFormatProperties>(out, *pstruct_in.properties, indent+1,  base_addr + offsetof(VkSparseImageFormatProperties2, properties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(std::string* out, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSparseImageFormatInfo2 *pstruct = (const VkPhysicalDeviceSparseImageFormatInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageType type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkImageType = "; // TEQ
    EnumToStringVkImageType(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // VkImageTiling tiling // SMB
    IndentSpaces(out, indent);
    *out += "tiling:                         ";
    *out += "VkImageTiling = "; // TEQ
    EnumToStringVkImageTiling(out, pstruct->tiling);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tiling);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDevicePointClippingProperties>(std::string* out, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevicePointClippingProperties *pstruct = (const VkPhysicalDevicePointClippingProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPointClippingBehavior pointClippingBehavior // SMB
    IndentSpaces(out, indent);
    *out += "pointClippingBehavior:          ";
    *out += "VkPointClippingBehavior = "; // TEQ
    EnumToStringVkPointClippingBehavior(out, pstruct->pointClippingBehavior);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pointClippingBehavior);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkInputAttachmentAspectReference>(std::string* out, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkInputAttachmentAspectReference *pstruct = (const VkInputAttachmentAspectReference *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t subpass // SMB
    IndentSpaces(out, indent);
    *out += "subpass:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpass);
    *out += "\n"; // GDS

    // uint32_t inputAttachmentIndex // SMB
    IndentSpaces(out, indent);
    *out += "inputAttachmentIndex:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->inputAttachmentIndex);
    *out += "\n"; // GDS

    // VkImageAspectFlags aspectMask // SMB
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>(std::string* out, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassInputAttachmentAspectCreateInfo *pstruct = (const VkRenderPassInputAttachmentAspectCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t aspectReferenceCount // SMB
    IndentSpaces(out, indent);
    *out += "aspectReferenceCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->aspectReferenceCount);
    *out += "\n"; // GDS

    // const VkInputAttachmentAspectReference* pAspectReferences // SMB
    IndentSpaces(out, indent);
    *out += "pAspectReferences:              ";
    *out += "const VkInputAttachmentAspectReference* = "; // TEQ
    if (pstruct->pAspectReferences == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAspectReferences->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkInputAttachmentAspectReference>(out, indent+1, 1, "VkInputAttachmentAspectReference", pstruct_in.pAspectReferences->GetMetaStructPointer(), "pAspectReferences", pstruct->aspectReferenceCount, false, pstruct_in.pAspectReferences->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkImageViewUsageCreateInfo>(std::string* out, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageViewUsageCreateInfo *pstruct = (const VkImageViewUsageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkImageUsageFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>(std::string* out, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineTessellationDomainOriginStateCreateInfo *pstruct = (const VkPipelineTessellationDomainOriginStateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkTessellationDomainOrigin domainOrigin // SMB
    IndentSpaces(out, indent);
    *out += "domainOrigin:                   ";
    *out += "VkTessellationDomainOrigin = "; // TEQ
    EnumToStringVkTessellationDomainOrigin(out, pstruct->domainOrigin);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->domainOrigin);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkRenderPassMultiviewCreateInfo>(std::string* out, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassMultiviewCreateInfo *pstruct = (const VkRenderPassMultiviewCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t subpassCount // SMB
    IndentSpaces(out, indent);
    *out += "subpassCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassCount);
    *out += "\n"; // GDS

    // const uint32_t* pViewMasks // SMB
    IndentSpaces(out, indent);
    *out += "pViewMasks:                     ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pViewMasks == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pViewMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pViewMasks.GetPointer()), "pViewMasks", pstruct->subpassCount,  vinfo_pViewMasks);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t dependencyCount // SMB
    IndentSpaces(out, indent);
    *out += "dependencyCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dependencyCount);
    *out += "\n"; // GDS

    // const int32_t* pViewOffsets // SMB
    IndentSpaces(out, indent);
    *out += "pViewOffsets:                   ";
    *out += "const int32_t* = "; // TEQ
    if (pstruct->pViewOffsets == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewOffsets.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pViewOffsets = {false, false, false, nullptr};
        ArrayToString<const int32_t*>(out, indent, 1, "const int32_t*", reinterpret_cast<const int32_t*>(pstruct_in.pViewOffsets.GetPointer()), "pViewOffsets", pstruct->dependencyCount,  vinfo_pViewOffsets);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t correlationMaskCount // SMB
    IndentSpaces(out, indent);
    *out += "correlationMaskCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->correlationMaskCount);
    *out += "\n"; // GDS

    // const uint32_t* pCorrelationMasks // SMB
    IndentSpaces(out, indent);
    *out += "pCorrelationMasks:              ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCorrelationMasks == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCorrelationMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCorrelationMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCorrelationMasks.GetPointer()), "pCorrelationMasks", pstruct->correlationMaskCount,  vinfo_pCorrelationMasks);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMultiviewFeatures>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMultiviewFeatures *pstruct = (const VkPhysicalDeviceMultiviewFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 multiview // SMB
    IndentSpaces(out, indent);
    *out += "multiview:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiview);
    *out += "\n"; // GDS

    // VkBool32 multiviewGeometryShader // SMB
    IndentSpaces(out, indent);
    *out += "multiviewGeometryShader:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiviewGeometryShader);
    *out += "\n"; // GDS

    // VkBool32 multiviewTessellationShader // SMB
    IndentSpaces(out, indent);
    *out += "multiviewTessellationShader:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->multiviewTessellationShader);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMultiviewProperties>(std::string* out, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMultiviewProperties *pstruct = (const VkPhysicalDeviceMultiviewProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t maxMultiviewViewCount // SMB
    IndentSpaces(out, indent);
    *out += "maxMultiviewViewCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMultiviewViewCount);
    *out += "\n"; // GDS

    // uint32_t maxMultiviewInstanceIndex // SMB
    IndentSpaces(out, indent);
    *out += "maxMultiviewInstanceIndex:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMultiviewInstanceIndex);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceVariablePointersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceVariablePointersFeatures *pstruct = (const VkPhysicalDeviceVariablePointersFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 variablePointersStorageBuffer // SMB
    IndentSpaces(out, indent);
    *out += "variablePointersStorageBuffer:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variablePointersStorageBuffer);
    *out += "\n"; // GDS

    // VkBool32 variablePointers // SMB
    IndentSpaces(out, indent);
    *out += "variablePointers:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variablePointers);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProtectedMemoryFeatures *pstruct = (const VkPhysicalDeviceProtectedMemoryFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 protectedMemory // SMB
    IndentSpaces(out, indent);
    *out += "protectedMemory:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->protectedMemory);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceProtectedMemoryProperties>(std::string* out, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceProtectedMemoryProperties *pstruct = (const VkPhysicalDeviceProtectedMemoryProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 protectedNoFault // SMB
    IndentSpaces(out, indent);
    *out += "protectedNoFault:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->protectedNoFault);
}

template <>
void StructureToString<Decoded_VkDeviceQueueInfo2>(std::string* out, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceQueueInfo2 *pstruct = (const VkDeviceQueueInfo2 *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceQueueCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDeviceQueueCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDeviceQueueCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t queueFamilyIndex // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyIndex:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndex);
    *out += "\n"; // GDS

    // uint32_t queueIndex // SMB
    IndentSpaces(out, indent);
    *out += "queueIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueIndex);
}

template <>
void StructureToString<Decoded_VkProtectedSubmitInfo>(std::string* out, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkProtectedSubmitInfo *pstruct = (const VkProtectedSubmitInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 protectedSubmit // SMB
    IndentSpaces(out, indent);
    *out += "protectedSubmit:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->protectedSubmit);
}

template <>
void StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerYcbcrConversionCreateInfo *pstruct = (const VkSamplerYcbcrConversionCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkSamplerYcbcrModelConversion ycbcrModel // SMB
    IndentSpaces(out, indent);
    *out += "ycbcrModel:                     ";
    *out += "VkSamplerYcbcrModelConversion = "; // TEQ
    EnumToStringVkSamplerYcbcrModelConversion(out, pstruct->ycbcrModel);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->ycbcrModel);
    *out += ")";
    *out += "\n"; // GDS

    // VkSamplerYcbcrRange ycbcrRange // SMB
    IndentSpaces(out, indent);
    *out += "ycbcrRange:                     ";
    *out += "VkSamplerYcbcrRange = "; // TEQ
    EnumToStringVkSamplerYcbcrRange(out, pstruct->ycbcrRange);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->ycbcrRange);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentMapping components // SMB
    IndentSpaces(out, indent);
    *out += "components:                     ";
    *out += "VkComponentMapping = "; // TEQ
    StructureToString<Decoded_VkComponentMapping>(out, *pstruct_in.components, indent+1,  base_addr + offsetof(VkSamplerYcbcrConversionCreateInfo, components)); // AZJ
    *out += "\n"; // GDS

    // VkChromaLocation xChromaOffset // SMB
    IndentSpaces(out, indent);
    *out += "xChromaOffset:                  ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->xChromaOffset);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->xChromaOffset);
    *out += ")";
    *out += "\n"; // GDS

    // VkChromaLocation yChromaOffset // SMB
    IndentSpaces(out, indent);
    *out += "yChromaOffset:                  ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->yChromaOffset);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->yChromaOffset);
    *out += ")";
    *out += "\n"; // GDS

    // VkFilter chromaFilter // SMB
    IndentSpaces(out, indent);
    *out += "chromaFilter:                   ";
    *out += "VkFilter = "; // TEQ
    EnumToStringVkFilter(out, pstruct->chromaFilter);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->chromaFilter);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 forceExplicitReconstruction // SMB
    IndentSpaces(out, indent);
    *out += "forceExplicitReconstruction:    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->forceExplicitReconstruction);
}

template <>
void StructureToString<Decoded_VkSamplerYcbcrConversionInfo>(std::string* out, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerYcbcrConversionInfo *pstruct = (const VkSamplerYcbcrConversionInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSamplerYcbcrConversion conversion // SMB
    IndentSpaces(out, indent);
    *out += "conversion:                     ";
    *out += "VkSamplerYcbcrConversion = "; // TEQ
    AddrToString(out, pstruct_in.conversion); // PAQ
}

template <>
void StructureToString<Decoded_VkBindImagePlaneMemoryInfo>(std::string* out, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImagePlaneMemoryInfo *pstruct = (const VkBindImagePlaneMemoryInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageAspectFlagBits planeAspect // SMB
    IndentSpaces(out, indent);
    *out += "planeAspect:                    ";
    *out += "VkImageAspectFlagBits = "; // TEQ
    EnumToStringVkImageAspectFlagBits(out, pstruct->planeAspect);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->planeAspect);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkImagePlaneMemoryRequirementsInfo>(std::string* out, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImagePlaneMemoryRequirementsInfo *pstruct = (const VkImagePlaneMemoryRequirementsInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageAspectFlagBits planeAspect // SMB
    IndentSpaces(out, indent);
    *out += "planeAspect:                    ";
    *out += "VkImageAspectFlagBits = "; // TEQ
    EnumToStringVkImageAspectFlagBits(out, pstruct->planeAspect);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->planeAspect);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(std::string* out, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures *pstruct = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 samplerYcbcrConversion // SMB
    IndentSpaces(out, indent);
    *out += "samplerYcbcrConversion:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->samplerYcbcrConversion);
}

template <>
void StructureToString<Decoded_VkSamplerYcbcrConversionImageFormatProperties>(std::string* out, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSamplerYcbcrConversionImageFormatProperties *pstruct = (const VkSamplerYcbcrConversionImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t combinedImageSamplerDescriptorCount // SMB
    IndentSpaces(out, indent);
    *out += "combinedImageSamplerDescriptorCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->combinedImageSamplerDescriptorCount);
}

template <>
void StructureToString<Decoded_VkDescriptorUpdateTemplateEntry>(std::string* out, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorUpdateTemplateEntry *pstruct = (const VkDescriptorUpdateTemplateEntry *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t dstBinding // SMB
    IndentSpaces(out, indent);
    *out += "dstBinding:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstBinding);
    *out += "\n"; // GDS

    // uint32_t dstArrayElement // SMB
    IndentSpaces(out, indent);
    *out += "dstArrayElement:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstArrayElement);
    *out += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    IndentSpaces(out, indent);
    *out += "descriptorCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorCount);
    *out += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // size_t offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // size_t stride // SMB
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stride);
}

template <>
void StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(std::string* out, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorUpdateTemplateCreateInfo *pstruct = (const VkDescriptorUpdateTemplateCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDescriptorUpdateTemplateCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDescriptorUpdateTemplateCreateFlags = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t descriptorUpdateEntryCount // SMB
    IndentSpaces(out, indent);
    *out += "descriptorUpdateEntryCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->descriptorUpdateEntryCount);
    *out += "\n"; // GDS

    // const VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries // SMB
    IndentSpaces(out, indent);
    *out += "pDescriptorUpdateEntries:       ";
    *out += "const VkDescriptorUpdateTemplateEntry* = "; // TEQ
    if (pstruct->pDescriptorUpdateEntries == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDescriptorUpdateEntries->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDescriptorUpdateTemplateEntry>(out, indent+1, 1, "VkDescriptorUpdateTemplateEntry", pstruct_in.pDescriptorUpdateEntries->GetMetaStructPointer(), "pDescriptorUpdateEntries", pstruct->descriptorUpdateEntryCount, false, pstruct_in.pDescriptorUpdateEntries->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // VkDescriptorUpdateTemplateType templateType // SMB
    IndentSpaces(out, indent);
    *out += "templateType:                   ";
    *out += "VkDescriptorUpdateTemplateType = "; // TEQ
    EnumToStringVkDescriptorUpdateTemplateType(out, pstruct->templateType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->templateType);
    *out += ")";
    *out += "\n"; // GDS

    // VkDescriptorSetLayout descriptorSetLayout // SMB
    IndentSpaces(out, indent);
    *out += "descriptorSetLayout:            ";
    *out += "VkDescriptorSetLayout = "; // TEQ
    AddrToString(out, pstruct_in.descriptorSetLayout); // PAQ
    *out += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // VkPipelineLayout pipelineLayout // SMB
    IndentSpaces(out, indent);
    *out += "pipelineLayout:                 ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.pipelineLayout); // PAQ
    *out += "\n"; // GDS

    // uint32_t set // SMB
    IndentSpaces(out, indent);
    *out += "set:                            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->set);
}

template <>
void StructureToString<Decoded_VkExternalMemoryProperties>(std::string* out, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalMemoryProperties *pstruct = (const VkExternalMemoryProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkExternalMemoryFeatureFlags externalMemoryFeatures // SMB
    IndentSpaces(out, indent);
    *out += "externalMemoryFeatures:         ";
    *out += "VkExternalMemoryFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->externalMemoryFeatures, EnumToStringVkExternalMemoryFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags compatibleHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalImageFormatInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalImageFormatInfo *pstruct = (const VkPhysicalDeviceExternalImageFormatInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExternalImageFormatProperties>(std::string* out, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalImageFormatProperties *pstruct = (const VkExternalImageFormatProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryProperties externalMemoryProperties // SMB
    IndentSpaces(out, indent);
    *out += "externalMemoryProperties:       ";
    *out += "VkExternalMemoryProperties = "; // TEQ
    StructureToString<Decoded_VkExternalMemoryProperties>(out, *pstruct_in.externalMemoryProperties, indent+1,  base_addr + offsetof(VkExternalImageFormatProperties, externalMemoryProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalBufferInfo *pstruct = (const VkPhysicalDeviceExternalBufferInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBufferCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBufferCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkBufferCreateFlagBits); // URW
    *out += "\n"; // GDS

    // VkBufferUsageFlags usage // SMB
    IndentSpaces(out, indent);
    *out += "usage:                          ";
    *out += "VkBufferUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->usage, EnumToStringVkBufferUsageFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExternalBufferProperties>(std::string* out, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalBufferProperties *pstruct = (const VkExternalBufferProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryProperties externalMemoryProperties // SMB
    IndentSpaces(out, indent);
    *out += "externalMemoryProperties:       ";
    *out += "VkExternalMemoryProperties = "; // TEQ
    StructureToString<Decoded_VkExternalMemoryProperties>(out, *pstruct_in.externalMemoryProperties, indent+1,  base_addr + offsetof(VkExternalBufferProperties, externalMemoryProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceIDProperties>(std::string* out, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceIDProperties *pstruct = (const VkPhysicalDeviceIDProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint8_t deviceUUID // SMB
    IndentSpaces(out, indent);
    *out += "deviceUUID:                     ";
    *out += "uint8_t[";
    *out += "VK_UUID_SIZE";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceIDProperties, deviceUUID)); // IYY
    ValueToStringStruct vinfo_deviceUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->deviceUUID), "deviceUUID", VK_UUID_SIZE, vinfo_deviceUUID); // JPA
    *out += "\n"; // GDS

    // uint8_t driverUUID // SMB
    IndentSpaces(out, indent);
    *out += "driverUUID:                     ";
    *out += "uint8_t[";
    *out += "VK_UUID_SIZE";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceIDProperties, driverUUID)); // IYY
    ValueToStringStruct vinfo_driverUUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->driverUUID), "driverUUID", VK_UUID_SIZE, vinfo_driverUUID); // JPA
    *out += "\n"; // GDS

    // uint8_t deviceLUID // SMB
    IndentSpaces(out, indent);
    *out += "deviceLUID:                     ";
    *out += "uint8_t[";
    *out += "VK_LUID_SIZE";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceIDProperties, deviceLUID)); // IYY
    ValueToStringStruct vinfo_deviceLUID = {false, false, false, nullptr};
    ArrayToString<uint8_t*>(out, indent, 0, "uint8_t", const_cast<uint8_t*>(pstruct->deviceLUID), "deviceLUID", VK_LUID_SIZE, vinfo_deviceLUID); // JPA
    *out += "\n"; // GDS

    // uint32_t deviceNodeMask // SMB
    IndentSpaces(out, indent);
    *out += "deviceNodeMask:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceNodeMask);
    *out += "\n"; // GDS

    // VkBool32 deviceLUIDValid // SMB
    IndentSpaces(out, indent);
    *out += "deviceLUIDValid:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->deviceLUIDValid);
}

template <>
void StructureToString<Decoded_VkExternalMemoryImageCreateInfo>(std::string* out, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalMemoryImageCreateInfo *pstruct = (const VkExternalMemoryImageCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags handleTypes // SMB
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkExternalMemoryBufferCreateInfo>(std::string* out, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalMemoryBufferCreateInfo *pstruct = (const VkExternalMemoryBufferCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags handleTypes // SMB
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkExportMemoryAllocateInfo>(std::string* out, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportMemoryAllocateInfo *pstruct = (const VkExportMemoryAllocateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags handleTypes // SMB
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalFenceInfo *pstruct = (const VkPhysicalDeviceExternalFenceInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExternalFenceProperties>(std::string* out, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalFenceProperties *pstruct = (const VkExternalFenceProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalFenceHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlags compatibleHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalFenceHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalFenceFeatureFlags externalFenceFeatures // SMB
    IndentSpaces(out, indent);
    *out += "externalFenceFeatures:          ";
    *out += "VkExternalFenceFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->externalFenceFeatures, EnumToStringVkExternalFenceFeatureFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkExportFenceCreateInfo>(std::string* out, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportFenceCreateInfo *pstruct = (const VkExportFenceCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlags handleTypes // SMB
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalFenceHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalFenceHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkExportSemaphoreCreateInfo>(std::string* out, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportSemaphoreCreateInfo *pstruct = (const VkExportSemaphoreCreateInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlags handleTypes // SMB
    IndentSpaces(out, indent);
    *out += "handleTypes:                    ";
    *out += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->handleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(std::string* out, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalSemaphoreInfo *pstruct = (const VkPhysicalDeviceExternalSemaphoreInfo *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkExternalSemaphoreProperties>(std::string* out, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalSemaphoreProperties *pstruct = (const VkExternalSemaphoreProperties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalSemaphoreHandleTypeFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures // SMB
    IndentSpaces(out, indent);
    *out += "externalSemaphoreFeatures:      ";
    *out += "VkExternalSemaphoreFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->externalSemaphoreFeatures, EnumToStringVkExternalSemaphoreFeatureFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMaintenance3Properties>(std::string* out, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMaintenance3Properties *pstruct = (const VkPhysicalDeviceMaintenance3Properties *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t maxPerSetDescriptors // SMB
    IndentSpaces(out, indent);
    *out += "maxPerSetDescriptors:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPerSetDescriptors);
    *out += "\n"; // GDS

    // VkDeviceSize maxMemoryAllocationSize // SMB
    IndentSpaces(out, indent);
    *out += "maxMemoryAllocationSize:        ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->maxMemoryAllocationSize);
}

template <>
void StructureToString<Decoded_VkDescriptorSetLayoutSupport>(std::string* out, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDescriptorSetLayoutSupport *pstruct = (const VkDescriptorSetLayoutSupport *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 supported // SMB
    IndentSpaces(out, indent);
    *out += "supported:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->supported);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>(std::string* out, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceShaderDrawParametersFeatures *pstruct = (const VkPhysicalDeviceShaderDrawParametersFeatures *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 shaderDrawParameters // SMB
    IndentSpaces(out, indent);
    *out += "shaderDrawParameters:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shaderDrawParameters);
}

void VulkanAsciiConsumer::Process_vkBindBufferMemory2(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>& pBindInfos)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBindBufferMemory2(device, bindInfoCount, pBindInfos)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindBufferMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = NULL", indent_string.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = ", indent_string.c_str(), "pBindInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBindBufferMemoryInfo>(&tmp_string, 2, 1, "VkBindBufferMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory2(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindImageMemoryInfo>& pBindInfos)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBindImageMemory2(device, bindInfoCount, pBindInfos)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindImageMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = NULL", indent_string.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = ", indent_string.c_str(), "pBindInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBindImageMemoryInfo>(&tmp_string, 2, 1, "VkBindImageMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupPeerMemoryFeatures(
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    const PointerDecoder<VkPeerMemoryFeatureFlags>& pPeerMemoryFeatures)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t heapIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "heapIndex:", heapIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t localDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "localDeviceIndex:", localDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t remoteDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "remoteDeviceIndex:", remoteDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPeerMemoryFeatureFlags* pPeerMemoryFeatures // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, *pPeerMemoryFeatures.GetPointer(), EnumToStringVkPeerMemoryFeatureFlagBits);
    fprintf(GetFile(), "%s%-32sVkPeerMemoryFeatureFlags* = %s", indent_string.c_str(), "pPeerMemoryFeatures:", tmp_string.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDeviceMask(
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetDeviceMask(commandBuffer, deviceMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t deviceMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "deviceMask:", deviceMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchBase(
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "baseGroupX:", baseGroupX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "baseGroupY:", baseGroupY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "baseGroupZ:", baseGroupZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountX:", groupCountX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountY:", groupCountY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountZ:", groupCountZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDeviceGroups(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceGroupCount,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>& pPhysicalDeviceGroupProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPhysicalDeviceGroupCount // ARG
    if (pPhysicalDeviceGroupCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPhysicalDeviceGroupCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPhysicalDeviceGroupCount:", static_cast<uint64_t>(*pPhysicalDeviceGroupCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties // ARG
    if (pPhysicalDeviceGroupProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = NULL", indent_string.c_str(), "pPhysicalDeviceGroupProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = ", indent_string.c_str(), "pPhysicalDeviceGroupProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pPhysicalDeviceGroupProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkPhysicalDeviceGroupProperties>(&tmp_string, 2, 1, "VkPhysicalDeviceGroupProperties",
            pPhysicalDeviceGroupProperties.GetMetaStructPointer(), "pPhysicalDeviceGroupProperties", *pPhysicalDeviceGroupCount.GetPointer(), false, pPhysicalDeviceGroupProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indent_string.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indent_string.c_str(), "pMemoryRequirements:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryRequirements2>(&tmp_string, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indent_string.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indent_string.c_str(), "pMemoryRequirements:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryRequirements2>(&tmp_string, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>& pInfo,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>& pSparseMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSparseMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSparseMemoryRequirementCount // ARG
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pSparseMemoryRequirementCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pSparseMemoryRequirementCount:", static_cast<uint64_t>(*pSparseMemoryRequirementCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageMemoryRequirements2* pSparseMemoryRequirements // ARG
    if (pSparseMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = NULL", indent_string.c_str(), "pSparseMemoryRequirements:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = ", indent_string.c_str(), "pSparseMemoryRequirements:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pSparseMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements2>(&tmp_string, 2, 1, "VkSparseImageMemoryRequirements2",
            pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>& pFeatures)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceFeatures2* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = NULL", indent_string.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = ", indent_string.c_str(), "pFeatures:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceFeatures2>(&tmp_string, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties2(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = NULL", indent_string.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = ", indent_string.c_str(), "pProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceProperties2>(&tmp_string, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties2(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties2>& pFormatProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmp_string = "";
    EnumToStringVkFormat(&tmp_string,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indent_string.c_str(), "format:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkFormatProperties2* pFormatProperties // ARG
    if (pFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = NULL", indent_string.c_str(), "pFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = ", indent_string.c_str(), "pFormatProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkFormatProperties2>(&tmp_string, *pFormatProperties.GetMetaStructPointer(), 2, pFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>& pImageFormatInfo,
    const StructPointerDecoder<Decoded_VkImageFormatProperties2>& pImageFormatProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo // ARG
    if (pImageFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = NULL", indent_string.c_str(), "pImageFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = ", indent_string.c_str(), "pImageFormatInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImageFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(&tmp_string, *pImageFormatInfo.GetMetaStructPointer(), 2, pImageFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImageFormatProperties2* pImageFormatProperties // ARG
    if (pImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = NULL", indent_string.c_str(), "pImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = ", indent_string.c_str(), "pImageFormatProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageFormatProperties2>(&tmp_string, *pImageFormatProperties.GetMetaStructPointer(), 2, pImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties2>& pQueueFamilyProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pQueueFamilyPropertyCount // ARG
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pQueueFamilyPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pQueueFamilyPropertyCount:", static_cast<uint64_t>(*pQueueFamilyPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueueFamilyProperties2* pQueueFamilyProperties // ARG
    if (pQueueFamilyProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = NULL", indent_string.c_str(), "pQueueFamilyProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = ", indent_string.c_str(), "pQueueFamilyProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pQueueFamilyProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkQueueFamilyProperties2>(&tmp_string, 2, 1, "VkQueueFamilyProperties2",
            pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>& pMemoryProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceMemoryProperties2* pMemoryProperties // ARG
    if (pMemoryProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = NULL", indent_string.c_str(), "pMemoryProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = ", indent_string.c_str(), "pMemoryProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(&tmp_string, *pMemoryProperties.GetMetaStructPointer(), 2, pMemoryProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>& pFormatInfo,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo // ARG
    if (pFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = NULL", indent_string.c_str(), "pFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = ", indent_string.c_str(), "pFormatInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(&tmp_string, *pFormatInfo.GetMetaStructPointer(), 2, pFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageFormatProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSparseImageFormatProperties2>(&tmp_string, 2, 1, "VkSparseImageFormatProperties2",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkTrimCommandPool(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkTrimCommandPool(device, commandPool, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indent_string.c_str(), "commandPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPoolTrimFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPoolTrimFlags = %d", indent_string.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceQueue2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceQueueInfo2>& pQueueInfo,
    const HandlePointerDecoder<VkQueue>&        pQueue)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceQueue2(device, pQueueInfo, pQueue)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceQueueInfo2* pQueueInfo // ARG
    if (pQueueInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceQueueInfo2* = NULL", indent_string.c_str(), "pQueueInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceQueueInfo2* = ", indent_string.c_str(), "pQueueInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pQueueInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDeviceQueueInfo2>(&tmp_string, *pQueueInfo.GetMetaStructPointer(), 2, pQueueInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueue* pQueue // ARG
    if (pQueue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = NULL", indent_string.c_str(), "pQueue:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = ", indent_string.c_str(), "pQueue:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pQueue.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSamplerYcbcrConversion(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSamplerYcbcrConversion>& pYcbcrConversion)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSamplerYcbcrConversionCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion* pYcbcrConversion // ARG
    if (pYcbcrConversion.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = NULL", indent_string.c_str(), "pYcbcrConversion:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = ", indent_string.c_str(), "pYcbcrConversion:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pYcbcrConversion.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySamplerYcbcrConversion(
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion ycbcrConversion // ARG
    fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion = ", indent_string.c_str(), "ycbcrConversion:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, ycbcrConversion);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorUpdateTemplate(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorUpdateTemplate>& pDescriptorUpdateTemplate)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate // ARG
    if (pDescriptorUpdateTemplate.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = NULL", indent_string.c_str(), "pDescriptorUpdateTemplate:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = ", indent_string.c_str(), "pDescriptorUpdateTemplate:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pDescriptorUpdateTemplate.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorUpdateTemplate(
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate descriptorUpdateTemplate // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate = ", indent_string.c_str(), "descriptorUpdateTemplate:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, descriptorUpdateTemplate);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalBufferProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>& pExternalBufferInfo,
    const StructPointerDecoder<Decoded_VkExternalBufferProperties>& pExternalBufferProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo // ARG
    if (pExternalBufferInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = NULL", indent_string.c_str(), "pExternalBufferInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = ", indent_string.c_str(), "pExternalBufferInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalBufferInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(&tmp_string, *pExternalBufferInfo.GetMetaStructPointer(), 2, pExternalBufferInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalBufferProperties* pExternalBufferProperties // ARG
    if (pExternalBufferProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = NULL", indent_string.c_str(), "pExternalBufferProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = ", indent_string.c_str(), "pExternalBufferProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalBufferProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExternalBufferProperties>(&tmp_string, *pExternalBufferProperties.GetMetaStructPointer(), 2, pExternalBufferProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalFenceProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>& pExternalFenceInfo,
    const StructPointerDecoder<Decoded_VkExternalFenceProperties>& pExternalFenceProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo // ARG
    if (pExternalFenceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = NULL", indent_string.c_str(), "pExternalFenceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = ", indent_string.c_str(), "pExternalFenceInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalFenceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(&tmp_string, *pExternalFenceInfo.GetMetaStructPointer(), 2, pExternalFenceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalFenceProperties* pExternalFenceProperties // ARG
    if (pExternalFenceProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = NULL", indent_string.c_str(), "pExternalFenceProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = ", indent_string.c_str(), "pExternalFenceProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalFenceProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExternalFenceProperties>(&tmp_string, *pExternalFenceProperties.GetMetaStructPointer(), 2, pExternalFenceProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalSemaphoreProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>& pExternalSemaphoreInfo,
    const StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>& pExternalSemaphoreProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo // ARG
    if (pExternalSemaphoreInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = NULL", indent_string.c_str(), "pExternalSemaphoreInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = ", indent_string.c_str(), "pExternalSemaphoreInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalSemaphoreInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(&tmp_string, *pExternalSemaphoreInfo.GetMetaStructPointer(), 2, pExternalSemaphoreInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalSemaphoreProperties* pExternalSemaphoreProperties // ARG
    if (pExternalSemaphoreProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = NULL", indent_string.c_str(), "pExternalSemaphoreProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = ", indent_string.c_str(), "pExternalSemaphoreProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalSemaphoreProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExternalSemaphoreProperties>(&tmp_string, *pExternalSemaphoreProperties.GetMetaStructPointer(), 2, pExternalSemaphoreProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDescriptorSetLayoutSupport(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>& pSupport)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayoutSupport* pSupport // ARG
    if (pSupport.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = NULL", indent_string.c_str(), "pSupport:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = ", indent_string.c_str(), "pSupport:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSupport.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorSetLayoutSupport>(&tmp_string, *pSupport.GetMetaStructPointer(), 2, pSupport.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkSurfaceTransformFlagBitsKHR(std::string* out, uint32_t enum_uint32)
{
    VkSurfaceTransformFlagBitsKHR e = static_cast<VkSurfaceTransformFlagBitsKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR:
            *out += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCompositeAlphaFlagBitsKHR(std::string* out, uint32_t enum_uint32)
{
    VkCompositeAlphaFlagBitsKHR e = static_cast<VkCompositeAlphaFlagBitsKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR:
            *out += std::string("VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR");
            return;
        case VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR:
            *out += std::string("VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR");
            return;
        case VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR:
            *out += std::string("VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR");
            return;
        case VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR:
            *out += std::string("VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkColorSpaceKHR(std::string* out, uint32_t enum_uint32)
{
    VkColorSpaceKHR e = static_cast<VkColorSpaceKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COLOR_SPACE_BT709_LINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_BT709_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_HDR10_ST2084_EXT:
            *out += std::string("VK_COLOR_SPACE_HDR10_ST2084_EXT");
            return;
        case VK_COLOR_SPACE_DISPLAY_NATIVE_AMD:
            *out += std::string("VK_COLOR_SPACE_DISPLAY_NATIVE_AMD");
            return;
        case VK_COLOR_SPACE_BT709_NONLINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_BT709_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_BT2020_LINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_BT2020_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_SRGB_NONLINEAR_KHR:
            *out += std::string("VK_COLOR_SPACE_SRGB_NONLINEAR_KHR");
            return;
        case VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_PASS_THROUGH_EXT:
            *out += std::string("VK_COLOR_SPACE_PASS_THROUGH_EXT");
            return;
        case VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_HDR10_HLG_EXT:
            *out += std::string("VK_COLOR_SPACE_HDR10_HLG_EXT");
            return;
        case VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT:
            *out += std::string("VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_DOLBYVISION_EXT:
            *out += std::string("VK_COLOR_SPACE_DOLBYVISION_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPresentModeKHR(std::string* out, uint32_t enum_uint32)
{
    VkPresentModeKHR e = static_cast<VkPresentModeKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PRESENT_MODE_FIFO_KHR:
            *out += std::string("VK_PRESENT_MODE_FIFO_KHR");
            return;
        case VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR:
            *out += std::string("VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR");
            return;
        case VK_PRESENT_MODE_IMMEDIATE_KHR:
            *out += std::string("VK_PRESENT_MODE_IMMEDIATE_KHR");
            return;
        case VK_PRESENT_MODE_MAILBOX_KHR:
            *out += std::string("VK_PRESENT_MODE_MAILBOX_KHR");
            return;
        case VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR:
            *out += std::string("VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR");
            return;
        case VK_PRESENT_MODE_FIFO_RELAXED_KHR:
            *out += std::string("VK_PRESENT_MODE_FIFO_RELAXED_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceFormatKHR>(std::string* out, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilitiesKHR *pstruct = (const VkSurfaceCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t minImageCount // SMB
    IndentSpaces(out, indent);
    *out += "minImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minImageCount);
    *out += "\n"; // GDS

    // uint32_t maxImageCount // SMB
    IndentSpaces(out, indent);
    *out += "maxImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageCount);
    *out += "\n"; // GDS

    // VkExtent2D currentExtent // SMB
    IndentSpaces(out, indent);
    *out += "currentExtent:                  ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.currentExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, currentExtent)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D minImageExtent // SMB
    IndentSpaces(out, indent);
    *out += "minImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, minImageExtent)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D maxImageExtent // SMB
    IndentSpaces(out, indent);
    *out += "maxImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, maxImageExtent)); // AZJ
    *out += "\n"; // GDS

    // uint32_t maxImageArrayLayers // SMB
    IndentSpaces(out, indent);
    *out += "maxImageArrayLayers:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageArrayLayers);
    *out += "\n"; // GDS

    // VkSurfaceTransformFlagsKHR supportedTransforms // SMB
    IndentSpaces(out, indent);
    *out += "supportedTransforms:            ";
    *out += "VkSurfaceTransformFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR currentTransform // SMB
    IndentSpaces(out, indent);
    *out += "currentTransform:               ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->currentTransform);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->currentTransform);
    *out += ")";
    *out += "\n"; // GDS

    // VkCompositeAlphaFlagsKHR supportedCompositeAlpha // SMB
    IndentSpaces(out, indent);
    *out += "supportedCompositeAlpha:        ";
    *out += "VkCompositeAlphaFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedCompositeAlpha, EnumToStringVkCompositeAlphaFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // VkImageUsageFlags supportedUsageFlags // SMB
    IndentSpaces(out, indent);
    *out += "supportedUsageFlags:            ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSurfaceFormatKHR>(std::string* out, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFormatKHR *pstruct = (const VkSurfaceFormatKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkColorSpaceKHR colorSpace // SMB
    IndentSpaces(out, indent);
    *out += "colorSpace:                     ";
    *out += "VkColorSpaceKHR = "; // TEQ
    EnumToStringVkColorSpaceKHR(out, pstruct->colorSpace);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->colorSpace);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkDestroySurfaceKHR(
    format::HandleId                            instance,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroySurfaceKHR(instance, surface, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceSupportKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    format::HandleId                            surface,
    const PointerDecoder<VkBool32>&             pSupported)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32* pSupported // ARG
    if (pSupported.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkBool32* = NULL", indent_string.c_str(), "pSupported:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkBool32* = %" PRId64 "", indent_string.c_str(), "pSupported:", static_cast<uint64_t>(*pSupported.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilitiesKHR>& pSurfaceCapabilities)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCapabilitiesKHR* pSurfaceCapabilities // ARG
    if (pSurfaceCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilitiesKHR* = NULL", indent_string.c_str(), "pSurfaceCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilitiesKHR* = ", indent_string.c_str(), "pSurfaceCapabilities:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(&tmp_string, *pSurfaceCapabilities.GetMetaStructPointer(), 2, pSurfaceCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pSurfaceFormatCount,
    const StructPointerDecoder<Decoded_VkSurfaceFormatKHR>& pSurfaceFormats)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSurfaceFormatCount // ARG
    if (pSurfaceFormatCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pSurfaceFormatCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pSurfaceFormatCount:", static_cast<uint64_t>(*pSurfaceFormatCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceFormatKHR* pSurfaceFormats // ARG
    if (pSurfaceFormats.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormatKHR* = NULL", indent_string.c_str(), "pSurfaceFormats:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormatKHR* = ", indent_string.c_str(), "pSurfaceFormats:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceFormats.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSurfaceFormatKHR>(&tmp_string, 2, 1, "VkSurfaceFormatKHR",
            pSurfaceFormats.GetMetaStructPointer(), "pSurfaceFormats", *pSurfaceFormatCount.GetPointer(), false, pSurfaceFormats.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pPresentModeCount,
    const PointerDecoder<VkPresentModeKHR>&     pPresentModes)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPresentModeCount // ARG
    if (pPresentModeCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPresentModeCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPresentModeCount:", static_cast<uint64_t>(*pPresentModeCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPresentModeKHR* pPresentModes // ARG
    if (pPresentModes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = NULL", indent_string.c_str(), "pPresentModes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = %" PRId64 "", indent_string.c_str(), "pPresentModes:", static_cast<uint64_t>(*pPresentModes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkDeviceGroupPresentModeFlagBitsKHR(std::string* out, uint32_t enum_uint32)
{
    VkDeviceGroupPresentModeFlagBitsKHR e = static_cast<VkDeviceGroupPresentModeFlagBitsKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR:
            *out += std::string("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR");
            return;
        case VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR:
            *out += std::string("VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR");
            return;
        case VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR:
            *out += std::string("VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR");
            return;
        case VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR:
            *out += std::string("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSwapchainCreateFlagBitsKHR(std::string* out, uint32_t enum_uint32)
{
    VkSwapchainCreateFlagBitsKHR e = static_cast<VkSwapchainCreateFlagBitsKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR:
            *out += std::string("VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR");
            return;
        case VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR:
            *out += std::string("VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR");
            return;
        case VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR:
            *out += std::string("VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPresentInfoKHR>(std::string* out, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindImageMemorySwapchainInfoKHR>(std::string* out, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAcquireNextImageInfoKHR>(std::string* out, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(std::string* out, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupPresentInfoKHR>(std::string* out, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSwapchainCreateInfoKHR *pstruct = (const VkSwapchainCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSwapchainCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSwapchainCreateFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSwapchainCreateFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // VkSurfaceKHR surface // SMB
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, pstruct_in.surface); // PAQ
    *out += "\n"; // GDS

    // uint32_t minImageCount // SMB
    IndentSpaces(out, indent);
    *out += "minImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minImageCount);
    *out += "\n"; // GDS

    // VkFormat imageFormat // SMB
    IndentSpaces(out, indent);
    *out += "imageFormat:                    ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->imageFormat);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageFormat);
    *out += ")";
    *out += "\n"; // GDS

    // VkColorSpaceKHR imageColorSpace // SMB
    IndentSpaces(out, indent);
    *out += "imageColorSpace:                ";
    *out += "VkColorSpaceKHR = "; // TEQ
    EnumToStringVkColorSpaceKHR(out, pstruct->imageColorSpace);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageColorSpace);
    *out += ")";
    *out += "\n"; // GDS

    // VkExtent2D imageExtent // SMB
    IndentSpaces(out, indent);
    *out += "imageExtent:                    ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkSwapchainCreateInfoKHR, imageExtent)); // AZJ
    *out += "\n"; // GDS

    // uint32_t imageArrayLayers // SMB
    IndentSpaces(out, indent);
    *out += "imageArrayLayers:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageArrayLayers);
    *out += "\n"; // GDS

    // VkImageUsageFlags imageUsage // SMB
    IndentSpaces(out, indent);
    *out += "imageUsage:                     ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->imageUsage, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // VkSharingMode imageSharingMode // SMB
    IndentSpaces(out, indent);
    *out += "imageSharingMode:               ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->imageSharingMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->imageSharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount);
    *out += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
    *out += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR preTransform // SMB
    IndentSpaces(out, indent);
    *out += "preTransform:                   ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->preTransform);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->preTransform);
    *out += ")";
    *out += "\n"; // GDS

    // VkCompositeAlphaFlagBitsKHR compositeAlpha // SMB
    IndentSpaces(out, indent);
    *out += "compositeAlpha:                 ";
    *out += "VkCompositeAlphaFlagBitsKHR = "; // TEQ
    EnumToStringVkCompositeAlphaFlagBitsKHR(out, pstruct->compositeAlpha);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->compositeAlpha);
    *out += ")";
    *out += "\n"; // GDS

    // VkPresentModeKHR presentMode // SMB
    IndentSpaces(out, indent);
    *out += "presentMode:                    ";
    *out += "VkPresentModeKHR = "; // TEQ
    EnumToStringVkPresentModeKHR(out, pstruct->presentMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->presentMode);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 clipped // SMB
    IndentSpaces(out, indent);
    *out += "clipped:                        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->clipped);
    *out += "\n"; // GDS

    // VkSwapchainKHR oldSwapchain // SMB
    IndentSpaces(out, indent);
    *out += "oldSwapchain:                   ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.oldSwapchain); // PAQ
}

template <>
void StructureToString<Decoded_VkPresentInfoKHR>(std::string* out, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPresentInfoKHR *pstruct = (const VkPresentInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "waitSemaphoreCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreCount);
    *out += "\n"; // GDS

    // const VkSemaphore* pWaitSemaphores // SMB
    IndentSpaces(out, indent);
    *out += "pWaitSemaphores:                ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pWaitSemaphores == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pstruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t swapchainCount // SMB
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->swapchainCount);
    *out += "\n"; // GDS

    // const VkSwapchainKHR* pSwapchains // SMB
    IndentSpaces(out, indent);
    *out += "pSwapchains:                    ";
    *out += "const VkSwapchainKHR* = "; // TEQ
    if (pstruct->pSwapchains == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSwapchains.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        ArrayToString<const VkSwapchainKHR*>(out, indent, 1, "const VkSwapchainKHR*", reinterpret_cast<const VkSwapchainKHR*>(pstruct_in.pSwapchains.GetPointer()), "pSwapchains", pstruct->swapchainCount,  vinfo_pSwapchains);  // CCQ
    }
    *out += "\n"; // GDS

    // const uint32_t* pImageIndices // SMB
    IndentSpaces(out, indent);
    *out += "pImageIndices:                  ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pImageIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pImageIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pImageIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pImageIndices.GetPointer()), "pImageIndices", pstruct->swapchainCount,  vinfo_pImageIndices);  // CCQ
    }
    *out += "\n"; // GDS

    // VkResult* pResults // SMB
    IndentSpaces(out, indent);
    *out += "pResults:                       ";
    *out += "VkResult* = "; // TEQ
    if (pstruct->pResults == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pResults.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pResults = {false, true, false, EnumToStringVkResult};
        ArrayToString<VkResult*>(out, indent, 1, "VkResult*", reinterpret_cast<VkResult*>(pstruct_in.pResults.GetPointer()), "pResults", pstruct->swapchainCount,  vinfo_pResults);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkImageSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageSwapchainCreateInfoKHR *pstruct = (const VkImageSwapchainCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSwapchainKHR swapchain // SMB
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.swapchain); // PAQ
}

template <>
void StructureToString<Decoded_VkBindImageMemorySwapchainInfoKHR>(std::string* out, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindImageMemorySwapchainInfoKHR *pstruct = (const VkBindImageMemorySwapchainInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSwapchainKHR swapchain // SMB
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.swapchain); // PAQ
    *out += "\n"; // GDS

    // uint32_t imageIndex // SMB
    IndentSpaces(out, indent);
    *out += "imageIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imageIndex);
}

template <>
void StructureToString<Decoded_VkAcquireNextImageInfoKHR>(std::string* out, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAcquireNextImageInfoKHR *pstruct = (const VkAcquireNextImageInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSwapchainKHR swapchain // SMB
    IndentSpaces(out, indent);
    *out += "swapchain:                      ";
    *out += "VkSwapchainKHR = "; // TEQ
    AddrToString(out, pstruct_in.swapchain); // PAQ
    *out += "\n"; // GDS

    // uint64_t timeout // SMB
    IndentSpaces(out, indent);
    *out += "timeout:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->timeout);
    *out += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // VkFence fence // SMB
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // uint32_t deviceMask // SMB
    IndentSpaces(out, indent);
    *out += "deviceMask:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceMask);
}

template <>
void StructureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(std::string* out, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupPresentCapabilitiesKHR *pstruct = (const VkDeviceGroupPresentCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t presentMask // SMB
    IndentSpaces(out, indent);
    *out += "presentMask:                    ";
    *out += "uint32_t[";
    *out += "VK_MAX_DEVICE_GROUP_SIZE";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkDeviceGroupPresentCapabilitiesKHR, presentMask)); // IYY
    ValueToStringStruct vinfo_presentMask = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->presentMask), "presentMask", VK_MAX_DEVICE_GROUP_SIZE, vinfo_presentMask); // JPA
    *out += "\n"; // GDS

    // VkDeviceGroupPresentModeFlagsKHR modes // SMB
    IndentSpaces(out, indent);
    *out += "modes:                          ";
    *out += "VkDeviceGroupPresentModeFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->modes, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR); // URW
}

template <>
void StructureToString<Decoded_VkDeviceGroupPresentInfoKHR>(std::string* out, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupPresentInfoKHR *pstruct = (const VkDeviceGroupPresentInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t swapchainCount // SMB
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->swapchainCount);
    *out += "\n"; // GDS

    // const uint32_t* pDeviceMasks // SMB
    IndentSpaces(out, indent);
    *out += "pDeviceMasks:                   ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceMasks == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceMasks.GetPointer()), "pDeviceMasks", pstruct->swapchainCount,  vinfo_pDeviceMasks);  // CCQ
    }
    *out += "\n"; // GDS

    // VkDeviceGroupPresentModeFlagBitsKHR mode // SMB
    IndentSpaces(out, indent);
    *out += "mode:                           ";
    *out += "VkDeviceGroupPresentModeFlagBitsKHR = "; // TEQ
    EnumToStringVkDeviceGroupPresentModeFlagBitsKHR(out, pstruct->mode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->mode);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>(std::string* out, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGroupSwapchainCreateInfoKHR *pstruct = (const VkDeviceGroupSwapchainCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceGroupPresentModeFlagsKHR modes // SMB
    IndentSpaces(out, indent);
    *out += "modes:                          ";
    *out += "VkDeviceGroupPresentModeFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->modes, EnumToStringVkDeviceGroupPresentModeFlagBitsKHR); // URW
}

void VulkanAsciiConsumer::Process_vkCreateSwapchainKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchain)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSwapchainCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSwapchainCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR* pSwapchain // ARG
    if (pSwapchain.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = NULL", indent_string.c_str(), "pSwapchain:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = ", indent_string.c_str(), "pSwapchain:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSwapchain.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySwapchainKHR(
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroySwapchainKHR(device, swapchain, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSwapchainImagesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const PointerDecoder<uint32_t>&             pSwapchainImageCount,
    const HandlePointerDecoder<VkImage>&        pSwapchainImages)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSwapchainImageCount // ARG
    if (pSwapchainImageCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pSwapchainImageCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pSwapchainImageCount:", static_cast<uint64_t>(*pSwapchainImageCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImage* pSwapchainImages // ARG
    if (pSwapchainImages.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImage* = NULL", indent_string.c_str(), "pSwapchainImages:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImage* = ", indent_string.c_str(), "pSwapchainImages:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pSwapchainImages.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pSwapchainImages = {true, false, false, nullptr};
        ArrayToString<VkImage*>(&tmp_string, 1, 1, "VkImage*", reinterpret_cast<VkImage*>(pSwapchainImages.GetPointer()), "pSwapchainImages", *pSwapchainImageCount.GetPointer(), vinfo_pSwapchainImages); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireNextImageKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    uint64_t                                    timeout,
    format::HandleId                            semaphore,
    format::HandleId                            fence,
    const PointerDecoder<uint32_t>&             pImageIndex)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t timeout // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indent_string.c_str(), "timeout:", timeout); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore semaphore // ARG
    fprintf(GetFile(), "%s%-32sVkSemaphore = ", indent_string.c_str(), "semaphore:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, semaphore);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indent_string.c_str(), "fence:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, fence);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pImageIndex // ARG
    if (pImageIndex.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pImageIndex:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pImageIndex:", static_cast<uint64_t>(*pImageIndex.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueuePresentKHR(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkPresentInfoKHR>& pPresentInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueuePresentKHR(queue, pPresentInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPresentInfoKHR* pPresentInfo // ARG
    if (pPresentInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPresentInfoKHR* = NULL", indent_string.c_str(), "pPresentInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPresentInfoKHR* = ", indent_string.c_str(), "pPresentInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pPresentInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPresentInfoKHR>(&tmp_string, *pPresentInfo.GetMetaStructPointer(), 2, pPresentInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupPresentCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceGroupPresentCapabilitiesKHR>& pDeviceGroupPresentCapabilities)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities // ARG
    if (pDeviceGroupPresentCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentCapabilitiesKHR* = NULL", indent_string.c_str(), "pDeviceGroupPresentCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentCapabilitiesKHR* = ", indent_string.c_str(), "pDeviceGroupPresentCapabilities:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pDeviceGroupPresentCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(&tmp_string, *pDeviceGroupPresentCapabilities.GetMetaStructPointer(), 2, pDeviceGroupPresentCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupSurfacePresentModesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            surface,
    const PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>& pModes)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGroupPresentModeFlagsKHR* pModes // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, *pModes.GetPointer(), EnumToStringVkDeviceGroupPresentModeFlagBitsKHR);
    fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentModeFlagsKHR* = %s", indent_string.c_str(), "pModes:", tmp_string.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDevicePresentRectanglesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pRectCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pRects)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pRectCount // ARG
    if (pRectCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pRectCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pRectCount:", static_cast<uint64_t>(*pRectCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkRect2D* pRects // ARG
    if (pRects.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRect2D* = NULL", indent_string.c_str(), "pRects:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRect2D* = ", indent_string.c_str(), "pRects:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pRects.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkRect2D>(&tmp_string, 2, 1, "VkRect2D",
            pRects.GetMetaStructPointer(), "pRects", *pRectCount.GetPointer(), false, pRects.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireNextImage2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAcquireNextImageInfoKHR>& pAcquireInfo,
    const PointerDecoder<uint32_t>&             pImageIndex)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAcquireNextImageInfoKHR* pAcquireInfo // ARG
    if (pAcquireInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAcquireNextImageInfoKHR* = NULL", indent_string.c_str(), "pAcquireInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAcquireNextImageInfoKHR* = ", indent_string.c_str(), "pAcquireInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAcquireInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAcquireNextImageInfoKHR>(&tmp_string, *pAcquireInfo.GetMetaStructPointer(), 2, pAcquireInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pImageIndex // ARG
    if (pImageIndex.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pImageIndex:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pImageIndex:", static_cast<uint64_t>(*pImageIndex.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkDisplayPlaneAlphaFlagBitsKHR(std::string* out, uint32_t enum_uint32)
{
    VkDisplayPlaneAlphaFlagBitsKHR e = static_cast<VkDisplayPlaneAlphaFlagBitsKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR:
            *out += std::string("VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR");
            return;
        case VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR:
            *out += std::string("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR");
            return;
        case VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR:
            *out += std::string("VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR");
            return;
        case VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR:
            *out += std::string("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkDisplayPropertiesKHR>(std::string* out, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModeParametersKHR>(std::string* out, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModePropertiesKHR>(std::string* out, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModeCreateInfoKHR>(std::string* out, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlanePropertiesKHR>(std::string* out, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(std::string* out, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayPropertiesKHR>(std::string* out, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPropertiesKHR *pstruct = (const VkDisplayPropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDisplayKHR display // SMB
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, pstruct_in.display); // PAQ
    *out += "\n"; // GDS

    // const char* displayName // SMB
    IndentSpaces(out, indent);
    *out += "displayName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->displayName); // TGH
    *out += "\n"; // GDS

    // VkExtent2D physicalDimensions // SMB
    IndentSpaces(out, indent);
    *out += "physicalDimensions:             ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.physicalDimensions, indent+1,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalDimensions)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D physicalResolution // SMB
    IndentSpaces(out, indent);
    *out += "physicalResolution:             ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.physicalResolution, indent+1,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalResolution)); // AZJ
    *out += "\n"; // GDS

    // VkSurfaceTransformFlagsKHR supportedTransforms // SMB
    IndentSpaces(out, indent);
    *out += "supportedTransforms:            ";
    *out += "VkSurfaceTransformFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // VkBool32 planeReorderPossible // SMB
    IndentSpaces(out, indent);
    *out += "planeReorderPossible:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->planeReorderPossible);
    *out += "\n"; // GDS

    // VkBool32 persistentContent // SMB
    IndentSpaces(out, indent);
    *out += "persistentContent:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->persistentContent);
}

template <>
void StructureToString<Decoded_VkDisplayModeParametersKHR>(std::string* out, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModeParametersKHR *pstruct = (const VkDisplayModeParametersKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkExtent2D visibleRegion // SMB
    IndentSpaces(out, indent);
    *out += "visibleRegion:                  ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.visibleRegion, indent+1,  base_addr + offsetof(VkDisplayModeParametersKHR, visibleRegion)); // AZJ
    *out += "\n"; // GDS

    // uint32_t refreshRate // SMB
    IndentSpaces(out, indent);
    *out += "refreshRate:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->refreshRate);
}

template <>
void StructureToString<Decoded_VkDisplayModePropertiesKHR>(std::string* out, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModePropertiesKHR *pstruct = (const VkDisplayModePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDisplayModeKHR displayMode // SMB
    IndentSpaces(out, indent);
    *out += "displayMode:                    ";
    *out += "VkDisplayModeKHR = "; // TEQ
    AddrToString(out, pstruct_in.displayMode); // PAQ
    *out += "\n"; // GDS

    // VkDisplayModeParametersKHR parameters // SMB
    IndentSpaces(out, indent);
    *out += "parameters:                     ";
    *out += "VkDisplayModeParametersKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayModeParametersKHR>(out, *pstruct_in.parameters, indent+1,  base_addr + offsetof(VkDisplayModePropertiesKHR, parameters)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayModeCreateInfoKHR>(std::string* out, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModeCreateInfoKHR *pstruct = (const VkDisplayModeCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayModeCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDisplayModeCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkDisplayModeParametersKHR parameters // SMB
    IndentSpaces(out, indent);
    *out += "parameters:                     ";
    *out += "VkDisplayModeParametersKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayModeParametersKHR>(out, *pstruct_in.parameters, indent+1,  base_addr + offsetof(VkDisplayModeCreateInfoKHR, parameters)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneCapabilitiesKHR *pstruct = (const VkDisplayPlaneCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDisplayPlaneAlphaFlagsKHR supportedAlpha // SMB
    IndentSpaces(out, indent);
    *out += "supportedAlpha:                 ";
    *out += "VkDisplayPlaneAlphaFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedAlpha, EnumToStringVkDisplayPlaneAlphaFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // VkOffset2D minSrcPosition // SMB
    IndentSpaces(out, indent);
    *out += "minSrcPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.minSrcPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcPosition)); // AZJ
    *out += "\n"; // GDS

    // VkOffset2D maxSrcPosition // SMB
    IndentSpaces(out, indent);
    *out += "maxSrcPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.maxSrcPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcPosition)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D minSrcExtent // SMB
    IndentSpaces(out, indent);
    *out += "minSrcExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minSrcExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcExtent)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D maxSrcExtent // SMB
    IndentSpaces(out, indent);
    *out += "maxSrcExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxSrcExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcExtent)); // AZJ
    *out += "\n"; // GDS

    // VkOffset2D minDstPosition // SMB
    IndentSpaces(out, indent);
    *out += "minDstPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.minDstPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstPosition)); // AZJ
    *out += "\n"; // GDS

    // VkOffset2D maxDstPosition // SMB
    IndentSpaces(out, indent);
    *out += "maxDstPosition:                 ";
    *out += "VkOffset2D = "; // TEQ
    StructureToString<Decoded_VkOffset2D>(out, *pstruct_in.maxDstPosition, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstPosition)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D minDstExtent // SMB
    IndentSpaces(out, indent);
    *out += "minDstExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minDstExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstExtent)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D maxDstExtent // SMB
    IndentSpaces(out, indent);
    *out += "maxDstExtent:                   ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxDstExtent, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstExtent)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayPlanePropertiesKHR>(std::string* out, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlanePropertiesKHR *pstruct = (const VkDisplayPlanePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkDisplayKHR currentDisplay // SMB
    IndentSpaces(out, indent);
    *out += "currentDisplay:                 ";
    *out += "VkDisplayKHR = "; // TEQ
    AddrToString(out, pstruct_in.currentDisplay); // PAQ
    *out += "\n"; // GDS

    // uint32_t currentStackIndex // SMB
    IndentSpaces(out, indent);
    *out += "currentStackIndex:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->currentStackIndex);
}

template <>
void StructureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(std::string* out, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplaySurfaceCreateInfoKHR *pstruct = (const VkDisplaySurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplaySurfaceCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDisplaySurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkDisplayModeKHR displayMode // SMB
    IndentSpaces(out, indent);
    *out += "displayMode:                    ";
    *out += "VkDisplayModeKHR = "; // TEQ
    AddrToString(out, pstruct_in.displayMode); // PAQ
    *out += "\n"; // GDS

    // uint32_t planeIndex // SMB
    IndentSpaces(out, indent);
    *out += "planeIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->planeIndex);
    *out += "\n"; // GDS

    // uint32_t planeStackIndex // SMB
    IndentSpaces(out, indent);
    *out += "planeStackIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->planeStackIndex);
    *out += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR transform // SMB
    IndentSpaces(out, indent);
    *out += "transform:                      ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->transform);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->transform);
    *out += ")";
    *out += "\n"; // GDS

    // float globalAlpha // SMB
    IndentSpaces(out, indent);
    *out += "globalAlpha:                    ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->globalAlpha);
    *out += "\n"; // GDS

    // VkDisplayPlaneAlphaFlagBitsKHR alphaMode // SMB
    IndentSpaces(out, indent);
    *out += "alphaMode:                      ";
    *out += "VkDisplayPlaneAlphaFlagBitsKHR = "; // TEQ
    EnumToStringVkDisplayPlaneAlphaFlagBitsKHR(out, pstruct->alphaMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->alphaMode);
    *out += ")";
    *out += "\n"; // GDS

    // VkExtent2D imageExtent // SMB
    IndentSpaces(out, indent);
    *out += "imageExtent:                    ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.imageExtent, indent+1,  base_addr + offsetof(VkDisplaySurfaceCreateInfoKHR, imageExtent)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPropertiesKHR>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPropertiesKHR* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPropertiesKHR* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkDisplayPropertiesKHR>(&tmp_string, 2, 1, "VkDisplayPropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPlanePropertiesKHR>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlanePropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlanePropertiesKHR* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlanePropertiesKHR* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkDisplayPlanePropertiesKHR>(&tmp_string, 2, 1, "VkDisplayPlanePropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneSupportedDisplaysKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    planeIndex,
    const PointerDecoder<uint32_t>&             pDisplayCount,
    const HandlePointerDecoder<VkDisplayKHR>&   pDisplays)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t planeIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "planeIndex:", planeIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pDisplayCount // ARG
    if (pDisplayCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pDisplayCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pDisplayCount:", static_cast<uint64_t>(*pDisplayCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR* pDisplays // ARG
    if (pDisplays.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = NULL", indent_string.c_str(), "pDisplays:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = ", indent_string.c_str(), "pDisplays:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pDisplays.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pDisplays = {true, false, false, nullptr};
        ArrayToString<VkDisplayKHR*>(&tmp_string, 1, 1, "VkDisplayKHR*", reinterpret_cast<VkDisplayKHR*>(pDisplays.GetPointer()), "pDisplays", *pDisplayCount.GetPointer(), vinfo_pDisplays); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayModePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayModePropertiesKHR>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indent_string.c_str(), "display:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, display);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModePropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModePropertiesKHR* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModePropertiesKHR* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkDisplayModePropertiesKHR>(&tmp_string, 2, 1, "VkDisplayModePropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDisplayModeKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayModeCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDisplayModeKHR>& pMode)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indent_string.c_str(), "display:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, display);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayModeCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayModeCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayModeCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDisplayModeCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModeKHR* pMode // ARG
    if (pMode.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeKHR* = NULL", indent_string.c_str(), "pMode:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeKHR* = ", indent_string.c_str(), "pMode:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pMode.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            mode,
    uint32_t                                    planeIndex,
    const StructPointerDecoder<Decoded_VkDisplayPlaneCapabilitiesKHR>& pCapabilities)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModeKHR mode // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayModeKHR = ", indent_string.c_str(), "mode:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, mode);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t planeIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "planeIndex:", planeIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlaneCapabilitiesKHR* pCapabilities // ARG
    if (pCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilitiesKHR* = NULL", indent_string.c_str(), "pCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilitiesKHR* = ", indent_string.c_str(), "pCapabilities:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(&tmp_string, *pCapabilities.GetMetaStructPointer(), 2, pCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDisplayPlaneSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDisplaySurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplaySurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplaySurfaceCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplaySurfaceCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkDisplayPresentInfoKHR>(std::string* out, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayPresentInfoKHR>(std::string* out, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPresentInfoKHR *pstruct = (const VkDisplayPresentInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkRect2D srcRect // SMB
    IndentSpaces(out, indent);
    *out += "srcRect:                        ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.srcRect, indent+1,  base_addr + offsetof(VkDisplayPresentInfoKHR, srcRect)); // AZJ
    *out += "\n"; // GDS

    // VkRect2D dstRect // SMB
    IndentSpaces(out, indent);
    *out += "dstRect:                        ";
    *out += "VkRect2D = "; // TEQ
    StructureToString<Decoded_VkRect2D>(out, *pstruct_in.dstRect, indent+1,  base_addr + offsetof(VkDisplayPresentInfoKHR, dstRect)); // AZJ
    *out += "\n"; // GDS

    // VkBool32 persistent // SMB
    IndentSpaces(out, indent);
    *out += "persistent:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->persistent);
}

void VulkanAsciiConsumer::Process_vkCreateSharedSwapchainsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    const StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchains)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t swapchainCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "swapchainCount:", swapchainCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkSwapchainCreateInfoKHR* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSwapchainCreateInfoKHR>(&tmp_string, 2, 1, "VkSwapchainCreateInfoKHR",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", swapchainCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR* pSwapchains // ARG
    if (pSwapchains.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = NULL", indent_string.c_str(), "pSwapchains:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = ", indent_string.c_str(), "pSwapchains:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pSwapchains.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        ArrayToString<VkSwapchainKHR*>(&tmp_string, 1, 1, "VkSwapchainKHR*", reinterpret_cast<VkSwapchainKHR*>(pSwapchains.GetPointer()), "pSwapchains", swapchainCount, vinfo_pSwapchains); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkXlibSurfaceCreateInfoKHR *pstruct = (const VkXlibSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkXlibSurfaceCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkXlibSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // void* dpy // SMB
    IndentSpaces(out, indent);
    *out += "dpy:                            ";
    *out += "void* = "; // TEQ
    if (pstruct->dpy == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.dpy); // PWR
    }
    *out += "\n"; // GDS

    // size_t window // SMB
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->window);
}

void VulkanAsciiConsumer::Process_vkCreateXlibSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkXlibSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkXlibSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkXlibSurfaceCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkXlibSurfaceCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    dpy,
    size_t                                      visualID)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* dpy // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indent_string.c_str(), "dpy:", dpy); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // size_t visualID // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indent_string.c_str(), "visualID:", visualID); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkXcbSurfaceCreateInfoKHR *pstruct = (const VkXcbSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkXcbSurfaceCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkXcbSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // void* connection // SMB
    IndentSpaces(out, indent);
    *out += "connection:                     ";
    *out += "void* = "; // TEQ
    if (pstruct->connection == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.connection); // PWR
    }
    *out += "\n"; // GDS

    // uint32_t window // SMB
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->window);
}

void VulkanAsciiConsumer::Process_vkCreateXcbSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkXcbSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkXcbSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkXcbSurfaceCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkXcbSurfaceCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    connection,
    uint32_t                                    visual_id)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* connection // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indent_string.c_str(), "connection:", connection); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t visual_id // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "visual_id:", visual_id); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWaylandSurfaceCreateInfoKHR *pstruct = (const VkWaylandSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkWaylandSurfaceCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkWaylandSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // struct void* display // SMB
    IndentSpaces(out, indent);
    *out += "display:                        ";
    *out += "struct void* = "; // TEQ
    if (pstruct->display == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.display); // PWR
    }
    *out += "\n"; // GDS

    // struct void* surface // SMB
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "struct void* = "; // TEQ
    if (pstruct->surface == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.surface); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateWaylandSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkWaylandSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkWaylandSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWaylandSurfaceCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWaylandSurfaceCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    display)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // struct void* display // ARG
    fprintf(GetFile(), "%s%-32sstruct void* = 0x%" PRIx64 "", indent_string.c_str(), "display:", display); // YQA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(std::string* out, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidSurfaceCreateInfoKHR *pstruct = (const VkAndroidSurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAndroidSurfaceCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkAndroidSurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // struct void* window // SMB
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "struct void* = "; // TEQ
    if (pstruct->window == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.window); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateAndroidSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkAndroidSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAndroidSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAndroidSurfaceCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAndroidSurfaceCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(std::string* out, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWin32SurfaceCreateInfoKHR *pstruct = (const VkWin32SurfaceCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkWin32SurfaceCreateFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkWin32SurfaceCreateFlagsKHR = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // void* hinstance // SMB
    IndentSpaces(out, indent);
    *out += "hinstance:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->hinstance == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.hinstance); // PWR
    }
    *out += "\n"; // GDS

    // void* hwnd // SMB
    IndentSpaces(out, indent);
    *out += "hwnd:                           ";
    *out += "void* = "; // TEQ
    if (pstruct->hwnd == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.hwnd); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateWin32SurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkWin32SurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkWin32SurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWin32SurfaceCreateInfoKHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWin32SurfaceCreateInfoKHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>& pFeatures)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceFeatures2* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = NULL", indent_string.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = ", indent_string.c_str(), "pFeatures:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceFeatures2>(&tmp_string, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = NULL", indent_string.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = ", indent_string.c_str(), "pProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceProperties2>(&tmp_string, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties2KHR(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties2>& pFormatProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmp_string = "";
    EnumToStringVkFormat(&tmp_string,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indent_string.c_str(), "format:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkFormatProperties2* pFormatProperties // ARG
    if (pFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = NULL", indent_string.c_str(), "pFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = ", indent_string.c_str(), "pFormatProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkFormatProperties2>(&tmp_string, *pFormatProperties.GetMetaStructPointer(), 2, pFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>& pImageFormatInfo,
    const StructPointerDecoder<Decoded_VkImageFormatProperties2>& pImageFormatProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo // ARG
    if (pImageFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = NULL", indent_string.c_str(), "pImageFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = ", indent_string.c_str(), "pImageFormatInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImageFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(&tmp_string, *pImageFormatInfo.GetMetaStructPointer(), 2, pImageFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImageFormatProperties2* pImageFormatProperties // ARG
    if (pImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = NULL", indent_string.c_str(), "pImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = ", indent_string.c_str(), "pImageFormatProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageFormatProperties2>(&tmp_string, *pImageFormatProperties.GetMetaStructPointer(), 2, pImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties2>& pQueueFamilyProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pQueueFamilyPropertyCount // ARG
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pQueueFamilyPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pQueueFamilyPropertyCount:", static_cast<uint64_t>(*pQueueFamilyPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueueFamilyProperties2* pQueueFamilyProperties // ARG
    if (pQueueFamilyProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = NULL", indent_string.c_str(), "pQueueFamilyProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = ", indent_string.c_str(), "pQueueFamilyProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pQueueFamilyProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkQueueFamilyProperties2>(&tmp_string, 2, 1, "VkQueueFamilyProperties2",
            pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>& pMemoryProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceMemoryProperties2* pMemoryProperties // ARG
    if (pMemoryProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = NULL", indent_string.c_str(), "pMemoryProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = ", indent_string.c_str(), "pMemoryProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(&tmp_string, *pMemoryProperties.GetMetaStructPointer(), 2, pMemoryProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>& pFormatInfo,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo // ARG
    if (pFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = NULL", indent_string.c_str(), "pFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = ", indent_string.c_str(), "pFormatInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(&tmp_string, *pFormatInfo.GetMetaStructPointer(), 2, pFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageFormatProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSparseImageFormatProperties2>(&tmp_string, 2, 1, "VkSparseImageFormatProperties2",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkPeerMemoryFeatureFlagBitsKHR(std::string* out, VkPeerMemoryFeatureFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkPeerMemoryFeatureFlagBits(out, e);
}


void EnumToStringVkMemoryAllocateFlagBitsKHR(std::string* out, VkMemoryAllocateFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkMemoryAllocateFlagBits(out, e);
}


void VulkanAsciiConsumer::Process_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    const PointerDecoder<VkPeerMemoryFeatureFlags>& pPeerMemoryFeatures)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t heapIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "heapIndex:", heapIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t localDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "localDeviceIndex:", localDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t remoteDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "remoteDeviceIndex:", remoteDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPeerMemoryFeatureFlags* pPeerMemoryFeatures // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, *pPeerMemoryFeatures.GetPointer(), EnumToStringVkPeerMemoryFeatureFlagBits);
    fprintf(GetFile(), "%s%-32sVkPeerMemoryFeatureFlags* = %s", indent_string.c_str(), "pPeerMemoryFeatures:", tmp_string.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDeviceMaskKHR(
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t deviceMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "deviceMask:", deviceMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchBaseKHR(
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "baseGroupX:", baseGroupX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "baseGroupY:", baseGroupY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "baseGroupZ:", baseGroupZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountX:", groupCountX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountY:", groupCountY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCountZ:", groupCountZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkTrimCommandPoolKHR(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkTrimCommandPoolKHR(device, commandPool, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indent_string.c_str(), "commandPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPoolTrimFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPoolTrimFlags = %d", indent_string.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDeviceGroupsKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceGroupCount,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>& pPhysicalDeviceGroupProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPhysicalDeviceGroupCount // ARG
    if (pPhysicalDeviceGroupCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPhysicalDeviceGroupCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPhysicalDeviceGroupCount:", static_cast<uint64_t>(*pPhysicalDeviceGroupCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties // ARG
    if (pPhysicalDeviceGroupProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = NULL", indent_string.c_str(), "pPhysicalDeviceGroupProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = ", indent_string.c_str(), "pPhysicalDeviceGroupProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pPhysicalDeviceGroupProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkPhysicalDeviceGroupProperties>(&tmp_string, 2, 1, "VkPhysicalDeviceGroupProperties",
            pPhysicalDeviceGroupProperties.GetMetaStructPointer(), "pPhysicalDeviceGroupProperties", *pPhysicalDeviceGroupCount.GetPointer(), false, pPhysicalDeviceGroupProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkExternalMemoryHandleTypeFlagBitsKHR(std::string* out, VkExternalMemoryHandleTypeFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, e);
}


void EnumToStringVkExternalMemoryFeatureFlagBitsKHR(std::string* out, VkExternalMemoryFeatureFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkExternalMemoryFeatureFlagBits(out, e);
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>& pExternalBufferInfo,
    const StructPointerDecoder<Decoded_VkExternalBufferProperties>& pExternalBufferProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo // ARG
    if (pExternalBufferInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = NULL", indent_string.c_str(), "pExternalBufferInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = ", indent_string.c_str(), "pExternalBufferInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalBufferInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(&tmp_string, *pExternalBufferInfo.GetMetaStructPointer(), 2, pExternalBufferInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalBufferProperties* pExternalBufferProperties // ARG
    if (pExternalBufferProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = NULL", indent_string.c_str(), "pExternalBufferProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = ", indent_string.c_str(), "pExternalBufferProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalBufferProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExternalBufferProperties>(&tmp_string, *pExternalBufferProperties.GetMetaStructPointer(), 2, pExternalBufferProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkImportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(std::string* out, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryWin32HandleInfoKHR *pstruct = (const VkImportMemoryWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // void* handle // SMB
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
    *out += "\n"; // GDS

    // const wchar_t* name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkExportMemoryWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportMemoryWin32HandleInfoKHR *pstruct = (const VkExportMemoryWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttributes->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t dwAccess // SMB
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess);
    *out += "\n"; // GDS

    // const wchar_t* name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(std::string* out, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryWin32HandlePropertiesKHR *pstruct = (const VkMemoryWin32HandlePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits);
}

template <>
void StructureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryGetWin32HandleInfoKHR *pstruct = (const VkMemoryGetWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo // ARG
    if (pGetWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetWin32HandleInfoKHR* = NULL", indent_string.c_str(), "pGetWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetWin32HandleInfoKHR* = ", indent_string.c_str(), "pGetWin32HandleInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pGetWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(&tmp_string, *pGetWin32HandleInfo.GetMetaStructPointer(), 2, pGetWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indent_string.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indent_string.c_str(), "pHandle:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandlePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    handle,
    const StructPointerDecoder<Decoded_VkMemoryWin32HandlePropertiesKHR>& pMemoryWin32HandleProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagBits handleType // ARG
    tmp_string = "";
    EnumToStringVkExternalMemoryHandleTypeFlagBits(&tmp_string,handleType); // EPW
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagBits = %s", indent_string.c_str(), "handleType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // void* handle // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indent_string.c_str(), "handle:", handle); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties // ARG
    if (pMemoryWin32HandleProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryWin32HandlePropertiesKHR* = NULL", indent_string.c_str(), "pMemoryWin32HandleProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryWin32HandlePropertiesKHR* = ", indent_string.c_str(), "pMemoryWin32HandleProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryWin32HandleProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(&tmp_string, *pMemoryWin32HandleProperties.GetMetaStructPointer(), 2, pMemoryWin32HandleProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkImportMemoryFdInfoKHR>(std::string* out, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryFdPropertiesKHR>(std::string* out, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryGetFdInfoKHR>(std::string* out, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportMemoryFdInfoKHR>(std::string* out, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryFdInfoKHR *pstruct = (const VkImportMemoryFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // int fd // SMB
    IndentSpaces(out, indent);
    *out += "fd:                             ";
    *out += "int = "; // TEQ
    SignedDecimalToString(out, pstruct->fd);
}

template <>
void StructureToString<Decoded_VkMemoryFdPropertiesKHR>(std::string* out, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryFdPropertiesKHR *pstruct = (const VkMemoryFdPropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits);
}

template <>
void StructureToString<Decoded_VkMemoryGetFdInfoKHR>(std::string* out, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryGetFdInfoKHR *pstruct = (const VkMemoryGetFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetMemoryFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetMemoryFdKHR(device, pGetFdInfo, pFd)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryGetFdInfoKHR* pGetFdInfo // ARG
    if (pGetFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetFdInfoKHR* = NULL", indent_string.c_str(), "pGetFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetFdInfoKHR* = ", indent_string.c_str(), "pGetFdInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pGetFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryGetFdInfoKHR>(&tmp_string, *pGetFdInfo.GetMetaStructPointer(), 2, pGetFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // int* pFd // ARG
    if (pFd.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sint* = NULL", indent_string.c_str(), "pFd:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sint* = %" PRId64 "", indent_string.c_str(), "pFd:", static_cast<uint64_t>(*pFd.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryFdPropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd,
    const StructPointerDecoder<Decoded_VkMemoryFdPropertiesKHR>& pMemoryFdProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagBits handleType // ARG
    tmp_string = "";
    EnumToStringVkExternalMemoryHandleTypeFlagBits(&tmp_string,handleType); // EPW
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagBits = %s", indent_string.c_str(), "handleType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // int fd // ARG
    fprintf(GetFile(), "%s%-32sint = %d", indent_string.c_str(), "fd:", fd); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryFdPropertiesKHR* pMemoryFdProperties // ARG
    if (pMemoryFdProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryFdPropertiesKHR* = NULL", indent_string.c_str(), "pMemoryFdProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryFdPropertiesKHR* = ", indent_string.c_str(), "pMemoryFdProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryFdProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryFdPropertiesKHR>(&tmp_string, *pMemoryFdProperties.GetMetaStructPointer(), 2, pMemoryFdProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkExternalSemaphoreHandleTypeFlagBitsKHR(std::string* out, VkExternalSemaphoreHandleTypeFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, e);
}


void EnumToStringVkExternalSemaphoreFeatureFlagBitsKHR(std::string* out, VkExternalSemaphoreFeatureFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkExternalSemaphoreFeatureFlagBits(out, e);
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>& pExternalSemaphoreInfo,
    const StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>& pExternalSemaphoreProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo // ARG
    if (pExternalSemaphoreInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = NULL", indent_string.c_str(), "pExternalSemaphoreInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = ", indent_string.c_str(), "pExternalSemaphoreInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalSemaphoreInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(&tmp_string, *pExternalSemaphoreInfo.GetMetaStructPointer(), 2, pExternalSemaphoreInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalSemaphoreProperties* pExternalSemaphoreProperties // ARG
    if (pExternalSemaphoreProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = NULL", indent_string.c_str(), "pExternalSemaphoreProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = ", indent_string.c_str(), "pExternalSemaphoreProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalSemaphoreProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExternalSemaphoreProperties>(&tmp_string, *pExternalSemaphoreProperties.GetMetaStructPointer(), 2, pExternalSemaphoreProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkSemaphoreImportFlagBitsKHR(std::string* out, VkSemaphoreImportFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkSemaphoreImportFlagBits(out, e);
}

template <> void StructureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkD3D12FenceSubmitInfoKHR>(std::string* out, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportSemaphoreWin32HandleInfoKHR *pstruct = (const VkImportSemaphoreWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // VkSemaphoreImportFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSemaphoreImportFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // void* handle // SMB
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
    *out += "\n"; // GDS

    // const wchar_t* name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkExportSemaphoreWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportSemaphoreWin32HandleInfoKHR *pstruct = (const VkExportSemaphoreWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttributes->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t dwAccess // SMB
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess);
    *out += "\n"; // GDS

    // const wchar_t* name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkD3D12FenceSubmitInfoKHR>(std::string* out, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkD3D12FenceSubmitInfoKHR *pstruct = (const VkD3D12FenceSubmitInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t waitSemaphoreValuesCount // SMB
    IndentSpaces(out, indent);
    *out += "waitSemaphoreValuesCount:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreValuesCount);
    *out += "\n"; // GDS

    // const uint64_t* pWaitSemaphoreValues // SMB
    IndentSpaces(out, indent);
    *out += "pWaitSemaphoreValues:           ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pstruct->waitSemaphoreValuesCount,  vinfo_pWaitSemaphoreValues);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t signalSemaphoreValuesCount // SMB
    IndentSpaces(out, indent);
    *out += "signalSemaphoreValuesCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreValuesCount);
    *out += "\n"; // GDS

    // const uint64_t* pSignalSemaphoreValues // SMB
    IndentSpaces(out, indent);
    *out += "pSignalSemaphoreValues:         ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pstruct->signalSemaphoreValuesCount,  vinfo_pSignalSemaphoreValues);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreGetWin32HandleInfoKHR *pstruct = (const VkSemaphoreGetWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkImportSemaphoreWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportSemaphoreWin32HandleInfoKHR>& pImportSemaphoreWin32HandleInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo // ARG
    if (pImportSemaphoreWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreWin32HandleInfoKHR* = NULL", indent_string.c_str(), "pImportSemaphoreWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreWin32HandleInfoKHR* = ", indent_string.c_str(), "pImportSemaphoreWin32HandleInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImportSemaphoreWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(&tmp_string, *pImportSemaphoreWin32HandleInfo.GetMetaStructPointer(), 2, pImportSemaphoreWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSemaphoreWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo // ARG
    if (pGetWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetWin32HandleInfoKHR* = NULL", indent_string.c_str(), "pGetWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetWin32HandleInfoKHR* = ", indent_string.c_str(), "pGetWin32HandleInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pGetWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(&tmp_string, *pGetWin32HandleInfo.GetMetaStructPointer(), 2, pGetWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indent_string.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indent_string.c_str(), "pHandle:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkImportSemaphoreFdInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreGetFdInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportSemaphoreFdInfoKHR>(std::string* out, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportSemaphoreFdInfoKHR *pstruct = (const VkImportSemaphoreFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // VkSemaphoreImportFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSemaphoreImportFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // int fd // SMB
    IndentSpaces(out, indent);
    *out += "fd:                             ";
    *out += "int = "; // TEQ
    SignedDecimalToString(out, pstruct->fd);
}

template <>
void StructureToString<Decoded_VkSemaphoreGetFdInfoKHR>(std::string* out, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreGetFdInfoKHR *pstruct = (const VkSemaphoreGetFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalSemaphoreHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkImportSemaphoreFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportSemaphoreFdInfoKHR>& pImportSemaphoreFdInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo // ARG
    if (pImportSemaphoreFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreFdInfoKHR* = NULL", indent_string.c_str(), "pImportSemaphoreFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreFdInfoKHR* = ", indent_string.c_str(), "pImportSemaphoreFdInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImportSemaphoreFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImportSemaphoreFdInfoKHR>(&tmp_string, *pImportSemaphoreFdInfo.GetMetaStructPointer(), 2, pImportSemaphoreFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSemaphoreFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreGetFdInfoKHR* pGetFdInfo // ARG
    if (pGetFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetFdInfoKHR* = NULL", indent_string.c_str(), "pGetFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetFdInfoKHR* = ", indent_string.c_str(), "pGetFdInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pGetFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSemaphoreGetFdInfoKHR>(&tmp_string, *pGetFdInfo.GetMetaStructPointer(), 2, pGetFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // int* pFd // ARG
    if (pFd.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sint* = NULL", indent_string.c_str(), "pFd:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sint* = %" PRId64 "", indent_string.c_str(), "pFd:", static_cast<uint64_t>(*pFd.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR>(std::string* out, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR>(std::string* out, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevicePushDescriptorPropertiesKHR *pstruct = (const VkPhysicalDevicePushDescriptorPropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t maxPushDescriptors // SMB
    IndentSpaces(out, indent);
    *out += "maxPushDescriptors:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPushDescriptors);
}

void VulkanAsciiConsumer::Process_vkCmdPushDescriptorSetKHR(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const StructPointerDecoder<Decoded_VkWriteDescriptorSet>& pDescriptorWrites)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineBindPoint pipelineBindPoint // ARG
    tmp_string = "";
    EnumToStringVkPipelineBindPoint(&tmp_string,pipelineBindPoint); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineBindPoint = %s", indent_string.c_str(), "pipelineBindPoint:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout layout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indent_string.c_str(), "layout:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, layout);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t set // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "set:", set); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorWriteCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "descriptorWriteCount:", descriptorWriteCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkWriteDescriptorSet* pDescriptorWrites // ARG
    if (pDescriptorWrites.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = NULL", indent_string.c_str(), "pDescriptorWrites:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = ", indent_string.c_str(), "pDescriptorWrites:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pDescriptorWrites.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkWriteDescriptorSet>(&tmp_string, 2, 1, "VkWriteDescriptorSet",
            pDescriptorWrites.GetMetaStructPointer(), "pDescriptorWrites", descriptorWriteCount, false, pDescriptorWrites.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkDescriptorUpdateTemplateTypeKHR(std::string* out, VkDescriptorUpdateTemplateTypeKHR e)
{
    assert(out != nullptr);
    EnumToStringVkDescriptorUpdateTemplateType(out, e);
}


void VulkanAsciiConsumer::Process_vkCreateDescriptorUpdateTemplateKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorUpdateTemplate>& pDescriptorUpdateTemplate)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate // ARG
    if (pDescriptorUpdateTemplate.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = NULL", indent_string.c_str(), "pDescriptorUpdateTemplate:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = ", indent_string.c_str(), "pDescriptorUpdateTemplate:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pDescriptorUpdateTemplate.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorUpdateTemplateKHR(
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate descriptorUpdateTemplate // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate = ", indent_string.c_str(), "descriptorUpdateTemplate:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, descriptorUpdateTemplate);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkAttachmentDescription2KHR>(std::string* out, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentReference2KHR>(std::string* out, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDescription2KHR>(std::string* out, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassDependency2KHR>(std::string* out, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassCreateInfo2KHR>(std::string* out, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassBeginInfoKHR>(std::string* out, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassEndInfoKHR>(std::string* out, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkAttachmentDescription2KHR>(std::string* out, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentDescription2KHR *pstruct = (const VkAttachmentDescription2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAttachmentDescriptionFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkAttachmentDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkAttachmentDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    IndentSpaces(out, indent);
    *out += "samples:                        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->samples);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->samples);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentLoadOp loadOp // SMB
    IndentSpaces(out, indent);
    *out += "loadOp:                         ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->loadOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->loadOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentStoreOp storeOp // SMB
    IndentSpaces(out, indent);
    *out += "storeOp:                        ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->storeOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->storeOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentLoadOp stencilLoadOp // SMB
    IndentSpaces(out, indent);
    *out += "stencilLoadOp:                  ";
    *out += "VkAttachmentLoadOp = "; // TEQ
    EnumToStringVkAttachmentLoadOp(out, pstruct->stencilLoadOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilLoadOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkAttachmentStoreOp stencilStoreOp // SMB
    IndentSpaces(out, indent);
    *out += "stencilStoreOp:                 ";
    *out += "VkAttachmentStoreOp = "; // TEQ
    EnumToStringVkAttachmentStoreOp(out, pstruct->stencilStoreOp);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stencilStoreOp);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageLayout initialLayout // SMB
    IndentSpaces(out, indent);
    *out += "initialLayout:                  ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->initialLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->initialLayout);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageLayout finalLayout // SMB
    IndentSpaces(out, indent);
    *out += "finalLayout:                    ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->finalLayout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->finalLayout);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkAttachmentReference2KHR>(std::string* out, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentReference2KHR *pstruct = (const VkAttachmentReference2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t attachment // SMB
    IndentSpaces(out, indent);
    *out += "attachment:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachment);
    *out += "\n"; // GDS

    // VkImageLayout layout // SMB
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkImageLayout = "; // TEQ
    EnumToStringVkImageLayout(out, pstruct->layout);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->layout);
    *out += ")";
    *out += "\n"; // GDS

    // VkImageAspectFlags aspectMask // SMB
    IndentSpaces(out, indent);
    *out += "aspectMask:                     ";
    *out += "VkImageAspectFlags = "; // TEQ
    FlagsToString(out, pstruct->aspectMask, EnumToStringVkImageAspectFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkSubpassDescription2KHR>(std::string* out, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDescription2KHR *pstruct = (const VkSubpassDescription2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSubpassDescriptionFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSubpassDescriptionFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSubpassDescriptionFlagBits); // URW
    *out += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t viewMask // SMB
    IndentSpaces(out, indent);
    *out += "viewMask:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewMask);
    *out += "\n"; // GDS

    // uint32_t inputAttachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "inputAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->inputAttachmentCount);
    *out += "\n"; // GDS

    // const VkAttachmentReference2KHR* pInputAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pInputAttachments:              ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pInputAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInputAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(out, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t colorAttachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "colorAttachmentCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->colorAttachmentCount);
    *out += "\n"; // GDS

    // const VkAttachmentReference2KHR* pColorAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pColorAttachments:              ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pColorAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pColorAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(out, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // const VkAttachmentReference2KHR* pResolveAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pResolveAttachments:            ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pResolveAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pResolveAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(out, indent+1, 1, "VkAttachmentReference2KHR", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // const VkAttachmentReference2KHR* pDepthStencilAttachment // SMB
    IndentSpaces(out, indent);
    *out += "pDepthStencilAttachment:        ";
    *out += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pstruct->pDepthStencilAttachment == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDepthStencilAttachment->GetAddress()); // JHI
        StructureToString<Decoded_VkAttachmentReference2KHR>(out, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, base_addr + offsetof(VkSubpassDescription2KHR, pDepthStencilAttachment)); // GLM
    }
    *out += "\n"; // GDS

    // uint32_t preserveAttachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "preserveAttachmentCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->preserveAttachmentCount);
    *out += "\n"; // GDS

    // const uint32_t* pPreserveAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pPreserveAttachments:           ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pPreserveAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPreserveAttachments.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pstruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkSubpassDependency2KHR>(std::string* out, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassDependency2KHR *pstruct = (const VkSubpassDependency2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t srcSubpass // SMB
    IndentSpaces(out, indent);
    *out += "srcSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->srcSubpass);
    *out += "\n"; // GDS

    // uint32_t dstSubpass // SMB
    IndentSpaces(out, indent);
    *out += "dstSubpass:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dstSubpass);
    *out += "\n"; // GDS

    // VkPipelineStageFlags srcStageMask // SMB
    IndentSpaces(out, indent);
    *out += "srcStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->srcStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // VkPipelineStageFlags dstStageMask // SMB
    IndentSpaces(out, indent);
    *out += "dstStageMask:                   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->dstStageMask, EnumToStringVkPipelineStageFlagBits); // URW
    *out += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "srcAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->srcAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    IndentSpaces(out, indent);
    *out += "dstAccessMask:                  ";
    *out += "VkAccessFlags = "; // TEQ
    FlagsToString(out, pstruct->dstAccessMask, EnumToStringVkAccessFlagBits); // URW
    *out += "\n"; // GDS

    // VkDependencyFlags dependencyFlags // SMB
    IndentSpaces(out, indent);
    *out += "dependencyFlags:                ";
    *out += "VkDependencyFlags = "; // TEQ
    FlagsToString(out, pstruct->dependencyFlags, EnumToStringVkDependencyFlagBits); // URW
    *out += "\n"; // GDS

    // int32_t viewOffset // SMB
    IndentSpaces(out, indent);
    *out += "viewOffset:                     ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->viewOffset);
}

template <>
void StructureToString<Decoded_VkRenderPassCreateInfo2KHR>(std::string* out, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassCreateInfo2KHR *pstruct = (const VkRenderPassCreateInfo2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkRenderPassCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkRenderPassCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkRenderPassCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    IndentSpaces(out, indent);
    *out += "attachmentCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentCount);
    *out += "\n"; // GDS

    // const VkAttachmentDescription2KHR* pAttachments // SMB
    IndentSpaces(out, indent);
    *out += "pAttachments:                   ";
    *out += "const VkAttachmentDescription2KHR* = "; // TEQ
    if (pstruct->pAttachments == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachments->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentDescription2KHR>(out, indent+1, 1, "VkAttachmentDescription2KHR", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t subpassCount // SMB
    IndentSpaces(out, indent);
    *out += "subpassCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassCount);
    *out += "\n"; // GDS

    // const VkSubpassDescription2KHR* pSubpasses // SMB
    IndentSpaces(out, indent);
    *out += "pSubpasses:                     ";
    *out += "const VkSubpassDescription2KHR* = "; // TEQ
    if (pstruct->pSubpasses == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSubpasses->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSubpassDescription2KHR>(out, indent+1, 1, "VkSubpassDescription2KHR", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t dependencyCount // SMB
    IndentSpaces(out, indent);
    *out += "dependencyCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dependencyCount);
    *out += "\n"; // GDS

    // const VkSubpassDependency2KHR* pDependencies // SMB
    IndentSpaces(out, indent);
    *out += "pDependencies:                  ";
    *out += "const VkSubpassDependency2KHR* = "; // TEQ
    if (pstruct->pDependencies == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDependencies->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSubpassDependency2KHR>(out, indent+1, 1, "VkSubpassDependency2KHR", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t correlatedViewMaskCount // SMB
    IndentSpaces(out, indent);
    *out += "correlatedViewMaskCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->correlatedViewMaskCount);
    *out += "\n"; // GDS

    // const uint32_t* pCorrelatedViewMasks // SMB
    IndentSpaces(out, indent);
    *out += "pCorrelatedViewMasks:           ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pCorrelatedViewMasks == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCorrelatedViewMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCorrelatedViewMasks = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pCorrelatedViewMasks.GetPointer()), "pCorrelatedViewMasks", pstruct->correlatedViewMaskCount,  vinfo_pCorrelatedViewMasks);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkSubpassBeginInfoKHR>(std::string* out, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassBeginInfoKHR *pstruct = (const VkSubpassBeginInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSubpassContents contents // SMB
    IndentSpaces(out, indent);
    *out += "contents:                       ";
    *out += "VkSubpassContents = "; // TEQ
    EnumToStringVkSubpassContents(out, pstruct->contents);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->contents);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSubpassEndInfoKHR>(std::string* out, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassEndInfoKHR *pstruct = (const VkSubpassEndInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
}

void VulkanAsciiConsumer::Process_vkCreateRenderPass2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkRenderPassCreateInfo2KHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkRenderPass>&   pRenderPass)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassCreateInfo2KHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo2KHR* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo2KHR* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkRenderPassCreateInfo2KHR>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass* pRenderPass // ARG
    if (pRenderPass.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = NULL", indent_string.c_str(), "pRenderPass:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = ", indent_string.c_str(), "pRenderPass:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pRenderPass.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginRenderPass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkRenderPassBeginInfo>& pRenderPassBegin,
    const StructPointerDecoder<Decoded_VkSubpassBeginInfoKHR>& pSubpassBeginInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassBeginInfo* pRenderPassBegin // ARG
    if (pRenderPassBegin.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = NULL", indent_string.c_str(), "pRenderPassBegin:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = ", indent_string.c_str(), "pRenderPassBegin:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pRenderPassBegin.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkRenderPassBeginInfo>(&tmp_string, *pRenderPassBegin.GetMetaStructPointer(), 2, pRenderPassBegin.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassBeginInfoKHR* pSubpassBeginInfo // ARG
    if (pSubpassBeginInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = NULL", indent_string.c_str(), "pSubpassBeginInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = ", indent_string.c_str(), "pSubpassBeginInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSubpassBeginInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSubpassBeginInfoKHR>(&tmp_string, *pSubpassBeginInfo.GetMetaStructPointer(), 2, pSubpassBeginInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdNextSubpass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSubpassBeginInfoKHR>& pSubpassBeginInfo,
    const StructPointerDecoder<Decoded_VkSubpassEndInfoKHR>& pSubpassEndInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassBeginInfoKHR* pSubpassBeginInfo // ARG
    if (pSubpassBeginInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = NULL", indent_string.c_str(), "pSubpassBeginInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = ", indent_string.c_str(), "pSubpassBeginInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSubpassBeginInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSubpassBeginInfoKHR>(&tmp_string, *pSubpassBeginInfo.GetMetaStructPointer(), 2, pSubpassBeginInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassEndInfoKHR* pSubpassEndInfo // ARG
    if (pSubpassEndInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = NULL", indent_string.c_str(), "pSubpassEndInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = ", indent_string.c_str(), "pSubpassEndInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSubpassEndInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSubpassEndInfoKHR>(&tmp_string, *pSubpassEndInfo.GetMetaStructPointer(), 2, pSubpassEndInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndRenderPass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSubpassEndInfoKHR>& pSubpassEndInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassEndInfoKHR* pSubpassEndInfo // ARG
    if (pSubpassEndInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = NULL", indent_string.c_str(), "pSubpassEndInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = ", indent_string.c_str(), "pSubpassEndInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSubpassEndInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSubpassEndInfoKHR>(&tmp_string, *pSubpassEndInfo.GetMetaStructPointer(), 2, pSubpassEndInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>(std::string* out, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSharedPresentSurfaceCapabilitiesKHR *pstruct = (const VkSharedPresentSurfaceCapabilitiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageUsageFlags sharedPresentSupportedUsageFlags // SMB
    IndentSpaces(out, indent);
    *out += "sharedPresentSupportedUsageFlags: ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->sharedPresentSupportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetSwapchainStatusKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetSwapchainStatusKHR(device, swapchain)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkExternalFenceHandleTypeFlagBitsKHR(std::string* out, VkExternalFenceHandleTypeFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, e);
}


void EnumToStringVkExternalFenceFeatureFlagBitsKHR(std::string* out, VkExternalFenceFeatureFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkExternalFenceFeatureFlagBits(out, e);
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>& pExternalFenceInfo,
    const StructPointerDecoder<Decoded_VkExternalFenceProperties>& pExternalFenceProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo // ARG
    if (pExternalFenceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = NULL", indent_string.c_str(), "pExternalFenceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = ", indent_string.c_str(), "pExternalFenceInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalFenceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(&tmp_string, *pExternalFenceInfo.GetMetaStructPointer(), 2, pExternalFenceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalFenceProperties* pExternalFenceProperties // ARG
    if (pExternalFenceProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = NULL", indent_string.c_str(), "pExternalFenceProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = ", indent_string.c_str(), "pExternalFenceProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalFenceProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExternalFenceProperties>(&tmp_string, *pExternalFenceProperties.GetMetaStructPointer(), 2, pExternalFenceProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkFenceImportFlagBitsKHR(std::string* out, VkFenceImportFlagBitsKHR e)
{
    assert(out != nullptr);
    EnumToStringVkFenceImportFlagBits(out, e);
}

template <> void StructureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportFenceWin32HandleInfoKHR *pstruct = (const VkImportFenceWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFence fence // SMB
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // VkFenceImportFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFenceImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFenceImportFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // void* handle // SMB
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
    *out += "\n"; // GDS

    // const wchar_t* name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkExportFenceWin32HandleInfoKHR>(std::string* out, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportFenceWin32HandleInfoKHR *pstruct = (const VkExportFenceWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttributes->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t dwAccess // SMB
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess);
    *out += "\n"; // GDS

    // const wchar_t* name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "const wchar_t* = "; // TEQ
    if (pstruct->name == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.name.GetAddress()); // PWQ
    }
}

template <>
void StructureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(std::string* out, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFenceGetWin32HandleInfoKHR *pstruct = (const VkFenceGetWin32HandleInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFence fence // SMB
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkImportFenceWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportFenceWin32HandleInfoKHR>& pImportFenceWin32HandleInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo // ARG
    if (pImportFenceWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceWin32HandleInfoKHR* = NULL", indent_string.c_str(), "pImportFenceWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceWin32HandleInfoKHR* = ", indent_string.c_str(), "pImportFenceWin32HandleInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImportFenceWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(&tmp_string, *pImportFenceWin32HandleInfo.GetMetaStructPointer(), 2, pImportFenceWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetFenceWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo // ARG
    if (pGetWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetWin32HandleInfoKHR* = NULL", indent_string.c_str(), "pGetWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetWin32HandleInfoKHR* = ", indent_string.c_str(), "pGetWin32HandleInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pGetWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(&tmp_string, *pGetWin32HandleInfo.GetMetaStructPointer(), 2, pGetWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indent_string.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indent_string.c_str(), "pHandle:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkImportFenceFdInfoKHR>(std::string* out, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFenceGetFdInfoKHR>(std::string* out, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportFenceFdInfoKHR>(std::string* out, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportFenceFdInfoKHR *pstruct = (const VkImportFenceFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFence fence // SMB
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // VkFenceImportFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkFenceImportFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkFenceImportFlagBits); // URW
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // int fd // SMB
    IndentSpaces(out, indent);
    *out += "fd:                             ";
    *out += "int = "; // TEQ
    SignedDecimalToString(out, pstruct->fd);
}

template <>
void StructureToString<Decoded_VkFenceGetFdInfoKHR>(std::string* out, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFenceGetFdInfoKHR *pstruct = (const VkFenceGetFdInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFence fence // SMB
    IndentSpaces(out, indent);
    *out += "fence:                          ";
    *out += "VkFence = "; // TEQ
    AddrToString(out, pstruct_in.fence); // PAQ
    *out += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalFenceHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkImportFenceFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportFenceFdInfoKHR>& pImportFenceFdInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkImportFenceFdKHR(device, pImportFenceFdInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportFenceFdInfoKHR* pImportFenceFdInfo // ARG
    if (pImportFenceFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceFdInfoKHR* = NULL", indent_string.c_str(), "pImportFenceFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceFdInfoKHR* = ", indent_string.c_str(), "pImportFenceFdInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pImportFenceFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImportFenceFdInfoKHR>(&tmp_string, *pImportFenceFdInfo.GetMetaStructPointer(), 2, pImportFenceFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetFenceFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetFenceFdKHR(device, pGetFdInfo, pFd)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFenceGetFdInfoKHR* pGetFdInfo // ARG
    if (pGetFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetFdInfoKHR* = NULL", indent_string.c_str(), "pGetFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetFdInfoKHR* = ", indent_string.c_str(), "pGetFdInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pGetFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkFenceGetFdInfoKHR>(&tmp_string, *pGetFdInfo.GetMetaStructPointer(), 2, pGetFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // int* pFd // ARG
    if (pFd.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sint* = NULL", indent_string.c_str(), "pFd:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sint* = %" PRId64 "", indent_string.c_str(), "pFd:", static_cast<uint64_t>(*pFd.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkPointClippingBehaviorKHR(std::string* out, VkPointClippingBehaviorKHR e)
{
    assert(out != nullptr);
    EnumToStringVkPointClippingBehavior(out, e);
}


void EnumToStringVkTessellationDomainOriginKHR(std::string* out, VkTessellationDomainOriginKHR e)
{
    assert(out != nullptr);
    EnumToStringVkTessellationDomainOrigin(out, e);
}

template <> void StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(std::string* out, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceCapabilities2KHR>(std::string* out, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceFormat2KHR>(std::string* out, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(std::string* out, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSurfaceInfo2KHR *pstruct = (const VkPhysicalDeviceSurfaceInfo2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSurfaceKHR surface // SMB
    IndentSpaces(out, indent);
    *out += "surface:                        ";
    *out += "VkSurfaceKHR = "; // TEQ
    AddrToString(out, pstruct_in.surface); // PAQ
}

template <>
void StructureToString<Decoded_VkSurfaceCapabilities2KHR>(std::string* out, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilities2KHR *pstruct = (const VkSurfaceCapabilities2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSurfaceCapabilitiesKHR surfaceCapabilities // SMB
    IndentSpaces(out, indent);
    *out += "surfaceCapabilities:            ";
    *out += "VkSurfaceCapabilitiesKHR = "; // TEQ
    StructureToString<Decoded_VkSurfaceCapabilitiesKHR>(out, *pstruct_in.surfaceCapabilities, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2KHR, surfaceCapabilities)); // AZJ
}

template <>
void StructureToString<Decoded_VkSurfaceFormat2KHR>(std::string* out, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFormat2KHR *pstruct = (const VkSurfaceFormat2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSurfaceFormatKHR surfaceFormat // SMB
    IndentSpaces(out, indent);
    *out += "surfaceFormat:                  ";
    *out += "VkSurfaceFormatKHR = "; // TEQ
    StructureToString<Decoded_VkSurfaceFormatKHR>(out, *pstruct_in.surfaceFormat, indent+1,  base_addr + offsetof(VkSurfaceFormat2KHR, surfaceFormat)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilities2KHR>& pSurfaceCapabilities)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indent_string.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indent_string.c_str(), "pSurfaceInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmp_string, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCapabilities2KHR* pSurfaceCapabilities // ARG
    if (pSurfaceCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2KHR* = NULL", indent_string.c_str(), "pSurfaceCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2KHR* = ", indent_string.c_str(), "pSurfaceCapabilities:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSurfaceCapabilities2KHR>(&tmp_string, *pSurfaceCapabilities.GetMetaStructPointer(), 2, pSurfaceCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<uint32_t>&             pSurfaceFormatCount,
    const StructPointerDecoder<Decoded_VkSurfaceFormat2KHR>& pSurfaceFormats)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indent_string.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indent_string.c_str(), "pSurfaceInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmp_string, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSurfaceFormatCount // ARG
    if (pSurfaceFormatCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pSurfaceFormatCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pSurfaceFormatCount:", static_cast<uint64_t>(*pSurfaceFormatCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceFormat2KHR* pSurfaceFormats // ARG
    if (pSurfaceFormats.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormat2KHR* = NULL", indent_string.c_str(), "pSurfaceFormats:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormat2KHR* = ", indent_string.c_str(), "pSurfaceFormats:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceFormats.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSurfaceFormat2KHR>(&tmp_string, 2, 1, "VkSurfaceFormat2KHR",
            pSurfaceFormats.GetMetaStructPointer(), "pSurfaceFormats", *pSurfaceFormatCount.GetPointer(), false, pSurfaceFormats.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkDisplayProperties2KHR>(std::string* out, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlaneProperties2KHR>(std::string* out, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayModeProperties2KHR>(std::string* out, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlaneInfo2KHR>(std::string* out, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayProperties2KHR>(std::string* out, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayProperties2KHR *pstruct = (const VkDisplayProperties2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayPropertiesKHR displayProperties // SMB
    IndentSpaces(out, indent);
    *out += "displayProperties:              ";
    *out += "VkDisplayPropertiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayPropertiesKHR>(out, *pstruct_in.displayProperties, indent+1,  base_addr + offsetof(VkDisplayProperties2KHR, displayProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayPlaneProperties2KHR>(std::string* out, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneProperties2KHR *pstruct = (const VkDisplayPlaneProperties2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayPlanePropertiesKHR displayPlaneProperties // SMB
    IndentSpaces(out, indent);
    *out += "displayPlaneProperties:         ";
    *out += "VkDisplayPlanePropertiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayPlanePropertiesKHR>(out, *pstruct_in.displayPlaneProperties, indent+1,  base_addr + offsetof(VkDisplayPlaneProperties2KHR, displayPlaneProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayModeProperties2KHR>(std::string* out, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayModeProperties2KHR *pstruct = (const VkDisplayModeProperties2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayModePropertiesKHR displayModeProperties // SMB
    IndentSpaces(out, indent);
    *out += "displayModeProperties:          ";
    *out += "VkDisplayModePropertiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayModePropertiesKHR>(out, *pstruct_in.displayModeProperties, indent+1,  base_addr + offsetof(VkDisplayModeProperties2KHR, displayModeProperties)); // AZJ
}

template <>
void StructureToString<Decoded_VkDisplayPlaneInfo2KHR>(std::string* out, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneInfo2KHR *pstruct = (const VkDisplayPlaneInfo2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayModeKHR mode // SMB
    IndentSpaces(out, indent);
    *out += "mode:                           ";
    *out += "VkDisplayModeKHR = "; // TEQ
    AddrToString(out, pstruct_in.mode); // PAQ
    *out += "\n"; // GDS

    // uint32_t planeIndex // SMB
    IndentSpaces(out, indent);
    *out += "planeIndex:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->planeIndex);
}

template <>
void StructureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(std::string* out, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPlaneCapabilities2KHR *pstruct = (const VkDisplayPlaneCapabilities2KHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayPlaneCapabilitiesKHR capabilities // SMB
    IndentSpaces(out, indent);
    *out += "capabilities:                   ";
    *out += "VkDisplayPlaneCapabilitiesKHR = "; // TEQ
    StructureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(out, *pstruct_in.capabilities, indent+1,  base_addr + offsetof(VkDisplayPlaneCapabilities2KHR, capabilities)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayProperties2KHR>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayProperties2KHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayProperties2KHR* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayProperties2KHR* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkDisplayProperties2KHR>(&tmp_string, 2, 1, "VkDisplayProperties2KHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPlaneProperties2KHR>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlaneProperties2KHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneProperties2KHR* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneProperties2KHR* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkDisplayPlaneProperties2KHR>(&tmp_string, 2, 1, "VkDisplayPlaneProperties2KHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayModeProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayModeProperties2KHR>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indent_string.c_str(), "display:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, display);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModeProperties2KHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeProperties2KHR* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeProperties2KHR* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkDisplayModeProperties2KHR>(&tmp_string, 2, 1, "VkDisplayModeProperties2KHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneCapabilities2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDisplayPlaneInfo2KHR>& pDisplayPlaneInfo,
    const StructPointerDecoder<Decoded_VkDisplayPlaneCapabilities2KHR>& pCapabilities)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo // ARG
    if (pDisplayPlaneInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPlaneInfo2KHR* = NULL", indent_string.c_str(), "pDisplayPlaneInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPlaneInfo2KHR* = ", indent_string.c_str(), "pDisplayPlaneInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pDisplayPlaneInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDisplayPlaneInfo2KHR>(&tmp_string, *pDisplayPlaneInfo.GetMetaStructPointer(), 2, pDisplayPlaneInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlaneCapabilities2KHR* pCapabilities // ARG
    if (pCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilities2KHR* = NULL", indent_string.c_str(), "pCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilities2KHR* = ", indent_string.c_str(), "pCapabilities:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(&tmp_string, *pCapabilities.GetMetaStructPointer(), 2, pCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageMemoryRequirementsInfo2>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indent_string.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indent_string.c_str(), "pMemoryRequirements:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryRequirements2>(&tmp_string, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkBufferMemoryRequirementsInfo2>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indent_string.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indent_string.c_str(), "pMemoryRequirements:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryRequirements2>(&tmp_string, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>& pInfo,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>& pSparseMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSparseMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSparseMemoryRequirementCount // ARG
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pSparseMemoryRequirementCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pSparseMemoryRequirementCount:", static_cast<uint64_t>(*pSparseMemoryRequirementCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageMemoryRequirements2* pSparseMemoryRequirements // ARG
    if (pSparseMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = NULL", indent_string.c_str(), "pSparseMemoryRequirements:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = ", indent_string.c_str(), "pSparseMemoryRequirements:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pSparseMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements2>(&tmp_string, 2, 1, "VkSparseImageMemoryRequirements2",
            pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkSamplerYcbcrModelConversionKHR(std::string* out, VkSamplerYcbcrModelConversionKHR e)
{
    assert(out != nullptr);
    EnumToStringVkSamplerYcbcrModelConversion(out, e);
}


void EnumToStringVkSamplerYcbcrRangeKHR(std::string* out, VkSamplerYcbcrRangeKHR e)
{
    assert(out != nullptr);
    EnumToStringVkSamplerYcbcrRange(out, e);
}


void EnumToStringVkChromaLocationKHR(std::string* out, VkChromaLocationKHR e)
{
    assert(out != nullptr);
    EnumToStringVkChromaLocation(out, e);
}


void VulkanAsciiConsumer::Process_vkCreateSamplerYcbcrConversionKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSamplerYcbcrConversion>& pYcbcrConversion)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSamplerYcbcrConversionCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion* pYcbcrConversion // ARG
    if (pYcbcrConversion.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = NULL", indent_string.c_str(), "pYcbcrConversion:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = ", indent_string.c_str(), "pYcbcrConversion:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pYcbcrConversion.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySamplerYcbcrConversionKHR(
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion ycbcrConversion // ARG
    fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion = ", indent_string.c_str(), "ycbcrConversion:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, ycbcrConversion);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkBindBufferMemory2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>& pBindInfos)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindBufferMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = NULL", indent_string.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = ", indent_string.c_str(), "pBindInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBindBufferMemoryInfo>(&tmp_string, 2, 1, "VkBindBufferMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindImageMemoryInfo>& pBindInfos)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindImageMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = NULL", indent_string.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = ", indent_string.c_str(), "pBindInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBindImageMemoryInfo>(&tmp_string, 2, 1, "VkBindImageMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkGetDescriptorSetLayoutSupportKHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>& pSupport)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayoutSupport* pSupport // ARG
    if (pSupport.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = NULL", indent_string.c_str(), "pSupport:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = ", indent_string.c_str(), "pSupport:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSupport.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDescriptorSetLayoutSupport>(&tmp_string, *pSupport.GetMetaStructPointer(), 2, pSupport.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdDrawIndirectCountKHR(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "countBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, countBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirectCountKHR(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "countBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, countBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkShaderFloatControlsIndependenceKHR(std::string* out, uint32_t enum_uint32)
{
    VkShaderFloatControlsIndependenceKHR e = static_cast<VkShaderFloatControlsIndependenceKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR:
            *out += std::string("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR");
            return;
        case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR:
            *out += std::string("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR");
            return;
        case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR:
            *out += std::string("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSemaphoreWaitFlagBitsKHR(std::string* out, uint32_t enum_uint32)
{
    VkSemaphoreWaitFlagBitsKHR e = static_cast<VkSemaphoreWaitFlagBitsKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SEMAPHORE_WAIT_ANY_BIT_KHR:
            *out += std::string("VK_SEMAPHORE_WAIT_ANY_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDriverIdKHR(std::string* out, uint32_t enum_uint32)
{
    VkDriverIdKHR e = static_cast<VkDriverIdKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DRIVER_ID_GGP_PROPRIETARY_KHR:
            *out += std::string("VK_DRIVER_ID_GGP_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR:
            *out += std::string("VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR");
            return;
        case VK_DRIVER_ID_ARM_PROPRIETARY_KHR:
            *out += std::string("VK_DRIVER_ID_ARM_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR:
            *out += std::string("VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR");
            return;
        case VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR:
            *out += std::string("VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_MESA_RADV_KHR:
            *out += std::string("VK_DRIVER_ID_MESA_RADV_KHR");
            return;
        case VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR:
            *out += std::string("VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR:
            *out += std::string("VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR");
            return;
        case VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR:
            *out += std::string("VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR");
            return;
        case VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR:
            *out += std::string("VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_AMD_PROPRIETARY_KHR:
            *out += std::string("VK_DRIVER_ID_AMD_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR:
            *out += std::string("VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkSemaphoreTypeKHR(std::string* out, uint32_t enum_uint32)
{
    VkSemaphoreTypeKHR e = static_cast<VkSemaphoreTypeKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SEMAPHORE_TYPE_TIMELINE_KHR:
            *out += std::string("VK_SEMAPHORE_TYPE_TIMELINE_KHR");
            return;
        case VK_SEMAPHORE_TYPE_BINARY_KHR:
            *out += std::string("VK_SEMAPHORE_TYPE_BINARY_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkResolveModeFlagBitsKHR(std::string* out, uint32_t enum_uint32)
{
    VkResolveModeFlagBitsKHR e = static_cast<VkResolveModeFlagBitsKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_RESOLVE_MODE_MIN_BIT_KHR:
            *out += std::string("VK_RESOLVE_MODE_MIN_BIT_KHR");
            return;
        case VK_RESOLVE_MODE_NONE_KHR:
            *out += std::string("VK_RESOLVE_MODE_NONE_KHR");
            return;
        case VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR:
            *out += std::string("VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR");
            return;
        case VK_RESOLVE_MODE_AVERAGE_BIT_KHR:
            *out += std::string("VK_RESOLVE_MODE_AVERAGE_BIT_KHR");
            return;
        case VK_RESOLVE_MODE_MAX_BIT_KHR:
            *out += std::string("VK_RESOLVE_MODE_MAX_BIT_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreTypeCreateInfoKHR>(std::string* out, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkTimelineSemaphoreSubmitInfoKHR>(std::string* out, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreWaitInfoKHR>(std::string* out, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSemaphoreSignalInfoKHR>(std::string* out, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *pstruct = (const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 timelineSemaphore // SMB
    IndentSpaces(out, indent);
    *out += "timelineSemaphore:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->timelineSemaphore);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR>(std::string* out, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *pstruct = (const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint64_t maxTimelineSemaphoreValueDifference // SMB
    IndentSpaces(out, indent);
    *out += "maxTimelineSemaphoreValueDifference: ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTimelineSemaphoreValueDifference);
}

template <>
void StructureToString<Decoded_VkSemaphoreTypeCreateInfoKHR>(std::string* out, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreTypeCreateInfoKHR *pstruct = (const VkSemaphoreTypeCreateInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphoreTypeKHR semaphoreType // SMB
    IndentSpaces(out, indent);
    *out += "semaphoreType:                  ";
    *out += "VkSemaphoreTypeKHR = "; // TEQ
    EnumToStringVkSemaphoreTypeKHR(out, pstruct->semaphoreType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->semaphoreType);
    *out += ")";
    *out += "\n"; // GDS

    // uint64_t initialValue // SMB
    IndentSpaces(out, indent);
    *out += "initialValue:                   ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->initialValue);
}

template <>
void StructureToString<Decoded_VkTimelineSemaphoreSubmitInfoKHR>(std::string* out, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkTimelineSemaphoreSubmitInfoKHR *pstruct = (const VkTimelineSemaphoreSubmitInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t waitSemaphoreValueCount // SMB
    IndentSpaces(out, indent);
    *out += "waitSemaphoreValueCount:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->waitSemaphoreValueCount);
    *out += "\n"; // GDS

    // const uint64_t* pWaitSemaphoreValues // SMB
    IndentSpaces(out, indent);
    *out += "pWaitSemaphoreValues:           ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pWaitSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pstruct->waitSemaphoreValueCount,  vinfo_pWaitSemaphoreValues);  // CCQ
    }
    *out += "\n"; // GDS

    // uint32_t signalSemaphoreValueCount // SMB
    IndentSpaces(out, indent);
    *out += "signalSemaphoreValueCount:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->signalSemaphoreValueCount);
    *out += "\n"; // GDS

    // const uint64_t* pSignalSemaphoreValues // SMB
    IndentSpaces(out, indent);
    *out += "pSignalSemaphoreValues:         ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSignalSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pstruct->signalSemaphoreValueCount,  vinfo_pSignalSemaphoreValues);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkSemaphoreWaitInfoKHR>(std::string* out, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreWaitInfoKHR *pstruct = (const VkSemaphoreWaitInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphoreWaitFlagsKHR flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkSemaphoreWaitFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkSemaphoreWaitFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // uint32_t semaphoreCount // SMB
    IndentSpaces(out, indent);
    *out += "semaphoreCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->semaphoreCount);
    *out += "\n"; // GDS

    // const VkSemaphore* pSemaphores // SMB
    IndentSpaces(out, indent);
    *out += "pSemaphores:                    ";
    *out += "const VkSemaphore* = "; // TEQ
    if (pstruct->pSemaphores == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSemaphores = {true, false, false, nullptr};
        ArrayToString<const VkSemaphore*>(out, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pstruct_in.pSemaphores.GetPointer()), "pSemaphores", pstruct->semaphoreCount,  vinfo_pSemaphores);  // CCQ
    }
    *out += "\n"; // GDS

    // const uint64_t* pValues // SMB
    IndentSpaces(out, indent);
    *out += "pValues:                        ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pValues == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pValues = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pValues.GetPointer()), "pValues", pstruct->semaphoreCount,  vinfo_pValues);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkSemaphoreSignalInfoKHR>(std::string* out, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSemaphoreSignalInfoKHR *pstruct = (const VkSemaphoreSignalInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    IndentSpaces(out, indent);
    *out += "semaphore:                      ";
    *out += "VkSemaphore = "; // TEQ
    AddrToString(out, pstruct_in.semaphore); // PAQ
    *out += "\n"; // GDS

    // uint64_t value // SMB
    IndentSpaces(out, indent);
    *out += "value:                          ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->value);
}

void VulkanAsciiConsumer::Process_vkGetSemaphoreCounterValueKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            semaphore,
    const PointerDecoder<uint64_t>&             pValue)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetSemaphoreCounterValueKHR(device, semaphore, pValue)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore semaphore // ARG
    fprintf(GetFile(), "%s%-32sVkSemaphore = ", indent_string.c_str(), "semaphore:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, semaphore);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pValue // ARG
    if (pValue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indent_string.c_str(), "pValue:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indent_string.c_str(), "pValue:", static_cast<uint64_t>(*pValue.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkWaitSemaphoresKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreWaitInfoKHR>& pWaitInfo,
    uint64_t                                    timeout)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkWaitSemaphoresKHR(device, pWaitInfo, timeout)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreWaitInfoKHR* pWaitInfo // ARG
    if (pWaitInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreWaitInfoKHR* = NULL", indent_string.c_str(), "pWaitInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreWaitInfoKHR* = ", indent_string.c_str(), "pWaitInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pWaitInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSemaphoreWaitInfoKHR>(&tmp_string, *pWaitInfo.GetMetaStructPointer(), 2, pWaitInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t timeout // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indent_string.c_str(), "timeout:", timeout); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkSignalSemaphoreKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreSignalInfoKHR>& pSignalInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkSignalSemaphoreKHR(device, pSignalInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreSignalInfoKHR* pSignalInfo // ARG
    if (pSignalInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreSignalInfoKHR* = NULL", indent_string.c_str(), "pSignalInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreSignalInfoKHR* = ", indent_string.c_str(), "pSignalInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSignalInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSemaphoreSignalInfoKHR>(&tmp_string, *pSignalInfo.GetMetaStructPointer(), 2, pSignalInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkPipelineExecutableStatisticFormatKHR(std::string* out, uint32_t enum_uint32)
{
    VkPipelineExecutableStatisticFormatKHR e = static_cast<VkPipelineExecutableStatisticFormatKHR>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR:
            *out += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR");
            return;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR:
            *out += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR");
            return;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR:
            *out += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR");
            return;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR:
            *out += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineInfoKHR>(std::string* out, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutablePropertiesKHR>(std::string* out, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableInfoKHR>(std::string* out, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableStatisticKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(std::string* out, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(std::string* out, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *pstruct = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 pipelineExecutableInfo // SMB
    IndentSpaces(out, indent);
    *out += "pipelineExecutableInfo:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->pipelineExecutableInfo);
}

template <>
void StructureToString<Decoded_VkPipelineInfoKHR>(std::string* out, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineInfoKHR *pstruct = (const VkPipelineInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipeline pipeline // SMB
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.pipeline); // PAQ
}

template <>
void StructureToString<Decoded_VkPipelineExecutablePropertiesKHR>(std::string* out, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutablePropertiesKHR *pstruct = (const VkPipelineExecutablePropertiesKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkShaderStageFlags stages // SMB
    IndentSpaces(out, indent);
    *out += "stages:                         ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stages, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // char name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *out += "\n"; // GDS

    // char description // SMB
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *out += "\n"; // GDS

    // uint32_t subgroupSize // SMB
    IndentSpaces(out, indent);
    *out += "subgroupSize:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subgroupSize);
}

template <>
void StructureToString<Decoded_VkPipelineExecutableInfoKHR>(std::string* out, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableInfoKHR *pstruct = (const VkPipelineExecutableInfoKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipeline pipeline // SMB
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.pipeline); // PAQ
    *out += "\n"; // GDS

    // uint32_t executableIndex // SMB
    IndentSpaces(out, indent);
    *out += "executableIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->executableIndex);
}

template <>
void StructureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableStatisticValueKHR *pstruct = (const VkPipelineExecutableStatisticValueKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkBool32 b32 // SMB
    IndentSpaces(out, indent);
    *out += "b32:                            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->b32);
    *out += "\n"; // GDS

    // int64_t i64 // SMB
    IndentSpaces(out, indent);
    *out += "i64:                            ";
    *out += "int64_t = "; // TEQ
    SignedDecimalToString(out, pstruct->i64);
    *out += "\n"; // GDS

    // uint64_t u64 // SMB
    IndentSpaces(out, indent);
    *out += "u64:                            ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->u64);
    *out += "\n"; // GDS

    // double f64 // SMB
    IndentSpaces(out, indent);
    *out += "f64:                            ";
    *out += "double = "; // TEQ
    DoubleToString(out, pstruct->f64);
}

template <>
void StructureToString<Decoded_VkPipelineExecutableStatisticKHR>(std::string* out, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableStatisticKHR *pstruct = (const VkPipelineExecutableStatisticKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // char name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *out += "\n"; // GDS

    // char description // SMB
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *out += "\n"; // GDS

    // VkPipelineExecutableStatisticFormatKHR format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkPipelineExecutableStatisticFormatKHR = "; // TEQ
    EnumToStringVkPipelineExecutableStatisticFormatKHR(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // VkPipelineExecutableStatisticValueKHR value // SMB
    IndentSpaces(out, indent);
    *out += "value:                          ";
    *out += "VkPipelineExecutableStatisticValueKHR = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(out, *pstruct_in.value, indent+1,  base_addr + offsetof(VkPipelineExecutableStatisticKHR, value)); // AZJ
}

template <>
void StructureToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(std::string* out, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineExecutableInternalRepresentationKHR *pstruct = (const VkPipelineExecutableInternalRepresentationKHR *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // char name // SMB
    IndentSpaces(out, indent);
    *out += "name:                           ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_name = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *out += "\n"; // GDS

    // char description // SMB
    IndentSpaces(out, indent);
    *out += "description:                    ";
    *out += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    ArrayToString<char*>(out, indent, 0, "char", const_cast<char*>(pstruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *out += "\n"; // GDS

    // VkBool32 isText // SMB
    IndentSpaces(out, indent);
    *out += "isText:                         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->isText);
    *out += "\n"; // GDS

    // size_t dataSize // SMB
    IndentSpaces(out, indent);
    *out += "dataSize:                       ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dataSize);
    *out += "\n"; // GDS

    // void* pData // SMB
    IndentSpaces(out, indent);
    *out += "pData:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pData.GetAddress()); // AHW
    }
}

void VulkanAsciiConsumer::Process_vkGetPipelineExecutablePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineInfoKHR>& pPipelineInfo,
    const PointerDecoder<uint32_t>&             pExecutableCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutablePropertiesKHR>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineInfoKHR* pPipelineInfo // ARG
    if (pPipelineInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineInfoKHR* = NULL", indent_string.c_str(), "pPipelineInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineInfoKHR* = ", indent_string.c_str(), "pPipelineInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pPipelineInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPipelineInfoKHR>(&tmp_string, *pPipelineInfo.GetMetaStructPointer(), 2, pPipelineInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pExecutableCount // ARG
    if (pExecutableCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pExecutableCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pExecutableCount:", static_cast<uint64_t>(*pExecutableCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineExecutablePropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutablePropertiesKHR* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutablePropertiesKHR* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkPipelineExecutablePropertiesKHR>(&tmp_string, 2, 1, "VkPipelineExecutablePropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pExecutableCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineExecutableStatisticsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>& pExecutableInfo,
    const PointerDecoder<uint32_t>&             pStatisticCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutableStatisticKHR>& pStatistics)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineExecutableInfoKHR* pExecutableInfo // ARG
    if (pExecutableInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = NULL", indent_string.c_str(), "pExecutableInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = ", indent_string.c_str(), "pExecutableInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExecutableInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPipelineExecutableInfoKHR>(&tmp_string, *pExecutableInfo.GetMetaStructPointer(), 2, pExecutableInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pStatisticCount // ARG
    if (pStatisticCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pStatisticCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pStatisticCount:", static_cast<uint64_t>(*pStatisticCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineExecutableStatisticKHR* pStatistics // ARG
    if (pStatistics.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableStatisticKHR* = NULL", indent_string.c_str(), "pStatistics:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableStatisticKHR* = ", indent_string.c_str(), "pStatistics:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pStatistics.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkPipelineExecutableStatisticKHR>(&tmp_string, 2, 1, "VkPipelineExecutableStatisticKHR",
            pStatistics.GetMetaStructPointer(), "pStatistics", *pStatisticCount.GetPointer(), false, pStatistics.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineExecutableInternalRepresentationsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>& pExecutableInfo,
    const PointerDecoder<uint32_t>&             pInternalRepresentationCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInternalRepresentationKHR>& pInternalRepresentations)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineExecutableInfoKHR* pExecutableInfo // ARG
    if (pExecutableInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = NULL", indent_string.c_str(), "pExecutableInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = ", indent_string.c_str(), "pExecutableInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExecutableInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPipelineExecutableInfoKHR>(&tmp_string, *pExecutableInfo.GetMetaStructPointer(), 2, pExecutableInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pInternalRepresentationCount // ARG
    if (pInternalRepresentationCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pInternalRepresentationCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pInternalRepresentationCount:", static_cast<uint64_t>(*pInternalRepresentationCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations // ARG
    if (pInternalRepresentations.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableInternalRepresentationKHR* = NULL", indent_string.c_str(), "pInternalRepresentations:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableInternalRepresentationKHR* = ", indent_string.c_str(), "pInternalRepresentations:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pInternalRepresentations.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(&tmp_string, 2, 1, "VkPipelineExecutableInternalRepresentationKHR",
            pInternalRepresentations.GetMetaStructPointer(), "pInternalRepresentations", *pInternalRepresentationCount.GetPointer(), false, pInternalRepresentations.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkDebugReportFlagBitsEXT(std::string* out, uint32_t enum_uint32)
{
    VkDebugReportFlagBitsEXT e = static_cast<VkDebugReportFlagBitsEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEBUG_REPORT_DEBUG_BIT_EXT:
            *out += std::string("VK_DEBUG_REPORT_DEBUG_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT:
            *out += std::string("VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_INFORMATION_BIT_EXT:
            *out += std::string("VK_DEBUG_REPORT_INFORMATION_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_WARNING_BIT_EXT:
            *out += std::string("VK_DEBUG_REPORT_WARNING_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_ERROR_BIT_EXT:
            *out += std::string("VK_DEBUG_REPORT_ERROR_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDebugReportObjectTypeEXT(std::string* out, uint32_t enum_uint32)
{
    VkDebugReportObjectTypeEXT e = static_cast<VkDebugReportObjectTypeEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
            *out += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(std::string* out, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(std::string* out, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugReportCallbackCreateInfoEXT *pstruct = (const VkDebugReportCallbackCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDebugReportFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDebugReportFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkDebugReportFlagBitsEXT); // URW
    *out += "\n"; // GDS

    // PFN_vkDebugReportCallbackEXT pfnCallback // SMB
    IndentSpaces(out, indent);
    *out += "pfnCallback:                    ";
    *out += "PFN_vkDebugReportCallbackEXT = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnCallback)); // WRX
    *out += "\n"; // GDS

    // void* pUserData // SMB
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateDebugReportCallbackEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDebugReportCallbackCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDebugReportCallbackEXT>& pCallback)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugReportCallbackCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugReportCallbackCreateInfoEXT* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugReportCallbackCreateInfoEXT* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportCallbackEXT* pCallback // ARG
    if (pCallback.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDebugReportCallbackEXT* = NULL", indent_string.c_str(), "pCallback:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDebugReportCallbackEXT* = ", indent_string.c_str(), "pCallback:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pCallback.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDebugReportCallbackEXT(
    format::HandleId                            instance,
    format::HandleId                            callback,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportCallbackEXT callback // ARG
    fprintf(GetFile(), "%s%-32sVkDebugReportCallbackEXT = ", indent_string.c_str(), "callback:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, callback);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDebugReportMessageEXT(
    format::HandleId                            instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const StringDecoder&                        pLayerPrefix,
    const StringDecoder&                        pMessage)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportFlagsEXT flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkDebugReportFlagBitsEXT);
    fprintf(GetFile(), "%s%-32sVkDebugReportFlagsEXT = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportObjectTypeEXT objectType // ARG
    tmp_string = "";
    EnumToStringVkDebugReportObjectTypeEXT(&tmp_string,objectType); // EPW
    fprintf(GetFile(), "%s%-32sVkDebugReportObjectTypeEXT = %s", indent_string.c_str(), "objectType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t object // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indent_string.c_str(), "object:", object); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // size_t location // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indent_string.c_str(), "location:", location); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // int32_t messageCode // ARG
    fprintf(GetFile(), "%s%-32sint32_t = %d", indent_string.c_str(), "messageCode:", messageCode); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const char* pLayerPrefix // ARG
    if (pLayerPrefix.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst char* = NULL", indent_string.c_str(), "pLayerPrefix:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst char* = %" PRId64 "", indent_string.c_str(), "pLayerPrefix:", static_cast<uint64_t>(*pLayerPrefix.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const char* pMessage // ARG
    if (pMessage.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst char* = NULL", indent_string.c_str(), "pMessage:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst char* = %" PRId64 "", indent_string.c_str(), "pMessage:", static_cast<uint64_t>(*pMessage.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkRasterizationOrderAMD(std::string* out, uint32_t enum_uint32)
{
    VkRasterizationOrderAMD e = static_cast<VkRasterizationOrderAMD>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_RASTERIZATION_ORDER_STRICT_AMD:
            *out += std::string("VK_RASTERIZATION_ORDER_STRICT_AMD");
            return;
        case VK_RASTERIZATION_ORDER_RELAXED_AMD:
            *out += std::string("VK_RASTERIZATION_ORDER_RELAXED_AMD");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(std::string* out, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugMarkerObjectNameInfoEXT *pstruct = (const VkDebugMarkerObjectNameInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDebugReportObjectTypeEXT objectType // SMB
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkDebugReportObjectTypeEXT = "; // TEQ
    EnumToStringVkDebugReportObjectTypeEXT(out, pstruct->objectType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // uint64_t object // SMB
    IndentSpaces(out, indent);
    *out += "object:                         ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->object);
    *out += "\n"; // GDS

    // const char* pObjectName // SMB
    IndentSpaces(out, indent);
    *out += "pObjectName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pObjectName); // TGH
}

template <>
void StructureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugMarkerObjectTagInfoEXT *pstruct = (const VkDebugMarkerObjectTagInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDebugReportObjectTypeEXT objectType // SMB
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkDebugReportObjectTypeEXT = "; // TEQ
    EnumToStringVkDebugReportObjectTypeEXT(out, pstruct->objectType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // uint64_t object // SMB
    IndentSpaces(out, indent);
    *out += "object:                         ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->object);
    *out += "\n"; // GDS

    // uint64_t tagName // SMB
    IndentSpaces(out, indent);
    *out += "tagName:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagName);
    *out += "\n"; // GDS

    // size_t tagSize // SMB
    IndentSpaces(out, indent);
    *out += "tagSize:                        ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagSize);
    *out += "\n"; // GDS

    // const void* pTag // SMB
    IndentSpaces(out, indent);
    *out += "pTag:                           ";
    *out += "const void* = "; // TEQ
    if (pstruct->pTag == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTag.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(std::string* out, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugMarkerMarkerInfoEXT *pstruct = (const VkDebugMarkerMarkerInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // const char* pMarkerName // SMB
    IndentSpaces(out, indent);
    *out += "pMarkerName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pMarkerName); // TGH
    *out += "\n"; // GDS

    // float color // SMB
    IndentSpaces(out, indent);
    *out += "color:                          ";
    *out += "float[";
    *out += "4";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkDebugMarkerMarkerInfoEXT, color)); // IYY
    ValueToStringStruct vinfo_color = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->color), "color", 4, vinfo_color); // JPA
}

void VulkanAsciiConsumer::Process_vkDebugMarkerSetObjectTagEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugMarkerObjectTagInfoEXT>& pTagInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDebugMarkerSetObjectTagEXT(device, pTagInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerObjectTagInfoEXT* pTagInfo // ARG
    if (pTagInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectTagInfoEXT* = NULL", indent_string.c_str(), "pTagInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectTagInfoEXT* = ", indent_string.c_str(), "pTagInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pTagInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(&tmp_string, *pTagInfo.GetMetaStructPointer(), 2, pTagInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDebugMarkerSetObjectNameEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugMarkerObjectNameInfoEXT>& pNameInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDebugMarkerSetObjectNameEXT(device, pNameInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerObjectNameInfoEXT* pNameInfo // ARG
    if (pNameInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectNameInfoEXT* = NULL", indent_string.c_str(), "pNameInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectNameInfoEXT* = ", indent_string.c_str(), "pNameInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pNameInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(&tmp_string, *pNameInfo.GetMetaStructPointer(), 2, pNameInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerBeginEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>& pMarkerInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerMarkerInfoEXT* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = NULL", indent_string.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = ", indent_string.c_str(), "pMarkerInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(&tmp_string, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerEndEXT(
    format::HandleId                            commandBuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDebugMarkerEndEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerInsertEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>& pMarkerInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerMarkerInfoEXT* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = NULL", indent_string.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = ", indent_string.c_str(), "pMarkerInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(&tmp_string, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT *pstruct = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 transformFeedback // SMB
    IndentSpaces(out, indent);
    *out += "transformFeedback:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedback);
    *out += "\n"; // GDS

    // VkBool32 geometryStreams // SMB
    IndentSpaces(out, indent);
    *out += "geometryStreams:                ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->geometryStreams);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT *pstruct = (const VkPhysicalDeviceTransformFeedbackPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t maxTransformFeedbackStreams // SMB
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackStreams:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackStreams);
    *out += "\n"; // GDS

    // uint32_t maxTransformFeedbackBuffers // SMB
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBuffers:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackBuffers);
    *out += "\n"; // GDS

    // VkDeviceSize maxTransformFeedbackBufferSize // SMB
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBufferSize: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->maxTransformFeedbackBufferSize);
    *out += "\n"; // GDS

    // uint32_t maxTransformFeedbackStreamDataSize // SMB
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackStreamDataSize: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackStreamDataSize);
    *out += "\n"; // GDS

    // uint32_t maxTransformFeedbackBufferDataSize // SMB
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBufferDataSize: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackBufferDataSize);
    *out += "\n"; // GDS

    // uint32_t maxTransformFeedbackBufferDataStride // SMB
    IndentSpaces(out, indent);
    *out += "maxTransformFeedbackBufferDataStride: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTransformFeedbackBufferDataStride);
    *out += "\n"; // GDS

    // VkBool32 transformFeedbackQueries // SMB
    IndentSpaces(out, indent);
    *out += "transformFeedbackQueries:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackQueries);
    *out += "\n"; // GDS

    // VkBool32 transformFeedbackStreamsLinesTriangles // SMB
    IndentSpaces(out, indent);
    *out += "transformFeedbackStreamsLinesTriangles: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackStreamsLinesTriangles);
    *out += "\n"; // GDS

    // VkBool32 transformFeedbackRasterizationStreamSelect // SMB
    IndentSpaces(out, indent);
    *out += "transformFeedbackRasterizationStreamSelect: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackRasterizationStreamSelect);
    *out += "\n"; // GDS

    // VkBool32 transformFeedbackDraw // SMB
    IndentSpaces(out, indent);
    *out += "transformFeedbackDraw:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->transformFeedbackDraw);
}

template <>
void StructureToString<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineRasterizationStateStreamCreateInfoEXT *pstruct = (const VkPipelineRasterizationStateStreamCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineRasterizationStateStreamCreateFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineRasterizationStateStreamCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t rasterizationStream // SMB
    IndentSpaces(out, indent);
    *out += "rasterizationStream:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->rasterizationStream);
}

void VulkanAsciiConsumer::Process_vkCmdBindTransformFeedbackBuffersEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const HandlePointerDecoder<VkBuffer>&       pBuffers,
    const PointerDecoder<VkDeviceSize>&         pOffsets,
    const PointerDecoder<VkDeviceSize>&         pSizes)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstBinding // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstBinding:", firstBinding); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindingCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindingCount:", bindingCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pBuffers // ARG
    if (pBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indent_string.c_str(), "pBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indent_string.c_str(), "pBuffers:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(&tmp_string, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pBuffers.GetPointer()), "pBuffers", bindingCount, vinfo_pBuffers); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pOffsets // ARG
    if (pOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indent_string.c_str(), "pOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indent_string.c_str(), "pOffsets:", static_cast<uint64_t>(*pOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pSizes // ARG
    if (pSizes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indent_string.c_str(), "pSizes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indent_string.c_str(), "pSizes:", static_cast<uint64_t>(*pSizes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginTransformFeedbackEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const HandlePointerDecoder<VkBuffer>&       pCounterBuffers,
    const PointerDecoder<VkDeviceSize>&         pCounterBufferOffsets)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstCounterBuffer // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstCounterBuffer:", firstCounterBuffer); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t counterBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "counterBufferCount:", counterBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pCounterBuffers // ARG
    if (pCounterBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indent_string.c_str(), "pCounterBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indent_string.c_str(), "pCounterBuffers:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pCounterBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pCounterBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(&tmp_string, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pCounterBuffers.GetPointer()), "pCounterBuffers", counterBufferCount, vinfo_pCounterBuffers); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pCounterBufferOffsets // ARG
    if (pCounterBufferOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indent_string.c_str(), "pCounterBufferOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indent_string.c_str(), "pCounterBufferOffsets:", static_cast<uint64_t>(*pCounterBufferOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndTransformFeedbackEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const HandlePointerDecoder<VkBuffer>&       pCounterBuffers,
    const PointerDecoder<VkDeviceSize>&         pCounterBufferOffsets)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstCounterBuffer // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstCounterBuffer:", firstCounterBuffer); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t counterBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "counterBufferCount:", counterBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pCounterBuffers // ARG
    if (pCounterBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indent_string.c_str(), "pCounterBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indent_string.c_str(), "pCounterBuffers:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pCounterBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pCounterBuffers = {true, false, false, nullptr};
        ArrayToString<const VkBuffer*>(&tmp_string, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pCounterBuffers.GetPointer()), "pCounterBuffers", counterBufferCount, vinfo_pCounterBuffers); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pCounterBufferOffsets // ARG
    if (pCounterBufferOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indent_string.c_str(), "pCounterBufferOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indent_string.c_str(), "pCounterBufferOffsets:", static_cast<uint64_t>(*pCounterBufferOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginQueryIndexedEXT(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags,
    uint32_t                                    index)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryControlFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkQueryControlFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryControlFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t index // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "index:", index); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndQueryIndexedEXT(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    uint32_t                                    index)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t index // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "index:", index); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndirectByteCountEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    format::HandleId                            counterBuffer,
    VkDeviceSize                                counterBufferOffset,
    uint32_t                                    counterOffset,
    uint32_t                                    vertexStride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t instanceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "instanceCount:", instanceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstInstance // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstInstance:", firstInstance); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer counterBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "counterBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, counterBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize counterBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "counterBufferOffset:", counterBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t counterOffset // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "counterOffset:", counterOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t vertexStride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "vertexStride:", vertexStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkImageViewHandleInfoNVX>(std::string* out, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImageViewHandleInfoNVX>(std::string* out, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageViewHandleInfoNVX *pstruct = (const VkImageViewHandleInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImageView imageView // SMB
    IndentSpaces(out, indent);
    *out += "imageView:                      ";
    *out += "VkImageView = "; // TEQ
    AddrToString(out, pstruct_in.imageView); // PAQ
    *out += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    IndentSpaces(out, indent);
    *out += "descriptorType:                 ";
    *out += "VkDescriptorType = "; // TEQ
    EnumToStringVkDescriptorType(out, pstruct->descriptorType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->descriptorType);
    *out += ")";
    *out += "\n"; // GDS

    // VkSampler sampler // SMB
    IndentSpaces(out, indent);
    *out += "sampler:                        ";
    *out += "VkSampler = "; // TEQ
    AddrToString(out, pstruct_in.sampler); // PAQ
}

void VulkanAsciiConsumer::Process_vkGetImageViewHandleNVX(
    uint32_t                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageViewHandleInfoNVX>& pInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageViewHandleNVX(device, pInfo)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageViewHandleInfoNVX* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewHandleInfoNVX* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewHandleInfoNVX* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageViewHandleInfoNVX>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdDrawIndirectCountAMD(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "countBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, countBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirectCountAMD(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "countBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, countBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkShaderInfoTypeAMD(std::string* out, uint32_t enum_uint32)
{
    VkShaderInfoTypeAMD e = static_cast<VkShaderInfoTypeAMD>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SHADER_INFO_TYPE_BINARY_AMD:
            *out += std::string("VK_SHADER_INFO_TYPE_BINARY_AMD");
            return;
        case VK_SHADER_INFO_TYPE_STATISTICS_AMD:
            *out += std::string("VK_SHADER_INFO_TYPE_STATISTICS_AMD");
            return;
        case VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD:
            *out += std::string("VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkShaderResourceUsageAMD>(std::string* out, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkShaderStatisticsInfoAMD>(std::string* out, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkShaderResourceUsageAMD>(std::string* out, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderResourceUsageAMD *pstruct = (const VkShaderResourceUsageAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t numUsedVgprs // SMB
    IndentSpaces(out, indent);
    *out += "numUsedVgprs:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numUsedVgprs);
    *out += "\n"; // GDS

    // uint32_t numUsedSgprs // SMB
    IndentSpaces(out, indent);
    *out += "numUsedSgprs:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numUsedSgprs);
    *out += "\n"; // GDS

    // uint32_t ldsSizePerLocalWorkGroup // SMB
    IndentSpaces(out, indent);
    *out += "ldsSizePerLocalWorkGroup:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->ldsSizePerLocalWorkGroup);
    *out += "\n"; // GDS

    // size_t ldsUsageSizeInBytes // SMB
    IndentSpaces(out, indent);
    *out += "ldsUsageSizeInBytes:            ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->ldsUsageSizeInBytes);
    *out += "\n"; // GDS

    // size_t scratchMemUsageInBytes // SMB
    IndentSpaces(out, indent);
    *out += "scratchMemUsageInBytes:         ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->scratchMemUsageInBytes);
}

template <>
void StructureToString<Decoded_VkShaderStatisticsInfoAMD>(std::string* out, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderStatisticsInfoAMD *pstruct = (const VkShaderStatisticsInfoAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkShaderStageFlags shaderStageMask // SMB
    IndentSpaces(out, indent);
    *out += "shaderStageMask:                ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->shaderStageMask, EnumToStringVkShaderStageFlagBits); // URW
    *out += "\n"; // GDS

    // VkShaderResourceUsageAMD resourceUsage // SMB
    IndentSpaces(out, indent);
    *out += "resourceUsage:                  ";
    *out += "VkShaderResourceUsageAMD = "; // TEQ
    StructureToString<Decoded_VkShaderResourceUsageAMD>(out, *pstruct_in.resourceUsage, indent+1,  base_addr + offsetof(VkShaderStatisticsInfoAMD, resourceUsage)); // AZJ
    *out += "\n"; // GDS

    // uint32_t numPhysicalVgprs // SMB
    IndentSpaces(out, indent);
    *out += "numPhysicalVgprs:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numPhysicalVgprs);
    *out += "\n"; // GDS

    // uint32_t numPhysicalSgprs // SMB
    IndentSpaces(out, indent);
    *out += "numPhysicalSgprs:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numPhysicalSgprs);
    *out += "\n"; // GDS

    // uint32_t numAvailableVgprs // SMB
    IndentSpaces(out, indent);
    *out += "numAvailableVgprs:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numAvailableVgprs);
    *out += "\n"; // GDS

    // uint32_t numAvailableSgprs // SMB
    IndentSpaces(out, indent);
    *out += "numAvailableSgprs:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numAvailableSgprs);
    *out += "\n"; // GDS

    // uint32_t computeWorkGroupSize // SMB
    IndentSpaces(out, indent);
    *out += "computeWorkGroupSize:           ";
    *out += "uint32_t[";
    *out += "3";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkShaderStatisticsInfoAMD, computeWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_computeWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->computeWorkGroupSize), "computeWorkGroupSize", 3, vinfo_computeWorkGroupSize); // JPA
}

void VulkanAsciiConsumer::Process_vkGetShaderInfoAMD(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    const PointerDecoder<size_t>&               pInfoSize,
    const PointerDecoder<uint8_t>&              pInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indent_string.c_str(), "pipeline:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipeline);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderStageFlagBits shaderStage // ARG
    tmp_string = "";
    EnumToStringVkShaderStageFlagBits(&tmp_string,shaderStage); // EPW
    fprintf(GetFile(), "%s%-32sVkShaderStageFlagBits = %s", indent_string.c_str(), "shaderStage:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderInfoTypeAMD infoType // ARG
    tmp_string = "";
    EnumToStringVkShaderInfoTypeAMD(&tmp_string,infoType); // EPW
    fprintf(GetFile(), "%s%-32sVkShaderInfoTypeAMD = %s", indent_string.c_str(), "infoType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // size_t* pInfoSize // ARG
    if (pInfoSize.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32ssize_t* = NULL", indent_string.c_str(), "pInfoSize:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32ssize_t* = %" PRId64 "", indent_string.c_str(), "pInfoSize:", static_cast<uint64_t>(*pInfoSize.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // void* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indent_string.c_str(), "pInfo:"); // UYD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indent_string.c_str(), "pInfo:");  // RYA
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress()); // YYX
        if (kPrintShaderCode)
        {
            ValueToStringStruct vinfo_pInfo = {false, false, false, nullptr};
            ArrayToString<const uint32_t*>(&tmp_string, 2, 1, "void*", reinterpret_cast<const uint32_t*>(pInfo.GetPointer()), "pInfo", static_cast<size_t>(*pInfoSize.GetPointer()) / 4, vinfo_pInfo);  // CRG
        }
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEU
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(std::string* out, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(std::string* out, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkStreamDescriptorSurfaceCreateInfoGGP *pstruct = (const VkStreamDescriptorSurfaceCreateInfoGGP *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkStreamDescriptorSurfaceCreateFlagsGGP flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkStreamDescriptorSurfaceCreateFlagsGGP = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint64_t streamDescriptor // SMB
    IndentSpaces(out, indent);
    *out += "streamDescriptor:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->streamDescriptor);
}

void VulkanAsciiConsumer::Process_vkCreateStreamDescriptorSurfaceGGP(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkStreamDescriptorSurfaceCreateInfoGGP* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkStreamDescriptorSurfaceCreateInfoGGP* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkExternalMemoryHandleTypeFlagBitsNV(std::string* out, uint32_t enum_uint32)
{
    VkExternalMemoryHandleTypeFlagBitsNV e = static_cast<VkExternalMemoryHandleTypeFlagBitsNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV:
            *out += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkExternalMemoryFeatureFlagBitsNV(std::string* out, uint32_t enum_uint32)
{
    VkExternalMemoryFeatureFlagBitsNV e = static_cast<VkExternalMemoryFeatureFlagBitsNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV:
            *out += std::string("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV:
            *out += std::string("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV:
            *out += std::string("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkExternalImageFormatPropertiesNV>(std::string* out, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkExternalImageFormatPropertiesNV>(std::string* out, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalImageFormatPropertiesNV *pstruct = (const VkExternalImageFormatPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkImageFormatProperties imageFormatProperties // SMB
    IndentSpaces(out, indent);
    *out += "imageFormatProperties:          ";
    *out += "VkImageFormatProperties = "; // TEQ
    StructureToString<Decoded_VkImageFormatProperties>(out, *pstruct_in.imageFormatProperties, indent+1,  base_addr + offsetof(VkExternalImageFormatPropertiesNV, imageFormatProperties)); // AZJ
    *out += "\n"; // GDS

    // VkExternalMemoryFeatureFlagsNV externalMemoryFeatures // SMB
    IndentSpaces(out, indent);
    *out += "externalMemoryFeatures:         ";
    *out += "VkExternalMemoryFeatureFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->externalMemoryFeatures, EnumToStringVkExternalMemoryFeatureFlagBitsNV); // URW
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "exportFromImportedHandleTypes:  ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->exportFromImportedHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes // SMB
    IndentSpaces(out, indent);
    *out += "compatibleHandleTypes:          ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->compatibleHandleTypes, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    const StructPointerDecoder<Decoded_VkExternalImageFormatPropertiesNV>& pExternalImageFormatProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmp_string = "";
    EnumToStringVkFormat(&tmp_string,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indent_string.c_str(), "format:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageType type // ARG
    tmp_string = "";
    EnumToStringVkImageType(&tmp_string,type); // EPW
    fprintf(GetFile(), "%s%-32sVkImageType = %s", indent_string.c_str(), "type:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageTiling tiling // ARG
    tmp_string = "";
    EnumToStringVkImageTiling(&tmp_string,tiling); // EPW
    fprintf(GetFile(), "%s%-32sVkImageTiling = %s", indent_string.c_str(), "tiling:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageUsageFlags usage // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, usage, EnumToStringVkImageUsageFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageUsageFlags = %s", indent_string.c_str(), "usage:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageCreateFlags flags // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, flags, EnumToStringVkImageCreateFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageCreateFlags = %s", indent_string.c_str(), "flags:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagsNV externalHandleType // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, externalHandleType, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV);
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagsNV = %s", indent_string.c_str(), "externalHandleType:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties // ARG
    if (pExternalImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalImageFormatPropertiesNV* = NULL", indent_string.c_str(), "pExternalImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalImageFormatPropertiesNV* = ", indent_string.c_str(), "pExternalImageFormatProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pExternalImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkExternalImageFormatPropertiesNV>(&tmp_string, *pExternalImageFormatProperties.GetMetaStructPointer(), 2, pExternalImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkImportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryWin32HandleInfoNV *pstruct = (const VkImportMemoryWin32HandleInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagsNV handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->handleType, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV); // URW
    *out += "\n"; // GDS

    // void* handle // SMB
    IndentSpaces(out, indent);
    *out += "handle:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->handle == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.handle); // PWR
    }
}

template <>
void StructureToString<Decoded_VkExportMemoryWin32HandleInfoNV>(std::string* out, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExportMemoryWin32HandleInfoNV *pstruct = (const VkExportMemoryWin32HandleInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    IndentSpaces(out, indent);
    *out += "pAttributes:                    ";
    *out += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pstruct->pAttributes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttributes->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t dwAccess // SMB
    IndentSpaces(out, indent);
    *out += "dwAccess:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dwAccess);
}

void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandleNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indent_string.c_str(), "memory:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, memory);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagsNV handleType // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, handleType, EnumToStringVkExternalMemoryHandleTypeFlagBitsNV);
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagsNV = %s", indent_string.c_str(), "handleType:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indent_string.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indent_string.c_str(), "pHandle:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkValidationCheckEXT(std::string* out, uint32_t enum_uint32)
{
    VkValidationCheckEXT e = static_cast<VkValidationCheckEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_VALIDATION_CHECK_ALL_EXT:
            *out += std::string("VK_VALIDATION_CHECK_ALL_EXT");
            return;
        case VK_VALIDATION_CHECK_SHADERS_EXT:
            *out += std::string("VK_VALIDATION_CHECK_SHADERS_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkViSurfaceCreateInfoNN>(std::string* out, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkViSurfaceCreateInfoNN>(std::string* out, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkViSurfaceCreateInfoNN *pstruct = (const VkViSurfaceCreateInfoNN *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkViSurfaceCreateFlagsNN flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkViSurfaceCreateFlagsNN = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // void* window // SMB
    IndentSpaces(out, indent);
    *out += "window:                         ";
    *out += "void* = "; // TEQ
    if (pstruct->window == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.window); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateViSurfaceNN(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkViSurfaceCreateInfoNN>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkViSurfaceCreateInfoNN* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkViSurfaceCreateInfoNN* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkViSurfaceCreateInfoNN* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkViSurfaceCreateInfoNN>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkConditionalRenderingFlagBitsEXT(std::string* out, uint32_t enum_uint32)
{
    VkConditionalRenderingFlagBitsEXT e = static_cast<VkConditionalRenderingFlagBitsEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT:
            *out += std::string("VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(std::string* out, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(std::string* out, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(std::string* out, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkConditionalRenderingBeginInfoEXT *pstruct = (const VkConditionalRenderingBeginInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
    *out += "\n"; // GDS

    // VkConditionalRenderingFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkConditionalRenderingFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkConditionalRenderingFlagBitsEXT); // URW
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT *pstruct = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 conditionalRendering // SMB
    IndentSpaces(out, indent);
    *out += "conditionalRendering:           ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->conditionalRendering);
    *out += "\n"; // GDS

    // VkBool32 inheritedConditionalRendering // SMB
    IndentSpaces(out, indent);
    *out += "inheritedConditionalRendering:  ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->inheritedConditionalRendering);
}

template <>
void StructureToString<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(std::string* out, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT *pstruct = (const VkCommandBufferInheritanceConditionalRenderingInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 conditionalRenderingEnable // SMB
    IndentSpaces(out, indent);
    *out += "conditionalRenderingEnable:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->conditionalRenderingEnable);
}

void VulkanAsciiConsumer::Process_vkCmdBeginConditionalRenderingEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkConditionalRenderingBeginInfoEXT>& pConditionalRenderingBegin)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin // ARG
    if (pConditionalRenderingBegin.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkConditionalRenderingBeginInfoEXT* = NULL", indent_string.c_str(), "pConditionalRenderingBegin:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkConditionalRenderingBeginInfoEXT* = ", indent_string.c_str(), "pConditionalRenderingBegin:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pConditionalRenderingBegin.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(&tmp_string, *pConditionalRenderingBegin.GetMetaStructPointer(), 2, pConditionalRenderingBegin.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndConditionalRenderingEXT(
    format::HandleId                            commandBuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdEndConditionalRenderingEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkIndirectCommandsLayoutUsageFlagBitsNVX(std::string* out, uint32_t enum_uint32)
{
    VkIndirectCommandsLayoutUsageFlagBitsNVX e = static_cast<VkIndirectCommandsLayoutUsageFlagBitsNVX>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkObjectEntryTypeNVX(std::string* out, uint32_t enum_uint32)
{
    VkObjectEntryTypeNVX e = static_cast<VkObjectEntryTypeNVX>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX:
            *out += std::string("VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX:
            *out += std::string("VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX:
            *out += std::string("VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX:
            *out += std::string("VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX:
            *out += std::string("VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkIndirectCommandsTokenTypeNVX(std::string* out, uint32_t enum_uint32)
{
    VkIndirectCommandsTokenTypeNVX e = static_cast<VkIndirectCommandsTokenTypeNVX>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX:
            *out += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkObjectEntryUsageFlagBitsNVX(std::string* out, uint32_t enum_uint32)
{
    VkObjectEntryUsageFlagBitsNVX e = static_cast<VkObjectEntryUsageFlagBitsNVX>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX:
            *out += std::string("VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX");
            return;
        case VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX:
            *out += std::string("VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkIndirectCommandsTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCmdProcessCommandsInfoNVX>(std::string* out, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(std::string* out, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableCreateInfoNVX>(std::string* out, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableEntryNVX>(std::string* out, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTablePipelineEntryNVX>(std::string* out, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableDescriptorSetEntryNVX>(std::string* out, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableVertexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTableIndexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkObjectTablePushConstantEntryNVX>(std::string* out, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGeneratedCommandsFeaturesNVX *pstruct = (const VkDeviceGeneratedCommandsFeaturesNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 computeBindingPointSupport // SMB
    IndentSpaces(out, indent);
    *out += "computeBindingPointSupport:     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->computeBindingPointSupport);
}

template <>
void StructureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(std::string* out, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceGeneratedCommandsLimitsNVX *pstruct = (const VkDeviceGeneratedCommandsLimitsNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t maxIndirectCommandsLayoutTokenCount // SMB
    IndentSpaces(out, indent);
    *out += "maxIndirectCommandsLayoutTokenCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxIndirectCommandsLayoutTokenCount);
    *out += "\n"; // GDS

    // uint32_t maxObjectEntryCounts // SMB
    IndentSpaces(out, indent);
    *out += "maxObjectEntryCounts:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxObjectEntryCounts);
    *out += "\n"; // GDS

    // uint32_t minSequenceCountBufferOffsetAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minSequenceCountBufferOffsetAlignment: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minSequenceCountBufferOffsetAlignment);
    *out += "\n"; // GDS

    // uint32_t minSequenceIndexBufferOffsetAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minSequenceIndexBufferOffsetAlignment: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minSequenceIndexBufferOffsetAlignment);
    *out += "\n"; // GDS

    // uint32_t minCommandsTokenBufferOffsetAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minCommandsTokenBufferOffsetAlignment: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minCommandsTokenBufferOffsetAlignment);
}

template <>
void StructureToString<Decoded_VkIndirectCommandsTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIndirectCommandsTokenNVX *pstruct = (const VkIndirectCommandsTokenNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkIndirectCommandsTokenTypeNVX tokenType // SMB
    IndentSpaces(out, indent);
    *out += "tokenType:                      ";
    *out += "VkIndirectCommandsTokenTypeNVX = "; // TEQ
    EnumToStringVkIndirectCommandsTokenTypeNVX(out, pstruct->tokenType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tokenType);
    *out += ")";
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
}

template <>
void StructureToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIndirectCommandsLayoutTokenNVX *pstruct = (const VkIndirectCommandsLayoutTokenNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkIndirectCommandsTokenTypeNVX tokenType // SMB
    IndentSpaces(out, indent);
    *out += "tokenType:                      ";
    *out += "VkIndirectCommandsTokenTypeNVX = "; // TEQ
    EnumToStringVkIndirectCommandsTokenTypeNVX(out, pstruct->tokenType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->tokenType);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t bindingUnit // SMB
    IndentSpaces(out, indent);
    *out += "bindingUnit:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->bindingUnit);
    *out += "\n"; // GDS

    // uint32_t dynamicCount // SMB
    IndentSpaces(out, indent);
    *out += "dynamicCount:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->dynamicCount);
    *out += "\n"; // GDS

    // uint32_t divisor // SMB
    IndentSpaces(out, indent);
    *out += "divisor:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->divisor);
}

template <>
void StructureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(std::string* out, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIndirectCommandsLayoutCreateInfoNVX *pstruct = (const VkIndirectCommandsLayoutCreateInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    IndentSpaces(out, indent);
    *out += "pipelineBindPoint:              ";
    *out += "VkPipelineBindPoint = "; // TEQ
    EnumToStringVkPipelineBindPoint(out, pstruct->pipelineBindPoint);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->pipelineBindPoint);
    *out += ")";
    *out += "\n"; // GDS

    // VkIndirectCommandsLayoutUsageFlagsNVX flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkIndirectCommandsLayoutUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkIndirectCommandsLayoutUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // uint32_t tokenCount // SMB
    IndentSpaces(out, indent);
    *out += "tokenCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tokenCount);
    *out += "\n"; // GDS

    // const VkIndirectCommandsLayoutTokenNVX* pTokens // SMB
    IndentSpaces(out, indent);
    *out += "pTokens:                        ";
    *out += "const VkIndirectCommandsLayoutTokenNVX* = "; // TEQ
    if (pstruct->pTokens == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTokens->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(out, indent+1, 1, "VkIndirectCommandsLayoutTokenNVX", pstruct_in.pTokens->GetMetaStructPointer(), "pTokens", pstruct->tokenCount, false, pstruct_in.pTokens->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkCmdProcessCommandsInfoNVX>(std::string* out, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCmdProcessCommandsInfoNVX *pstruct = (const VkCmdProcessCommandsInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkObjectTableNVX objectTable // SMB
    IndentSpaces(out, indent);
    *out += "objectTable:                    ";
    *out += "VkObjectTableNVX = "; // TEQ
    AddrToString(out, pstruct_in.objectTable); // PAQ
    *out += "\n"; // GDS

    // VkIndirectCommandsLayoutNVX indirectCommandsLayout // SMB
    IndentSpaces(out, indent);
    *out += "indirectCommandsLayout:         ";
    *out += "VkIndirectCommandsLayoutNVX = "; // TEQ
    AddrToString(out, pstruct_in.indirectCommandsLayout); // PAQ
    *out += "\n"; // GDS

    // uint32_t indirectCommandsTokenCount // SMB
    IndentSpaces(out, indent);
    *out += "indirectCommandsTokenCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->indirectCommandsTokenCount);
    *out += "\n"; // GDS

    // const VkIndirectCommandsTokenNVX* pIndirectCommandsTokens // SMB
    IndentSpaces(out, indent);
    *out += "pIndirectCommandsTokens:        ";
    *out += "const VkIndirectCommandsTokenNVX* = "; // TEQ
    if (pstruct->pIndirectCommandsTokens == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pIndirectCommandsTokens->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkIndirectCommandsTokenNVX>(out, indent+1, 1, "VkIndirectCommandsTokenNVX", pstruct_in.pIndirectCommandsTokens->GetMetaStructPointer(), "pIndirectCommandsTokens", pstruct->indirectCommandsTokenCount, false, pstruct_in.pIndirectCommandsTokens->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t maxSequencesCount // SMB
    IndentSpaces(out, indent);
    *out += "maxSequencesCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSequencesCount);
    *out += "\n"; // GDS

    // VkCommandBuffer targetCommandBuffer // SMB
    IndentSpaces(out, indent);
    *out += "targetCommandBuffer:            ";
    *out += "VkCommandBuffer = "; // TEQ
    AddrToString(out, pstruct_in.targetCommandBuffer); // PAQ
    *out += "\n"; // GDS

    // VkBuffer sequencesCountBuffer // SMB
    IndentSpaces(out, indent);
    *out += "sequencesCountBuffer:           ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.sequencesCountBuffer); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize sequencesCountOffset // SMB
    IndentSpaces(out, indent);
    *out += "sequencesCountOffset:           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->sequencesCountOffset);
    *out += "\n"; // GDS

    // VkBuffer sequencesIndexBuffer // SMB
    IndentSpaces(out, indent);
    *out += "sequencesIndexBuffer:           ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.sequencesIndexBuffer); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize sequencesIndexOffset // SMB
    IndentSpaces(out, indent);
    *out += "sequencesIndexOffset:           ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->sequencesIndexOffset);
}

template <>
void StructureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(std::string* out, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCmdReserveSpaceForCommandsInfoNVX *pstruct = (const VkCmdReserveSpaceForCommandsInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkObjectTableNVX objectTable // SMB
    IndentSpaces(out, indent);
    *out += "objectTable:                    ";
    *out += "VkObjectTableNVX = "; // TEQ
    AddrToString(out, pstruct_in.objectTable); // PAQ
    *out += "\n"; // GDS

    // VkIndirectCommandsLayoutNVX indirectCommandsLayout // SMB
    IndentSpaces(out, indent);
    *out += "indirectCommandsLayout:         ";
    *out += "VkIndirectCommandsLayoutNVX = "; // TEQ
    AddrToString(out, pstruct_in.indirectCommandsLayout); // PAQ
    *out += "\n"; // GDS

    // uint32_t maxSequencesCount // SMB
    IndentSpaces(out, indent);
    *out += "maxSequencesCount:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSequencesCount);
}

template <>
void StructureToString<Decoded_VkObjectTableCreateInfoNVX>(std::string* out, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableCreateInfoNVX *pstruct = (const VkObjectTableCreateInfoNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t objectCount // SMB
    IndentSpaces(out, indent);
    *out += "objectCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectCount);
    *out += "\n"; // GDS

    // const VkObjectEntryTypeNVX* pObjectEntryTypes // SMB
    IndentSpaces(out, indent);
    *out += "pObjectEntryTypes:              ";
    *out += "const VkObjectEntryTypeNVX* = "; // TEQ
    if (pstruct->pObjectEntryTypes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjectEntryTypes.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pObjectEntryTypes = {false, true, false, EnumToStringVkObjectEntryTypeNVX};
        ArrayToString<const VkObjectEntryTypeNVX*>(out, indent, 1, "const VkObjectEntryTypeNVX*", reinterpret_cast<const VkObjectEntryTypeNVX*>(pstruct_in.pObjectEntryTypes.GetPointer()), "pObjectEntryTypes", pstruct->objectCount,  vinfo_pObjectEntryTypes);  // CCQ
    }
    *out += "\n"; // GDS

    // const uint32_t* pObjectEntryCounts // SMB
    IndentSpaces(out, indent);
    *out += "pObjectEntryCounts:             ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pObjectEntryCounts == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjectEntryCounts.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pObjectEntryCounts = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pObjectEntryCounts.GetPointer()), "pObjectEntryCounts", pstruct->objectCount,  vinfo_pObjectEntryCounts);  // CCQ
    }
    *out += "\n"; // GDS

    // const VkObjectEntryUsageFlagsNVX* pObjectEntryUsageFlags // SMB
    IndentSpaces(out, indent);
    *out += "pObjectEntryUsageFlags:         ";
    *out += "const VkObjectEntryUsageFlagsNVX* = "; // TEQ
    if (pstruct->pObjectEntryUsageFlags == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjectEntryUsageFlags.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pObjectEntryUsageFlags = {false, false, true, EnumToStringVkObjectEntryUsageFlagBitsNVX};
        ArrayToString<const VkObjectEntryUsageFlagsNVX*>(out, indent, 1, "const VkObjectEntryUsageFlagsNVX*", reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(pstruct_in.pObjectEntryUsageFlags.GetPointer()), "pObjectEntryUsageFlags", pstruct->objectCount,  vinfo_pObjectEntryUsageFlags);  // CCR
    }
    *out += "\n"; // GDS

    // uint32_t maxUniformBuffersPerDescriptor // SMB
    IndentSpaces(out, indent);
    *out += "maxUniformBuffersPerDescriptor: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxUniformBuffersPerDescriptor);
    *out += "\n"; // GDS

    // uint32_t maxStorageBuffersPerDescriptor // SMB
    IndentSpaces(out, indent);
    *out += "maxStorageBuffersPerDescriptor: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxStorageBuffersPerDescriptor);
    *out += "\n"; // GDS

    // uint32_t maxStorageImagesPerDescriptor // SMB
    IndentSpaces(out, indent);
    *out += "maxStorageImagesPerDescriptor:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxStorageImagesPerDescriptor);
    *out += "\n"; // GDS

    // uint32_t maxSampledImagesPerDescriptor // SMB
    IndentSpaces(out, indent);
    *out += "maxSampledImagesPerDescriptor:  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxSampledImagesPerDescriptor);
    *out += "\n"; // GDS

    // uint32_t maxPipelineLayouts // SMB
    IndentSpaces(out, indent);
    *out += "maxPipelineLayouts:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxPipelineLayouts);
}

template <>
void StructureToString<Decoded_VkObjectTableEntryNVX>(std::string* out, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableEntryNVX *pstruct = (const VkObjectTableEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
}

template <>
void StructureToString<Decoded_VkObjectTablePipelineEntryNVX>(std::string* out, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTablePipelineEntryNVX *pstruct = (const VkObjectTablePipelineEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // VkPipeline pipeline // SMB
    IndentSpaces(out, indent);
    *out += "pipeline:                       ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.pipeline); // PAQ
}

template <>
void StructureToString<Decoded_VkObjectTableDescriptorSetEntryNVX>(std::string* out, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableDescriptorSetEntryNVX *pstruct = (const VkObjectTableDescriptorSetEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // VkPipelineLayout pipelineLayout // SMB
    IndentSpaces(out, indent);
    *out += "pipelineLayout:                 ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.pipelineLayout); // PAQ
    *out += "\n"; // GDS

    // VkDescriptorSet descriptorSet // SMB
    IndentSpaces(out, indent);
    *out += "descriptorSet:                  ";
    *out += "VkDescriptorSet = "; // TEQ
    AddrToString(out, pstruct_in.descriptorSet); // PAQ
}

template <>
void StructureToString<Decoded_VkObjectTableVertexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableVertexBufferEntryNVX *pstruct = (const VkObjectTableVertexBufferEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkObjectTableIndexBufferEntryNVX>(std::string* out, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTableIndexBufferEntryNVX *pstruct = (const VkObjectTableIndexBufferEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
    *out += "\n"; // GDS

    // VkIndexType indexType // SMB
    IndentSpaces(out, indent);
    *out += "indexType:                      ";
    *out += "VkIndexType = "; // TEQ
    EnumToStringVkIndexType(out, pstruct->indexType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->indexType);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkObjectTablePushConstantEntryNVX>(std::string* out, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkObjectTablePushConstantEntryNVX *pstruct = (const VkObjectTablePushConstantEntryNVX *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkObjectEntryTypeNVX = "; // TEQ
    EnumToStringVkObjectEntryTypeNVX(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkObjectEntryUsageFlagBitsNVX); // URW
    *out += "\n"; // GDS

    // VkPipelineLayout pipelineLayout // SMB
    IndentSpaces(out, indent);
    *out += "pipelineLayout:                 ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.pipelineLayout); // PAQ
    *out += "\n"; // GDS

    // VkShaderStageFlags stageFlags // SMB
    IndentSpaces(out, indent);
    *out += "stageFlags:                     ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->stageFlags, EnumToStringVkShaderStageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkCmdProcessCommandsNVX(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCmdProcessCommandsInfoNVX>& pProcessCommandsInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo // ARG
    if (pProcessCommandsInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdProcessCommandsInfoNVX* = NULL", indent_string.c_str(), "pProcessCommandsInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdProcessCommandsInfoNVX* = ", indent_string.c_str(), "pProcessCommandsInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pProcessCommandsInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkCmdProcessCommandsInfoNVX>(&tmp_string, *pProcessCommandsInfo.GetMetaStructPointer(), 2, pProcessCommandsInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdReserveSpaceForCommandsNVX(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>& pReserveSpaceInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo // ARG
    if (pReserveSpaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdReserveSpaceForCommandsInfoNVX* = NULL", indent_string.c_str(), "pReserveSpaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdReserveSpaceForCommandsInfoNVX* = ", indent_string.c_str(), "pReserveSpaceInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pReserveSpaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(&tmp_string, *pReserveSpaceInfo.GetMetaStructPointer(), 2, pReserveSpaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateIndirectCommandsLayoutNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkIndirectCommandsLayoutNVX>& pIndirectCommandsLayout)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, pIndirectCommandsLayout)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkIndirectCommandsLayoutCreateInfoNVX* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkIndirectCommandsLayoutCreateInfoNVX* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout // ARG
    if (pIndirectCommandsLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkIndirectCommandsLayoutNVX* = NULL", indent_string.c_str(), "pIndirectCommandsLayout:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkIndirectCommandsLayoutNVX* = ", indent_string.c_str(), "pIndirectCommandsLayout:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pIndirectCommandsLayout.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyIndirectCommandsLayoutNVX(
    format::HandleId                            device,
    format::HandleId                            indirectCommandsLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkIndirectCommandsLayoutNVX indirectCommandsLayout // ARG
    fprintf(GetFile(), "%s%-32sVkIndirectCommandsLayoutNVX = ", indent_string.c_str(), "indirectCommandsLayout:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, indirectCommandsLayout);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateObjectTableNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkObjectTableCreateInfoNVX>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkObjectTableNVX>& pObjectTable)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateObjectTableNVX(device, pCreateInfo, pAllocator, pObjectTable)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkObjectTableCreateInfoNVX* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectTableCreateInfoNVX* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectTableCreateInfoNVX* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkObjectTableCreateInfoNVX>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkObjectTableNVX* pObjectTable // ARG
    if (pObjectTable.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkObjectTableNVX* = NULL", indent_string.c_str(), "pObjectTable:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkObjectTableNVX* = ", indent_string.c_str(), "pObjectTable:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pObjectTable.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyObjectTableNVX(
    format::HandleId                            device,
    format::HandleId                            objectTable,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyObjectTableNVX(device, objectTable, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkObjectTableNVX objectTable // ARG
    fprintf(GetFile(), "%s%-32sVkObjectTableNVX = ", indent_string.c_str(), "objectTable:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, objectTable);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkUnregisterObjectsNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            objectTable,
    uint32_t                                    objectCount,
    const PointerDecoder<VkObjectEntryTypeNVX>& pObjectEntryTypes,
    const PointerDecoder<uint32_t>&             pObjectIndices)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkUnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkObjectTableNVX objectTable // ARG
    fprintf(GetFile(), "%s%-32sVkObjectTableNVX = ", indent_string.c_str(), "objectTable:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, objectTable);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t objectCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "objectCount:", objectCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkObjectEntryTypeNVX* pObjectEntryTypes // ARG
    if (pObjectEntryTypes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectEntryTypeNVX* = NULL", indent_string.c_str(), "pObjectEntryTypes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectEntryTypeNVX* = %" PRId64 "", indent_string.c_str(), "pObjectEntryTypes:", static_cast<uint64_t>(*pObjectEntryTypes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const uint32_t* pObjectIndices // ARG
    if (pObjectIndices.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = NULL", indent_string.c_str(), "pObjectIndices:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = %" PRId64 "", indent_string.c_str(), "pObjectIndices:", static_cast<uint64_t>(*pObjectIndices.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>& pFeatures,
    const StructPointerDecoder<Decoded_VkDeviceGeneratedCommandsLimitsNVX>& pLimits)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, pLimits)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGeneratedCommandsFeaturesNVX* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsFeaturesNVX* = NULL", indent_string.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsFeaturesNVX* = ", indent_string.c_str(), "pFeatures:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(&tmp_string, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGeneratedCommandsLimitsNVX* pLimits // ARG
    if (pLimits.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsLimitsNVX* = NULL", indent_string.c_str(), "pLimits:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsLimitsNVX* = ", indent_string.c_str(), "pLimits:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pLimits.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(&tmp_string, *pLimits.GetMetaStructPointer(), 2, pLimits.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkViewportWScalingNV>(std::string* out, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkViewportWScalingNV>(std::string* out, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkViewportWScalingNV *pstruct = (const VkViewportWScalingNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // float xcoeff // SMB
    IndentSpaces(out, indent);
    *out += "xcoeff:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->xcoeff);
    *out += "\n"; // GDS

    // float ycoeff // SMB
    IndentSpaces(out, indent);
    *out += "ycoeff:                         ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->ycoeff);
}

template <>
void StructureToString<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportWScalingStateCreateInfoNV *pstruct = (const VkPipelineViewportWScalingStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 viewportWScalingEnable // SMB
    IndentSpaces(out, indent);
    *out += "viewportWScalingEnable:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->viewportWScalingEnable);
    *out += "\n"; // GDS

    // uint32_t viewportCount // SMB
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportCount);
    *out += "\n"; // GDS

    // const VkViewportWScalingNV* pViewportWScalings // SMB
    IndentSpaces(out, indent);
    *out += "pViewportWScalings:             ";
    *out += "const VkViewportWScalingNV* = "; // TEQ
    if (pstruct->pViewportWScalings == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pViewportWScalings->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkViewportWScalingNV>(out, indent+1, 1, "VkViewportWScalingNV", pstruct_in.pViewportWScalings->GetMetaStructPointer(), "pViewportWScalings", pstruct->viewportCount, false, pstruct_in.pViewportWScalings->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetViewportWScalingNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkViewportWScalingNV>& pViewportWScalings)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstViewport // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstViewport:", firstViewport); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t viewportCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "viewportCount:", viewportCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkViewportWScalingNV* pViewportWScalings // ARG
    if (pViewportWScalings.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkViewportWScalingNV* = NULL", indent_string.c_str(), "pViewportWScalings:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkViewportWScalingNV* = ", indent_string.c_str(), "pViewportWScalings:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pViewportWScalings.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkViewportWScalingNV>(&tmp_string, 2, 1, "VkViewportWScalingNV",
            pViewportWScalings.GetMetaStructPointer(), "pViewportWScalings", viewportCount, false, pViewportWScalings.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkReleaseDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkReleaseDisplayEXT(physicalDevice, display)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indent_string.c_str(), "display:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, display);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkAcquireXlibDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    format::HandleId                            display)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAcquireXlibDisplayEXT(physicalDevice, dpy, display)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // void* dpy // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indent_string.c_str(), "dpy:", dpy); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indent_string.c_str(), "display:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, display);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRandROutputDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    size_t                                      rrOutput,
    const HandlePointerDecoder<VkDisplayKHR>&   pDisplay)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // void* dpy // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indent_string.c_str(), "dpy:", dpy); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // size_t rrOutput // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indent_string.c_str(), "rrOutput:", rrOutput); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR* pDisplay // ARG
    if (pDisplay.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = NULL", indent_string.c_str(), "pDisplay:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = ", indent_string.c_str(), "pDisplay:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pDisplay.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkSurfaceCounterFlagBitsEXT(std::string* out, uint32_t enum_uint32)
{
    VkSurfaceCounterFlagBitsEXT e = static_cast<VkSurfaceCounterFlagBitsEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SURFACE_COUNTER_VBLANK_EXT:
            *out += std::string("VK_SURFACE_COUNTER_VBLANK_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkSurfaceCapabilities2EXT>(std::string* out, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSurfaceCapabilities2EXT>(std::string* out, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilities2EXT *pstruct = (const VkSurfaceCapabilities2EXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t minImageCount // SMB
    IndentSpaces(out, indent);
    *out += "minImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->minImageCount);
    *out += "\n"; // GDS

    // uint32_t maxImageCount // SMB
    IndentSpaces(out, indent);
    *out += "maxImageCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageCount);
    *out += "\n"; // GDS

    // VkExtent2D currentExtent // SMB
    IndentSpaces(out, indent);
    *out += "currentExtent:                  ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.currentExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, currentExtent)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D minImageExtent // SMB
    IndentSpaces(out, indent);
    *out += "minImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.minImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, minImageExtent)); // AZJ
    *out += "\n"; // GDS

    // VkExtent2D maxImageExtent // SMB
    IndentSpaces(out, indent);
    *out += "maxImageExtent:                 ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxImageExtent, indent+1,  base_addr + offsetof(VkSurfaceCapabilities2EXT, maxImageExtent)); // AZJ
    *out += "\n"; // GDS

    // uint32_t maxImageArrayLayers // SMB
    IndentSpaces(out, indent);
    *out += "maxImageArrayLayers:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxImageArrayLayers);
    *out += "\n"; // GDS

    // VkSurfaceTransformFlagsKHR supportedTransforms // SMB
    IndentSpaces(out, indent);
    *out += "supportedTransforms:            ";
    *out += "VkSurfaceTransformFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedTransforms, EnumToStringVkSurfaceTransformFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR currentTransform // SMB
    IndentSpaces(out, indent);
    *out += "currentTransform:               ";
    *out += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    EnumToStringVkSurfaceTransformFlagBitsKHR(out, pstruct->currentTransform);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->currentTransform);
    *out += ")";
    *out += "\n"; // GDS

    // VkCompositeAlphaFlagsKHR supportedCompositeAlpha // SMB
    IndentSpaces(out, indent);
    *out += "supportedCompositeAlpha:        ";
    *out += "VkCompositeAlphaFlagsKHR = "; // TEQ
    FlagsToString(out, pstruct->supportedCompositeAlpha, EnumToStringVkCompositeAlphaFlagBitsKHR); // URW
    *out += "\n"; // GDS

    // VkImageUsageFlags supportedUsageFlags // SMB
    IndentSpaces(out, indent);
    *out += "supportedUsageFlags:            ";
    *out += "VkImageUsageFlags = "; // TEQ
    FlagsToString(out, pstruct->supportedUsageFlags, EnumToStringVkImageUsageFlagBits); // URW
    *out += "\n"; // GDS

    // VkSurfaceCounterFlagsEXT supportedSurfaceCounters // SMB
    IndentSpaces(out, indent);
    *out += "supportedSurfaceCounters:       ";
    *out += "VkSurfaceCounterFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->supportedSurfaceCounters, EnumToStringVkSurfaceCounterFlagBitsEXT); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilities2EXT>& pSurfaceCapabilities)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indent_string.c_str(), "surface:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, surface);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCapabilities2EXT* pSurfaceCapabilities // ARG
    if (pSurfaceCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2EXT* = NULL", indent_string.c_str(), "pSurfaceCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2EXT* = ", indent_string.c_str(), "pSurfaceCapabilities:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSurfaceCapabilities2EXT>(&tmp_string, *pSurfaceCapabilities.GetMetaStructPointer(), 2, pSurfaceCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkDisplayPowerStateEXT(std::string* out, uint32_t enum_uint32)
{
    VkDisplayPowerStateEXT e = static_cast<VkDisplayPowerStateEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DISPLAY_POWER_STATE_ON_EXT:
            *out += std::string("VK_DISPLAY_POWER_STATE_ON_EXT");
            return;
        case VK_DISPLAY_POWER_STATE_OFF_EXT:
            *out += std::string("VK_DISPLAY_POWER_STATE_OFF_EXT");
            return;
        case VK_DISPLAY_POWER_STATE_SUSPEND_EXT:
            *out += std::string("VK_DISPLAY_POWER_STATE_SUSPEND_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDisplayEventTypeEXT(std::string* out, uint32_t enum_uint32)
{
    VkDisplayEventTypeEXT e = static_cast<VkDisplayEventTypeEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT:
            *out += std::string("VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDeviceEventTypeEXT(std::string* out, uint32_t enum_uint32)
{
    VkDeviceEventTypeEXT e = static_cast<VkDeviceEventTypeEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT:
            *out += std::string("VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkDisplayPowerInfoEXT>(std::string* out, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDeviceEventInfoEXT>(std::string* out, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDisplayEventInfoEXT>(std::string* out, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSwapchainCounterCreateInfoEXT>(std::string* out, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayPowerInfoEXT>(std::string* out, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayPowerInfoEXT *pstruct = (const VkDisplayPowerInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayPowerStateEXT powerState // SMB
    IndentSpaces(out, indent);
    *out += "powerState:                     ";
    *out += "VkDisplayPowerStateEXT = "; // TEQ
    EnumToStringVkDisplayPowerStateEXT(out, pstruct->powerState);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->powerState);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkDeviceEventInfoEXT>(std::string* out, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDeviceEventInfoEXT *pstruct = (const VkDeviceEventInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceEventTypeEXT deviceEvent // SMB
    IndentSpaces(out, indent);
    *out += "deviceEvent:                    ";
    *out += "VkDeviceEventTypeEXT = "; // TEQ
    EnumToStringVkDeviceEventTypeEXT(out, pstruct->deviceEvent);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->deviceEvent);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkDisplayEventInfoEXT>(std::string* out, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayEventInfoEXT *pstruct = (const VkDisplayEventInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDisplayEventTypeEXT displayEvent // SMB
    IndentSpaces(out, indent);
    *out += "displayEvent:                   ";
    *out += "VkDisplayEventTypeEXT = "; // TEQ
    EnumToStringVkDisplayEventTypeEXT(out, pstruct->displayEvent);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->displayEvent);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSwapchainCounterCreateInfoEXT>(std::string* out, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSwapchainCounterCreateInfoEXT *pstruct = (const VkSwapchainCounterCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSurfaceCounterFlagsEXT surfaceCounters // SMB
    IndentSpaces(out, indent);
    *out += "surfaceCounters:                ";
    *out += "VkSurfaceCounterFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->surfaceCounters, EnumToStringVkSurfaceCounterFlagBitsEXT); // URW
}

void VulkanAsciiConsumer::Process_vkDisplayPowerControlEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayPowerInfoEXT>& pDisplayPowerInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indent_string.c_str(), "display:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, display);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayPowerInfoEXT* pDisplayPowerInfo // ARG
    if (pDisplayPowerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPowerInfoEXT* = NULL", indent_string.c_str(), "pDisplayPowerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPowerInfoEXT* = ", indent_string.c_str(), "pDisplayPowerInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pDisplayPowerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDisplayPowerInfoEXT>(&tmp_string, *pDisplayPowerInfo.GetMetaStructPointer(), 2, pDisplayPowerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkRegisterDeviceEventEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceEventInfoEXT>& pDeviceEventInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceEventInfoEXT* pDeviceEventInfo // ARG
    if (pDeviceEventInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceEventInfoEXT* = NULL", indent_string.c_str(), "pDeviceEventInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceEventInfoEXT* = ", indent_string.c_str(), "pDeviceEventInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pDeviceEventInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDeviceEventInfoEXT>(&tmp_string, *pDeviceEventInfo.GetMetaStructPointer(), 2, pDeviceEventInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence* pFence // ARG
    if (pFence.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFence* = NULL", indent_string.c_str(), "pFence:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFence* = ", indent_string.c_str(), "pFence:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pFence.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkRegisterDisplayEventEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayEventInfoEXT>& pDisplayEventInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indent_string.c_str(), "display:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, display);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayEventInfoEXT* pDisplayEventInfo // ARG
    if (pDisplayEventInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayEventInfoEXT* = NULL", indent_string.c_str(), "pDisplayEventInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayEventInfoEXT* = ", indent_string.c_str(), "pDisplayEventInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pDisplayEventInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDisplayEventInfoEXT>(&tmp_string, *pDisplayEventInfo.GetMetaStructPointer(), 2, pDisplayEventInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence* pFence // ARG
    if (pFence.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFence* = NULL", indent_string.c_str(), "pFence:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFence* = ", indent_string.c_str(), "pFence:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pFence.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSwapchainCounterEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    const PointerDecoder<uint64_t>&             pCounterValue)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCounterFlagBitsEXT counter // ARG
    tmp_string = "";
    EnumToStringVkSurfaceCounterFlagBitsEXT(&tmp_string,counter); // EPW
    fprintf(GetFile(), "%s%-32sVkSurfaceCounterFlagBitsEXT = %s", indent_string.c_str(), "counter:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pCounterValue // ARG
    if (pCounterValue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indent_string.c_str(), "pCounterValue:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indent_string.c_str(), "pCounterValue:", static_cast<uint64_t>(*pCounterValue.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkRefreshCycleDurationGOOGLE>(std::string* out, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPastPresentationTimingGOOGLE>(std::string* out, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPresentTimeGOOGLE>(std::string* out, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPresentTimesInfoGOOGLE>(std::string* out, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkRefreshCycleDurationGOOGLE>(std::string* out, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRefreshCycleDurationGOOGLE *pstruct = (const VkRefreshCycleDurationGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint64_t refreshDuration // SMB
    IndentSpaces(out, indent);
    *out += "refreshDuration:                ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->refreshDuration);
}

template <>
void StructureToString<Decoded_VkPastPresentationTimingGOOGLE>(std::string* out, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPastPresentationTimingGOOGLE *pstruct = (const VkPastPresentationTimingGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t presentID // SMB
    IndentSpaces(out, indent);
    *out += "presentID:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->presentID);
    *out += "\n"; // GDS

    // uint64_t desiredPresentTime // SMB
    IndentSpaces(out, indent);
    *out += "desiredPresentTime:             ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->desiredPresentTime);
    *out += "\n"; // GDS

    // uint64_t actualPresentTime // SMB
    IndentSpaces(out, indent);
    *out += "actualPresentTime:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->actualPresentTime);
    *out += "\n"; // GDS

    // uint64_t earliestPresentTime // SMB
    IndentSpaces(out, indent);
    *out += "earliestPresentTime:            ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->earliestPresentTime);
    *out += "\n"; // GDS

    // uint64_t presentMargin // SMB
    IndentSpaces(out, indent);
    *out += "presentMargin:                  ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->presentMargin);
}

template <>
void StructureToString<Decoded_VkPresentTimeGOOGLE>(std::string* out, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPresentTimeGOOGLE *pstruct = (const VkPresentTimeGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t presentID // SMB
    IndentSpaces(out, indent);
    *out += "presentID:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->presentID);
    *out += "\n"; // GDS

    // uint64_t desiredPresentTime // SMB
    IndentSpaces(out, indent);
    *out += "desiredPresentTime:             ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->desiredPresentTime);
}

template <>
void StructureToString<Decoded_VkPresentTimesInfoGOOGLE>(std::string* out, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPresentTimesInfoGOOGLE *pstruct = (const VkPresentTimesInfoGOOGLE *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t swapchainCount // SMB
    IndentSpaces(out, indent);
    *out += "swapchainCount:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->swapchainCount);
    *out += "\n"; // GDS

    // const VkPresentTimeGOOGLE* pTimes // SMB
    IndentSpaces(out, indent);
    *out += "pTimes:                         ";
    *out += "const VkPresentTimeGOOGLE* = "; // TEQ
    if (pstruct->pTimes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTimes->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPresentTimeGOOGLE>(out, indent+1, 1, "VkPresentTimeGOOGLE", pstruct_in.pTimes->GetMetaStructPointer(), "pTimes", pstruct->swapchainCount, false, pstruct_in.pTimes->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkGetRefreshCycleDurationGOOGLE(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const StructPointerDecoder<Decoded_VkRefreshCycleDurationGOOGLE>& pDisplayTimingProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties // ARG
    if (pDisplayTimingProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRefreshCycleDurationGOOGLE* = NULL", indent_string.c_str(), "pDisplayTimingProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRefreshCycleDurationGOOGLE* = ", indent_string.c_str(), "pDisplayTimingProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pDisplayTimingProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkRefreshCycleDurationGOOGLE>(&tmp_string, *pDisplayTimingProperties.GetMetaStructPointer(), 2, pDisplayTimingProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPastPresentationTimingGOOGLE(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const PointerDecoder<uint32_t>&             pPresentationTimingCount,
    const StructPointerDecoder<Decoded_VkPastPresentationTimingGOOGLE>& pPresentationTimings)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPresentationTimingCount // ARG
    if (pPresentationTimingCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPresentationTimingCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPresentationTimingCount:", static_cast<uint64_t>(*pPresentationTimingCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPastPresentationTimingGOOGLE* pPresentationTimings // ARG
    if (pPresentationTimings.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPastPresentationTimingGOOGLE* = NULL", indent_string.c_str(), "pPresentationTimings:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPastPresentationTimingGOOGLE* = ", indent_string.c_str(), "pPresentationTimings:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pPresentationTimings.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkPastPresentationTimingGOOGLE>(&tmp_string, 2, 1, "VkPastPresentationTimingGOOGLE",
            pPresentationTimings.GetMetaStructPointer(), "pPresentationTimings", *pPresentationTimingCount.GetPointer(), false, pPresentationTimings.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkDiscardRectangleModeEXT(std::string* out, uint32_t enum_uint32)
{
    VkDiscardRectangleModeEXT e = static_cast<VkDiscardRectangleModeEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT:
            *out += std::string("VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT");
            return;
        case VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT:
            *out += std::string("VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkViewportCoordinateSwizzleNV(std::string* out, uint32_t enum_uint32)
{
    VkViewportCoordinateSwizzleNV e = static_cast<VkViewportCoordinateSwizzleNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV:
            *out += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT *pstruct = (const VkPhysicalDeviceDiscardRectanglePropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t maxDiscardRectangles // SMB
    IndentSpaces(out, indent);
    *out += "maxDiscardRectangles:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDiscardRectangles);
}

template <>
void StructureToString<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineDiscardRectangleStateCreateInfoEXT *pstruct = (const VkPipelineDiscardRectangleStateCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineDiscardRectangleStateCreateFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineDiscardRectangleStateCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkDiscardRectangleModeEXT discardRectangleMode // SMB
    IndentSpaces(out, indent);
    *out += "discardRectangleMode:           ";
    *out += "VkDiscardRectangleModeEXT = "; // TEQ
    EnumToStringVkDiscardRectangleModeEXT(out, pstruct->discardRectangleMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->discardRectangleMode);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t discardRectangleCount // SMB
    IndentSpaces(out, indent);
    *out += "discardRectangleCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->discardRectangleCount);
    *out += "\n"; // GDS

    // const VkRect2D* pDiscardRectangles // SMB
    IndentSpaces(out, indent);
    *out += "pDiscardRectangles:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pDiscardRectangles == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDiscardRectangles->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pDiscardRectangles->GetMetaStructPointer(), "pDiscardRectangles", pstruct->discardRectangleCount, false, pstruct_in.pDiscardRectangles->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetDiscardRectangleEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pDiscardRectangles)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstDiscardRectangle // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstDiscardRectangle:", firstDiscardRectangle); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t discardRectangleCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "discardRectangleCount:", discardRectangleCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRect2D* pDiscardRectangles // ARG
    if (pDiscardRectangles.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = NULL", indent_string.c_str(), "pDiscardRectangles:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = ", indent_string.c_str(), "pDiscardRectangles:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pDiscardRectangles.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkRect2D>(&tmp_string, 2, 1, "VkRect2D",
            pDiscardRectangles.GetMetaStructPointer(), "pDiscardRectangles", discardRectangleCount, false, pDiscardRectangles.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkConservativeRasterizationModeEXT(std::string* out, uint32_t enum_uint32)
{
    VkConservativeRasterizationModeEXT e = static_cast<VkConservativeRasterizationModeEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT:
            *out += std::string("VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT");
            return;
        case VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT:
            *out += std::string("VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT");
            return;
        case VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT:
            *out += std::string("VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkXYColorEXT>(std::string* out, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkHdrMetadataEXT>(std::string* out, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkXYColorEXT>(std::string* out, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkXYColorEXT *pstruct = (const VkXYColorEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // float x // SMB
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->x);
    *out += "\n"; // GDS

    // float y // SMB
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->y);
}

template <>
void StructureToString<Decoded_VkHdrMetadataEXT>(std::string* out, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkHdrMetadataEXT *pstruct = (const VkHdrMetadataEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkXYColorEXT displayPrimaryRed // SMB
    IndentSpaces(out, indent);
    *out += "displayPrimaryRed:              ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.displayPrimaryRed, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryRed)); // AZJ
    *out += "\n"; // GDS

    // VkXYColorEXT displayPrimaryGreen // SMB
    IndentSpaces(out, indent);
    *out += "displayPrimaryGreen:            ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.displayPrimaryGreen, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryGreen)); // AZJ
    *out += "\n"; // GDS

    // VkXYColorEXT displayPrimaryBlue // SMB
    IndentSpaces(out, indent);
    *out += "displayPrimaryBlue:             ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.displayPrimaryBlue, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryBlue)); // AZJ
    *out += "\n"; // GDS

    // VkXYColorEXT whitePoint // SMB
    IndentSpaces(out, indent);
    *out += "whitePoint:                     ";
    *out += "VkXYColorEXT = "; // TEQ
    StructureToString<Decoded_VkXYColorEXT>(out, *pstruct_in.whitePoint, indent+1,  base_addr + offsetof(VkHdrMetadataEXT, whitePoint)); // AZJ
    *out += "\n"; // GDS

    // float maxLuminance // SMB
    IndentSpaces(out, indent);
    *out += "maxLuminance:                   ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxLuminance);
    *out += "\n"; // GDS

    // float minLuminance // SMB
    IndentSpaces(out, indent);
    *out += "minLuminance:                   ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->minLuminance);
    *out += "\n"; // GDS

    // float maxContentLightLevel // SMB
    IndentSpaces(out, indent);
    *out += "maxContentLightLevel:           ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxContentLightLevel);
    *out += "\n"; // GDS

    // float maxFrameAverageLightLevel // SMB
    IndentSpaces(out, indent);
    *out += "maxFrameAverageLightLevel:      ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->maxFrameAverageLightLevel);
}

void VulkanAsciiConsumer::Process_vkSetHdrMetadataEXT(
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchains,
    const StructPointerDecoder<Decoded_VkHdrMetadataEXT>& pMetadata)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t swapchainCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "swapchainCount:", swapchainCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkSwapchainKHR* pSwapchains // ARG
    if (pSwapchains.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainKHR* = NULL", indent_string.c_str(), "pSwapchains:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainKHR* = ", indent_string.c_str(), "pSwapchains:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pSwapchains.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        ArrayToString<const VkSwapchainKHR*>(&tmp_string, 1, 1, "const VkSwapchainKHR*", reinterpret_cast<const VkSwapchainKHR*>(pSwapchains.GetPointer()), "pSwapchains", swapchainCount, vinfo_pSwapchains); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkHdrMetadataEXT* pMetadata // ARG
    if (pMetadata.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkHdrMetadataEXT* = NULL", indent_string.c_str(), "pMetadata:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkHdrMetadataEXT* = ", indent_string.c_str(), "pMetadata:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pMetadata.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkHdrMetadataEXT>(&tmp_string, 2, 1, "VkHdrMetadataEXT",
            pMetadata.GetMetaStructPointer(), "pMetadata", swapchainCount, false, pMetadata.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkIOSSurfaceCreateInfoMVK *pstruct = (const VkIOSSurfaceCreateInfoMVK *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkIOSSurfaceCreateFlagsMVK flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkIOSSurfaceCreateFlagsMVK = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // const void* pView // SMB
    IndentSpaces(out, indent);
    *out += "pView:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pView == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pView); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateIOSSurfaceMVK(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkIOSSurfaceCreateInfoMVK>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkIOSSurfaceCreateInfoMVK* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkIOSSurfaceCreateInfoMVK* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkIOSSurfaceCreateInfoMVK* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(std::string* out, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMacOSSurfaceCreateInfoMVK *pstruct = (const VkMacOSSurfaceCreateInfoMVK *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkMacOSSurfaceCreateFlagsMVK flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMacOSSurfaceCreateFlagsMVK = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // const void* pView // SMB
    IndentSpaces(out, indent);
    *out += "pView:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pView == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pView); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateMacOSSurfaceMVK(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkMacOSSurfaceCreateInfoMVK>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMacOSSurfaceCreateInfoMVK* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMacOSSurfaceCreateInfoMVK* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMacOSSurfaceCreateInfoMVK* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkDebugUtilsMessageTypeFlagBitsEXT(std::string* out, uint32_t enum_uint32)
{
    VkDebugUtilsMessageTypeFlagBitsEXT e = static_cast<VkDebugUtilsMessageTypeFlagBitsEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT:
            *out += std::string("VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT:
            *out += std::string("VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT:
            *out += std::string("VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDebugUtilsMessageSeverityFlagBitsEXT(std::string* out, uint32_t enum_uint32)
{
    VkDebugUtilsMessageSeverityFlagBitsEXT e = static_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:
            *out += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:
            *out += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:
            *out += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:
            *out += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsLabelEXT>(std::string* out, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsObjectNameInfoEXT *pstruct = (const VkDebugUtilsObjectNameInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkObjectType objectType // SMB
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkObjectType = "; // TEQ
    EnumToStringVkObjectType(out, pstruct->objectType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // uint64_t objectHandle // SMB
    IndentSpaces(out, indent);
    *out += "objectHandle:                   ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectHandle);
    *out += "\n"; // GDS

    // const char* pObjectName // SMB
    IndentSpaces(out, indent);
    *out += "pObjectName:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pObjectName); // TGH
}

template <>
void StructureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(std::string* out, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsObjectTagInfoEXT *pstruct = (const VkDebugUtilsObjectTagInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkObjectType objectType // SMB
    IndentSpaces(out, indent);
    *out += "objectType:                     ";
    *out += "VkObjectType = "; // TEQ
    EnumToStringVkObjectType(out, pstruct->objectType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->objectType);
    *out += ")";
    *out += "\n"; // GDS

    // uint64_t objectHandle // SMB
    IndentSpaces(out, indent);
    *out += "objectHandle:                   ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectHandle);
    *out += "\n"; // GDS

    // uint64_t tagName // SMB
    IndentSpaces(out, indent);
    *out += "tagName:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagName);
    *out += "\n"; // GDS

    // size_t tagSize // SMB
    IndentSpaces(out, indent);
    *out += "tagSize:                        ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->tagSize);
    *out += "\n"; // GDS

    // const void* pTag // SMB
    IndentSpaces(out, indent);
    *out += "pTag:                           ";
    *out += "const void* = "; // TEQ
    if (pstruct->pTag == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pTag.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkDebugUtilsLabelEXT>(std::string* out, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsLabelEXT *pstruct = (const VkDebugUtilsLabelEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // const char* pLabelName // SMB
    IndentSpaces(out, indent);
    *out += "pLabelName:                     ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pLabelName); // TGH
    *out += "\n"; // GDS

    // float color // SMB
    IndentSpaces(out, indent);
    *out += "color:                          ";
    *out += "float[";
    *out += "4";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkDebugUtilsLabelEXT, color)); // IYY
    ValueToStringStruct vinfo_color = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->color), "color", 4, vinfo_color); // JPA
}

template <>
void StructureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsMessengerCallbackDataEXT *pstruct = (const VkDebugUtilsMessengerCallbackDataEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDebugUtilsMessengerCallbackDataFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDebugUtilsMessengerCallbackDataFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // const char* pMessageIdName // SMB
    IndentSpaces(out, indent);
    *out += "pMessageIdName:                 ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pMessageIdName); // TGH
    *out += "\n"; // GDS

    // int32_t messageIdNumber // SMB
    IndentSpaces(out, indent);
    *out += "messageIdNumber:                ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->messageIdNumber);
    *out += "\n"; // GDS

    // const char* pMessage // SMB
    IndentSpaces(out, indent);
    *out += "pMessage:                       ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->pMessage); // TGH
    *out += "\n"; // GDS

    // uint32_t queueLabelCount // SMB
    IndentSpaces(out, indent);
    *out += "queueLabelCount:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueLabelCount);
    *out += "\n"; // GDS

    // const VkDebugUtilsLabelEXT* pQueueLabels // SMB
    IndentSpaces(out, indent);
    *out += "pQueueLabels:                   ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pstruct->pQueueLabels == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueLabels->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(out, indent+1, 1, "VkDebugUtilsLabelEXT", pstruct_in.pQueueLabels->GetMetaStructPointer(), "pQueueLabels", pstruct->queueLabelCount, false, pstruct_in.pQueueLabels->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t cmdBufLabelCount // SMB
    IndentSpaces(out, indent);
    *out += "cmdBufLabelCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->cmdBufLabelCount);
    *out += "\n"; // GDS

    // const VkDebugUtilsLabelEXT* pCmdBufLabels // SMB
    IndentSpaces(out, indent);
    *out += "pCmdBufLabels:                  ";
    *out += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pstruct->pCmdBufLabels == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCmdBufLabels->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(out, indent+1, 1, "VkDebugUtilsLabelEXT", pstruct_in.pCmdBufLabels->GetMetaStructPointer(), "pCmdBufLabels", pstruct->cmdBufLabelCount, false, pstruct_in.pCmdBufLabels->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t objectCount // SMB
    IndentSpaces(out, indent);
    *out += "objectCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->objectCount);
    *out += "\n"; // GDS

    // const VkDebugUtilsObjectNameInfoEXT* pObjects // SMB
    IndentSpaces(out, indent);
    *out += "pObjects:                       ";
    *out += "const VkDebugUtilsObjectNameInfoEXT* = "; // TEQ
    if (pstruct->pObjects == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pObjects->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(out, indent+1, 1, "VkDebugUtilsObjectNameInfoEXT", pstruct_in.pObjects->GetMetaStructPointer(), "pObjects", pstruct->objectCount, false, pstruct_in.pObjects->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(std::string* out, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDebugUtilsMessengerCreateInfoEXT *pstruct = (const VkDebugUtilsMessengerCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDebugUtilsMessengerCreateFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkDebugUtilsMessengerCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkDebugUtilsMessageSeverityFlagsEXT messageSeverity // SMB
    IndentSpaces(out, indent);
    *out += "messageSeverity:                ";
    *out += "VkDebugUtilsMessageSeverityFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->messageSeverity, EnumToStringVkDebugUtilsMessageSeverityFlagBitsEXT); // URW
    *out += "\n"; // GDS

    // VkDebugUtilsMessageTypeFlagsEXT messageType // SMB
    IndentSpaces(out, indent);
    *out += "messageType:                    ";
    *out += "VkDebugUtilsMessageTypeFlagsEXT = "; // TEQ
    FlagsToString(out, pstruct->messageType, EnumToStringVkDebugUtilsMessageTypeFlagBitsEXT); // URW
    *out += "\n"; // GDS

    // PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback // SMB
    IndentSpaces(out, indent);
    *out += "pfnUserCallback:                ";
    *out += "PFN_vkDebugUtilsMessengerCallbackEXT = "; // TEQ
    AddrToString(out, reinterpret_cast<uint64_t>(pstruct->pfnUserCallback)); // WRX
    *out += "\n"; // GDS

    // void* pUserData // SMB
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkSetDebugUtilsObjectNameEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugUtilsObjectNameInfoEXT>& pNameInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkSetDebugUtilsObjectNameEXT(device, pNameInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsObjectNameInfoEXT* pNameInfo // ARG
    if (pNameInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectNameInfoEXT* = NULL", indent_string.c_str(), "pNameInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectNameInfoEXT* = ", indent_string.c_str(), "pNameInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pNameInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(&tmp_string, *pNameInfo.GetMetaStructPointer(), 2, pNameInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkSetDebugUtilsObjectTagEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugUtilsObjectTagInfoEXT>& pTagInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkSetDebugUtilsObjectTagEXT(device, pTagInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsObjectTagInfoEXT* pTagInfo // ARG
    if (pTagInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectTagInfoEXT* = NULL", indent_string.c_str(), "pTagInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectTagInfoEXT* = ", indent_string.c_str(), "pTagInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pTagInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(&tmp_string, *pTagInfo.GetMetaStructPointer(), 2, pTagInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueBeginDebugUtilsLabelEXT(
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indent_string.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indent_string.c_str(), "pLabelInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(&tmp_string, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueEndDebugUtilsLabelEXT(
    format::HandleId                            queue)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueueEndDebugUtilsLabelEXT(queue)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueInsertDebugUtilsLabelEXT(
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indent_string.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indent_string.c_str(), "pLabelInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(&tmp_string, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indent_string.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indent_string.c_str(), "pLabelInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(&tmp_string, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdEndDebugUtilsLabelEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdInsertDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indent_string.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indent_string.c_str(), "pLabelInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsLabelEXT>(&tmp_string, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDebugUtilsMessengerEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDebugUtilsMessengerCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDebugUtilsMessengerEXT>& pMessenger)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCreateInfoEXT* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCreateInfoEXT* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessengerEXT* pMessenger // ARG
    if (pMessenger.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDebugUtilsMessengerEXT* = NULL", indent_string.c_str(), "pMessenger:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDebugUtilsMessengerEXT* = ", indent_string.c_str(), "pMessenger:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pMessenger.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDebugUtilsMessengerEXT(
    format::HandleId                            instance,
    format::HandleId                            messenger,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessengerEXT messenger // ARG
    fprintf(GetFile(), "%s%-32sVkDebugUtilsMessengerEXT = ", indent_string.c_str(), "messenger:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, messenger);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkSubmitDebugUtilsMessageEXT(
    format::HandleId                            instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT             messageTypes,
    const StructPointerDecoder<Decoded_VkDebugUtilsMessengerCallbackDataEXT>& pCallbackData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity // ARG
    tmp_string = "";
    EnumToStringVkDebugUtilsMessageSeverityFlagBitsEXT(&tmp_string,messageSeverity); // EPW
    fprintf(GetFile(), "%s%-32sVkDebugUtilsMessageSeverityFlagBitsEXT = %s", indent_string.c_str(), "messageSeverity:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessageTypeFlagsEXT messageTypes // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, messageTypes, EnumToStringVkDebugUtilsMessageTypeFlagBitsEXT);
    fprintf(GetFile(), "%s%-32sVkDebugUtilsMessageTypeFlagsEXT = %s", indent_string.c_str(), "messageTypes:", tmp_string.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData // ARG
    if (pCallbackData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCallbackDataEXT* = NULL", indent_string.c_str(), "pCallbackData:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCallbackDataEXT* = ", indent_string.c_str(), "pCallbackData:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCallbackData.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(&tmp_string, *pCallbackData.GetMetaStructPointer(), 2, pCallbackData.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkAndroidHardwareBufferUsageANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImportAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkExternalFormatANDROID>(std::string* out, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkAndroidHardwareBufferUsageANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidHardwareBufferUsageANDROID *pstruct = (const VkAndroidHardwareBufferUsageANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint64_t androidHardwareBufferUsage // SMB
    IndentSpaces(out, indent);
    *out += "androidHardwareBufferUsage:     ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->androidHardwareBufferUsage);
}

template <>
void StructureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidHardwareBufferPropertiesANDROID *pstruct = (const VkAndroidHardwareBufferPropertiesANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceSize allocationSize // SMB
    IndentSpaces(out, indent);
    *out += "allocationSize:                 ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->allocationSize);
    *out += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits);
}

template <>
void StructureToString<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>(std::string* out, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAndroidHardwareBufferFormatPropertiesANDROID *pstruct = (const VkAndroidHardwareBufferFormatPropertiesANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFormat format // SMB
    IndentSpaces(out, indent);
    *out += "format:                         ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->format);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->format);
    *out += ")";
    *out += "\n"; // GDS

    // uint64_t externalFormat // SMB
    IndentSpaces(out, indent);
    *out += "externalFormat:                 ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->externalFormat);
    *out += "\n"; // GDS

    // VkFormatFeatureFlags formatFeatures // SMB
    IndentSpaces(out, indent);
    *out += "formatFeatures:                 ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->formatFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
    *out += "\n"; // GDS

    // VkComponentMapping samplerYcbcrConversionComponents // SMB
    IndentSpaces(out, indent);
    *out += "samplerYcbcrConversionComponents: ";
    *out += "VkComponentMapping = "; // TEQ
    StructureToString<Decoded_VkComponentMapping>(out, *pstruct_in.samplerYcbcrConversionComponents, indent+1,  base_addr + offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents)); // AZJ
    *out += "\n"; // GDS

    // VkSamplerYcbcrModelConversion suggestedYcbcrModel // SMB
    IndentSpaces(out, indent);
    *out += "suggestedYcbcrModel:            ";
    *out += "VkSamplerYcbcrModelConversion = "; // TEQ
    EnumToStringVkSamplerYcbcrModelConversion(out, pstruct->suggestedYcbcrModel);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedYcbcrModel);
    *out += ")";
    *out += "\n"; // GDS

    // VkSamplerYcbcrRange suggestedYcbcrRange // SMB
    IndentSpaces(out, indent);
    *out += "suggestedYcbcrRange:            ";
    *out += "VkSamplerYcbcrRange = "; // TEQ
    EnumToStringVkSamplerYcbcrRange(out, pstruct->suggestedYcbcrRange);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedYcbcrRange);
    *out += ")";
    *out += "\n"; // GDS

    // VkChromaLocation suggestedXChromaOffset // SMB
    IndentSpaces(out, indent);
    *out += "suggestedXChromaOffset:         ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->suggestedXChromaOffset);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedXChromaOffset);
    *out += ")";
    *out += "\n"; // GDS

    // VkChromaLocation suggestedYChromaOffset // SMB
    IndentSpaces(out, indent);
    *out += "suggestedYChromaOffset:         ";
    *out += "VkChromaLocation = "; // TEQ
    EnumToStringVkChromaLocation(out, pstruct->suggestedYChromaOffset);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->suggestedYChromaOffset);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkImportAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportAndroidHardwareBufferInfoANDROID *pstruct = (const VkImportAndroidHardwareBufferInfoANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // struct void* buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "struct void* = "; // TEQ
    if (pstruct->buffer == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.buffer); // PWR
    }
}

template <>
void StructureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(std::string* out, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryGetAndroidHardwareBufferInfoANDROID *pstruct = (const VkMemoryGetAndroidHardwareBufferInfoANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
}

template <>
void StructureToString<Decoded_VkExternalFormatANDROID>(std::string* out, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkExternalFormatANDROID *pstruct = (const VkExternalFormatANDROID *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint64_t externalFormat // SMB
    IndentSpaces(out, indent);
    *out += "externalFormat:                 ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->externalFormat);
}

void VulkanAsciiConsumer::Process_vkGetAndroidHardwareBufferPropertiesANDROID(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint64_t                                    buffer,
    const StructPointerDecoder<Decoded_VkAndroidHardwareBufferPropertiesANDROID>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const struct void* buffer // ARG
    fprintf(GetFile(), "%s%-32sconst struct void* = 0x%" PRIx64 "", indent_string.c_str(), "buffer:", buffer); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkAndroidHardwareBufferPropertiesANDROID* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkAndroidHardwareBufferPropertiesANDROID* = NULL", indent_string.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkAndroidHardwareBufferPropertiesANDROID* = ", indent_string.c_str(), "pProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(&tmp_string, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryAndroidHardwareBufferANDROID(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>& pInfo,
    const PointerDecoder<uint64_t>&             pBuffer)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetAndroidHardwareBufferInfoANDROID* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetAndroidHardwareBufferInfoANDROID* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // struct void** pBuffer // ARG
    if (pBuffer.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sstruct void** = NULL", indent_string.c_str(), "pBuffer:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sstruct void** = ", indent_string.c_str(), "pBuffer:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pBuffer.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkSamplerReductionModeEXT(std::string* out, uint32_t enum_uint32)
{
    VkSamplerReductionModeEXT e = static_cast<VkSamplerReductionModeEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT:
            *out += std::string("VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT");
            return;
        case VK_SAMPLER_REDUCTION_MODE_MAX_EXT:
            *out += std::string("VK_SAMPLER_REDUCTION_MODE_MAX_EXT");
            return;
        case VK_SAMPLER_REDUCTION_MODE_MIN_EXT:
            *out += std::string("VK_SAMPLER_REDUCTION_MODE_MIN_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkSampleLocationEXT>(std::string* out, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSampleLocationsInfoEXT>(std::string* out, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAttachmentSampleLocationsEXT>(std::string* out, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSubpassSampleLocationsEXT>(std::string* out, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>(std::string* out, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMultisamplePropertiesEXT>(std::string* out, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSampleLocationEXT>(std::string* out, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSampleLocationEXT *pstruct = (const VkSampleLocationEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // float x // SMB
    IndentSpaces(out, indent);
    *out += "x:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->x);
    *out += "\n"; // GDS

    // float y // SMB
    IndentSpaces(out, indent);
    *out += "y:                              ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->y);
}

template <>
void StructureToString<Decoded_VkSampleLocationsInfoEXT>(std::string* out, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSampleLocationsInfoEXT *pstruct = (const VkSampleLocationsInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSampleCountFlagBits sampleLocationsPerPixel // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationsPerPixel:        ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->sampleLocationsPerPixel);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sampleLocationsPerPixel);
    *out += ")";
    *out += "\n"; // GDS

    // VkExtent2D sampleLocationGridSize // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationGridSize:         ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.sampleLocationGridSize, indent+1,  base_addr + offsetof(VkSampleLocationsInfoEXT, sampleLocationGridSize)); // AZJ
    *out += "\n"; // GDS

    // uint32_t sampleLocationsCount // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationsCount:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleLocationsCount);
    *out += "\n"; // GDS

    // const VkSampleLocationEXT* pSampleLocations // SMB
    IndentSpaces(out, indent);
    *out += "pSampleLocations:               ";
    *out += "const VkSampleLocationEXT* = "; // TEQ
    if (pstruct->pSampleLocations == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSampleLocations->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSampleLocationEXT>(out, indent+1, 1, "VkSampleLocationEXT", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationsCount, false, pstruct_in.pSampleLocations->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkAttachmentSampleLocationsEXT>(std::string* out, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAttachmentSampleLocationsEXT *pstruct = (const VkAttachmentSampleLocationsEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t attachmentIndex // SMB
    IndentSpaces(out, indent);
    *out += "attachmentIndex:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentIndex);
    *out += "\n"; // GDS

    // VkSampleLocationsInfoEXT sampleLocationsInfo // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationsInfo:            ";
    *out += "VkSampleLocationsInfoEXT = "; // TEQ
    StructureToString<Decoded_VkSampleLocationsInfoEXT>(out, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkAttachmentSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

template <>
void StructureToString<Decoded_VkSubpassSampleLocationsEXT>(std::string* out, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSubpassSampleLocationsEXT *pstruct = (const VkSubpassSampleLocationsEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t subpassIndex // SMB
    IndentSpaces(out, indent);
    *out += "subpassIndex:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->subpassIndex);
    *out += "\n"; // GDS

    // VkSampleLocationsInfoEXT sampleLocationsInfo // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationsInfo:            ";
    *out += "VkSampleLocationsInfoEXT = "; // TEQ
    StructureToString<Decoded_VkSampleLocationsInfoEXT>(out, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkSubpassSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

template <>
void StructureToString<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>(std::string* out, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRenderPassSampleLocationsBeginInfoEXT *pstruct = (const VkRenderPassSampleLocationsBeginInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t attachmentInitialSampleLocationsCount // SMB
    IndentSpaces(out, indent);
    *out += "attachmentInitialSampleLocationsCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->attachmentInitialSampleLocationsCount);
    *out += "\n"; // GDS

    // const VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations // SMB
    IndentSpaces(out, indent);
    *out += "pAttachmentInitialSampleLocations: ";
    *out += "const VkAttachmentSampleLocationsEXT* = "; // TEQ
    if (pstruct->pAttachmentInitialSampleLocations == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAttachmentInitialSampleLocations->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkAttachmentSampleLocationsEXT>(out, indent+1, 1, "VkAttachmentSampleLocationsEXT", pstruct_in.pAttachmentInitialSampleLocations->GetMetaStructPointer(), "pAttachmentInitialSampleLocations", pstruct->attachmentInitialSampleLocationsCount, false, pstruct_in.pAttachmentInitialSampleLocations->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t postSubpassSampleLocationsCount // SMB
    IndentSpaces(out, indent);
    *out += "postSubpassSampleLocationsCount: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->postSubpassSampleLocationsCount);
    *out += "\n"; // GDS

    // const VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations // SMB
    IndentSpaces(out, indent);
    *out += "pPostSubpassSampleLocations:    ";
    *out += "const VkSubpassSampleLocationsEXT* = "; // TEQ
    if (pstruct->pPostSubpassSampleLocations == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPostSubpassSampleLocations->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSubpassSampleLocationsEXT>(out, indent+1, 1, "VkSubpassSampleLocationsEXT", pstruct_in.pPostSubpassSampleLocations->GetMetaStructPointer(), "pPostSubpassSampleLocations", pstruct->postSubpassSampleLocationsCount, false, pstruct_in.pPostSubpassSampleLocations->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineSampleLocationsStateCreateInfoEXT *pstruct = (const VkPipelineSampleLocationsStateCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 sampleLocationsEnable // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationsEnable:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->sampleLocationsEnable);
    *out += "\n"; // GDS

    // VkSampleLocationsInfoEXT sampleLocationsInfo // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationsInfo:            ";
    *out += "VkSampleLocationsInfoEXT = "; // TEQ
    StructureToString<Decoded_VkSampleLocationsInfoEXT>(out, *pstruct_in.sampleLocationsInfo, indent+1,  base_addr + offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo)); // AZJ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceSampleLocationsPropertiesEXT *pstruct = (const VkPhysicalDeviceSampleLocationsPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkSampleCountFlags sampleLocationSampleCounts // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationSampleCounts:     ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->sampleLocationSampleCounts, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkExtent2D maxSampleLocationGridSize // SMB
    IndentSpaces(out, indent);
    *out += "maxSampleLocationGridSize:      ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxSampleLocationGridSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize)); // AZJ
    *out += "\n"; // GDS

    // float sampleLocationCoordinateRange // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationCoordinateRange:  ";
    *out += "float[";
    *out += "2";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationCoordinateRange)); // IYY
    ValueToStringStruct vinfo_sampleLocationCoordinateRange = {false, false, false, nullptr};
    ArrayToString<float*>(out, indent, 0, "float", const_cast<float*>(pstruct->sampleLocationCoordinateRange), "sampleLocationCoordinateRange", 2, vinfo_sampleLocationCoordinateRange); // JPA
    *out += "\n"; // GDS

    // uint32_t sampleLocationSubPixelBits // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationSubPixelBits:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleLocationSubPixelBits);
    *out += "\n"; // GDS

    // VkBool32 variableSampleLocations // SMB
    IndentSpaces(out, indent);
    *out += "variableSampleLocations:        ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->variableSampleLocations);
}

template <>
void StructureToString<Decoded_VkMultisamplePropertiesEXT>(std::string* out, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMultisamplePropertiesEXT *pstruct = (const VkMultisamplePropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExtent2D maxSampleLocationGridSize // SMB
    IndentSpaces(out, indent);
    *out += "maxSampleLocationGridSize:      ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.maxSampleLocationGridSize, indent+1,  base_addr + offsetof(VkMultisamplePropertiesEXT, maxSampleLocationGridSize)); // AZJ
}

void VulkanAsciiConsumer::Process_vkCmdSetSampleLocationsEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSampleLocationsInfoEXT>& pSampleLocationsInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSampleLocationsInfoEXT* pSampleLocationsInfo // ARG
    if (pSampleLocationsInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSampleLocationsInfoEXT* = NULL", indent_string.c_str(), "pSampleLocationsInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSampleLocationsInfoEXT* = ", indent_string.c_str(), "pSampleLocationsInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSampleLocationsInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkSampleLocationsInfoEXT>(&tmp_string, *pSampleLocationsInfo.GetMetaStructPointer(), 2, pSampleLocationsInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMultisamplePropertiesEXT(
    format::HandleId                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    const StructPointerDecoder<Decoded_VkMultisamplePropertiesEXT>& pMultisampleProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSampleCountFlagBits samples // ARG
    tmp_string = "";
    EnumToStringVkSampleCountFlagBits(&tmp_string,samples); // EPW
    fprintf(GetFile(), "%s%-32sVkSampleCountFlagBits = %s", indent_string.c_str(), "samples:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkMultisamplePropertiesEXT* pMultisampleProperties // ARG
    if (pMultisampleProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMultisamplePropertiesEXT* = NULL", indent_string.c_str(), "pMultisampleProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMultisamplePropertiesEXT* = ", indent_string.c_str(), "pMultisampleProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMultisampleProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMultisamplePropertiesEXT>(&tmp_string, *pMultisampleProperties.GetMetaStructPointer(), 2, pMultisampleProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkCoverageModulationModeNV(std::string* out, uint32_t enum_uint32)
{
    VkCoverageModulationModeNV e = static_cast<VkCoverageModulationModeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COVERAGE_MODULATION_MODE_RGBA_NV:
            *out += std::string("VK_COVERAGE_MODULATION_MODE_RGBA_NV");
            return;
        case VK_COVERAGE_MODULATION_MODE_RGB_NV:
            *out += std::string("VK_COVERAGE_MODULATION_MODE_RGB_NV");
            return;
        case VK_COVERAGE_MODULATION_MODE_ALPHA_NV:
            *out += std::string("VK_COVERAGE_MODULATION_MODE_ALPHA_NV");
            return;
        case VK_COVERAGE_MODULATION_MODE_NONE_NV:
            *out += std::string("VK_COVERAGE_MODULATION_MODE_NONE_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkBlendOverlapEXT(std::string* out, uint32_t enum_uint32)
{
    VkBlendOverlapEXT e = static_cast<VkBlendOverlapEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_BLEND_OVERLAP_CONJOINT_EXT:
            *out += std::string("VK_BLEND_OVERLAP_CONJOINT_EXT");
            return;
        case VK_BLEND_OVERLAP_DISJOINT_EXT:
            *out += std::string("VK_BLEND_OVERLAP_DISJOINT_EXT");
            return;
        case VK_BLEND_OVERLAP_UNCORRELATED_EXT:
            *out += std::string("VK_BLEND_OVERLAP_UNCORRELATED_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrmFormatModifierPropertiesListEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(std::string* out, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrmFormatModifierPropertiesEXT *pstruct = (const VkDrmFormatModifierPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint64_t drmFormatModifier // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier);
    *out += "\n"; // GDS

    // uint32_t drmFormatModifierPlaneCount // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifierPlaneCount:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierPlaneCount);
    *out += "\n"; // GDS

    // VkFormatFeatureFlags drmFormatModifierTilingFeatures // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifierTilingFeatures: ";
    *out += "VkFormatFeatureFlags = "; // TEQ
    FlagsToString(out, pstruct->drmFormatModifierTilingFeatures, EnumToStringVkFormatFeatureFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkDrmFormatModifierPropertiesListEXT>(std::string* out, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrmFormatModifierPropertiesListEXT *pstruct = (const VkDrmFormatModifierPropertiesListEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t drmFormatModifierCount // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifierCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierCount);
    *out += "\n"; // GDS

    // VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties // SMB
    IndentSpaces(out, indent);
    *out += "pDrmFormatModifierProperties:   ";
    *out += "VkDrmFormatModifierPropertiesEXT* = "; // TEQ
    if (pstruct->pDrmFormatModifierProperties == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDrmFormatModifierProperties->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkDrmFormatModifierPropertiesEXT>(out, indent+1, 1, "VkDrmFormatModifierPropertiesEXT", pstruct_in.pDrmFormatModifierProperties->GetMetaStructPointer(), "pDrmFormatModifierProperties", pstruct->drmFormatModifierCount, false, pstruct_in.pDrmFormatModifierProperties->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(std::string* out, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *pstruct = (const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint64_t drmFormatModifier // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier);
    *out += "\n"; // GDS

    // VkSharingMode sharingMode // SMB
    IndentSpaces(out, indent);
    *out += "sharingMode:                    ";
    *out += "VkSharingMode = "; // TEQ
    EnumToStringVkSharingMode(out, pstruct->sharingMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sharingMode);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    IndentSpaces(out, indent);
    *out += "queueFamilyIndexCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->queueFamilyIndexCount);
    *out += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    IndentSpaces(out, indent);
    *out += "pQueueFamilyIndices:            ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pstruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageDrmFormatModifierListCreateInfoEXT *pstruct = (const VkImageDrmFormatModifierListCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t drmFormatModifierCount // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifierCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierCount);
    *out += "\n"; // GDS

    // const uint64_t* pDrmFormatModifiers // SMB
    IndentSpaces(out, indent);
    *out += "pDrmFormatModifiers:            ";
    *out += "const uint64_t* = "; // TEQ
    if (pstruct->pDrmFormatModifiers == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDrmFormatModifiers.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDrmFormatModifiers = {false, false, false, nullptr};
        ArrayToString<const uint64_t*>(out, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pstruct_in.pDrmFormatModifiers.GetPointer()), "pDrmFormatModifiers", pstruct->drmFormatModifierCount,  vinfo_pDrmFormatModifiers);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageDrmFormatModifierExplicitCreateInfoEXT *pstruct = (const VkImageDrmFormatModifierExplicitCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint64_t drmFormatModifier // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier);
    *out += "\n"; // GDS

    // uint32_t drmFormatModifierPlaneCount // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifierPlaneCount:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifierPlaneCount);
    *out += "\n"; // GDS

    // const VkSubresourceLayout* pPlaneLayouts // SMB
    IndentSpaces(out, indent);
    *out += "pPlaneLayouts:                  ";
    *out += "const VkSubresourceLayout* = "; // TEQ
    if (pstruct->pPlaneLayouts == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pPlaneLayouts->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkSubresourceLayout>(out, indent+1, 1, "VkSubresourceLayout", pstruct_in.pPlaneLayouts->GetMetaStructPointer(), "pPlaneLayouts", pstruct->drmFormatModifierPlaneCount, false, pstruct_in.pPlaneLayouts->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(std::string* out, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImageDrmFormatModifierPropertiesEXT *pstruct = (const VkImageDrmFormatModifierPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint64_t drmFormatModifier // SMB
    IndentSpaces(out, indent);
    *out += "drmFormatModifier:              ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->drmFormatModifier);
}

void VulkanAsciiConsumer::Process_vkGetImageDrmFormatModifierPropertiesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkImageDrmFormatModifierPropertiesEXT>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indent_string.c_str(), "image:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, image);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageDrmFormatModifierPropertiesEXT* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageDrmFormatModifierPropertiesEXT* = NULL", indent_string.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageDrmFormatModifierPropertiesEXT* = ", indent_string.c_str(), "pProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(&tmp_string, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkValidationCacheHeaderVersionEXT(std::string* out, uint32_t enum_uint32)
{
    VkValidationCacheHeaderVersionEXT e = static_cast<VkValidationCacheHeaderVersionEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT:
            *out += std::string("VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkValidationCacheCreateInfoEXT *pstruct = (const VkValidationCacheCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkValidationCacheCreateFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkValidationCacheCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // size_t initialDataSize // SMB
    IndentSpaces(out, indent);
    *out += "initialDataSize:                ";
    *out += "size_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->initialDataSize);
    *out += "\n"; // GDS

    // const void* pInitialData // SMB
    IndentSpaces(out, indent);
    *out += "pInitialData:                   ";
    *out += "const void* = "; // TEQ
    if (pstruct->pInitialData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pInitialData.GetAddress()); // AHW
    }
}

template <>
void StructureToString<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>(std::string* out, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShaderModuleValidationCacheCreateInfoEXT *pstruct = (const VkShaderModuleValidationCacheCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkValidationCacheEXT validationCache // SMB
    IndentSpaces(out, indent);
    *out += "validationCache:                ";
    *out += "VkValidationCacheEXT = "; // TEQ
    AddrToString(out, pstruct_in.validationCache); // PAQ
}

void VulkanAsciiConsumer::Process_vkCreateValidationCacheEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkValidationCacheCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkValidationCacheEXT>& pValidationCache)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkValidationCacheCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheCreateInfoEXT* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheCreateInfoEXT* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkValidationCacheCreateInfoEXT>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT* pValidationCache // ARG
    if (pValidationCache.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkValidationCacheEXT* = NULL", indent_string.c_str(), "pValidationCache:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkValidationCacheEXT* = ", indent_string.c_str(), "pValidationCache:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pValidationCache.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyValidationCacheEXT(
    format::HandleId                            device,
    format::HandleId                            validationCache,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyValidationCacheEXT(device, validationCache, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT validationCache // ARG
    fprintf(GetFile(), "%s%-32sVkValidationCacheEXT = ", indent_string.c_str(), "validationCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, validationCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkMergeValidationCachesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    const HandlePointerDecoder<VkValidationCacheEXT>& pSrcCaches)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT dstCache // ARG
    fprintf(GetFile(), "%s%-32sVkValidationCacheEXT = ", indent_string.c_str(), "dstCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t srcCacheCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "srcCacheCount:", srcCacheCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkValidationCacheEXT* pSrcCaches // ARG
    if (pSrcCaches.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheEXT* = NULL", indent_string.c_str(), "pSrcCaches:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheEXT* = ", indent_string.c_str(), "pSrcCaches:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pSrcCaches.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pSrcCaches = {true, false, false, nullptr};
        ArrayToString<const VkValidationCacheEXT*>(&tmp_string, 1, 1, "const VkValidationCacheEXT*", reinterpret_cast<const VkValidationCacheEXT*>(pSrcCaches.GetPointer()), "pSrcCaches", srcCacheCount, vinfo_pSrcCaches); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetValidationCacheDataEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            validationCache,
    const PointerDecoder<size_t>&               pDataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT validationCache // ARG
    fprintf(GetFile(), "%s%-32sVkValidationCacheEXT = ", indent_string.c_str(), "validationCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, validationCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // size_t* pDataSize // ARG
    if (pDataSize.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32ssize_t* = NULL", indent_string.c_str(), "pDataSize:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32ssize_t* = %" PRId64 "", indent_string.c_str(), "pDataSize:", static_cast<uint64_t>(*pDataSize.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indent_string.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indent_string.c_str(), "pData:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkShadingRatePaletteEntryNV(std::string* out, uint32_t enum_uint32)
{
    VkShadingRatePaletteEntryNV e = static_cast<VkShadingRatePaletteEntryNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV:
            *out += std::string("VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkDescriptorBindingFlagBitsEXT(std::string* out, uint32_t enum_uint32)
{
    VkDescriptorBindingFlagBitsEXT e = static_cast<VkDescriptorBindingFlagBitsEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT:
            *out += std::string("VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT");
            return;
        case VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT:
            *out += std::string("VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT");
            return;
        case VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT:
            *out += std::string("VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT");
            return;
        case VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT:
            *out += std::string("VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCoarseSampleOrderTypeNV(std::string* out, uint32_t enum_uint32)
{
    VkCoarseSampleOrderTypeNV e = static_cast<VkCoarseSampleOrderTypeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV:
            *out += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV");
            return;
        case VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV:
            *out += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV");
            return;
        case VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV:
            *out += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV");
            return;
        case VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV:
            *out += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkShadingRatePaletteNV>(std::string* out, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCoarseSampleLocationNV>(std::string* out, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCoarseSampleOrderCustomNV>(std::string* out, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkShadingRatePaletteNV>(std::string* out, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkShadingRatePaletteNV *pstruct = (const VkShadingRatePaletteNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t shadingRatePaletteEntryCount // SMB
    IndentSpaces(out, indent);
    *out += "shadingRatePaletteEntryCount:   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shadingRatePaletteEntryCount);
    *out += "\n"; // GDS

    // const VkShadingRatePaletteEntryNV* pShadingRatePaletteEntries // SMB
    IndentSpaces(out, indent);
    *out += "pShadingRatePaletteEntries:     ";
    *out += "const VkShadingRatePaletteEntryNV* = "; // TEQ
    if (pstruct->pShadingRatePaletteEntries == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pShadingRatePaletteEntries.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pShadingRatePaletteEntries = {false, true, false, EnumToStringVkShadingRatePaletteEntryNV};
        ArrayToString<const VkShadingRatePaletteEntryNV*>(out, indent, 1, "const VkShadingRatePaletteEntryNV*", reinterpret_cast<const VkShadingRatePaletteEntryNV*>(pstruct_in.pShadingRatePaletteEntries.GetPointer()), "pShadingRatePaletteEntries", pstruct->shadingRatePaletteEntryCount,  vinfo_pShadingRatePaletteEntries);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportShadingRateImageStateCreateInfoNV *pstruct = (const VkPipelineViewportShadingRateImageStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 shadingRateImageEnable // SMB
    IndentSpaces(out, indent);
    *out += "shadingRateImageEnable:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shadingRateImageEnable);
    *out += "\n"; // GDS

    // uint32_t viewportCount // SMB
    IndentSpaces(out, indent);
    *out += "viewportCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->viewportCount);
    *out += "\n"; // GDS

    // const VkShadingRatePaletteNV* pShadingRatePalettes // SMB
    IndentSpaces(out, indent);
    *out += "pShadingRatePalettes:           ";
    *out += "const VkShadingRatePaletteNV* = "; // TEQ
    if (pstruct->pShadingRatePalettes == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pShadingRatePalettes->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkShadingRatePaletteNV>(out, indent+1, 1, "VkShadingRatePaletteNV", pstruct_in.pShadingRatePalettes->GetMetaStructPointer(), "pShadingRatePalettes", pstruct->viewportCount, false, pstruct_in.pShadingRatePalettes->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceShadingRateImageFeaturesNV *pstruct = (const VkPhysicalDeviceShadingRateImageFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 shadingRateImage // SMB
    IndentSpaces(out, indent);
    *out += "shadingRateImage:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shadingRateImage);
    *out += "\n"; // GDS

    // VkBool32 shadingRateCoarseSampleOrder // SMB
    IndentSpaces(out, indent);
    *out += "shadingRateCoarseSampleOrder:   ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->shadingRateCoarseSampleOrder);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceShadingRateImagePropertiesNV *pstruct = (const VkPhysicalDeviceShadingRateImagePropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExtent2D shadingRateTexelSize // SMB
    IndentSpaces(out, indent);
    *out += "shadingRateTexelSize:           ";
    *out += "VkExtent2D = "; // TEQ
    StructureToString<Decoded_VkExtent2D>(out, *pstruct_in.shadingRateTexelSize, indent+1,  base_addr + offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize)); // AZJ
    *out += "\n"; // GDS

    // uint32_t shadingRatePaletteSize // SMB
    IndentSpaces(out, indent);
    *out += "shadingRatePaletteSize:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shadingRatePaletteSize);
    *out += "\n"; // GDS

    // uint32_t shadingRateMaxCoarseSamples // SMB
    IndentSpaces(out, indent);
    *out += "shadingRateMaxCoarseSamples:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shadingRateMaxCoarseSamples);
}

template <>
void StructureToString<Decoded_VkCoarseSampleLocationNV>(std::string* out, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCoarseSampleLocationNV *pstruct = (const VkCoarseSampleLocationNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t pixelX // SMB
    IndentSpaces(out, indent);
    *out += "pixelX:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->pixelX);
    *out += "\n"; // GDS

    // uint32_t pixelY // SMB
    IndentSpaces(out, indent);
    *out += "pixelY:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->pixelY);
    *out += "\n"; // GDS

    // uint32_t sample // SMB
    IndentSpaces(out, indent);
    *out += "sample:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sample);
}

template <>
void StructureToString<Decoded_VkCoarseSampleOrderCustomNV>(std::string* out, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCoarseSampleOrderCustomNV *pstruct = (const VkCoarseSampleOrderCustomNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkShadingRatePaletteEntryNV shadingRate // SMB
    IndentSpaces(out, indent);
    *out += "shadingRate:                    ";
    *out += "VkShadingRatePaletteEntryNV = "; // TEQ
    EnumToStringVkShadingRatePaletteEntryNV(out, pstruct->shadingRate);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->shadingRate);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t sampleCount // SMB
    IndentSpaces(out, indent);
    *out += "sampleCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleCount);
    *out += "\n"; // GDS

    // uint32_t sampleLocationCount // SMB
    IndentSpaces(out, indent);
    *out += "sampleLocationCount:            ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->sampleLocationCount);
    *out += "\n"; // GDS

    // const VkCoarseSampleLocationNV* pSampleLocations // SMB
    IndentSpaces(out, indent);
    *out += "pSampleLocations:               ";
    *out += "const VkCoarseSampleLocationNV* = "; // TEQ
    if (pstruct->pSampleLocations == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pSampleLocations->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkCoarseSampleLocationNV>(out, indent+1, 1, "VkCoarseSampleLocationNV", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationCount, false, pstruct_in.pSampleLocations->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *pstruct = (const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkCoarseSampleOrderTypeNV sampleOrderType // SMB
    IndentSpaces(out, indent);
    *out += "sampleOrderType:                ";
    *out += "VkCoarseSampleOrderTypeNV = "; // TEQ
    EnumToStringVkCoarseSampleOrderTypeNV(out, pstruct->sampleOrderType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sampleOrderType);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t customSampleOrderCount // SMB
    IndentSpaces(out, indent);
    *out += "customSampleOrderCount:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->customSampleOrderCount);
    *out += "\n"; // GDS

    // const VkCoarseSampleOrderCustomNV* pCustomSampleOrders // SMB
    IndentSpaces(out, indent);
    *out += "pCustomSampleOrders:            ";
    *out += "const VkCoarseSampleOrderCustomNV* = "; // TEQ
    if (pstruct->pCustomSampleOrders == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCustomSampleOrders->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkCoarseSampleOrderCustomNV>(out, indent+1, 1, "VkCoarseSampleOrderCustomNV", pstruct_in.pCustomSampleOrders->GetMetaStructPointer(), "pCustomSampleOrders", pstruct->customSampleOrderCount, false, pstruct_in.pCustomSampleOrders->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdBindShadingRateImageNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            imageView,
    VkImageLayout                               imageLayout)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageView imageView // ARG
    fprintf(GetFile(), "%s%-32sVkImageView = ", indent_string.c_str(), "imageView:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, imageView);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout imageLayout // ARG
    tmp_string = "";
    EnumToStringVkImageLayout(&tmp_string,imageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indent_string.c_str(), "imageLayout:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetViewportShadingRatePaletteNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkShadingRatePaletteNV>& pShadingRatePalettes)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstViewport // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstViewport:", firstViewport); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t viewportCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "viewportCount:", viewportCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkShadingRatePaletteNV* pShadingRatePalettes // ARG
    if (pShadingRatePalettes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkShadingRatePaletteNV* = NULL", indent_string.c_str(), "pShadingRatePalettes:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkShadingRatePaletteNV* = ", indent_string.c_str(), "pShadingRatePalettes:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pShadingRatePalettes.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkShadingRatePaletteNV>(&tmp_string, 2, 1, "VkShadingRatePaletteNV",
            pShadingRatePalettes.GetMetaStructPointer(), "pShadingRatePalettes", viewportCount, false, pShadingRatePalettes.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetCoarseSampleOrderNV(
    format::HandleId                            commandBuffer,
    VkCoarseSampleOrderTypeNV                   sampleOrderType,
    uint32_t                                    customSampleOrderCount,
    const StructPointerDecoder<Decoded_VkCoarseSampleOrderCustomNV>& pCustomSampleOrders)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCoarseSampleOrderTypeNV sampleOrderType // ARG
    tmp_string = "";
    EnumToStringVkCoarseSampleOrderTypeNV(&tmp_string,sampleOrderType); // EPW
    fprintf(GetFile(), "%s%-32sVkCoarseSampleOrderTypeNV = %s", indent_string.c_str(), "sampleOrderType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t customSampleOrderCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "customSampleOrderCount:", customSampleOrderCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCoarseSampleOrderCustomNV* pCustomSampleOrders // ARG
    if (pCustomSampleOrders.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCoarseSampleOrderCustomNV* = NULL", indent_string.c_str(), "pCustomSampleOrders:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCoarseSampleOrderCustomNV* = ", indent_string.c_str(), "pCustomSampleOrders:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pCustomSampleOrders.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkCoarseSampleOrderCustomNV>(&tmp_string, 2, 1, "VkCoarseSampleOrderCustomNV",
            pCustomSampleOrders.GetMetaStructPointer(), "pCustomSampleOrders", customSampleOrderCount, false, pCustomSampleOrders.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkGeometryInstanceFlagBitsNV(std::string* out, uint32_t enum_uint32)
{
    VkGeometryInstanceFlagBitsNV e = static_cast<VkGeometryInstanceFlagBitsNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV:
            *out += std::string("VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV");
            return;
        case VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV:
            *out += std::string("VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV");
            return;
        case VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV:
            *out += std::string("VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV");
            return;
        case VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV:
            *out += std::string("VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkGeometryTypeNV(std::string* out, uint32_t enum_uint32)
{
    VkGeometryTypeNV e = static_cast<VkGeometryTypeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_GEOMETRY_TYPE_AABBS_NV:
            *out += std::string("VK_GEOMETRY_TYPE_AABBS_NV");
            return;
        case VK_GEOMETRY_TYPE_TRIANGLES_NV:
            *out += std::string("VK_GEOMETRY_TYPE_TRIANGLES_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkBuildAccelerationStructureFlagBitsNV(std::string* out, uint32_t enum_uint32)
{
    VkBuildAccelerationStructureFlagBitsNV e = static_cast<VkBuildAccelerationStructureFlagBitsNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV:
            *out += std::string("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV:
            *out += std::string("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV:
            *out += std::string("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV:
            *out += std::string("VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV:
            *out += std::string("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkGeometryFlagBitsNV(std::string* out, uint32_t enum_uint32)
{
    VkGeometryFlagBitsNV e = static_cast<VkGeometryFlagBitsNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_GEOMETRY_OPAQUE_BIT_NV:
            *out += std::string("VK_GEOMETRY_OPAQUE_BIT_NV");
            return;
        case VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV:
            *out += std::string("VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkRayTracingShaderGroupTypeNV(std::string* out, uint32_t enum_uint32)
{
    VkRayTracingShaderGroupTypeNV e = static_cast<VkRayTracingShaderGroupTypeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV:
            *out += std::string("VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV");
            return;
        case VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV:
            *out += std::string("VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV");
            return;
        case VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV:
            *out += std::string("VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkAccelerationStructureMemoryRequirementsTypeNV(std::string* out, uint32_t enum_uint32)
{
    VkAccelerationStructureMemoryRequirementsTypeNV e = static_cast<VkAccelerationStructureMemoryRequirementsTypeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV:
            *out += std::string("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV");
            return;
        case VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV:
            *out += std::string("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV");
            return;
        case VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV:
            *out += std::string("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkAccelerationStructureTypeNV(std::string* out, uint32_t enum_uint32)
{
    VkAccelerationStructureTypeNV e = static_cast<VkAccelerationStructureTypeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV:
            *out += std::string("VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV");
            return;
        case VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV:
            *out += std::string("VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkCopyAccelerationStructureModeNV(std::string* out, uint32_t enum_uint32)
{
    VkCopyAccelerationStructureModeNV e = static_cast<VkCopyAccelerationStructureModeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV:
            *out += std::string("VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV");
            return;
        case VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV:
            *out += std::string("VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(std::string* out, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkRayTracingPipelineCreateInfoNV>(std::string* out, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryTrianglesNV>(std::string* out, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryAABBNV>(std::string* out, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryDataNV>(std::string* out, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkGeometryNV>(std::string* out, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAccelerationStructureInfoNV>(std::string* out, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAccelerationStructureCreateInfoNV>(std::string* out, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(std::string* out, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkWriteDescriptorSetAccelerationStructureNV>(std::string* out, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(std::string* out, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(std::string* out, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRayTracingShaderGroupCreateInfoNV *pstruct = (const VkRayTracingShaderGroupCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkRayTracingShaderGroupTypeNV type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkRayTracingShaderGroupTypeNV = "; // TEQ
    EnumToStringVkRayTracingShaderGroupTypeNV(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // uint32_t generalShader // SMB
    IndentSpaces(out, indent);
    *out += "generalShader:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->generalShader);
    *out += "\n"; // GDS

    // uint32_t closestHitShader // SMB
    IndentSpaces(out, indent);
    *out += "closestHitShader:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->closestHitShader);
    *out += "\n"; // GDS

    // uint32_t anyHitShader // SMB
    IndentSpaces(out, indent);
    *out += "anyHitShader:                   ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->anyHitShader);
    *out += "\n"; // GDS

    // uint32_t intersectionShader // SMB
    IndentSpaces(out, indent);
    *out += "intersectionShader:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->intersectionShader);
}

template <>
void StructureToString<Decoded_VkRayTracingPipelineCreateInfoNV>(std::string* out, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkRayTracingPipelineCreateInfoNV *pstruct = (const VkRayTracingPipelineCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineCreateFlags flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCreateFlags = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkPipelineCreateFlagBits); // URW
    *out += "\n"; // GDS

    // uint32_t stageCount // SMB
    IndentSpaces(out, indent);
    *out += "stageCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stageCount);
    *out += "\n"; // GDS

    // const VkPipelineShaderStageCreateInfo* pStages // SMB
    IndentSpaces(out, indent);
    *out += "pStages:                        ";
    *out += "const VkPipelineShaderStageCreateInfo* = "; // TEQ
    if (pstruct->pStages == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pStages->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(out, indent+1, 1, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t groupCount // SMB
    IndentSpaces(out, indent);
    *out += "groupCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->groupCount);
    *out += "\n"; // GDS

    // const VkRayTracingShaderGroupCreateInfoNV* pGroups // SMB
    IndentSpaces(out, indent);
    *out += "pGroups:                        ";
    *out += "const VkRayTracingShaderGroupCreateInfoNV* = "; // TEQ
    if (pstruct->pGroups == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pGroups->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(out, indent+1, 1, "VkRayTracingShaderGroupCreateInfoNV", pstruct_in.pGroups->GetMetaStructPointer(), "pGroups", pstruct->groupCount, false, pstruct_in.pGroups->GetAddress());  // CCP
    }
    *out += "\n"; // GDS

    // uint32_t maxRecursionDepth // SMB
    IndentSpaces(out, indent);
    *out += "maxRecursionDepth:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxRecursionDepth);
    *out += "\n"; // GDS

    // VkPipelineLayout layout // SMB
    IndentSpaces(out, indent);
    *out += "layout:                         ";
    *out += "VkPipelineLayout = "; // TEQ
    AddrToString(out, pstruct_in.layout); // PAQ
    *out += "\n"; // GDS

    // VkPipeline basePipelineHandle // SMB
    IndentSpaces(out, indent);
    *out += "basePipelineHandle:             ";
    *out += "VkPipeline = "; // TEQ
    AddrToString(out, pstruct_in.basePipelineHandle); // PAQ
    *out += "\n"; // GDS

    // int32_t basePipelineIndex // SMB
    IndentSpaces(out, indent);
    *out += "basePipelineIndex:              ";
    *out += "int32_t = "; // TEQ
    SignedDecimalToString(out, pstruct->basePipelineIndex);
}

template <>
void StructureToString<Decoded_VkGeometryTrianglesNV>(std::string* out, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryTrianglesNV *pstruct = (const VkGeometryTrianglesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBuffer vertexData // SMB
    IndentSpaces(out, indent);
    *out += "vertexData:                     ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.vertexData); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize vertexOffset // SMB
    IndentSpaces(out, indent);
    *out += "vertexOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexOffset);
    *out += "\n"; // GDS

    // uint32_t vertexCount // SMB
    IndentSpaces(out, indent);
    *out += "vertexCount:                    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->vertexCount);
    *out += "\n"; // GDS

    // VkDeviceSize vertexStride // SMB
    IndentSpaces(out, indent);
    *out += "vertexStride:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->vertexStride);
    *out += "\n"; // GDS

    // VkFormat vertexFormat // SMB
    IndentSpaces(out, indent);
    *out += "vertexFormat:                   ";
    *out += "VkFormat = "; // TEQ
    EnumToStringVkFormat(out, pstruct->vertexFormat);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->vertexFormat);
    *out += ")";
    *out += "\n"; // GDS

    // VkBuffer indexData // SMB
    IndentSpaces(out, indent);
    *out += "indexData:                      ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.indexData); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize indexOffset // SMB
    IndentSpaces(out, indent);
    *out += "indexOffset:                    ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->indexOffset);
    *out += "\n"; // GDS

    // uint32_t indexCount // SMB
    IndentSpaces(out, indent);
    *out += "indexCount:                     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->indexCount);
    *out += "\n"; // GDS

    // VkIndexType indexType // SMB
    IndentSpaces(out, indent);
    *out += "indexType:                      ";
    *out += "VkIndexType = "; // TEQ
    EnumToStringVkIndexType(out, pstruct->indexType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->indexType);
    *out += ")";
    *out += "\n"; // GDS

    // VkBuffer transformData // SMB
    IndentSpaces(out, indent);
    *out += "transformData:                  ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.transformData); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize transformOffset // SMB
    IndentSpaces(out, indent);
    *out += "transformOffset:                ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->transformOffset);
}

template <>
void StructureToString<Decoded_VkGeometryAABBNV>(std::string* out, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryAABBNV *pstruct = (const VkGeometryAABBNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBuffer aabbData // SMB
    IndentSpaces(out, indent);
    *out += "aabbData:                       ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.aabbData); // PAQ
    *out += "\n"; // GDS

    // uint32_t numAABBs // SMB
    IndentSpaces(out, indent);
    *out += "numAABBs:                       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->numAABBs);
    *out += "\n"; // GDS

    // uint32_t stride // SMB
    IndentSpaces(out, indent);
    *out += "stride:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->stride);
    *out += "\n"; // GDS

    // VkDeviceSize offset // SMB
    IndentSpaces(out, indent);
    *out += "offset:                         ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->offset);
}

template <>
void StructureToString<Decoded_VkGeometryDataNV>(std::string* out, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryDataNV *pstruct = (const VkGeometryDataNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkGeometryTrianglesNV triangles // SMB
    IndentSpaces(out, indent);
    *out += "triangles:                      ";
    *out += "VkGeometryTrianglesNV = "; // TEQ
    StructureToString<Decoded_VkGeometryTrianglesNV>(out, *pstruct_in.triangles, indent+1,  base_addr + offsetof(VkGeometryDataNV, triangles)); // AZJ
    *out += "\n"; // GDS

    // VkGeometryAABBNV aabbs // SMB
    IndentSpaces(out, indent);
    *out += "aabbs:                          ";
    *out += "VkGeometryAABBNV = "; // TEQ
    StructureToString<Decoded_VkGeometryAABBNV>(out, *pstruct_in.aabbs, indent+1,  base_addr + offsetof(VkGeometryDataNV, aabbs)); // AZJ
}

template <>
void StructureToString<Decoded_VkGeometryNV>(std::string* out, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkGeometryNV *pstruct = (const VkGeometryNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkGeometryTypeNV geometryType // SMB
    IndentSpaces(out, indent);
    *out += "geometryType:                   ";
    *out += "VkGeometryTypeNV = "; // TEQ
    EnumToStringVkGeometryTypeNV(out, pstruct->geometryType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->geometryType);
    *out += ")";
    *out += "\n"; // GDS

    // VkGeometryDataNV geometry // SMB
    IndentSpaces(out, indent);
    *out += "geometry:                       ";
    *out += "VkGeometryDataNV = "; // TEQ
    StructureToString<Decoded_VkGeometryDataNV>(out, *pstruct_in.geometry, indent+1,  base_addr + offsetof(VkGeometryNV, geometry)); // AZJ
    *out += "\n"; // GDS

    // VkGeometryFlagsNV flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkGeometryFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkGeometryFlagBitsNV); // URW
}

template <>
void StructureToString<Decoded_VkAccelerationStructureInfoNV>(std::string* out, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAccelerationStructureInfoNV *pstruct = (const VkAccelerationStructureInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAccelerationStructureTypeNV type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkAccelerationStructureTypeNV = "; // TEQ
    EnumToStringVkAccelerationStructureTypeNV(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkBuildAccelerationStructureFlagsNV flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkBuildAccelerationStructureFlagsNV = "; // TEQ
    FlagsToString(out, pstruct->flags, EnumToStringVkBuildAccelerationStructureFlagBitsNV); // URW
    *out += "\n"; // GDS

    // uint32_t instanceCount // SMB
    IndentSpaces(out, indent);
    *out += "instanceCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->instanceCount);
    *out += "\n"; // GDS

    // uint32_t geometryCount // SMB
    IndentSpaces(out, indent);
    *out += "geometryCount:                  ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->geometryCount);
    *out += "\n"; // GDS

    // const VkGeometryNV* pGeometries // SMB
    IndentSpaces(out, indent);
    *out += "pGeometries:                    ";
    *out += "const VkGeometryNV* = "; // TEQ
    if (pstruct->pGeometries == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pGeometries->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkGeometryNV>(out, indent+1, 1, "VkGeometryNV", pstruct_in.pGeometries->GetMetaStructPointer(), "pGeometries", pstruct->geometryCount, false, pstruct_in.pGeometries->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkAccelerationStructureCreateInfoNV>(std::string* out, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAccelerationStructureCreateInfoNV *pstruct = (const VkAccelerationStructureCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceSize compactedSize // SMB
    IndentSpaces(out, indent);
    *out += "compactedSize:                  ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->compactedSize);
    *out += "\n"; // GDS

    // VkAccelerationStructureInfoNV info // SMB
    IndentSpaces(out, indent);
    *out += "info:                           ";
    *out += "VkAccelerationStructureInfoNV = "; // TEQ
    StructureToString<Decoded_VkAccelerationStructureInfoNV>(out, *pstruct_in.info, indent+1,  base_addr + offsetof(VkAccelerationStructureCreateInfoNV, info)); // AZJ
}

template <>
void StructureToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(std::string* out, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBindAccelerationStructureMemoryInfoNV *pstruct = (const VkBindAccelerationStructureMemoryInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAccelerationStructureNV accelerationStructure // SMB
    IndentSpaces(out, indent);
    *out += "accelerationStructure:          ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, pstruct_in.accelerationStructure); // PAQ
    *out += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    IndentSpaces(out, indent);
    *out += "memory:                         ";
    *out += "VkDeviceMemory = "; // TEQ
    AddrToString(out, pstruct_in.memory); // PAQ
    *out += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    IndentSpaces(out, indent);
    *out += "memoryOffset:                   ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->memoryOffset);
    *out += "\n"; // GDS

    // uint32_t deviceIndexCount // SMB
    IndentSpaces(out, indent);
    *out += "deviceIndexCount:               ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceIndexCount);
    *out += "\n"; // GDS

    // const uint32_t* pDeviceIndices // SMB
    IndentSpaces(out, indent);
    *out += "pDeviceIndices:                 ";
    *out += "const uint32_t* = "; // TEQ
    if (pstruct->pDeviceIndices == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        ArrayToString<const uint32_t*>(out, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pstruct_in.pDeviceIndices.GetPointer()), "pDeviceIndices", pstruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkWriteDescriptorSetAccelerationStructureNV>(std::string* out, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkWriteDescriptorSetAccelerationStructureNV *pstruct = (const VkWriteDescriptorSetAccelerationStructureNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t accelerationStructureCount // SMB
    IndentSpaces(out, indent);
    *out += "accelerationStructureCount:     ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->accelerationStructureCount);
    *out += "\n"; // GDS

    // const VkAccelerationStructureNV* pAccelerationStructures // SMB
    IndentSpaces(out, indent);
    *out += "pAccelerationStructures:        ";
    *out += "const VkAccelerationStructureNV* = "; // TEQ
    if (pstruct->pAccelerationStructures == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pAccelerationStructures.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pAccelerationStructures = {true, false, false, nullptr};
        ArrayToString<const VkAccelerationStructureNV*>(out, indent, 1, "const VkAccelerationStructureNV*", reinterpret_cast<const VkAccelerationStructureNV*>(pstruct_in.pAccelerationStructures.GetPointer()), "pAccelerationStructures", pstruct->accelerationStructureCount,  vinfo_pAccelerationStructures);  // CCQ
    }
}

template <>
void StructureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(std::string* out, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkAccelerationStructureMemoryRequirementsInfoNV *pstruct = (const VkAccelerationStructureMemoryRequirementsInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkAccelerationStructureMemoryRequirementsTypeNV type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkAccelerationStructureMemoryRequirementsTypeNV = "; // TEQ
    EnumToStringVkAccelerationStructureMemoryRequirementsTypeNV(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkAccelerationStructureNV accelerationStructure // SMB
    IndentSpaces(out, indent);
    *out += "accelerationStructure:          ";
    *out += "VkAccelerationStructureNV = "; // TEQ
    AddrToString(out, pstruct_in.accelerationStructure); // PAQ
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceRayTracingPropertiesNV *pstruct = (const VkPhysicalDeviceRayTracingPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t shaderGroupHandleSize // SMB
    IndentSpaces(out, indent);
    *out += "shaderGroupHandleSize:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shaderGroupHandleSize);
    *out += "\n"; // GDS

    // uint32_t maxRecursionDepth // SMB
    IndentSpaces(out, indent);
    *out += "maxRecursionDepth:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxRecursionDepth);
    *out += "\n"; // GDS

    // uint32_t maxShaderGroupStride // SMB
    IndentSpaces(out, indent);
    *out += "maxShaderGroupStride:           ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxShaderGroupStride);
    *out += "\n"; // GDS

    // uint32_t shaderGroupBaseAlignment // SMB
    IndentSpaces(out, indent);
    *out += "shaderGroupBaseAlignment:       ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->shaderGroupBaseAlignment);
    *out += "\n"; // GDS

    // uint64_t maxGeometryCount // SMB
    IndentSpaces(out, indent);
    *out += "maxGeometryCount:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxGeometryCount);
    *out += "\n"; // GDS

    // uint64_t maxInstanceCount // SMB
    IndentSpaces(out, indent);
    *out += "maxInstanceCount:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxInstanceCount);
    *out += "\n"; // GDS

    // uint64_t maxTriangleCount // SMB
    IndentSpaces(out, indent);
    *out += "maxTriangleCount:               ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTriangleCount);
    *out += "\n"; // GDS

    // uint32_t maxDescriptorSetAccelerationStructures // SMB
    IndentSpaces(out, indent);
    *out += "maxDescriptorSetAccelerationStructures: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDescriptorSetAccelerationStructures);
}

void VulkanAsciiConsumer::Process_vkCreateAccelerationStructureNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAccelerationStructureCreateInfoNV>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkAccelerationStructureNV>& pAccelerationStructure)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureCreateInfoNV* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureCreateInfoNV* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureCreateInfoNV* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAccelerationStructureCreateInfoNV>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV* pAccelerationStructure // ARG
    if (pAccelerationStructure.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV* = NULL", indent_string.c_str(), "pAccelerationStructure:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV* = ", indent_string.c_str(), "pAccelerationStructure:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pAccelerationStructure.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyAccelerationStructureNV(
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV accelerationStructure // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indent_string.c_str(), "accelerationStructure:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, accelerationStructure);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetAccelerationStructureMemoryRequirementsNV(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2KHR>& pMemoryRequirements)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureMemoryRequirementsInfoNV* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureMemoryRequirementsInfoNV* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2KHR* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2KHR* = NULL", indent_string.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2KHR* = ", indent_string.c_str(), "pMemoryRequirements:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryRequirements2KHR>(&tmp_string, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkBindAccelerationStructureMemoryNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindAccelerationStructureMemoryInfoNV>& pBindInfos)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindAccelerationStructureMemoryInfoNV* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindAccelerationStructureMemoryInfoNV* = NULL", indent_string.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindAccelerationStructureMemoryInfoNV* = ", indent_string.c_str(), "pBindInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(&tmp_string, 2, 1, "VkBindAccelerationStructureMemoryInfoNV",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBuildAccelerationStructureNV(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkAccelerationStructureInfoNV>& pInfo,
    format::HandleId                            instanceData,
    VkDeviceSize                                instanceOffset,
    VkBool32                                    update,
    format::HandleId                            dst,
    format::HandleId                            src,
    format::HandleId                            scratch,
    VkDeviceSize                                scratchOffset)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureInfoNV* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureInfoNV* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureInfoNV* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAccelerationStructureInfoNV>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer instanceData // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "instanceData:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instanceData);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize instanceOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "instanceOffset:", instanceOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32 update // ARG
    fprintf(GetFile(), "%s%-32sVkBool32 = %u", indent_string.c_str(), "update:", update); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV dst // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indent_string.c_str(), "dst:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dst);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV src // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indent_string.c_str(), "src:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, src);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer scratch // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "scratch:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, scratch);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize scratchOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "scratchOffset:", scratchOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyAccelerationStructureNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            dst,
    format::HandleId                            src,
    VkCopyAccelerationStructureModeNV           mode)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV dst // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indent_string.c_str(), "dst:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dst);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV src // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indent_string.c_str(), "src:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, src);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCopyAccelerationStructureModeNV mode // ARG
    tmp_string = "";
    EnumToStringVkCopyAccelerationStructureModeNV(&tmp_string,mode); // EPW
    fprintf(GetFile(), "%s%-32sVkCopyAccelerationStructureModeNV = %s", indent_string.c_str(), "mode:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdTraceRaysNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    format::HandleId                            missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    format::HandleId                            hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    format::HandleId                            callableShaderBindingTableBuffer,
    VkDeviceSize                                callableShaderBindingOffset,
    VkDeviceSize                                callableShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer raygenShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "raygenShaderBindingTableBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, raygenShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize raygenShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "raygenShaderBindingOffset:", raygenShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer missShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "missShaderBindingTableBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, missShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize missShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "missShaderBindingOffset:", missShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize missShaderBindingStride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "missShaderBindingStride:", missShaderBindingStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer hitShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "hitShaderBindingTableBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, hitShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize hitShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "hitShaderBindingOffset:", hitShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize hitShaderBindingStride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "hitShaderBindingStride:", hitShaderBindingStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer callableShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "callableShaderBindingTableBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, callableShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize callableShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "callableShaderBindingOffset:", callableShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize callableShaderBindingStride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "callableShaderBindingStride:", callableShaderBindingStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t width // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "width:", width); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t height // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "height:", height); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t depth // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "depth:", depth); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateRayTracingPipelinesNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkRayTracingPipelineCreateInfoNV>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indent_string.c_str(), "pipelineCache:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipelineCache);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t createInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "createInfoCount:", createInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRayTracingPipelineCreateInfoNV* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRayTracingPipelineCreateInfoNV* = NULL", indent_string.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRayTracingPipelineCreateInfoNV* = ", indent_string.c_str(), "pCreateInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkRayTracingPipelineCreateInfoNV>(&tmp_string, 2, 1, "VkRayTracingPipelineCreateInfoNV",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline* pPipelines // ARG
    if (pPipelines.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = NULL", indent_string.c_str(), "pPipelines:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = ", indent_string.c_str(), "pPipelines:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pPipelines.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        ArrayToString<VkPipeline*>(&tmp_string, 1, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount, vinfo_pPipelines); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRayTracingShaderGroupHandlesNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indent_string.c_str(), "pipeline:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipeline);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstGroup // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstGroup:", firstGroup); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "groupCount:", groupCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // size_t dataSize // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indent_string.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indent_string.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indent_string.c_str(), "pData:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetAccelerationStructureHandleNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV accelerationStructure // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indent_string.c_str(), "accelerationStructure:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, accelerationStructure);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // size_t dataSize // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indent_string.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indent_string.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indent_string.c_str(), "pData:");  // SSA
        tmp_string = "";
        AddrToString(&tmp_string, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmp_string.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWriteAccelerationStructuresPropertiesNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    accelerationStructureCount,
    const HandlePointerDecoder<VkAccelerationStructureNV>& pAccelerationStructures,
    VkQueryType                                 queryType,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t accelerationStructureCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "accelerationStructureCount:", accelerationStructureCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureNV* pAccelerationStructures // ARG
    if (pAccelerationStructures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureNV* = NULL", indent_string.c_str(), "pAccelerationStructures:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureNV* = ", indent_string.c_str(), "pAccelerationStructures:");  // SXB
        tmp_string = "";
        AddrToString(&tmp_string, pAccelerationStructures.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // YEF
        tmp_string = "";
        ValueToStringStruct vinfo_pAccelerationStructures = {true, false, false, nullptr};
        ArrayToString<const VkAccelerationStructureNV*>(&tmp_string, 1, 1, "const VkAccelerationStructureNV*", reinterpret_cast<const VkAccelerationStructureNV*>(pAccelerationStructures.GetPointer()), "pAccelerationStructures", accelerationStructureCount, vinfo_pAccelerationStructures); // SFX
        fprintf(GetFile(), "%s", tmp_string.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryType queryType // ARG
    tmp_string = "";
    EnumToStringVkQueryType(&tmp_string,queryType); // EPW
    fprintf(GetFile(), "%s%-32sVkQueryType = %s", indent_string.c_str(), "queryType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCompileDeferredNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    shader)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCompileDeferredNV(device, pipeline, shader)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indent_string.c_str(), "pipeline:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, pipeline);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t shader // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "shader:", shader); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkQueueGlobalPriorityEXT(std::string* out, uint32_t enum_uint32)
{
    VkQueueGlobalPriorityEXT e = static_cast<VkQueueGlobalPriorityEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT:
            *out += std::string("VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT");
            return;
        case VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT:
            *out += std::string("VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT");
            return;
        case VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT:
            *out += std::string("VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT");
            return;
        case VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT:
            *out += std::string("VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkImportMemoryHostPointerInfoEXT>(std::string* out, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(std::string* out, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImportMemoryHostPointerInfoEXT>(std::string* out, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImportMemoryHostPointerInfoEXT *pstruct = (const VkImportMemoryHostPointerInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    IndentSpaces(out, indent);
    *out += "handleType:                     ";
    *out += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    EnumToStringVkExternalMemoryHandleTypeFlagBits(out, pstruct->handleType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->handleType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pHostPointer // SMB
    IndentSpaces(out, indent);
    *out += "pHostPointer:                   ";
    *out += "void* = "; // TEQ
    if (pstruct->pHostPointer == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pHostPointer); // PWR
    }
}

template <>
void StructureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(std::string* out, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMemoryHostPointerPropertiesEXT *pstruct = (const VkMemoryHostPointerPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    IndentSpaces(out, indent);
    *out += "memoryTypeBits:                 ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->memoryTypeBits);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *pstruct = (const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceSize minImportedHostPointerAlignment // SMB
    IndentSpaces(out, indent);
    *out += "minImportedHostPointerAlignment: ";
    *out += "VkDeviceSize = "; // TEQ
    SignedDecimalToString(out, pstruct->minImportedHostPointerAlignment);
}

void VulkanAsciiConsumer::Process_vkGetMemoryHostPointerPropertiesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    pHostPointer,
    const StructPointerDecoder<Decoded_VkMemoryHostPointerPropertiesEXT>& pMemoryHostPointerProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagBits handleType // ARG
    tmp_string = "";
    EnumToStringVkExternalMemoryHandleTypeFlagBits(&tmp_string,handleType); // EPW
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagBits = %s", indent_string.c_str(), "handleType:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // const void* pHostPointer // ARG
    fprintf(GetFile(), "%s%-32sconst void* = 0x%" PRIx64 "", indent_string.c_str(), "pHostPointer:", pHostPointer); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties // ARG
    if (pMemoryHostPointerProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryHostPointerPropertiesEXT* = NULL", indent_string.c_str(), "pMemoryHostPointerProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryHostPointerPropertiesEXT* = ", indent_string.c_str(), "pMemoryHostPointerProperties:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMemoryHostPointerProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(&tmp_string, *pMemoryHostPointerProperties.GetMetaStructPointer(), 2, pMemoryHostPointerProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdWriteBufferMarkerAMD(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlagBits pipelineStage // ARG
    tmp_string = "";
    EnumToStringVkPipelineStageFlagBits(&tmp_string,pipelineStage); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlagBits = %s", indent_string.c_str(), "pipelineStage:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "dstBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, dstBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t marker // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "marker:", marker); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkPipelineCompilerControlFlagBitsAMD(std::string* out, uint32_t enum_uint32)
{
    VkPipelineCompilerControlFlagBitsAMD e = static_cast<VkPipelineCompilerControlFlagBitsAMD>(enum_uint32);
    assert(out != nullptr);
    *out += std::string("UNKNOWN");
};


void EnumToStringVkTimeDomainEXT(std::string* out, uint32_t enum_uint32)
{
    VkTimeDomainEXT e = static_cast<VkTimeDomainEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT:
            *out += std::string("VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT");
            return;
        case VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT:
            *out += std::string("VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT");
            return;
        case VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT:
            *out += std::string("VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT");
            return;
        case VK_TIME_DOMAIN_DEVICE_EXT:
            *out += std::string("VK_TIME_DOMAIN_DEVICE_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkCalibratedTimestampInfoEXT>(std::string* out, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkCalibratedTimestampInfoEXT>(std::string* out, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCalibratedTimestampInfoEXT *pstruct = (const VkCalibratedTimestampInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkTimeDomainEXT timeDomain // SMB
    IndentSpaces(out, indent);
    *out += "timeDomain:                     ";
    *out += "VkTimeDomainEXT = "; // TEQ
    EnumToStringVkTimeDomainEXT(out, pstruct->timeDomain);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->timeDomain);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pTimeDomainCount,
    const PointerDecoder<VkTimeDomainEXT>&      pTimeDomains)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pTimeDomainCount // ARG
    if (pTimeDomainCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pTimeDomainCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pTimeDomainCount:", static_cast<uint64_t>(*pTimeDomainCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkTimeDomainEXT* pTimeDomains // ARG
    if (pTimeDomains.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkTimeDomainEXT* = NULL", indent_string.c_str(), "pTimeDomains:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkTimeDomainEXT* = %" PRId64 "", indent_string.c_str(), "pTimeDomains:", static_cast<uint64_t>(*pTimeDomains.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetCalibratedTimestampsEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    timestampCount,
    const StructPointerDecoder<Decoded_VkCalibratedTimestampInfoEXT>& pTimestampInfos,
    const PointerDecoder<uint64_t>&             pTimestamps,
    const PointerDecoder<uint64_t>&             pMaxDeviation)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t timestampCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "timestampCount:", timestampCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCalibratedTimestampInfoEXT* pTimestampInfos // ARG
    if (pTimestampInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCalibratedTimestampInfoEXT* = NULL", indent_string.c_str(), "pTimestampInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCalibratedTimestampInfoEXT* = ", indent_string.c_str(), "pTimestampInfos:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pTimestampInfos.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkCalibratedTimestampInfoEXT>(&tmp_string, 2, 1, "VkCalibratedTimestampInfoEXT",
            pTimestampInfos.GetMetaStructPointer(), "pTimestampInfos", timestampCount, false, pTimestampInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pTimestamps // ARG
    if (pTimestamps.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indent_string.c_str(), "pTimestamps:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indent_string.c_str(), "pTimestamps:", static_cast<uint64_t>(*pTimestamps.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pMaxDeviation // ARG
    if (pMaxDeviation.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indent_string.c_str(), "pMaxDeviation:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indent_string.c_str(), "pMaxDeviation:", static_cast<uint64_t>(*pMaxDeviation.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkPipelineCreationFeedbackFlagBitsEXT(std::string* out, uint32_t enum_uint32)
{
    VkPipelineCreationFeedbackFlagBitsEXT e = static_cast<VkPipelineCreationFeedbackFlagBitsEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT:
            *out += std::string("VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT");
            return;
        case VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT:
            *out += std::string("VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT");
            return;
        case VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT:
            *out += std::string("VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkMemoryOverallocationBehaviorAMD(std::string* out, uint32_t enum_uint32)
{
    VkMemoryOverallocationBehaviorAMD e = static_cast<VkMemoryOverallocationBehaviorAMD>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD:
            *out += std::string("VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD");
            return;
        case VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD:
            *out += std::string("VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD");
            return;
        case VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD:
            *out += std::string("VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkDrawMeshTasksIndirectCommandNV>(std::string* out, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMeshShaderFeaturesNV *pstruct = (const VkPhysicalDeviceMeshShaderFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 taskShader // SMB
    IndentSpaces(out, indent);
    *out += "taskShader:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->taskShader);
    *out += "\n"; // GDS

    // VkBool32 meshShader // SMB
    IndentSpaces(out, indent);
    *out += "meshShader:                     ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->meshShader);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceMeshShaderPropertiesNV *pstruct = (const VkPhysicalDeviceMeshShaderPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t maxDrawMeshTasksCount // SMB
    IndentSpaces(out, indent);
    *out += "maxDrawMeshTasksCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxDrawMeshTasksCount);
    *out += "\n"; // GDS

    // uint32_t maxTaskWorkGroupInvocations // SMB
    IndentSpaces(out, indent);
    *out += "maxTaskWorkGroupInvocations:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTaskWorkGroupInvocations);
    *out += "\n"; // GDS

    // uint32_t maxTaskWorkGroupSize // SMB
    IndentSpaces(out, indent);
    *out += "maxTaskWorkGroupSize:           ";
    *out += "uint32_t[";
    *out += "3";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_maxTaskWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxTaskWorkGroupSize), "maxTaskWorkGroupSize", 3, vinfo_maxTaskWorkGroupSize); // JPA
    *out += "\n"; // GDS

    // uint32_t maxTaskTotalMemorySize // SMB
    IndentSpaces(out, indent);
    *out += "maxTaskTotalMemorySize:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTaskTotalMemorySize);
    *out += "\n"; // GDS

    // uint32_t maxTaskOutputCount // SMB
    IndentSpaces(out, indent);
    *out += "maxTaskOutputCount:             ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxTaskOutputCount);
    *out += "\n"; // GDS

    // uint32_t maxMeshWorkGroupInvocations // SMB
    IndentSpaces(out, indent);
    *out += "maxMeshWorkGroupInvocations:    ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshWorkGroupInvocations);
    *out += "\n"; // GDS

    // uint32_t maxMeshWorkGroupSize // SMB
    IndentSpaces(out, indent);
    *out += "maxMeshWorkGroupSize:           ";
    *out += "uint32_t[";
    *out += "3";
    *out += "] = ";
    AddrToString(out, base_addr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_maxMeshWorkGroupSize = {false, false, false, nullptr};
    ArrayToString<uint32_t*>(out, indent, 0, "uint32_t", const_cast<uint32_t*>(pstruct->maxMeshWorkGroupSize), "maxMeshWorkGroupSize", 3, vinfo_maxMeshWorkGroupSize); // JPA
    *out += "\n"; // GDS

    // uint32_t maxMeshTotalMemorySize // SMB
    IndentSpaces(out, indent);
    *out += "maxMeshTotalMemorySize:         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshTotalMemorySize);
    *out += "\n"; // GDS

    // uint32_t maxMeshOutputVertices // SMB
    IndentSpaces(out, indent);
    *out += "maxMeshOutputVertices:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshOutputVertices);
    *out += "\n"; // GDS

    // uint32_t maxMeshOutputPrimitives // SMB
    IndentSpaces(out, indent);
    *out += "maxMeshOutputPrimitives:        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshOutputPrimitives);
    *out += "\n"; // GDS

    // uint32_t maxMeshMultiviewViewCount // SMB
    IndentSpaces(out, indent);
    *out += "maxMeshMultiviewViewCount:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->maxMeshMultiviewViewCount);
    *out += "\n"; // GDS

    // uint32_t meshOutputPerVertexGranularity // SMB
    IndentSpaces(out, indent);
    *out += "meshOutputPerVertexGranularity: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->meshOutputPerVertexGranularity);
    *out += "\n"; // GDS

    // uint32_t meshOutputPerPrimitiveGranularity // SMB
    IndentSpaces(out, indent);
    *out += "meshOutputPerPrimitiveGranularity: ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->meshOutputPerPrimitiveGranularity);
}

template <>
void StructureToString<Decoded_VkDrawMeshTasksIndirectCommandNV>(std::string* out, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDrawMeshTasksIndirectCommandNV *pstruct = (const VkDrawMeshTasksIndirectCommandNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t taskCount // SMB
    IndentSpaces(out, indent);
    *out += "taskCount:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->taskCount);
    *out += "\n"; // GDS

    // uint32_t firstTask // SMB
    IndentSpaces(out, indent);
    *out += "firstTask:                      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->firstTask);
}

void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    taskCount,
    uint32_t                                    firstTask)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t taskCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "taskCount:", taskCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstTask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstTask:", firstTask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksIndirectNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t drawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "drawCount:", drawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksIndirectCountNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "buffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, buffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indent_string.c_str(), "countBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, countBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indent_string.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV *pstruct = (const VkPipelineViewportExclusiveScissorStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t exclusiveScissorCount // SMB
    IndentSpaces(out, indent);
    *out += "exclusiveScissorCount:          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->exclusiveScissorCount);
    *out += "\n"; // GDS

    // const VkRect2D* pExclusiveScissors // SMB
    IndentSpaces(out, indent);
    *out += "pExclusiveScissors:             ";
    *out += "const VkRect2D* = "; // TEQ
    if (pstruct->pExclusiveScissors == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pExclusiveScissors->GetAddress()); // WUS
        ArrayOfStructsToString<Decoded_VkRect2D>(out, indent+1, 1, "VkRect2D", pstruct_in.pExclusiveScissors->GetMetaStructPointer(), "pExclusiveScissors", pstruct->exclusiveScissorCount, false, pstruct_in.pExclusiveScissors->GetAddress());  // CCP
    }
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceExclusiveScissorFeaturesNV *pstruct = (const VkPhysicalDeviceExclusiveScissorFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 exclusiveScissor // SMB
    IndentSpaces(out, indent);
    *out += "exclusiveScissor:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->exclusiveScissor);
}

void VulkanAsciiConsumer::Process_vkCmdSetExclusiveScissorNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pExclusiveScissors)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstExclusiveScissor // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstExclusiveScissor:", firstExclusiveScissor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t exclusiveScissorCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "exclusiveScissorCount:", exclusiveScissorCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRect2D* pExclusiveScissors // ARG
    if (pExclusiveScissors.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = NULL", indent_string.c_str(), "pExclusiveScissors:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = ", indent_string.c_str(), "pExclusiveScissors:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pExclusiveScissors.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkRect2D>(&tmp_string, 2, 1, "VkRect2D",
            pExclusiveScissors.GetMetaStructPointer(), "pExclusiveScissors", exclusiveScissorCount, false, pExclusiveScissors.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkQueueFamilyCheckpointPropertiesNV>(std::string* out, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkCheckpointDataNV>(std::string* out, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkQueueFamilyCheckpointPropertiesNV>(std::string* out, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueueFamilyCheckpointPropertiesNV *pstruct = (const VkQueueFamilyCheckpointPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineStageFlags checkpointExecutionStageMask // SMB
    IndentSpaces(out, indent);
    *out += "checkpointExecutionStageMask:   ";
    *out += "VkPipelineStageFlags = "; // TEQ
    FlagsToString(out, pstruct->checkpointExecutionStageMask, EnumToStringVkPipelineStageFlagBits); // URW
}

template <>
void StructureToString<Decoded_VkCheckpointDataNV>(std::string* out, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCheckpointDataNV *pstruct = (const VkCheckpointDataNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineStageFlagBits stage // SMB
    IndentSpaces(out, indent);
    *out += "stage:                          ";
    *out += "VkPipelineStageFlagBits = "; // TEQ
    EnumToStringVkPipelineStageFlagBits(out, pstruct->stage);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->stage);
    *out += ")";
    *out += "\n"; // GDS

    // void* pCheckpointMarker // SMB
    IndentSpaces(out, indent);
    *out += "pCheckpointMarker:              ";
    *out += "void* = "; // TEQ
    if (pstruct->pCheckpointMarker == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pCheckpointMarker); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetCheckpointNV(
    format::HandleId                            commandBuffer,
    uint64_t                                    pCheckpointMarker)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const void* pCheckpointMarker // ARG
    fprintf(GetFile(), "%s%-32sconst void* = 0x%" PRIx64 "", indent_string.c_str(), "pCheckpointMarker:", pCheckpointMarker); // YQA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetQueueCheckpointDataNV(
    format::HandleId                            queue,
    const PointerDecoder<uint32_t>&             pCheckpointDataCount,
    const StructPointerDecoder<Decoded_VkCheckpointDataNV>& pCheckpointData)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pCheckpointDataCount // ARG
    if (pCheckpointDataCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pCheckpointDataCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pCheckpointDataCount:", static_cast<uint64_t>(*pCheckpointDataCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCheckpointDataNV* pCheckpointData // ARG
    if (pCheckpointData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCheckpointDataNV* = NULL", indent_string.c_str(), "pCheckpointData:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCheckpointDataNV* = ", indent_string.c_str(), "pCheckpointData:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pCheckpointData.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkCheckpointDataNV>(&tmp_string, 2, 1, "VkCheckpointDataNV",
            pCheckpointData.GetMetaStructPointer(), "pCheckpointData", *pCheckpointDataCount.GetPointer(), false, pCheckpointData.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkQueryPoolSamplingModeINTEL(std::string* out, uint32_t enum_uint32)
{
    VkQueryPoolSamplingModeINTEL e = static_cast<VkQueryPoolSamplingModeINTEL>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL:
            *out += std::string("VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPerformanceOverrideTypeINTEL(std::string* out, uint32_t enum_uint32)
{
    VkPerformanceOverrideTypeINTEL e = static_cast<VkPerformanceOverrideTypeINTEL>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL:
            *out += std::string("VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL");
            return;
        case VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL:
            *out += std::string("VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPerformanceParameterTypeINTEL(std::string* out, uint32_t enum_uint32)
{
    VkPerformanceParameterTypeINTEL e = static_cast<VkPerformanceParameterTypeINTEL>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL:
            *out += std::string("VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL");
            return;
        case VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL:
            *out += std::string("VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPerformanceValueTypeINTEL(std::string* out, uint32_t enum_uint32)
{
    VkPerformanceValueTypeINTEL e = static_cast<VkPerformanceValueTypeINTEL>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL:
            *out += std::string("VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL:
            *out += std::string("VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL:
            *out += std::string("VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL:
            *out += std::string("VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL:
            *out += std::string("VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkPerformanceConfigurationTypeINTEL(std::string* out, uint32_t enum_uint32)
{
    VkPerformanceConfigurationTypeINTEL e = static_cast<VkPerformanceConfigurationTypeINTEL>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL:
            *out += std::string("VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPerformanceValueDataINTEL>(std::string* out, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceValueINTEL>(std::string* out, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(std::string* out, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkQueryPoolCreateInfoINTEL>(std::string* out, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceOverrideInfoINTEL>(std::string* out, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(std::string* out, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPerformanceValueDataINTEL>(std::string* out, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceValueDataINTEL *pstruct = (const VkPerformanceValueDataINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // uint32_t value32 // SMB
    IndentSpaces(out, indent);
    *out += "value32:                        ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->value32);
    *out += "\n"; // GDS

    // uint64_t value64 // SMB
    IndentSpaces(out, indent);
    *out += "value64:                        ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->value64);
    *out += "\n"; // GDS

    // float valueFloat // SMB
    IndentSpaces(out, indent);
    *out += "valueFloat:                     ";
    *out += "float = "; // TEQ
    DoubleToString(out, pstruct->valueFloat);
    *out += "\n"; // GDS

    // VkBool32 valueBool // SMB
    IndentSpaces(out, indent);
    *out += "valueBool:                      ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->valueBool);
    *out += "\n"; // GDS

    // const char* valueString // SMB
    IndentSpaces(out, indent);
    *out += "valueString:                    ";
    *out += "const char* = "; // TEQ
    StringToQuotedString(out, pstruct->valueString); // TGH
}

template <>
void StructureToString<Decoded_VkPerformanceValueINTEL>(std::string* out, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceValueINTEL *pstruct = (const VkPerformanceValueINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkPerformanceValueTypeINTEL type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkPerformanceValueTypeINTEL = "; // TEQ
    EnumToStringVkPerformanceValueTypeINTEL(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkPerformanceValueDataINTEL data // SMB
    IndentSpaces(out, indent);
    *out += "data:                           ";
    *out += "VkPerformanceValueDataINTEL = "; // TEQ
    *out += "(Union):"; // RGT
    StructureToString<Decoded_VkPerformanceValueDataINTEL>(out, *pstruct_in.data, indent+1,  base_addr + offsetof(VkPerformanceValueINTEL, data)); // AZJ
}

template <>
void StructureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(std::string* out, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkInitializePerformanceApiInfoINTEL *pstruct = (const VkInitializePerformanceApiInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // void* pUserData // SMB
    IndentSpaces(out, indent);
    *out += "pUserData:                      ";
    *out += "void* = "; // TEQ
    if (pstruct->pUserData == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pUserData); // PWR
    }
}

template <>
void StructureToString<Decoded_VkQueryPoolCreateInfoINTEL>(std::string* out, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkQueryPoolCreateInfoINTEL *pstruct = (const VkQueryPoolCreateInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkQueryPoolSamplingModeINTEL performanceCountersSampling // SMB
    IndentSpaces(out, indent);
    *out += "performanceCountersSampling:    ";
    *out += "VkQueryPoolSamplingModeINTEL = "; // TEQ
    EnumToStringVkQueryPoolSamplingModeINTEL(out, pstruct->performanceCountersSampling);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->performanceCountersSampling);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPerformanceMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceMarkerInfoINTEL *pstruct = (const VkPerformanceMarkerInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint64_t marker // SMB
    IndentSpaces(out, indent);
    *out += "marker:                         ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->marker);
}

template <>
void StructureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(std::string* out, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceStreamMarkerInfoINTEL *pstruct = (const VkPerformanceStreamMarkerInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t marker // SMB
    IndentSpaces(out, indent);
    *out += "marker:                         ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->marker);
}

template <>
void StructureToString<Decoded_VkPerformanceOverrideInfoINTEL>(std::string* out, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceOverrideInfoINTEL *pstruct = (const VkPerformanceOverrideInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPerformanceOverrideTypeINTEL type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkPerformanceOverrideTypeINTEL = "; // TEQ
    EnumToStringVkPerformanceOverrideTypeINTEL(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 enable // SMB
    IndentSpaces(out, indent);
    *out += "enable:                         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->enable);
    *out += "\n"; // GDS

    // uint64_t parameter // SMB
    IndentSpaces(out, indent);
    *out += "parameter:                      ";
    *out += "uint64_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->parameter);
}

template <>
void StructureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(std::string* out, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPerformanceConfigurationAcquireInfoINTEL *pstruct = (const VkPerformanceConfigurationAcquireInfoINTEL *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPerformanceConfigurationTypeINTEL type // SMB
    IndentSpaces(out, indent);
    *out += "type:                           ";
    *out += "VkPerformanceConfigurationTypeINTEL = "; // TEQ
    EnumToStringVkPerformanceConfigurationTypeINTEL(out, pstruct->type);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->type);
    *out += ")";
}

void VulkanAsciiConsumer::Process_vkInitializePerformanceApiINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkInitializePerformanceApiInfoINTEL>& pInitializeInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkInitializePerformanceApiINTEL(device, pInitializeInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkInitializePerformanceApiInfoINTEL* pInitializeInfo // ARG
    if (pInitializeInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkInitializePerformanceApiInfoINTEL* = NULL", indent_string.c_str(), "pInitializeInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkInitializePerformanceApiInfoINTEL* = ", indent_string.c_str(), "pInitializeInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInitializeInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(&tmp_string, *pInitializeInfo.GetMetaStructPointer(), 2, pInitializeInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkUninitializePerformanceApiINTEL(
    format::HandleId                            device)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkUninitializePerformanceApiINTEL(device)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceMarkerINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceMarkerInfoINTEL>& pMarkerInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceMarkerInfoINTEL* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceMarkerInfoINTEL* = NULL", indent_string.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceMarkerInfoINTEL* = ", indent_string.c_str(), "pMarkerInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPerformanceMarkerInfoINTEL>(&tmp_string, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceStreamMarkerINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceStreamMarkerInfoINTEL>& pMarkerInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceStreamMarkerInfoINTEL* = NULL", indent_string.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceStreamMarkerInfoINTEL* = ", indent_string.c_str(), "pMarkerInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(&tmp_string, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceOverrideINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceOverrideInfoINTEL>& pOverrideInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceOverrideInfoINTEL* pOverrideInfo // ARG
    if (pOverrideInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceOverrideInfoINTEL* = NULL", indent_string.c_str(), "pOverrideInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceOverrideInfoINTEL* = ", indent_string.c_str(), "pOverrideInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pOverrideInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPerformanceOverrideInfoINTEL>(&tmp_string, *pOverrideInfo.GetMetaStructPointer(), 2, pOverrideInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquirePerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>& pAcquireInfo,
    const HandlePointerDecoder<VkPerformanceConfigurationINTEL>& pConfiguration)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo // ARG
    if (pAcquireInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceConfigurationAcquireInfoINTEL* = NULL", indent_string.c_str(), "pAcquireInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceConfigurationAcquireInfoINTEL* = ", indent_string.c_str(), "pAcquireInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAcquireInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(&tmp_string, *pAcquireInfo.GetMetaStructPointer(), 2, pAcquireInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceConfigurationINTEL* pConfiguration // ARG
    if (pConfiguration.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL* = NULL", indent_string.c_str(), "pConfiguration:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL* = ", indent_string.c_str(), "pConfiguration:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pConfiguration.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkReleasePerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            configuration)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkReleasePerformanceConfigurationINTEL(device, configuration)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceConfigurationINTEL configuration // ARG
    fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL = ", indent_string.c_str(), "configuration:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, configuration);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueSetPerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    format::HandleId                            configuration)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkQueueSetPerformanceConfigurationINTEL(queue, configuration)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indent_string.c_str(), "queue:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queue);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceConfigurationINTEL configuration // ARG
    fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL = ", indent_string.c_str(), "configuration:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, configuration);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPerformanceParameterINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkPerformanceParameterTypeINTEL             parameter,
    const StructPointerDecoder<Decoded_VkPerformanceValueINTEL>& pValue)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPerformanceParameterINTEL(device, parameter, pValue)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceParameterTypeINTEL parameter // ARG
    tmp_string = "";
    EnumToStringVkPerformanceParameterTypeINTEL(&tmp_string,parameter); // EPW
    fprintf(GetFile(), "%s%-32sVkPerformanceParameterTypeINTEL = %s", indent_string.c_str(), "parameter:", tmp_string.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceValueINTEL* pValue // ARG
    if (pValue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceValueINTEL* = NULL", indent_string.c_str(), "pValue:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceValueINTEL* = ", indent_string.c_str(), "pValue:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pValue.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPerformanceValueINTEL>(&tmp_string, *pValue.GetMetaStructPointer(), 2, pValue.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>(std::string* out, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>(std::string* out, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>(std::string* out, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD *pstruct = (const VkDisplayNativeHdrSurfaceCapabilitiesAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 localDimmingSupport // SMB
    IndentSpaces(out, indent);
    *out += "localDimmingSupport:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->localDimmingSupport);
}

template <>
void StructureToString<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>(std::string* out, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSwapchainDisplayNativeHdrCreateInfoAMD *pstruct = (const VkSwapchainDisplayNativeHdrCreateInfoAMD *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 localDimmingEnable // SMB
    IndentSpaces(out, indent);
    *out += "localDimmingEnable:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->localDimmingEnable);
}

void VulkanAsciiConsumer::Process_vkSetLocalDimmingAMD(
    format::HandleId                            device,
    format::HandleId                            swapChain,
    VkBool32                                    localDimmingEnable)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapChain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapChain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapChain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32 localDimmingEnable // ARG
    fprintf(GetFile(), "%s%-32sVkBool32 = %u", indent_string.c_str(), "localDimmingEnable:", localDimmingEnable); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(std::string* out, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(std::string* out, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkImagePipeSurfaceCreateInfoFUCHSIA *pstruct = (const VkImagePipeSurfaceCreateInfoFUCHSIA *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkImagePipeSurfaceCreateFlagsFUCHSIA flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkImagePipeSurfaceCreateFlagsFUCHSIA = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // uint32_t imagePipeHandle // SMB
    IndentSpaces(out, indent);
    *out += "imagePipeHandle:                ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->imagePipeHandle);
}

void VulkanAsciiConsumer::Process_vkCreateImagePipeSurfaceFUCHSIA(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImagePipeSurfaceCreateInfoFUCHSIA* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImagePipeSurfaceCreateInfoFUCHSIA* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkMetalSurfaceCreateInfoEXT *pstruct = (const VkMetalSurfaceCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkMetalSurfaceCreateFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkMetalSurfaceCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // const void* pLayer // SMB
    IndentSpaces(out, indent);
    *out += "pLayer:                         ";
    *out += "const void* = "; // TEQ
    if (pstruct->pLayer == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pLayer); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateMetalSurfaceEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkMetalSurfaceCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMetalSurfaceCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMetalSurfaceCreateInfoEXT* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMetalSurfaceCreateInfoEXT* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkShaderCorePropertiesFlagBitsAMD(std::string* out, uint32_t enum_uint32)
{
    VkShaderCorePropertiesFlagBitsAMD e = static_cast<VkShaderCorePropertiesFlagBitsAMD>(enum_uint32);
    assert(out != nullptr);
    *out += std::string("UNKNOWN");
};

template <> void StructureToString<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferDeviceAddressInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkBufferDeviceAddressCreateInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *pstruct = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 bufferDeviceAddress // SMB
    IndentSpaces(out, indent);
    *out += "bufferDeviceAddress:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferDeviceAddress);
    *out += "\n"; // GDS

    // VkBool32 bufferDeviceAddressCaptureReplay // SMB
    IndentSpaces(out, indent);
    *out += "bufferDeviceAddressCaptureReplay: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferDeviceAddressCaptureReplay);
    *out += "\n"; // GDS

    // VkBool32 bufferDeviceAddressMultiDevice // SMB
    IndentSpaces(out, indent);
    *out += "bufferDeviceAddressMultiDevice: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bufferDeviceAddressMultiDevice);
}

template <>
void StructureToString<Decoded_VkBufferDeviceAddressInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferDeviceAddressInfoEXT *pstruct = (const VkBufferDeviceAddressInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBuffer buffer // SMB
    IndentSpaces(out, indent);
    *out += "buffer:                         ";
    *out += "VkBuffer = "; // TEQ
    AddrToString(out, pstruct_in.buffer); // PAQ
}

template <>
void StructureToString<Decoded_VkBufferDeviceAddressCreateInfoEXT>(std::string* out, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkBufferDeviceAddressCreateInfoEXT *pstruct = (const VkBufferDeviceAddressCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkDeviceAddress deviceAddress // SMB
    IndentSpaces(out, indent);
    *out += "deviceAddress:                  ";
    *out += "VkDeviceAddress = "; // TEQ
    UnsignedDecimalToString(out, pstruct->deviceAddress);
}

void VulkanAsciiConsumer::Process_vkGetBufferDeviceAddressEXT(
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferDeviceAddressInfoEXT>& pInfo)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetBufferDeviceAddressEXT(device, pInfo)");
    fprintf(GetFile(), " returns 0x%" PRIx64 ":\n", returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferDeviceAddressInfoEXT* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferDeviceAddressInfoEXT* = NULL", indent_string.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferDeviceAddressInfoEXT* = ", indent_string.c_str(), "pInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkBufferDeviceAddressInfoEXT>(&tmp_string, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkValidationFeatureDisableEXT(std::string* out, uint32_t enum_uint32)
{
    VkValidationFeatureDisableEXT e = static_cast<VkValidationFeatureDisableEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_ALL_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_DISABLE_ALL_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkScopeNV(std::string* out, uint32_t enum_uint32)
{
    VkScopeNV e = static_cast<VkScopeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_SCOPE_SUBGROUP_NV:
            *out += std::string("VK_SCOPE_SUBGROUP_NV");
            return;
        case VK_SCOPE_WORKGROUP_NV:
            *out += std::string("VK_SCOPE_WORKGROUP_NV");
            return;
        case VK_SCOPE_DEVICE_NV:
            *out += std::string("VK_SCOPE_DEVICE_NV");
            return;
        case VK_SCOPE_QUEUE_FAMILY_NV:
            *out += std::string("VK_SCOPE_QUEUE_FAMILY_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkComponentTypeNV(std::string* out, uint32_t enum_uint32)
{
    VkComponentTypeNV e = static_cast<VkComponentTypeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COMPONENT_TYPE_SINT16_NV:
            *out += std::string("VK_COMPONENT_TYPE_SINT16_NV");
            return;
        case VK_COMPONENT_TYPE_FLOAT32_NV:
            *out += std::string("VK_COMPONENT_TYPE_FLOAT32_NV");
            return;
        case VK_COMPONENT_TYPE_SINT32_NV:
            *out += std::string("VK_COMPONENT_TYPE_SINT32_NV");
            return;
        case VK_COMPONENT_TYPE_UINT8_NV:
            *out += std::string("VK_COMPONENT_TYPE_UINT8_NV");
            return;
        case VK_COMPONENT_TYPE_UINT16_NV:
            *out += std::string("VK_COMPONENT_TYPE_UINT16_NV");
            return;
        case VK_COMPONENT_TYPE_UINT32_NV:
            *out += std::string("VK_COMPONENT_TYPE_UINT32_NV");
            return;
        case VK_COMPONENT_TYPE_UINT64_NV:
            *out += std::string("VK_COMPONENT_TYPE_UINT64_NV");
            return;
        case VK_COMPONENT_TYPE_SINT8_NV:
            *out += std::string("VK_COMPONENT_TYPE_SINT8_NV");
            return;
        case VK_COMPONENT_TYPE_FLOAT64_NV:
            *out += std::string("VK_COMPONENT_TYPE_FLOAT64_NV");
            return;
        case VK_COMPONENT_TYPE_FLOAT16_NV:
            *out += std::string("VK_COMPONENT_TYPE_FLOAT16_NV");
            return;
        case VK_COMPONENT_TYPE_SINT64_NV:
            *out += std::string("VK_COMPONENT_TYPE_SINT64_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};


void EnumToStringVkValidationFeatureEnableEXT(std::string* out, uint32_t enum_uint32)
{
    VkValidationFeatureEnableEXT e = static_cast<VkValidationFeatureEnableEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT");
            return;
        case VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT");
            return;
        case VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT:
            *out += std::string("VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkCooperativeMatrixPropertiesNV *pstruct = (const VkCooperativeMatrixPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t MSize // SMB
    IndentSpaces(out, indent);
    *out += "MSize:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->MSize);
    *out += "\n"; // GDS

    // uint32_t NSize // SMB
    IndentSpaces(out, indent);
    *out += "NSize:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->NSize);
    *out += "\n"; // GDS

    // uint32_t KSize // SMB
    IndentSpaces(out, indent);
    *out += "KSize:                          ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->KSize);
    *out += "\n"; // GDS

    // VkComponentTypeNV AType // SMB
    IndentSpaces(out, indent);
    *out += "AType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->AType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->AType);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentTypeNV BType // SMB
    IndentSpaces(out, indent);
    *out += "BType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->BType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->BType);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentTypeNV CType // SMB
    IndentSpaces(out, indent);
    *out += "CType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->CType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->CType);
    *out += ")";
    *out += "\n"; // GDS

    // VkComponentTypeNV DType // SMB
    IndentSpaces(out, indent);
    *out += "DType:                          ";
    *out += "VkComponentTypeNV = "; // TEQ
    EnumToStringVkComponentTypeNV(out, pstruct->DType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->DType);
    *out += ")";
    *out += "\n"; // GDS

    // VkScopeNV scope // SMB
    IndentSpaces(out, indent);
    *out += "scope:                          ";
    *out += "VkScopeNV = "; // TEQ
    EnumToStringVkScopeNV(out, pstruct->scope);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->scope);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV *pstruct = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 cooperativeMatrix // SMB
    IndentSpaces(out, indent);
    *out += "cooperativeMatrix:              ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->cooperativeMatrix);
    *out += "\n"; // GDS

    // VkBool32 cooperativeMatrixRobustBufferAccess // SMB
    IndentSpaces(out, indent);
    *out += "cooperativeMatrixRobustBufferAccess: ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->cooperativeMatrixRobustBufferAccess);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>(std::string* out, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV *pstruct = (const VkPhysicalDeviceCooperativeMatrixPropertiesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkShaderStageFlags cooperativeMatrixSupportedStages // SMB
    IndentSpaces(out, indent);
    *out += "cooperativeMatrixSupportedStages: ";
    *out += "VkShaderStageFlags = "; // TEQ
    FlagsToString(out, pstruct->cooperativeMatrixSupportedStages, EnumToStringVkShaderStageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkCooperativeMatrixPropertiesNV>& pProperties)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCooperativeMatrixPropertiesNV* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCooperativeMatrixPropertiesNV* = NULL", indent_string.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCooperativeMatrixPropertiesNV* = ", indent_string.c_str(), "pProperties:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkCooperativeMatrixPropertiesNV>(&tmp_string, 2, 1, "VkCooperativeMatrixPropertiesNV",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkCoverageReductionModeNV(std::string* out, uint32_t enum_uint32)
{
    VkCoverageReductionModeNV e = static_cast<VkCoverageReductionModeNV>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_COVERAGE_REDUCTION_MODE_MERGE_NV:
            *out += std::string("VK_COVERAGE_REDUCTION_MODE_MERGE_NV");
            return;
        case VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV:
            *out += std::string("VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(std::string* out, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>(std::string* out, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV *pstruct = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 coverageReductionMode // SMB
    IndentSpaces(out, indent);
    *out += "coverageReductionMode:          ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->coverageReductionMode);
}

template <>
void StructureToString<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>(std::string* out, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineCoverageReductionStateCreateInfoNV *pstruct = (const VkPipelineCoverageReductionStateCreateInfoNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkPipelineCoverageReductionStateCreateFlagsNV flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkPipelineCoverageReductionStateCreateFlagsNV = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
    *out += "\n"; // GDS

    // VkCoverageReductionModeNV coverageReductionMode // SMB
    IndentSpaces(out, indent);
    *out += "coverageReductionMode:          ";
    *out += "VkCoverageReductionModeNV = "; // TEQ
    EnumToStringVkCoverageReductionModeNV(out, pstruct->coverageReductionMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->coverageReductionMode);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(std::string* out, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkFramebufferMixedSamplesCombinationNV *pstruct = (const VkFramebufferMixedSamplesCombinationNV *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkCoverageReductionModeNV coverageReductionMode // SMB
    IndentSpaces(out, indent);
    *out += "coverageReductionMode:          ";
    *out += "VkCoverageReductionModeNV = "; // TEQ
    EnumToStringVkCoverageReductionModeNV(out, pstruct->coverageReductionMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->coverageReductionMode);
    *out += ")";
    *out += "\n"; // GDS

    // VkSampleCountFlagBits rasterizationSamples // SMB
    IndentSpaces(out, indent);
    *out += "rasterizationSamples:           ";
    *out += "VkSampleCountFlagBits = "; // TEQ
    EnumToStringVkSampleCountFlagBits(out, pstruct->rasterizationSamples);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->rasterizationSamples);
    *out += ")";
    *out += "\n"; // GDS

    // VkSampleCountFlags depthStencilSamples // SMB
    IndentSpaces(out, indent);
    *out += "depthStencilSamples:            ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->depthStencilSamples, EnumToStringVkSampleCountFlagBits); // URW
    *out += "\n"; // GDS

    // VkSampleCountFlags colorSamples // SMB
    IndentSpaces(out, indent);
    *out += "colorSamples:                   ";
    *out += "VkSampleCountFlags = "; // TEQ
    FlagsToString(out, pstruct->colorSamples, EnumToStringVkSampleCountFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pCombinationCount,
    const StructPointerDecoder<Decoded_VkFramebufferMixedSamplesCombinationNV>& pCombinations)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pCombinationCount // ARG
    if (pCombinationCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pCombinationCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pCombinationCount:", static_cast<uint64_t>(*pCombinationCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFramebufferMixedSamplesCombinationNV* pCombinations // ARG
    if (pCombinations.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFramebufferMixedSamplesCombinationNV* = NULL", indent_string.c_str(), "pCombinations:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFramebufferMixedSamplesCombinationNV* = ", indent_string.c_str(), "pCombinations:"); // GRR
        tmp_string = "";
        AddrToString(&tmp_string, pCombinations.GetAddress());
        fprintf(GetFile(), "%s", tmp_string.c_str());  // SSU
        tmp_string = "";
        ArrayOfStructsToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(&tmp_string, 2, 1, "VkFramebufferMixedSamplesCombinationNV",
            pCombinations.GetMetaStructPointer(), "pCombinations", *pCombinationCount.GetPointer(), false, pCombinations.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmp_string.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkFullScreenExclusiveEXT(std::string* out, uint32_t enum_uint32)
{
    VkFullScreenExclusiveEXT e = static_cast<VkFullScreenExclusiveEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT:
            *out += std::string("VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT");
            return;
        case VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT:
            *out += std::string("VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT");
            return;
        case VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT:
            *out += std::string("VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT");
            return;
        case VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT:
            *out += std::string("VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>(std::string* out, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFullScreenExclusiveInfoEXT *pstruct = (const VkSurfaceFullScreenExclusiveInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkFullScreenExclusiveEXT fullScreenExclusive // SMB
    IndentSpaces(out, indent);
    *out += "fullScreenExclusive:            ";
    *out += "VkFullScreenExclusiveEXT = "; // TEQ
    EnumToStringVkFullScreenExclusiveEXT(out, pstruct->fullScreenExclusive);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->fullScreenExclusive);
    *out += ")";
}

template <>
void StructureToString<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>(std::string* out, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT *pstruct = (const VkSurfaceCapabilitiesFullScreenExclusiveEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 fullScreenExclusiveSupported // SMB
    IndentSpaces(out, indent);
    *out += "fullScreenExclusiveSupported:   ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->fullScreenExclusiveSupported);
}

template <>
void StructureToString<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>(std::string* out, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkSurfaceFullScreenExclusiveWin32InfoEXT *pstruct = (const VkSurfaceFullScreenExclusiveWin32InfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // void* hmonitor // SMB
    IndentSpaces(out, indent);
    *out += "hmonitor:                       ";
    *out += "void* = "; // TEQ
    if (pstruct->hmonitor == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.hmonitor); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfacePresentModes2EXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<uint32_t>&             pPresentModeCount,
    const PointerDecoder<VkPresentModeKHR>&     pPresentModes)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indent_string.c_str(), "physicalDevice:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, physicalDevice);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indent_string.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indent_string.c_str(), "pSurfaceInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmp_string, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPresentModeCount // ARG
    if (pPresentModeCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indent_string.c_str(), "pPresentModeCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indent_string.c_str(), "pPresentModeCount:", static_cast<uint64_t>(*pPresentModeCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPresentModeKHR* pPresentModes // ARG
    if (pPresentModes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = NULL", indent_string.c_str(), "pPresentModes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = %" PRId64 "", indent_string.c_str(), "pPresentModes:", static_cast<uint64_t>(*pPresentModes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireFullScreenExclusiveModeEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkAcquireFullScreenExclusiveModeEXT(device, swapchain)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkReleaseFullScreenExclusiveModeEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkReleaseFullScreenExclusiveModeEXT(device, swapchain)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indent_string.c_str(), "swapchain:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, swapchain);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupSurfacePresentModes2EXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>& pModes)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indent_string.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indent_string.c_str(), "pSurfaceInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmp_string, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGroupPresentModeFlagsKHR* pModes // ARG
    tmp_string = "";
    FlagsToString(&tmp_string, *pModes.GetPointer(), EnumToStringVkDeviceGroupPresentModeFlagBitsKHR);
    fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentModeFlagsKHR* = %s", indent_string.c_str(), "pModes:", tmp_string.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(std::string* out, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkHeadlessSurfaceCreateInfoEXT *pstruct = (const VkHeadlessSurfaceCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkHeadlessSurfaceCreateFlagsEXT flags // SMB
    IndentSpaces(out, indent);
    *out += "flags:                          ";
    *out += "VkHeadlessSurfaceCreateFlagsEXT = "; // TEQ
    UnsignedDecimalToString(out, pstruct->flags);
}

void VulkanAsciiConsumer::Process_vkCreateHeadlessSurfaceEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkHeadlessSurfaceCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)");
    tmp_string = "";
    EnumToStringVkResult(&tmp_string, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmp_string.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indent_string.c_str(), "instance:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, instance);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkHeadlessSurfaceCreateInfoEXT* = NULL", indent_string.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkHeadlessSurfaceCreateInfoEXT* = ", indent_string.c_str(), "pCreateInfo:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(&tmp_string, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indent_string.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indent_string.c_str(), "pAllocator:"); // WPO
        tmp_string = "";
        AddrToString(&tmp_string, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmp_string.c_str()); // WPP
        tmp_string = "";
        StructureToString<Decoded_VkAllocationCallbacks>(&tmp_string, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmp_string.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indent_string.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indent_string.c_str(), "pSurface:");  // TAZ
        tmp_string = "";
        AddrToString(&tmp_string, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmp_string.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}


void EnumToStringVkLineRasterizationModeEXT(std::string* out, uint32_t enum_uint32)
{
    VkLineRasterizationModeEXT e = static_cast<VkLineRasterizationModeEXT>(enum_uint32);
    assert(out != nullptr);
    switch (e)
    {
        case VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT:
            *out += std::string("VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT");
            return;
        case VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT:
            *out += std::string("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT");
            return;
        case VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT:
            *out += std::string("VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT");
            return;
        case VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT:
            *out += std::string("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT");
            return;
        default:
            *out += std::string("UNKNOWN");
            return;
    };
};

template <> void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX
template <> void StructureToString<Decoded_VkPipelineRasterizationLineStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceLineRasterizationFeaturesEXT *pstruct = (const VkPhysicalDeviceLineRasterizationFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 rectangularLines // SMB
    IndentSpaces(out, indent);
    *out += "rectangularLines:               ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->rectangularLines);
    *out += "\n"; // GDS

    // VkBool32 bresenhamLines // SMB
    IndentSpaces(out, indent);
    *out += "bresenhamLines:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->bresenhamLines);
    *out += "\n"; // GDS

    // VkBool32 smoothLines // SMB
    IndentSpaces(out, indent);
    *out += "smoothLines:                    ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->smoothLines);
    *out += "\n"; // GDS

    // VkBool32 stippledRectangularLines // SMB
    IndentSpaces(out, indent);
    *out += "stippledRectangularLines:       ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledRectangularLines);
    *out += "\n"; // GDS

    // VkBool32 stippledBresenhamLines // SMB
    IndentSpaces(out, indent);
    *out += "stippledBresenhamLines:         ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledBresenhamLines);
    *out += "\n"; // GDS

    // VkBool32 stippledSmoothLines // SMB
    IndentSpaces(out, indent);
    *out += "stippledSmoothLines:            ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledSmoothLines);
}

template <>
void StructureToString<Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT>(std::string* out, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceLineRasterizationPropertiesEXT *pstruct = (const VkPhysicalDeviceLineRasterizationPropertiesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // uint32_t lineSubPixelPrecisionBits // SMB
    IndentSpaces(out, indent);
    *out += "lineSubPixelPrecisionBits:      ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->lineSubPixelPrecisionBits);
}

template <>
void StructureToString<Decoded_VkPipelineRasterizationLineStateCreateInfoEXT>(std::string* out, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPipelineRasterizationLineStateCreateInfoEXT *pstruct = (const VkPipelineRasterizationLineStateCreateInfoEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // const void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "const void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkLineRasterizationModeEXT lineRasterizationMode // SMB
    IndentSpaces(out, indent);
    *out += "lineRasterizationMode:          ";
    *out += "VkLineRasterizationModeEXT = "; // TEQ
    EnumToStringVkLineRasterizationModeEXT(out, pstruct->lineRasterizationMode);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->lineRasterizationMode);
    *out += ")";
    *out += "\n"; // GDS

    // VkBool32 stippledLineEnable // SMB
    IndentSpaces(out, indent);
    *out += "stippledLineEnable:             ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->stippledLineEnable);
    *out += "\n"; // GDS

    // uint32_t lineStippleFactor // SMB
    IndentSpaces(out, indent);
    *out += "lineStippleFactor:              ";
    *out += "uint32_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->lineStippleFactor);
    *out += "\n"; // GDS

    // uint16_t lineStipplePattern // SMB
    IndentSpaces(out, indent);
    *out += "lineStipplePattern:             ";
    *out += "uint16_t = "; // TEQ
    UnsignedDecimalToString(out, pstruct->lineStipplePattern);
}

void VulkanAsciiConsumer::Process_vkCmdSetLineStippleEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    lineStippleFactor,
    uint16_t                                    lineStipplePattern)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indent_string.c_str(), "commandBuffer:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, commandBuffer);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t lineStippleFactor // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "lineStippleFactor:", lineStippleFactor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint16_t lineStipplePattern // ARG
    fprintf(GetFile(), "%s%-32suint16_t = %d", indent_string.c_str(), "lineStipplePattern:", lineStipplePattern); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}

template <> void StructureToString<Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr); // ARX

template <>
void StructureToString<Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT>(std::string* out, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr) // GAA
{
    const VkPhysicalDeviceHostQueryResetFeaturesEXT *pstruct = (const VkPhysicalDeviceHostQueryResetFeaturesEXT *)pstruct_in.decoded_value; // BTB
    assert(out != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    *out += "\n"; // UUR

    // VkStructureType sType // SMB
    IndentSpaces(out, indent);
    *out += "sType:                          ";
    *out += "VkStructureType = "; // TEQ
    EnumToStringVkStructureType(out, pstruct->sType);
    *out += " (";
    UnsignedDecimalToString(out, pstruct->sType);
    *out += ")";
    *out += "\n"; // GDS

    // void* pNext // SMB
    IndentSpaces(out, indent);
    *out += "pNext:                          ";
    *out += "void* = "; // TEQ
    if (pstruct->pNext == nullptr) // WWW
    {
        *out += "NULL";
    }
    else
    {
        AddrToString(out, pstruct_in.pNext->GetAddress()); // PWS
    }
    *out += "\n"; // GDS

    // VkBool32 hostQueryReset // SMB
    IndentSpaces(out, indent);
    *out += "hostQueryReset:                 ";
    *out += "VkBool32 = "; // TEQ
    SignedDecimalToString(out, pstruct->hostQueryReset);
}

void VulkanAsciiConsumer::Process_vkResetQueryPoolEXT(
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    std::string indent_string;
    std::string tmp_string;
    IndentSpaces(&indent_string, 1);
    fprintf(GetFile(), "vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indent_string.c_str(), "device:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, device);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indent_string.c_str(), "queryPool:"); // TRP
    tmp_string = "";
    AddrToString(&tmp_string, queryPool);
    fprintf(GetFile(), "%s", tmp_string.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indent_string.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmp_string = "\n";   // HDS
    fprintf(GetFile(), "%s", tmp_string.c_str());
}
GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)
