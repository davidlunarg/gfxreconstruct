/*
** Copyright (c) 2018-2019 Valve Corporation
** Copyright (c) 2018-2019 LunarG, Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include <inttypes.h>
#include <string>
#include <functional>

#include "generated/generated_vulkan_ascii_consumer.h"

#include "decode/vulkan_enum_util.h"
#include "util/defines.h"

#include "vulkan/vulkan.h"
#include "format/platform_types.h"

extern int  indentSize;
extern bool noAddr;
extern bool printShaderCode;

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

typedef std::function<void(std::string *, uint32_t)> EnumToStringFunc;

void signedDecimalToString(std::string* rString, int64_t n)
{
    char decstring[30];
    assert(rString != nullptr);
    snprintf(decstring, sizeof(decstring), "%" PRId64, n);
    snprintf(decstring, sizeof(decstring), "%" PRId64, n);
    *rString += decstring;
}

void unsignedDecimalToString(std::string* rString, uint64_t n)
{
    char decstring[30];
    assert(rString != nullptr);
    snprintf(decstring, sizeof(decstring), "%" PRIu64, n);
    *rString += decstring;
}

void doubleToString(std::string* rString, double d)
{
    char floatstring[30];
    snprintf(floatstring, sizeof(floatstring), "%g", d);
    *rString += floatstring;
}

void addrToString(std::string* rString, uint64_t v)
{
    assert(rString != nullptr);
    if (noAddr)
    {
        *rString += "address";
    }
    else
    {
        char s[30];
        snprintf(s, sizeof(s), "0x%" PRIx64, v);
        *rString += s;
    }
}

// Utility for doing indentation
void indentSpaces(std::string* rString, int indent)
{
    assert(rString != nullptr);
    rString->insert(rString->end(), indent * indentSize, ' ');
}

void flagsToString(std::string* rString, VkFlags flags, EnumToStringFunc enumToStringFunc)
{
    VkFlags m = 1;
    assert(rString != nullptr);
    unsignedDecimalToString(rString, flags);
    if (flags != 0)
    {
        *rString += " (";
        while (flags)
        {
            if (m & flags)
            {
                //void (*fp)(std::string*, VkFlags);
                //*((uint64_t*)&fp) = (uint64_t)funcPtr;
                //fp(rString, (m & flags));
                enumToStringFunc(rString, (m & flags));
                flags = flags & ~m;
                if (flags & ~m)
                {
                    *rString += " | ";
                }
            }
            else
            {
                flags &= ~m;
            }
            m <<= 1;
        }
        *rString += ")";
    }
    return;
}

typedef struct ValueToStringStruct {
   bool isHandleAddr;
   bool isEnum;
   bool isFlags;
   EnumToStringFunc enumToStringFunc;
} ValueToStringStruct;


template <typename T>
void valueToString(std::string* rString, T value, const ValueToStringStruct &vinfo)
{
    assert(rString != nullptr);
    assert((vinfo.isHandleAddr + vinfo.isEnum  + vinfo.isFlags) <= 1);
    assert(vinfo.isEnum ? vinfo.enumToStringFunc != nullptr : true);
    assert(vinfo.isFlags ? vinfo.enumToStringFunc != nullptr : true);
    if (vinfo.isHandleAddr)
    {
        uint64_t v = *((uint64_t*)value);
        addrToString(rString, v);
    }
    else if (vinfo.isFlags)
    {
        uint32_t v = *((uint32_t*)value);
        flagsToString(rString, v, vinfo.enumToStringFunc);
    }
    else if (vinfo.isEnum)
    {
        uint32_t v = *((uint32_t*)value);
        vinfo.enumToStringFunc(rString, v);
    }
    else if (std::is_same<T, float*>::value || std::is_same<T, const float*>::value)
    {
        double v = *((float*)value);
        doubleToString(rString, v);
    }
    else if (std::is_same<T, double*>::value || std::is_same<T, const double*>::value)
    {
        doubleToString(rString, *((double*)value));
    }
    else if (std::is_same<T, int32_t*>::value || std::is_same<T, const int32_t*>::value)
    {
        int32_t v = *((int32_t*)value);
        signedDecimalToString(rString, v);
    }
    else if (std::is_same<T, uint32_t*>::value || std::is_same<T, const uint32_t*>::value)
    {
        uint32_t v = *((uint32_t*)value);
        unsignedDecimalToString(rString, v);
    }
    else if (std::is_same<T, int64_t*>::value || std::is_same<T, const int64_t*>::value)
    {
        int64_t v = *((int64_t*)value);
        signedDecimalToString(rString, v);
    }
    else if (std::is_same<T, unsigned int*>::value || std::is_same<T, const unsigned int*>::value)
    {
        unsigned int v = *((unsigned int*)value);
        unsignedDecimalToString(rString, v);
    }
    else if (std::is_same<T, unsigned char*>::value || std::is_same<T, const unsigned char*>::value)
    {
        unsigned char v = *((unsigned char*)value);
        unsignedDecimalToString(rString, v);
    }
    else
    {
        uint64_t v = *((uint64_t*)value);
        unsignedDecimalToString(rString, v);
    }
}
void stringToQuotedString(std::string* rString, const char* s)
{
    assert(rString != nullptr);
    if (s != nullptr)
    {
        *rString += "\"";
        *rString += s;
        *rString += "\"";
    }
    else
    {
        *rString += "NULL";
    }
}

void padString(std::string* s, size_t len)
{
    assert(s != nullptr);
    if (s->length() < len)
    {
        s->insert(s->end(), len - s->length(), ' ');
    }
}

template <typename T>
void structureToString(std::string* rString, const T& pStruct, int indent, uint64_t baseAddr);

template <typename T>
void arrayToString(std::string*              rString,
                   int                       indent,
                   const int                 pointerCount,
                   const char*               fullTypeName,
                   T                         array,
                   const char*               arrayName,
                   const size_t              arrayLength,
                   const ValueToStringStruct &vinfo)
{
    assert(rString != nullptr);
    assert((vinfo.isHandleAddr + vinfo.isEnum  + vinfo.isFlags) <= 1);
    assert(vinfo.isEnum ? vinfo.enumToStringFunc != nullptr : true);
    assert(vinfo.isFlags ? vinfo.enumToStringFunc != nullptr : true);
    if (arrayLength == 0 || array == nullptr)
    {
        return;
    }
    if (pointerCount <= 1 &&
        (std::is_same<T, const char>::value || std::is_same<T, const char>::value || std::is_same<T, char>::value ||
         std::is_same<T, const char*>::value || std::is_same<T, char*>::value))
    {
        stringToQuotedString(rString, *((const char**)&array));
    }
    else
    {
        std::string fullTypeNameStr = fullTypeName;
        if (*fullTypeNameStr.rbegin() == '*')
        {
            // Remove last * in type name
            fullTypeNameStr.pop_back();
        }
        *rString += "\n";
        for (uint64_t j = 0; j < arrayLength; j++)
        {
            indentSpaces(rString, indent + 1);
            std::string nameIdx;
            nameIdx += arrayName;
            nameIdx += "[";
            unsignedDecimalToString(&nameIdx, j);
            nameIdx += "]: ";
            padString(&nameIdx, 32);
            *rString += nameIdx;
            *rString += fullTypeNameStr;
            *rString += " = ";
            if (pointerCount > 1)
            {
                if (pointerCount == 2 && strstr(fullTypeName, "char"))
                {
                    stringToQuotedString(rString, ((const char**)array)[j]);
                }
                else
                {
                    fprintf(stderr, "ERROR: arrayToString arrays of non-strings not implemented\n");
                }
            }
            else
            {
                valueToString<T>(rString, &array[j], vinfo);
            }
            if (j < arrayLength - 1)
            {
                *rString += "\n";
            }
        }
    }
}

template <typename T>
void arrayOfStructsToString(std::string* rString,
                            int          indent,
                            const int    pointerCount,
                            const char*  baseTypeName,
                            T*           array,
                            const char*  arrayName,
                            const size_t arrayLength,
                            bool         isUnion,
                            uint64_t     baseAddr)
{
    assert(rString != nullptr);
    if (arrayLength == 0 || array == nullptr)
    {
        return;
    }
    *rString += "\n";
    for (uint64_t j = 0; j < arrayLength; j++)
    {
        indentSpaces(rString, indent);
        std::string nameIdx;
        nameIdx += arrayName;
        nameIdx += "[";
        unsignedDecimalToString(&nameIdx, j);
        nameIdx += "]: ";
        padString(&nameIdx, 32);
        *rString += nameIdx;
        *rString += baseTypeName;
        *rString += " = ";
        addrToString(rString, baseAddr + j * sizeof(T)); // UEW
        if (isUnion)
        {
            *rString += " (Union)";
        }
        *rString += ":";
        if (pointerCount > 1)
        {
            fprintf(stderr, "ERROR: arrayOfStructsToString cannot handle arrays of arrays\n");
        }
        else
        {
            structureToString<T>(rString, array[j], indent+1, baseAddr + j * sizeof(T)); // YQS
        }
        if (j < arrayLength - 1)
        {
            *rString += "\n"; // AZC
        }
    }
}



void enumToString_VkFilter(std::string* rString, uint32_t enumValueInt32)
{
    VkFilter enumValue = static_cast<VkFilter>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FILTER_NEAREST:
            *rString += std::string("VK_FILTER_NEAREST");
            return;
        case VK_FILTER_LINEAR:
            *rString += std::string("VK_FILTER_LINEAR");
            return;
        case VK_FILTER_CUBIC_IMG:
            *rString += std::string("VK_FILTER_CUBIC_IMG");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkComponentSwizzle(std::string* rString, uint32_t enumValueInt32)
{
    VkComponentSwizzle enumValue = static_cast<VkComponentSwizzle>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMPONENT_SWIZZLE_ONE:
            *rString += std::string("VK_COMPONENT_SWIZZLE_ONE");
            return;
        case VK_COMPONENT_SWIZZLE_G:
            *rString += std::string("VK_COMPONENT_SWIZZLE_G");
            return;
        case VK_COMPONENT_SWIZZLE_B:
            *rString += std::string("VK_COMPONENT_SWIZZLE_B");
            return;
        case VK_COMPONENT_SWIZZLE_R:
            *rString += std::string("VK_COMPONENT_SWIZZLE_R");
            return;
        case VK_COMPONENT_SWIZZLE_ZERO:
            *rString += std::string("VK_COMPONENT_SWIZZLE_ZERO");
            return;
        case VK_COMPONENT_SWIZZLE_A:
            *rString += std::string("VK_COMPONENT_SWIZZLE_A");
            return;
        case VK_COMPONENT_SWIZZLE_IDENTITY:
            *rString += std::string("VK_COMPONENT_SWIZZLE_IDENTITY");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDescriptorPoolCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkDescriptorPoolCreateFlagBits enumValue = static_cast<VkDescriptorPoolCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT:
            *rString += std::string("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT");
            return;
        case VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT:
            *rString += std::string("VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkStencilFaceFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkStencilFaceFlagBits enumValue = static_cast<VkStencilFaceFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_STENCIL_FACE_BACK_BIT:
            *rString += std::string("VK_STENCIL_FACE_BACK_BIT");
            return;
        case VK_STENCIL_FACE_FRONT_BIT:
            *rString += std::string("VK_STENCIL_FACE_FRONT_BIT");
            return;
        case VK_STENCIL_FACE_FRONT_AND_BACK:
            *rString += std::string("VK_STENCIL_FACE_FRONT_AND_BACK");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkQueueFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkQueueFlagBits enumValue = static_cast<VkQueueFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_QUEUE_TRANSFER_BIT:
            *rString += std::string("VK_QUEUE_TRANSFER_BIT");
            return;
        case VK_QUEUE_GRAPHICS_BIT:
            *rString += std::string("VK_QUEUE_GRAPHICS_BIT");
            return;
        case VK_QUEUE_SPARSE_BINDING_BIT:
            *rString += std::string("VK_QUEUE_SPARSE_BINDING_BIT");
            return;
        case VK_QUEUE_PROTECTED_BIT:
            *rString += std::string("VK_QUEUE_PROTECTED_BIT");
            return;
        case VK_QUEUE_COMPUTE_BIT:
            *rString += std::string("VK_QUEUE_COMPUTE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSubpassDescriptionFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkSubpassDescriptionFlagBits enumValue = static_cast<VkSubpassDescriptionFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX:
            *rString += std::string("VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX");
            return;
        case VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX:
            *rString += std::string("VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageType(std::string* rString, uint32_t enumValueInt32)
{
    VkImageType enumValue = static_cast<VkImageType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_TYPE_1D:
            *rString += std::string("VK_IMAGE_TYPE_1D");
            return;
        case VK_IMAGE_TYPE_2D:
            *rString += std::string("VK_IMAGE_TYPE_2D");
            return;
        case VK_IMAGE_TYPE_3D:
            *rString += std::string("VK_IMAGE_TYPE_3D");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCullModeFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkCullModeFlagBits enumValue = static_cast<VkCullModeFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_CULL_MODE_FRONT_BIT:
            *rString += std::string("VK_CULL_MODE_FRONT_BIT");
            return;
        case VK_CULL_MODE_FRONT_AND_BACK:
            *rString += std::string("VK_CULL_MODE_FRONT_AND_BACK");
            return;
        case VK_CULL_MODE_NONE:
            *rString += std::string("VK_CULL_MODE_NONE");
            return;
        case VK_CULL_MODE_BACK_BIT:
            *rString += std::string("VK_CULL_MODE_BACK_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDeviceQueueCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkDeviceQueueCreateFlagBits enumValue = static_cast<VkDeviceQueueCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT:
            *rString += std::string("VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkBlendFactor(std::string* rString, uint32_t enumValueInt32)
{
    VkBlendFactor enumValue = static_cast<VkBlendFactor>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR");
            return;
        case VK_BLEND_FACTOR_DST_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_DST_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR");
            return;
        case VK_BLEND_FACTOR_SRC_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_SRC_COLOR");
            return;
        case VK_BLEND_FACTOR_ZERO:
            *rString += std::string("VK_BLEND_FACTOR_ZERO");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR");
            return;
        case VK_BLEND_FACTOR_DST_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_DST_ALPHA");
            return;
        case VK_BLEND_FACTOR_CONSTANT_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_CONSTANT_COLOR");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA");
            return;
        case VK_BLEND_FACTOR_CONSTANT_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_CONSTANT_ALPHA");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA");
            return;
        case VK_BLEND_FACTOR_ONE:
            *rString += std::string("VK_BLEND_FACTOR_ONE");
            return;
        case VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA");
            return;
        case VK_BLEND_FACTOR_SRC1_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_SRC1_ALPHA");
            return;
        case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
            *rString += std::string("VK_BLEND_FACTOR_SRC_ALPHA_SATURATE");
            return;
        case VK_BLEND_FACTOR_SRC_ALPHA:
            *rString += std::string("VK_BLEND_FACTOR_SRC_ALPHA");
            return;
        case VK_BLEND_FACTOR_SRC1_COLOR:
            *rString += std::string("VK_BLEND_FACTOR_SRC1_COLOR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkAttachmentLoadOp(std::string* rString, uint32_t enumValueInt32)
{
    VkAttachmentLoadOp enumValue = static_cast<VkAttachmentLoadOp>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_ATTACHMENT_LOAD_OP_DONT_CARE:
            *rString += std::string("VK_ATTACHMENT_LOAD_OP_DONT_CARE");
            return;
        case VK_ATTACHMENT_LOAD_OP_LOAD:
            *rString += std::string("VK_ATTACHMENT_LOAD_OP_LOAD");
            return;
        case VK_ATTACHMENT_LOAD_OP_CLEAR:
            *rString += std::string("VK_ATTACHMENT_LOAD_OP_CLEAR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkColorComponentFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkColorComponentFlagBits enumValue = static_cast<VkColorComponentFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COLOR_COMPONENT_A_BIT:
            *rString += std::string("VK_COLOR_COMPONENT_A_BIT");
            return;
        case VK_COLOR_COMPONENT_G_BIT:
            *rString += std::string("VK_COLOR_COMPONENT_G_BIT");
            return;
        case VK_COLOR_COMPONENT_R_BIT:
            *rString += std::string("VK_COLOR_COMPONENT_R_BIT");
            return;
        case VK_COLOR_COMPONENT_B_BIT:
            *rString += std::string("VK_COLOR_COMPONENT_B_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkInternalAllocationType(std::string* rString, uint32_t enumValueInt32)
{
    VkInternalAllocationType enumValue = static_cast<VkInternalAllocationType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE:
            *rString += std::string("VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkRenderPassCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkRenderPassCreateFlagBits enumValue = static_cast<VkRenderPassCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    *rString += std::string("UNKNOWN");
};


void enumToString_VkPipelineBindPoint(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineBindPoint enumValue = static_cast<VkPipelineBindPoint>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PIPELINE_BIND_POINT_COMPUTE:
            *rString += std::string("VK_PIPELINE_BIND_POINT_COMPUTE");
            return;
        case VK_PIPELINE_BIND_POINT_GRAPHICS:
            *rString += std::string("VK_PIPELINE_BIND_POINT_GRAPHICS");
            return;
        case VK_PIPELINE_BIND_POINT_RAY_TRACING_NV:
            *rString += std::string("VK_PIPELINE_BIND_POINT_RAY_TRACING_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSampleCountFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkSampleCountFlagBits enumValue = static_cast<VkSampleCountFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SAMPLE_COUNT_64_BIT:
            *rString += std::string("VK_SAMPLE_COUNT_64_BIT");
            return;
        case VK_SAMPLE_COUNT_32_BIT:
            *rString += std::string("VK_SAMPLE_COUNT_32_BIT");
            return;
        case VK_SAMPLE_COUNT_4_BIT:
            *rString += std::string("VK_SAMPLE_COUNT_4_BIT");
            return;
        case VK_SAMPLE_COUNT_8_BIT:
            *rString += std::string("VK_SAMPLE_COUNT_8_BIT");
            return;
        case VK_SAMPLE_COUNT_16_BIT:
            *rString += std::string("VK_SAMPLE_COUNT_16_BIT");
            return;
        case VK_SAMPLE_COUNT_1_BIT:
            *rString += std::string("VK_SAMPLE_COUNT_1_BIT");
            return;
        case VK_SAMPLE_COUNT_2_BIT:
            *rString += std::string("VK_SAMPLE_COUNT_2_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPrimitiveTopology(std::string* rString, uint32_t enumValueInt32)
{
    VkPrimitiveTopology enumValue = static_cast<VkPrimitiveTopology>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_LIST:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_LIST");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_STRIP:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY");
            return;
        case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_PATCH_LIST");
            return;
        case VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST");
            return;
        case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP");
            return;
        case VK_PRIMITIVE_TOPOLOGY_POINT_LIST:
            *rString += std::string("VK_PRIMITIVE_TOPOLOGY_POINT_LIST");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkStencilOp(std::string* rString, uint32_t enumValueInt32)
{
    VkStencilOp enumValue = static_cast<VkStencilOp>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_STENCIL_OP_REPLACE:
            *rString += std::string("VK_STENCIL_OP_REPLACE");
            return;
        case VK_STENCIL_OP_ZERO:
            *rString += std::string("VK_STENCIL_OP_ZERO");
            return;
        case VK_STENCIL_OP_INCREMENT_AND_WRAP:
            *rString += std::string("VK_STENCIL_OP_INCREMENT_AND_WRAP");
            return;
        case VK_STENCIL_OP_INCREMENT_AND_CLAMP:
            *rString += std::string("VK_STENCIL_OP_INCREMENT_AND_CLAMP");
            return;
        case VK_STENCIL_OP_KEEP:
            *rString += std::string("VK_STENCIL_OP_KEEP");
            return;
        case VK_STENCIL_OP_INVERT:
            *rString += std::string("VK_STENCIL_OP_INVERT");
            return;
        case VK_STENCIL_OP_DECREMENT_AND_WRAP:
            *rString += std::string("VK_STENCIL_OP_DECREMENT_AND_WRAP");
            return;
        case VK_STENCIL_OP_DECREMENT_AND_CLAMP:
            *rString += std::string("VK_STENCIL_OP_DECREMENT_AND_CLAMP");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkQueryControlFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkQueryControlFlagBits enumValue = static_cast<VkQueryControlFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_QUERY_CONTROL_PRECISE_BIT:
            *rString += std::string("VK_QUERY_CONTROL_PRECISE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkVendorId(std::string* rString, uint32_t enumValueInt32)
{
    VkVendorId enumValue = static_cast<VkVendorId>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_VENDOR_ID_VSI:
            *rString += std::string("VK_VENDOR_ID_VSI");
            return;
        case VK_VENDOR_ID_KAZAN:
            *rString += std::string("VK_VENDOR_ID_KAZAN");
            return;
        case VK_VENDOR_ID_VIV:
            *rString += std::string("VK_VENDOR_ID_VIV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkResult(std::string* rString, uint32_t enumValueInt32)
{
    VkResult enumValue = static_cast<VkResult>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SUBOPTIMAL_KHR:
            *rString += std::string("VK_SUBOPTIMAL_KHR");
            return;
        case VK_ERROR_OUT_OF_POOL_MEMORY:
            *rString += std::string("VK_ERROR_OUT_OF_POOL_MEMORY");
            return;
        case VK_ERROR_FRAGMENTED_POOL:
            *rString += std::string("VK_ERROR_FRAGMENTED_POOL");
            return;
        case VK_ERROR_MEMORY_MAP_FAILED:
            *rString += std::string("VK_ERROR_MEMORY_MAP_FAILED");
            return;
        case VK_EVENT_SET:
            *rString += std::string("VK_EVENT_SET");
            return;
        case VK_ERROR_FORMAT_NOT_SUPPORTED:
            *rString += std::string("VK_ERROR_FORMAT_NOT_SUPPORTED");
            return;
        case VK_ERROR_INVALID_SHADER_NV:
            *rString += std::string("VK_ERROR_INVALID_SHADER_NV");
            return;
        case VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT:
            *rString += std::string("VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT");
            return;
        case VK_ERROR_OUT_OF_HOST_MEMORY:
            *rString += std::string("VK_ERROR_OUT_OF_HOST_MEMORY");
            return;
        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:
            *rString += std::string("VK_ERROR_NATIVE_WINDOW_IN_USE_KHR");
            return;
        case VK_ERROR_LAYER_NOT_PRESENT:
            *rString += std::string("VK_ERROR_LAYER_NOT_PRESENT");
            return;
        case VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT:
            *rString += std::string("VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT");
            return;
        case VK_TIMEOUT:
            *rString += std::string("VK_TIMEOUT");
            return;
        case VK_SUCCESS:
            *rString += std::string("VK_SUCCESS");
            return;
        case VK_ERROR_DEVICE_LOST:
            *rString += std::string("VK_ERROR_DEVICE_LOST");
            return;
        case VK_ERROR_NOT_PERMITTED_EXT:
            *rString += std::string("VK_ERROR_NOT_PERMITTED_EXT");
            return;
        case VK_ERROR_TOO_MANY_OBJECTS:
            *rString += std::string("VK_ERROR_TOO_MANY_OBJECTS");
            return;
        case VK_ERROR_OUT_OF_DEVICE_MEMORY:
            *rString += std::string("VK_ERROR_OUT_OF_DEVICE_MEMORY");
            return;
        case VK_ERROR_EXTENSION_NOT_PRESENT:
            *rString += std::string("VK_ERROR_EXTENSION_NOT_PRESENT");
            return;
        case VK_ERROR_FEATURE_NOT_PRESENT:
            *rString += std::string("VK_ERROR_FEATURE_NOT_PRESENT");
            return;
        case VK_ERROR_OUT_OF_DATE_KHR:
            *rString += std::string("VK_ERROR_OUT_OF_DATE_KHR");
            return;
        case VK_ERROR_FRAGMENTATION_EXT:
            *rString += std::string("VK_ERROR_FRAGMENTATION_EXT");
            return;
        case VK_NOT_READY:
            *rString += std::string("VK_NOT_READY");
            return;
        case VK_ERROR_INVALID_EXTERNAL_HANDLE:
            *rString += std::string("VK_ERROR_INVALID_EXTERNAL_HANDLE");
            return;
        case VK_ERROR_INITIALIZATION_FAILED:
            *rString += std::string("VK_ERROR_INITIALIZATION_FAILED");
            return;
        case VK_ERROR_SURFACE_LOST_KHR:
            *rString += std::string("VK_ERROR_SURFACE_LOST_KHR");
            return;
        case VK_INCOMPLETE:
            *rString += std::string("VK_INCOMPLETE");
            return;
        case VK_ERROR_VALIDATION_FAILED_EXT:
            *rString += std::string("VK_ERROR_VALIDATION_FAILED_EXT");
            return;
        case VK_EVENT_RESET:
            *rString += std::string("VK_EVENT_RESET");
            return;
        case VK_ERROR_INVALID_DEVICE_ADDRESS_EXT:
            *rString += std::string("VK_ERROR_INVALID_DEVICE_ADDRESS_EXT");
            return;
        case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:
            *rString += std::string("VK_ERROR_INCOMPATIBLE_DISPLAY_KHR");
            return;
        case VK_ERROR_INCOMPATIBLE_DRIVER:
            *rString += std::string("VK_ERROR_INCOMPATIBLE_DRIVER");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPipelineStageFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineStageFlagBits enumValue = static_cast<VkPipelineStageFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT:
            *rString += std::string("VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT");
            return;
        case VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_HOST_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_HOST_BIT");
            return;
        case VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT");
            return;
        case VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT");
            return;
        case VK_PIPELINE_STAGE_ALL_COMMANDS_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_ALL_COMMANDS_BIT");
            return;
        case VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT:
            *rString += std::string("VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT");
            return;
        case VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV:
            *rString += std::string("VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_VERTEX_SHADER_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_VERTEX_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT");
            return;
        case VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV:
            *rString += std::string("VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT");
            return;
        case VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT:
            *rString += std::string("VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT");
            return;
        case VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV:
            *rString += std::string("VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX:
            *rString += std::string("VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX");
            return;
        case VK_PIPELINE_STAGE_VERTEX_INPUT_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_VERTEX_INPUT_BIT");
            return;
        case VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV:
            *rString += std::string("VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT");
            return;
        case VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV:
            *rString += std::string("VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV");
            return;
        case VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT");
            return;
        case VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT");
            return;
        case VK_PIPELINE_STAGE_TRANSFER_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_TRANSFER_BIT");
            return;
        case VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT:
            *rString += std::string("VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkShaderModuleCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkShaderModuleCreateFlagBits enumValue = static_cast<VkShaderModuleCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    *rString += std::string("UNKNOWN");
};


void enumToString_VkPipelineCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineCreateFlagBits enumValue = static_cast<VkPipelineCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PIPELINE_CREATE_DERIVATIVE_BIT:
            *rString += std::string("VK_PIPELINE_CREATE_DERIVATIVE_BIT");
            return;
        case VK_PIPELINE_CREATE_DISPATCH_BASE:
            *rString += std::string("VK_PIPELINE_CREATE_DISPATCH_BASE");
            return;
        case VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV:
            *rString += std::string("VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV");
            return;
        case VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT:
            *rString += std::string("VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT");
            return;
        case VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT:
            *rString += std::string("VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT");
            return;
        case VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR:
            *rString += std::string("VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR");
            return;
        case VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT:
            *rString += std::string("VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT");
            return;
        case VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR:
            *rString += std::string("VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkFrontFace(std::string* rString, uint32_t enumValueInt32)
{
    VkFrontFace enumValue = static_cast<VkFrontFace>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FRONT_FACE_CLOCKWISE:
            *rString += std::string("VK_FRONT_FACE_CLOCKWISE");
            return;
        case VK_FRONT_FACE_COUNTER_CLOCKWISE:
            *rString += std::string("VK_FRONT_FACE_COUNTER_CLOCKWISE");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPipelineShaderStageCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineShaderStageCreateFlagBits enumValue = static_cast<VkPipelineShaderStageCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT:
            *rString += std::string("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT");
            return;
        case VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT:
            *rString += std::string("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSamplerMipmapMode(std::string* rString, uint32_t enumValueInt32)
{
    VkSamplerMipmapMode enumValue = static_cast<VkSamplerMipmapMode>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SAMPLER_MIPMAP_MODE_LINEAR:
            *rString += std::string("VK_SAMPLER_MIPMAP_MODE_LINEAR");
            return;
        case VK_SAMPLER_MIPMAP_MODE_NEAREST:
            *rString += std::string("VK_SAMPLER_MIPMAP_MODE_NEAREST");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDescriptorType(std::string* rString, uint32_t enumValueInt32)
{
    VkDescriptorType enumValue = static_cast<VkDescriptorType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
            *rString += std::string("VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER");
            return;
        case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV:
            *rString += std::string("VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV");
            return;
        case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT:
            *rString += std::string("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT");
            return;
        case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
            *rString += std::string("VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE");
            return;
        case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
            *rString += std::string("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER");
            return;
        case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
            *rString += std::string("VK_DESCRIPTOR_TYPE_STORAGE_IMAGE");
            return;
        case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
            *rString += std::string("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC");
            return;
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
            *rString += std::string("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER");
            return;
        case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
            *rString += std::string("VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT");
            return;
        case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
            *rString += std::string("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER");
            return;
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
            *rString += std::string("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC");
            return;
        case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
            *rString += std::string("VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER");
            return;
        case VK_DESCRIPTOR_TYPE_SAMPLER:
            *rString += std::string("VK_DESCRIPTOR_TYPE_SAMPLER");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageTiling(std::string* rString, uint32_t enumValueInt32)
{
    VkImageTiling enumValue = static_cast<VkImageTiling>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_TILING_OPTIMAL:
            *rString += std::string("VK_IMAGE_TILING_OPTIMAL");
            return;
        case VK_IMAGE_TILING_LINEAR:
            *rString += std::string("VK_IMAGE_TILING_LINEAR");
            return;
        case VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT:
            *rString += std::string("VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkAttachmentStoreOp(std::string* rString, uint32_t enumValueInt32)
{
    VkAttachmentStoreOp enumValue = static_cast<VkAttachmentStoreOp>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_ATTACHMENT_STORE_OP_STORE:
            *rString += std::string("VK_ATTACHMENT_STORE_OP_STORE");
            return;
        case VK_ATTACHMENT_STORE_OP_DONT_CARE:
            *rString += std::string("VK_ATTACHMENT_STORE_OP_DONT_CARE");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkFramebufferCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkFramebufferCreateFlagBits enumValue = static_cast<VkFramebufferCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR:
            *rString += std::string("VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkFormat(std::string* rString, uint32_t enumValueInt32)
{
    VkFormat enumValue = static_cast<VkFormat>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FORMAT_ASTC_8x5_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_8x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_12x10_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_12x10_SRGB_BLOCK");
            return;
        case VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_D24_UNORM_S8_UINT:
            *rString += std::string("VK_FORMAT_D24_UNORM_S8_UINT");
            return;
        case VK_FORMAT_BC5_SNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC5_SNORM_BLOCK");
            return;
        case VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:
            *rString += std::string("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM");
            return;
        case VK_FORMAT_BC7_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC7_UNORM_BLOCK");
            return;
        case VK_FORMAT_R16G16B16A16_UINT:
            *rString += std::string("VK_FORMAT_R16G16B16A16_UINT");
            return;
        case VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_A2B10G10R10_UNORM_PACK32:
            *rString += std::string("VK_FORMAT_A2B10G10R10_UNORM_PACK32");
            return;
        case VK_FORMAT_B8G8R8_SSCALED:
            *rString += std::string("VK_FORMAT_B8G8R8_SSCALED");
            return;
        case VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_D16_UNORM_S8_UINT:
            *rString += std::string("VK_FORMAT_D16_UNORM_S8_UINT");
            return;
        case VK_FORMAT_BC1_RGBA_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_BC1_RGBA_SRGB_BLOCK");
            return;
        case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
            *rString += std::string("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM");
            return;
        case VK_FORMAT_D32_SFLOAT_S8_UINT:
            *rString += std::string("VK_FORMAT_D32_SFLOAT_S8_UINT");
            return;
        case VK_FORMAT_D16_UNORM:
            *rString += std::string("VK_FORMAT_D16_UNORM");
            return;
        case VK_FORMAT_A1R5G5B5_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_A1R5G5B5_UNORM_PACK16");
            return;
        case VK_FORMAT_R16G16B16_USCALED:
            *rString += std::string("VK_FORMAT_R16G16B16_USCALED");
            return;
        case VK_FORMAT_R64G64B64A64_UINT:
            *rString += std::string("VK_FORMAT_R64G64B64A64_UINT");
            return;
        case VK_FORMAT_R4G4B4A4_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_R4G4B4A4_UNORM_PACK16");
            return;
        case VK_FORMAT_B8G8R8G8_422_UNORM:
            *rString += std::string("VK_FORMAT_B8G8R8G8_422_UNORM");
            return;
        case VK_FORMAT_R16G16B16A16_UNORM:
            *rString += std::string("VK_FORMAT_R16G16B16A16_UNORM");
            return;
        case VK_FORMAT_R8G8B8A8_UINT:
            *rString += std::string("VK_FORMAT_R8G8B8A8_UINT");
            return;
        case VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_R64G64B64_UINT:
            *rString += std::string("VK_FORMAT_R64G64B64_UINT");
            return;
        case VK_FORMAT_ASTC_10x8_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x8_UNORM_BLOCK");
            return;
        case VK_FORMAT_R64G64B64A64_SFLOAT:
            *rString += std::string("VK_FORMAT_R64G64B64A64_SFLOAT");
            return;
        case VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
            *rString += std::string("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_R8_UINT:
            *rString += std::string("VK_FORMAT_R8_UINT");
            return;
        case VK_FORMAT_A8B8G8R8_UNORM_PACK32:
            *rString += std::string("VK_FORMAT_A8B8G8R8_UNORM_PACK32");
            return;
        case VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R16_SNORM:
            *rString += std::string("VK_FORMAT_R16_SNORM");
            return;
        case VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_5x4_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_5x4_UNORM_BLOCK");
            return;
        case VK_FORMAT_R32G32B32A32_SFLOAT:
            *rString += std::string("VK_FORMAT_R32G32B32A32_SFLOAT");
            return;
        case VK_FORMAT_R8G8B8A8_USCALED:
            *rString += std::string("VK_FORMAT_R8G8B8A8_USCALED");
            return;
        case VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:
            *rString += std::string("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM");
            return;
        case VK_FORMAT_R16G16B16_SSCALED:
            *rString += std::string("VK_FORMAT_R16G16B16_SSCALED");
            return;
        case VK_FORMAT_R16G16_SSCALED:
            *rString += std::string("VK_FORMAT_R16G16_SSCALED");
            return;
        case VK_FORMAT_A2R10G10B10_SSCALED_PACK32:
            *rString += std::string("VK_FORMAT_A2R10G10B10_SSCALED_PACK32");
            return;
        case VK_FORMAT_BC3_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC3_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R32G32_UINT:
            *rString += std::string("VK_FORMAT_R32G32_UINT");
            return;
        case VK_FORMAT_B10G11R11_UFLOAT_PACK32:
            *rString += std::string("VK_FORMAT_B10G11R11_UFLOAT_PACK32");
            return;
        case VK_FORMAT_A8B8G8R8_SINT_PACK32:
            *rString += std::string("VK_FORMAT_A8B8G8R8_SINT_PACK32");
            return;
        case VK_FORMAT_R8G8B8_UNORM:
            *rString += std::string("VK_FORMAT_R8G8B8_UNORM");
            return;
        case VK_FORMAT_X8_D24_UNORM_PACK32:
            *rString += std::string("VK_FORMAT_X8_D24_UNORM_PACK32");
            return;
        case VK_FORMAT_BC4_SNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC4_SNORM_BLOCK");
            return;
        case VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:
            *rString += std::string("VK_FORMAT_E5B9G9R9_UFLOAT_PACK32");
            return;
        case VK_FORMAT_R5G6B5_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_R5G6B5_UNORM_PACK16");
            return;
        case VK_FORMAT_R32G32B32A32_UINT:
            *rString += std::string("VK_FORMAT_R32G32B32A32_UINT");
            return;
        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_ASTC_10x10_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x10_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_12x12_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_12x12_SRGB_BLOCK");
            return;
        case VK_FORMAT_B8G8R8A8_SNORM:
            *rString += std::string("VK_FORMAT_B8G8R8A8_SNORM");
            return;
        case VK_FORMAT_EAC_R11_SNORM_BLOCK:
            *rString += std::string("VK_FORMAT_EAC_R11_SNORM_BLOCK");
            return;
        case VK_FORMAT_A2R10G10B10_UNORM_PACK32:
            *rString += std::string("VK_FORMAT_A2R10G10B10_UNORM_PACK32");
            return;
        case VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_R10X6G10X6_UNORM_2PACK16:
            *rString += std::string("VK_FORMAT_R10X6G10X6_UNORM_2PACK16");
            return;
        case VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
            *rString += std::string("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM");
            return;
        case VK_FORMAT_ASTC_8x8_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_8x8_SRGB_BLOCK");
            return;
        case VK_FORMAT_R16G16_SFLOAT:
            *rString += std::string("VK_FORMAT_R16G16_SFLOAT");
            return;
        case VK_FORMAT_R16_UNORM:
            *rString += std::string("VK_FORMAT_R16_UNORM");
            return;
        case VK_FORMAT_B8G8R8A8_SSCALED:
            *rString += std::string("VK_FORMAT_B8G8R8A8_SSCALED");
            return;
        case VK_FORMAT_R16G16B16_SINT:
            *rString += std::string("VK_FORMAT_R16G16B16_SINT");
            return;
        case VK_FORMAT_BC2_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC2_UNORM_BLOCK");
            return;
        case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_B8G8R8A8_UNORM:
            *rString += std::string("VK_FORMAT_B8G8R8A8_UNORM");
            return;
        case VK_FORMAT_A8B8G8R8_SNORM_PACK32:
            *rString += std::string("VK_FORMAT_A8B8G8R8_SNORM_PACK32");
            return;
        case VK_FORMAT_R8G8_SNORM:
            *rString += std::string("VK_FORMAT_R8G8_SNORM");
            return;
        case VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK");
            return;
        case VK_FORMAT_A8B8G8R8_SRGB_PACK32:
            *rString += std::string("VK_FORMAT_A8B8G8R8_SRGB_PACK32");
            return;
        case VK_FORMAT_R64_SFLOAT:
            *rString += std::string("VK_FORMAT_R64_SFLOAT");
            return;
        case VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:
            *rString += std::string("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM");
            return;
        case VK_FORMAT_R16G16B16_SNORM:
            *rString += std::string("VK_FORMAT_R16G16B16_SNORM");
            return;
        case VK_FORMAT_A2B10G10R10_SSCALED_PACK32:
            *rString += std::string("VK_FORMAT_A2B10G10R10_SSCALED_PACK32");
            return;
        case VK_FORMAT_BC6H_SFLOAT_BLOCK:
            *rString += std::string("VK_FORMAT_BC6H_SFLOAT_BLOCK");
            return;
        case VK_FORMAT_BC3_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_BC3_SRGB_BLOCK");
            return;
        case VK_FORMAT_R16G16B16A16_SSCALED:
            *rString += std::string("VK_FORMAT_R16G16B16A16_SSCALED");
            return;
        case VK_FORMAT_R32G32_SINT:
            *rString += std::string("VK_FORMAT_R32G32_SINT");
            return;
        case VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R16G16_USCALED:
            *rString += std::string("VK_FORMAT_R16G16_USCALED");
            return;
        case VK_FORMAT_R32_UINT:
            *rString += std::string("VK_FORMAT_R32_UINT");
            return;
        case VK_FORMAT_R32G32B32_UINT:
            *rString += std::string("VK_FORMAT_R32G32B32_UINT");
            return;
        case VK_FORMAT_G16B16G16R16_422_UNORM:
            *rString += std::string("VK_FORMAT_G16B16G16R16_422_UNORM");
            return;
        case VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_B8G8R8_SNORM:
            *rString += std::string("VK_FORMAT_B8G8R8_SNORM");
            return;
        case VK_FORMAT_R8G8B8_SINT:
            *rString += std::string("VK_FORMAT_R8G8B8_SINT");
            return;
        case VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK");
            return;
        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_B16G16R16G16_422_UNORM:
            *rString += std::string("VK_FORMAT_B16G16R16G16_422_UNORM");
            return;
        case VK_FORMAT_R8G8B8A8_SINT:
            *rString += std::string("VK_FORMAT_R8G8B8A8_SINT");
            return;
        case VK_FORMAT_A2B10G10R10_SNORM_PACK32:
            *rString += std::string("VK_FORMAT_A2B10G10R10_SNORM_PACK32");
            return;
        case VK_FORMAT_B8G8R8_USCALED:
            *rString += std::string("VK_FORMAT_B8G8R8_USCALED");
            return;
        case VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
            *rString += std::string("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_ASTC_6x5_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_6x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R5G5B5A1_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_R5G5B5A1_UNORM_PACK16");
            return;
        case VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK");
            return;
        case VK_FORMAT_R8_SRGB:
            *rString += std::string("VK_FORMAT_R8_SRGB");
            return;
        case VK_FORMAT_BC6H_UFLOAT_BLOCK:
            *rString += std::string("VK_FORMAT_BC6H_UFLOAT_BLOCK");
            return;
        case VK_FORMAT_ASTC_6x6_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_6x6_SRGB_BLOCK");
            return;
        case VK_FORMAT_S8_UINT:
            *rString += std::string("VK_FORMAT_S8_UINT");
            return;
        case VK_FORMAT_R8_SINT:
            *rString += std::string("VK_FORMAT_R8_SINT");
            return;
        case VK_FORMAT_BC4_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC4_UNORM_BLOCK");
            return;
        case VK_FORMAT_R64G64B64A64_SINT:
            *rString += std::string("VK_FORMAT_R64G64B64A64_SINT");
            return;
        case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16");
            return;
        case VK_FORMAT_ASTC_5x4_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_5x4_SRGB_BLOCK");
            return;
        case VK_FORMAT_R8G8B8_SRGB:
            *rString += std::string("VK_FORMAT_R8G8B8_SRGB");
            return;
        case VK_FORMAT_ASTC_10x6_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x6_SRGB_BLOCK");
            return;
        case VK_FORMAT_B4G4R4A4_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_B4G4R4A4_UNORM_PACK16");
            return;
        case VK_FORMAT_R16_UINT:
            *rString += std::string("VK_FORMAT_R16_UINT");
            return;
        case VK_FORMAT_ASTC_5x5_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_5x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_R16G16_UINT:
            *rString += std::string("VK_FORMAT_R16G16_UINT");
            return;
        case VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
            *rString += std::string("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM");
            return;
        case VK_FORMAT_ASTC_4x4_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_4x4_SRGB_BLOCK");
            return;
        case VK_FORMAT_A8B8G8R8_SSCALED_PACK32:
            *rString += std::string("VK_FORMAT_A8B8G8R8_SSCALED_PACK32");
            return;
        case VK_FORMAT_R10X6_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_R10X6_UNORM_PACK16");
            return;
        case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_R16_SFLOAT:
            *rString += std::string("VK_FORMAT_R16_SFLOAT");
            return;
        case VK_FORMAT_D32_SFLOAT:
            *rString += std::string("VK_FORMAT_D32_SFLOAT");
            return;
        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_B8G8R8A8_SINT:
            *rString += std::string("VK_FORMAT_B8G8R8A8_SINT");
            return;
        case VK_FORMAT_BC1_RGB_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC1_RGB_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_12x12_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_12x12_UNORM_BLOCK");
            return;
        case VK_FORMAT_R8_USCALED:
            *rString += std::string("VK_FORMAT_R8_USCALED");
            return;
        case VK_FORMAT_A2R10G10B10_UINT_PACK32:
            *rString += std::string("VK_FORMAT_A2R10G10B10_UINT_PACK32");
            return;
        case VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:
            *rString += std::string("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM");
            return;
        case VK_FORMAT_R8G8_SRGB:
            *rString += std::string("VK_FORMAT_R8G8_SRGB");
            return;
        case VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:
            *rString += std::string("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM");
            return;
        case VK_FORMAT_UNDEFINED:
            *rString += std::string("VK_FORMAT_UNDEFINED");
            return;
        case VK_FORMAT_R8G8B8_UINT:
            *rString += std::string("VK_FORMAT_R8G8B8_UINT");
            return;
        case VK_FORMAT_B8G8R8_SRGB:
            *rString += std::string("VK_FORMAT_B8G8R8_SRGB");
            return;
        case VK_FORMAT_R16G16_SNORM:
            *rString += std::string("VK_FORMAT_R16G16_SNORM");
            return;
        case VK_FORMAT_R64G64_SFLOAT:
            *rString += std::string("VK_FORMAT_R64G64_SFLOAT");
            return;
        case VK_FORMAT_R8G8B8_USCALED:
            *rString += std::string("VK_FORMAT_R8G8B8_USCALED");
            return;
        case VK_FORMAT_EAC_R11G11_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_EAC_R11G11_UNORM_BLOCK");
            return;
        case VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
            *rString += std::string("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_ASTC_10x8_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x8_SRGB_BLOCK");
            return;
        case VK_FORMAT_R8G8_SINT:
            *rString += std::string("VK_FORMAT_R8G8_SINT");
            return;
        case VK_FORMAT_A2R10G10B10_USCALED_PACK32:
            *rString += std::string("VK_FORMAT_A2R10G10B10_USCALED_PACK32");
            return;
        case VK_FORMAT_R16G16_SINT:
            *rString += std::string("VK_FORMAT_R16G16_SINT");
            return;
        case VK_FORMAT_R8G8_SSCALED:
            *rString += std::string("VK_FORMAT_R8G8_SSCALED");
            return;
        case VK_FORMAT_ASTC_8x6_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_8x6_UNORM_BLOCK");
            return;
        case VK_FORMAT_B5G6R5_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_B5G6R5_UNORM_PACK16");
            return;
        case VK_FORMAT_R8G8B8A8_SRGB:
            *rString += std::string("VK_FORMAT_R8G8B8A8_SRGB");
            return;
        case VK_FORMAT_R8G8_UNORM:
            *rString += std::string("VK_FORMAT_R8G8_UNORM");
            return;
        case VK_FORMAT_A2R10G10B10_SNORM_PACK32:
            *rString += std::string("VK_FORMAT_A2R10G10B10_SNORM_PACK32");
            return;
        case VK_FORMAT_R32G32B32A32_SINT:
            *rString += std::string("VK_FORMAT_R32G32B32A32_SINT");
            return;
        case VK_FORMAT_ASTC_10x5_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_R8_SNORM:
            *rString += std::string("VK_FORMAT_R8_SNORM");
            return;
        case VK_FORMAT_R8_UNORM:
            *rString += std::string("VK_FORMAT_R8_UNORM");
            return;
        case VK_FORMAT_A8B8G8R8_UINT_PACK32:
            *rString += std::string("VK_FORMAT_A8B8G8R8_UINT_PACK32");
            return;
        case VK_FORMAT_A2R10G10B10_SINT_PACK32:
            *rString += std::string("VK_FORMAT_A2R10G10B10_SINT_PACK32");
            return;
        case VK_FORMAT_R32G32B32_SFLOAT:
            *rString += std::string("VK_FORMAT_R32G32B32_SFLOAT");
            return;
        case VK_FORMAT_R12X4_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_R12X4_UNORM_PACK16");
            return;
        case VK_FORMAT_B8G8R8_UINT:
            *rString += std::string("VK_FORMAT_B8G8R8_UINT");
            return;
        case VK_FORMAT_R12X4G12X4_UNORM_2PACK16:
            *rString += std::string("VK_FORMAT_R12X4G12X4_UNORM_2PACK16");
            return;
        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_B8G8R8_UNORM:
            *rString += std::string("VK_FORMAT_B8G8R8_UNORM");
            return;
        case VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_R16_SSCALED:
            *rString += std::string("VK_FORMAT_R16_SSCALED");
            return;
        case VK_FORMAT_B8G8R8A8_USCALED:
            *rString += std::string("VK_FORMAT_B8G8R8A8_USCALED");
            return;
        case VK_FORMAT_R32G32B32_SINT:
            *rString += std::string("VK_FORMAT_R32G32B32_SINT");
            return;
        case VK_FORMAT_ASTC_10x10_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x10_SRGB_BLOCK");
            return;
        case VK_FORMAT_A2B10G10R10_UINT_PACK32:
            *rString += std::string("VK_FORMAT_A2B10G10R10_UINT_PACK32");
            return;
        case VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:
            *rString += std::string("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM");
            return;
        case VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_8x6_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_8x6_SRGB_BLOCK");
            return;
        case VK_FORMAT_ASTC_8x8_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_8x8_UNORM_BLOCK");
            return;
        case VK_FORMAT_G8B8G8R8_422_UNORM:
            *rString += std::string("VK_FORMAT_G8B8G8R8_422_UNORM");
            return;
        case VK_FORMAT_EAC_R11G11_SNORM_BLOCK:
            *rString += std::string("VK_FORMAT_EAC_R11G11_SNORM_BLOCK");
            return;
        case VK_FORMAT_R32_SFLOAT:
            *rString += std::string("VK_FORMAT_R32_SFLOAT");
            return;
        case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16");
            return;
        case VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_BC5_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC5_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R16G16B16A16_SFLOAT:
            *rString += std::string("VK_FORMAT_R16G16B16A16_SFLOAT");
            return;
        case VK_FORMAT_A2B10G10R10_USCALED_PACK32:
            *rString += std::string("VK_FORMAT_A2B10G10R10_USCALED_PACK32");
            return;
        case VK_FORMAT_R8G8_UINT:
            *rString += std::string("VK_FORMAT_R8G8_UINT");
            return;
        case VK_FORMAT_A8B8G8R8_USCALED_PACK32:
            *rString += std::string("VK_FORMAT_A8B8G8R8_USCALED_PACK32");
            return;
        case VK_FORMAT_B8G8R8A8_UINT:
            *rString += std::string("VK_FORMAT_B8G8R8A8_UINT");
            return;
        case VK_FORMAT_A2B10G10R10_SINT_PACK32:
            *rString += std::string("VK_FORMAT_A2B10G10R10_SINT_PACK32");
            return;
        case VK_FORMAT_EAC_R11_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_EAC_R11_UNORM_BLOCK");
            return;
        case VK_FORMAT_B8G8R8A8_SRGB:
            *rString += std::string("VK_FORMAT_B8G8R8A8_SRGB");
            return;
        case VK_FORMAT_R16G16B16_UNORM:
            *rString += std::string("VK_FORMAT_R16G16B16_UNORM");
            return;
        case VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:
            *rString += std::string("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16");
            return;
        case VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R64G64_SINT:
            *rString += std::string("VK_FORMAT_R64G64_SINT");
            return;
        case VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG");
            return;
        case VK_FORMAT_BC2_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_BC2_SRGB_BLOCK");
            return;
        case VK_FORMAT_R16G16B16A16_SNORM:
            *rString += std::string("VK_FORMAT_R16G16B16A16_SNORM");
            return;
        case VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R8G8B8A8_UNORM:
            *rString += std::string("VK_FORMAT_R8G8B8A8_UNORM");
            return;
        case VK_FORMAT_R16G16B16_UINT:
            *rString += std::string("VK_FORMAT_R16G16B16_UINT");
            return;
        case VK_FORMAT_ASTC_6x6_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_6x6_UNORM_BLOCK");
            return;
        case VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
            *rString += std::string("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM");
            return;
        case VK_FORMAT_R8G8B8A8_SNORM:
            *rString += std::string("VK_FORMAT_R8G8B8A8_SNORM");
            return;
        case VK_FORMAT_R64_UINT:
            *rString += std::string("VK_FORMAT_R64_UINT");
            return;
        case VK_FORMAT_R16G16B16A16_SINT:
            *rString += std::string("VK_FORMAT_R16G16B16A16_SINT");
            return;
        case VK_FORMAT_ASTC_5x5_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_5x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_R16G16B16_SFLOAT:
            *rString += std::string("VK_FORMAT_R16G16B16_SFLOAT");
            return;
        case VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_B8G8R8_SINT:
            *rString += std::string("VK_FORMAT_B8G8R8_SINT");
            return;
        case VK_FORMAT_B5G5R5A1_UNORM_PACK16:
            *rString += std::string("VK_FORMAT_B5G5R5A1_UNORM_PACK16");
            return;
        case VK_FORMAT_R16G16_UNORM:
            *rString += std::string("VK_FORMAT_R16G16_UNORM");
            return;
        case VK_FORMAT_ASTC_10x5_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:
            *rString += std::string("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16");
            return;
        case VK_FORMAT_R32G32_SFLOAT:
            *rString += std::string("VK_FORMAT_R32G32_SFLOAT");
            return;
        case VK_FORMAT_R64_SINT:
            *rString += std::string("VK_FORMAT_R64_SINT");
            return;
        case VK_FORMAT_ASTC_4x4_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_4x4_UNORM_BLOCK");
            return;
        case VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
            *rString += std::string("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16");
            return;
        case VK_FORMAT_R8G8B8_SSCALED:
            *rString += std::string("VK_FORMAT_R8G8B8_SSCALED");
            return;
        case VK_FORMAT_R8G8B8A8_SSCALED:
            *rString += std::string("VK_FORMAT_R8G8B8A8_SSCALED");
            return;
        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16");
            return;
        case VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT:
            *rString += std::string("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT");
            return;
        case VK_FORMAT_R8_SSCALED:
            *rString += std::string("VK_FORMAT_R8_SSCALED");
            return;
        case VK_FORMAT_R16G16B16A16_USCALED:
            *rString += std::string("VK_FORMAT_R16G16B16A16_USCALED");
            return;
        case VK_FORMAT_BC1_RGBA_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_BC1_RGBA_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_12x10_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_12x10_UNORM_BLOCK");
            return;
        case VK_FORMAT_R32_SINT:
            *rString += std::string("VK_FORMAT_R32_SINT");
            return;
        case VK_FORMAT_R64G64B64_SINT:
            *rString += std::string("VK_FORMAT_R64G64B64_SINT");
            return;
        case VK_FORMAT_BC7_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_BC7_SRGB_BLOCK");
            return;
        case VK_FORMAT_R16_USCALED:
            *rString += std::string("VK_FORMAT_R16_USCALED");
            return;
        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
            *rString += std::string("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16");
            return;
        case VK_FORMAT_R8G8B8_SNORM:
            *rString += std::string("VK_FORMAT_R8G8B8_SNORM");
            return;
        case VK_FORMAT_ASTC_10x6_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_10x6_UNORM_BLOCK");
            return;
        case VK_FORMAT_ASTC_6x5_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_6x5_SRGB_BLOCK");
            return;
        case VK_FORMAT_R64G64_UINT:
            *rString += std::string("VK_FORMAT_R64G64_UINT");
            return;
        case VK_FORMAT_BC1_RGB_SRGB_BLOCK:
            *rString += std::string("VK_FORMAT_BC1_RGB_SRGB_BLOCK");
            return;
        case VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG:
            *rString += std::string("VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG");
            return;
        case VK_FORMAT_R16_SINT:
            *rString += std::string("VK_FORMAT_R16_SINT");
            return;
        case VK_FORMAT_R8G8_USCALED:
            *rString += std::string("VK_FORMAT_R8G8_USCALED");
            return;
        case VK_FORMAT_ASTC_8x5_UNORM_BLOCK:
            *rString += std::string("VK_FORMAT_ASTC_8x5_UNORM_BLOCK");
            return;
        case VK_FORMAT_R4G4_UNORM_PACK8:
            *rString += std::string("VK_FORMAT_R4G4_UNORM_PACK8");
            return;
        case VK_FORMAT_R64G64B64_SFLOAT:
            *rString += std::string("VK_FORMAT_R64G64B64_SFLOAT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCommandPoolResetFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkCommandPoolResetFlagBits enumValue = static_cast<VkCommandPoolResetFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT:
            *rString += std::string("VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDynamicState(std::string* rString, uint32_t enumValueInt32)
{
    VkDynamicState enumValue = static_cast<VkDynamicState>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV:
            *rString += std::string("VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV");
            return;
        case VK_DYNAMIC_STATE_VIEWPORT:
            *rString += std::string("VK_DYNAMIC_STATE_VIEWPORT");
            return;
        case VK_DYNAMIC_STATE_LINE_WIDTH:
            *rString += std::string("VK_DYNAMIC_STATE_LINE_WIDTH");
            return;
        case VK_DYNAMIC_STATE_STENCIL_WRITE_MASK:
            *rString += std::string("VK_DYNAMIC_STATE_STENCIL_WRITE_MASK");
            return;
        case VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT:
            *rString += std::string("VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT");
            return;
        case VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV:
            *rString += std::string("VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV");
            return;
        case VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT:
            *rString += std::string("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT");
            return;
        case VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV:
            *rString += std::string("VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV");
            return;
        case VK_DYNAMIC_STATE_DEPTH_BOUNDS:
            *rString += std::string("VK_DYNAMIC_STATE_DEPTH_BOUNDS");
            return;
        case VK_DYNAMIC_STATE_DEPTH_BIAS:
            *rString += std::string("VK_DYNAMIC_STATE_DEPTH_BIAS");
            return;
        case VK_DYNAMIC_STATE_LINE_STIPPLE_EXT:
            *rString += std::string("VK_DYNAMIC_STATE_LINE_STIPPLE_EXT");
            return;
        case VK_DYNAMIC_STATE_BLEND_CONSTANTS:
            *rString += std::string("VK_DYNAMIC_STATE_BLEND_CONSTANTS");
            return;
        case VK_DYNAMIC_STATE_SCISSOR:
            *rString += std::string("VK_DYNAMIC_STATE_SCISSOR");
            return;
        case VK_DYNAMIC_STATE_STENCIL_REFERENCE:
            *rString += std::string("VK_DYNAMIC_STATE_STENCIL_REFERENCE");
            return;
        case VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV:
            *rString += std::string("VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV");
            return;
        case VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK:
            *rString += std::string("VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSamplerAddressMode(std::string* rString, uint32_t enumValueInt32)
{
    VkSamplerAddressMode enumValue = static_cast<VkSamplerAddressMode>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER:
            *rString += std::string("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER");
            return;
        case VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE:
            *rString += std::string("VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE");
            return;
        case VK_SAMPLER_ADDRESS_MODE_REPEAT:
            *rString += std::string("VK_SAMPLER_ADDRESS_MODE_REPEAT");
            return;
        case VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE:
            *rString += std::string("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE");
            return;
        case VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT:
            *rString += std::string("VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkStructureType(std::string* rString, uint32_t enumValueInt32)
{
    VkStructureType enumValue = static_cast<VkStructureType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
            *rString += std::string("VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE");
            return;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_APPLICATION_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_APPLICATION_INFO");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX");
            return;
        case VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO");
            return;
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
            *rString += std::string("VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
            *rString += std::string("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO");
            return;
        case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
            *rString += std::string("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN:
            *rString += std::string("VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN");
            return;
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_BARRIER");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT");
            return;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
            *rString += std::string("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SUBMIT_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_SUBMIT_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
            *rString += std::string("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO");
            return;
        case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD");
            return;
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD");
            return;
        case VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK:
            *rString += std::string("VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
            *rString += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
            *rString += std::string("VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
            *rString += std::string("VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
            *rString += std::string("VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE");
            return;
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
            *rString += std::string("VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_GEOMETRY_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_GEOMETRY_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_HDR_METADATA_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
            *rString += std::string("VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
            *rString += std::string("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
            *rString += std::string("VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
            *rString += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_FENCE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
            *rString += std::string("VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX:
            *rString += std::string("VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX");
            return;
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT");
            return;
        case VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
            *rString += std::string("VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2");
            return;
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK:
            *rString += std::string("VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL:
            *rString += std::string("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT");
            return;
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
            *rString += std::string("VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2");
            return;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO");
            return;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV");
            return;
        case VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
            *rString += std::string("VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_EVENT_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2");
            return;
        case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_PRESENT_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV");
            return;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR");
            return;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV");
            return;
        case VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR");
            return;
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
            *rString += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
            *rString += std::string("VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL");
            return;
        case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BIND_SPARSE_INFO");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
            *rString += std::string("VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO");
            return;
        case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
            *rString += std::string("VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV");
            return;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT");
            return;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT");
            return;
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR:
            *rString += std::string("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR");
            return;
        case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT");
            return;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
            *rString += std::string("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageUsageFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkImageUsageFlagBits enumValue = static_cast<VkImageUsageFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_USAGE_TRANSFER_DST_BIT:
            *rString += std::string("VK_IMAGE_USAGE_TRANSFER_DST_BIT");
            return;
        case VK_IMAGE_USAGE_TRANSFER_SRC_BIT:
            *rString += std::string("VK_IMAGE_USAGE_TRANSFER_SRC_BIT");
            return;
        case VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT:
            *rString += std::string("VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV:
            *rString += std::string("VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV");
            return;
        case VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT:
            *rString += std::string("VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT:
            *rString += std::string("VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT:
            *rString += std::string("VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT");
            return;
        case VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT:
            *rString += std::string("VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT");
            return;
        case VK_IMAGE_USAGE_SAMPLED_BIT:
            *rString += std::string("VK_IMAGE_USAGE_SAMPLED_BIT");
            return;
        case VK_IMAGE_USAGE_STORAGE_BIT:
            *rString += std::string("VK_IMAGE_USAGE_STORAGE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkShaderStageFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkShaderStageFlagBits enumValue = static_cast<VkShaderStageFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SHADER_STAGE_GEOMETRY_BIT:
            *rString += std::string("VK_SHADER_STAGE_GEOMETRY_BIT");
            return;
        case VK_SHADER_STAGE_CALLABLE_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_CALLABLE_BIT_NV");
            return;
        case VK_SHADER_STAGE_TASK_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_TASK_BIT_NV");
            return;
        case VK_SHADER_STAGE_RAYGEN_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_RAYGEN_BIT_NV");
            return;
        case VK_SHADER_STAGE_FRAGMENT_BIT:
            *rString += std::string("VK_SHADER_STAGE_FRAGMENT_BIT");
            return;
        case VK_SHADER_STAGE_MESH_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_MESH_BIT_NV");
            return;
        case VK_SHADER_STAGE_INTERSECTION_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_INTERSECTION_BIT_NV");
            return;
        case VK_SHADER_STAGE_VERTEX_BIT:
            *rString += std::string("VK_SHADER_STAGE_VERTEX_BIT");
            return;
        case VK_SHADER_STAGE_ALL:
            *rString += std::string("VK_SHADER_STAGE_ALL");
            return;
        case VK_SHADER_STAGE_MISS_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_MISS_BIT_NV");
            return;
        case VK_SHADER_STAGE_ANY_HIT_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_ANY_HIT_BIT_NV");
            return;
        case VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT:
            *rString += std::string("VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT");
            return;
        case VK_SHADER_STAGE_ALL_GRAPHICS:
            *rString += std::string("VK_SHADER_STAGE_ALL_GRAPHICS");
            return;
        case VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT:
            *rString += std::string("VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT");
            return;
        case VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV:
            *rString += std::string("VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV");
            return;
        case VK_SHADER_STAGE_COMPUTE_BIT:
            *rString += std::string("VK_SHADER_STAGE_COMPUTE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSparseMemoryBindFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkSparseMemoryBindFlagBits enumValue = static_cast<VkSparseMemoryBindFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SPARSE_MEMORY_BIND_METADATA_BIT:
            *rString += std::string("VK_SPARSE_MEMORY_BIND_METADATA_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkVertexInputRate(std::string* rString, uint32_t enumValueInt32)
{
    VkVertexInputRate enumValue = static_cast<VkVertexInputRate>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_VERTEX_INPUT_RATE_VERTEX:
            *rString += std::string("VK_VERTEX_INPUT_RATE_VERTEX");
            return;
        case VK_VERTEX_INPUT_RATE_INSTANCE:
            *rString += std::string("VK_VERTEX_INPUT_RATE_INSTANCE");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPolygonMode(std::string* rString, uint32_t enumValueInt32)
{
    VkPolygonMode enumValue = static_cast<VkPolygonMode>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_POLYGON_MODE_FILL_RECTANGLE_NV:
            *rString += std::string("VK_POLYGON_MODE_FILL_RECTANGLE_NV");
            return;
        case VK_POLYGON_MODE_FILL:
            *rString += std::string("VK_POLYGON_MODE_FILL");
            return;
        case VK_POLYGON_MODE_LINE:
            *rString += std::string("VK_POLYGON_MODE_LINE");
            return;
        case VK_POLYGON_MODE_POINT:
            *rString += std::string("VK_POLYGON_MODE_POINT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCommandBufferUsageFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkCommandBufferUsageFlagBits enumValue = static_cast<VkCommandBufferUsageFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT:
            *rString += std::string("VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT");
            return;
        case VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:
            *rString += std::string("VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT");
            return;
        case VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:
            *rString += std::string("VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkImageCreateFlagBits enumValue = static_cast<VkImageCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT:
            *rString += std::string("VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT");
            return;
        case VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT:
            *rString += std::string("VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT");
            return;
        case VK_IMAGE_CREATE_PROTECTED_BIT:
            *rString += std::string("VK_IMAGE_CREATE_PROTECTED_BIT");
            return;
        case VK_IMAGE_CREATE_EXTENDED_USAGE_BIT:
            *rString += std::string("VK_IMAGE_CREATE_EXTENDED_USAGE_BIT");
            return;
        case VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT:
            *rString += std::string("VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT");
            return;
        case VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT:
            *rString += std::string("VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT");
            return;
        case VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT:
            *rString += std::string("VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT");
            return;
        case VK_IMAGE_CREATE_SPARSE_BINDING_BIT:
            *rString += std::string("VK_IMAGE_CREATE_SPARSE_BINDING_BIT");
            return;
        case VK_IMAGE_CREATE_ALIAS_BIT:
            *rString += std::string("VK_IMAGE_CREATE_ALIAS_BIT");
            return;
        case VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT:
            *rString += std::string("VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT");
            return;
        case VK_IMAGE_CREATE_DISJOINT_BIT:
            *rString += std::string("VK_IMAGE_CREATE_DISJOINT_BIT");
            return;
        case VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV:
            *rString += std::string("VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV");
            return;
        case VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT:
            *rString += std::string("VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT");
            return;
        case VK_IMAGE_CREATE_SPARSE_ALIASED_BIT:
            *rString += std::string("VK_IMAGE_CREATE_SPARSE_ALIASED_BIT");
            return;
        case VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT:
            *rString += std::string("VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPipelineCacheHeaderVersion(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineCacheHeaderVersion enumValue = static_cast<VkPipelineCacheHeaderVersion>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PIPELINE_CACHE_HEADER_VERSION_ONE:
            *rString += std::string("VK_PIPELINE_CACHE_HEADER_VERSION_ONE");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkQueryPipelineStatisticFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkQueryPipelineStatisticFlagBits enumValue = static_cast<VkQueryPipelineStatisticFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT");
            return;
        case VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT:
            *rString += std::string("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageViewType(std::string* rString, uint32_t enumValueInt32)
{
    VkImageViewType enumValue = static_cast<VkImageViewType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_VIEW_TYPE_CUBE:
            *rString += std::string("VK_IMAGE_VIEW_TYPE_CUBE");
            return;
        case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY:
            *rString += std::string("VK_IMAGE_VIEW_TYPE_CUBE_ARRAY");
            return;
        case VK_IMAGE_VIEW_TYPE_1D_ARRAY:
            *rString += std::string("VK_IMAGE_VIEW_TYPE_1D_ARRAY");
            return;
        case VK_IMAGE_VIEW_TYPE_1D:
            *rString += std::string("VK_IMAGE_VIEW_TYPE_1D");
            return;
        case VK_IMAGE_VIEW_TYPE_2D:
            *rString += std::string("VK_IMAGE_VIEW_TYPE_2D");
            return;
        case VK_IMAGE_VIEW_TYPE_3D:
            *rString += std::string("VK_IMAGE_VIEW_TYPE_3D");
            return;
        case VK_IMAGE_VIEW_TYPE_2D_ARRAY:
            *rString += std::string("VK_IMAGE_VIEW_TYPE_2D_ARRAY");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCommandBufferLevel(std::string* rString, uint32_t enumValueInt32)
{
    VkCommandBufferLevel enumValue = static_cast<VkCommandBufferLevel>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMMAND_BUFFER_LEVEL_SECONDARY:
            *rString += std::string("VK_COMMAND_BUFFER_LEVEL_SECONDARY");
            return;
        case VK_COMMAND_BUFFER_LEVEL_PRIMARY:
            *rString += std::string("VK_COMMAND_BUFFER_LEVEL_PRIMARY");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkBufferCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkBufferCreateFlagBits enumValue = static_cast<VkBufferCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_BUFFER_CREATE_PROTECTED_BIT:
            *rString += std::string("VK_BUFFER_CREATE_PROTECTED_BIT");
            return;
        case VK_BUFFER_CREATE_SPARSE_BINDING_BIT:
            *rString += std::string("VK_BUFFER_CREATE_SPARSE_BINDING_BIT");
            return;
        case VK_BUFFER_CREATE_SPARSE_ALIASED_BIT:
            *rString += std::string("VK_BUFFER_CREATE_SPARSE_ALIASED_BIT");
            return;
        case VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT:
            *rString += std::string("VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT");
            return;
        case VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT:
            *rString += std::string("VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkFenceCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkFenceCreateFlagBits enumValue = static_cast<VkFenceCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FENCE_CREATE_SIGNALED_BIT:
            *rString += std::string("VK_FENCE_CREATE_SIGNALED_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPhysicalDeviceType(std::string* rString, uint32_t enumValueInt32)
{
    VkPhysicalDeviceType enumValue = static_cast<VkPhysicalDeviceType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PHYSICAL_DEVICE_TYPE_OTHER:
            *rString += std::string("VK_PHYSICAL_DEVICE_TYPE_OTHER");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_CPU:
            *rString += std::string("VK_PHYSICAL_DEVICE_TYPE_CPU");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
            *rString += std::string("VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
            *rString += std::string("VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU");
            return;
        case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
            *rString += std::string("VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkLogicOp(std::string* rString, uint32_t enumValueInt32)
{
    VkLogicOp enumValue = static_cast<VkLogicOp>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_LOGIC_OP_NOR:
            *rString += std::string("VK_LOGIC_OP_NOR");
            return;
        case VK_LOGIC_OP_COPY:
            *rString += std::string("VK_LOGIC_OP_COPY");
            return;
        case VK_LOGIC_OP_EQUIVALENT:
            *rString += std::string("VK_LOGIC_OP_EQUIVALENT");
            return;
        case VK_LOGIC_OP_AND:
            *rString += std::string("VK_LOGIC_OP_AND");
            return;
        case VK_LOGIC_OP_OR:
            *rString += std::string("VK_LOGIC_OP_OR");
            return;
        case VK_LOGIC_OP_NO_OP:
            *rString += std::string("VK_LOGIC_OP_NO_OP");
            return;
        case VK_LOGIC_OP_AND_INVERTED:
            *rString += std::string("VK_LOGIC_OP_AND_INVERTED");
            return;
        case VK_LOGIC_OP_CLEAR:
            *rString += std::string("VK_LOGIC_OP_CLEAR");
            return;
        case VK_LOGIC_OP_INVERT:
            *rString += std::string("VK_LOGIC_OP_INVERT");
            return;
        case VK_LOGIC_OP_COPY_INVERTED:
            *rString += std::string("VK_LOGIC_OP_COPY_INVERTED");
            return;
        case VK_LOGIC_OP_SET:
            *rString += std::string("VK_LOGIC_OP_SET");
            return;
        case VK_LOGIC_OP_AND_REVERSE:
            *rString += std::string("VK_LOGIC_OP_AND_REVERSE");
            return;
        case VK_LOGIC_OP_OR_REVERSE:
            *rString += std::string("VK_LOGIC_OP_OR_REVERSE");
            return;
        case VK_LOGIC_OP_NAND:
            *rString += std::string("VK_LOGIC_OP_NAND");
            return;
        case VK_LOGIC_OP_XOR:
            *rString += std::string("VK_LOGIC_OP_XOR");
            return;
        case VK_LOGIC_OP_OR_INVERTED:
            *rString += std::string("VK_LOGIC_OP_OR_INVERTED");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageLayout(std::string* rString, uint32_t enumValueInt32)
{
    VkImageLayout enumValue = static_cast<VkImageLayout>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_PREINITIALIZED:
            *rString += std::string("VK_IMAGE_LAYOUT_PREINITIALIZED");
            return;
        case VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_GENERAL:
            *rString += std::string("VK_IMAGE_LAYOUT_GENERAL");
            return;
        case VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV:
            *rString += std::string("VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV");
            return;
        case VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT:
            *rString += std::string("VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT");
            return;
        case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:
            *rString += std::string("VK_IMAGE_LAYOUT_PRESENT_SRC_KHR");
            return;
        case VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR:
            *rString += std::string("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR");
            return;
        case VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
            *rString += std::string("VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL");
            return;
        case VK_IMAGE_LAYOUT_UNDEFINED:
            *rString += std::string("VK_IMAGE_LAYOUT_UNDEFINED");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkBorderColor(std::string* rString, uint32_t enumValueInt32)
{
    VkBorderColor enumValue = static_cast<VkBorderColor>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_BORDER_COLOR_INT_OPAQUE_BLACK:
            *rString += std::string("VK_BORDER_COLOR_INT_OPAQUE_BLACK");
            return;
        case VK_BORDER_COLOR_INT_OPAQUE_WHITE:
            *rString += std::string("VK_BORDER_COLOR_INT_OPAQUE_WHITE");
            return;
        case VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK:
            *rString += std::string("VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK");
            return;
        case VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE:
            *rString += std::string("VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE");
            return;
        case VK_BORDER_COLOR_INT_TRANSPARENT_BLACK:
            *rString += std::string("VK_BORDER_COLOR_INT_TRANSPARENT_BLACK");
            return;
        case VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK:
            *rString += std::string("VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkMemoryPropertyFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkMemoryPropertyFlagBits enumValue = static_cast<VkMemoryPropertyFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT:
            *rString += std::string("VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT");
            return;
        case VK_MEMORY_PROPERTY_HOST_CACHED_BIT:
            *rString += std::string("VK_MEMORY_PROPERTY_HOST_CACHED_BIT");
            return;
        case VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD:
            *rString += std::string("VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD");
            return;
        case VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT:
            *rString += std::string("VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT");
            return;
        case VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT:
            *rString += std::string("VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT");
            return;
        case VK_MEMORY_PROPERTY_PROTECTED_BIT:
            *rString += std::string("VK_MEMORY_PROPERTY_PROTECTED_BIT");
            return;
        case VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD:
            *rString += std::string("VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD");
            return;
        case VK_MEMORY_PROPERTY_HOST_COHERENT_BIT:
            *rString += std::string("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageViewCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkImageViewCreateFlagBits enumValue = static_cast<VkImageViewCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT:
            *rString += std::string("VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCompareOp(std::string* rString, uint32_t enumValueInt32)
{
    VkCompareOp enumValue = static_cast<VkCompareOp>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMPARE_OP_LESS:
            *rString += std::string("VK_COMPARE_OP_LESS");
            return;
        case VK_COMPARE_OP_EQUAL:
            *rString += std::string("VK_COMPARE_OP_EQUAL");
            return;
        case VK_COMPARE_OP_GREATER:
            *rString += std::string("VK_COMPARE_OP_GREATER");
            return;
        case VK_COMPARE_OP_LESS_OR_EQUAL:
            *rString += std::string("VK_COMPARE_OP_LESS_OR_EQUAL");
            return;
        case VK_COMPARE_OP_NOT_EQUAL:
            *rString += std::string("VK_COMPARE_OP_NOT_EQUAL");
            return;
        case VK_COMPARE_OP_GREATER_OR_EQUAL:
            *rString += std::string("VK_COMPARE_OP_GREATER_OR_EQUAL");
            return;
        case VK_COMPARE_OP_ALWAYS:
            *rString += std::string("VK_COMPARE_OP_ALWAYS");
            return;
        case VK_COMPARE_OP_NEVER:
            *rString += std::string("VK_COMPARE_OP_NEVER");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkFormatFeatureFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkFormatFeatureFlagBits enumValue = static_cast<VkFormatFeatureFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT");
            return;
        case VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT");
            return;
        case VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT");
            return;
        case VK_FORMAT_FEATURE_TRANSFER_DST_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_TRANSFER_DST_BIT");
            return;
        case VK_FORMAT_FEATURE_BLIT_SRC_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_BLIT_SRC_BIT");
            return;
        case VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT");
            return;
        case VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT");
            return;
        case VK_FORMAT_FEATURE_BLIT_DST_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_BLIT_DST_BIT");
            return;
        case VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT");
            return;
        case VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT");
            return;
        case VK_FORMAT_FEATURE_TRANSFER_SRC_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_TRANSFER_SRC_BIT");
            return;
        case VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT");
            return;
        case VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT");
            return;
        case VK_FORMAT_FEATURE_DISJOINT_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_DISJOINT_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG");
            return;
        case VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT:
            *rString += std::string("VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT");
            return;
        case VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT");
            return;
        case VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT:
            *rString += std::string("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT");
            return;
        case VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT");
            return;
        case VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT:
            *rString += std::string("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkMemoryHeapFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkMemoryHeapFlagBits enumValue = static_cast<VkMemoryHeapFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_MEMORY_HEAP_MULTI_INSTANCE_BIT:
            *rString += std::string("VK_MEMORY_HEAP_MULTI_INSTANCE_BIT");
            return;
        case VK_MEMORY_HEAP_DEVICE_LOCAL_BIT:
            *rString += std::string("VK_MEMORY_HEAP_DEVICE_LOCAL_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkBufferUsageFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkBufferUsageFlagBits enumValue = static_cast<VkBufferUsageFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT:
            *rString += std::string("VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_TRANSFER_DST_BIT:
            *rString += std::string("VK_BUFFER_USAGE_TRANSFER_DST_BIT");
            return;
        case VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT:
            *rString += std::string("VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT:
            *rString += std::string("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_TRANSFER_SRC_BIT:
            *rString += std::string("VK_BUFFER_USAGE_TRANSFER_SRC_BIT");
            return;
        case VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT:
            *rString += std::string("VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT:
            *rString += std::string("VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT:
            *rString += std::string("VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_STORAGE_BUFFER_BIT:
            *rString += std::string("VK_BUFFER_USAGE_STORAGE_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT:
            *rString += std::string("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_RAY_TRACING_BIT_NV:
            *rString += std::string("VK_BUFFER_USAGE_RAY_TRACING_BIT_NV");
            return;
        case VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT:
            *rString += std::string("VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT");
            return;
        case VK_BUFFER_USAGE_INDEX_BUFFER_BIT:
            *rString += std::string("VK_BUFFER_USAGE_INDEX_BUFFER_BIT");
            return;
        case VK_BUFFER_USAGE_VERTEX_BUFFER_BIT:
            *rString += std::string("VK_BUFFER_USAGE_VERTEX_BUFFER_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkQueryResultFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkQueryResultFlagBits enumValue = static_cast<VkQueryResultFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_QUERY_RESULT_64_BIT:
            *rString += std::string("VK_QUERY_RESULT_64_BIT");
            return;
        case VK_QUERY_RESULT_WAIT_BIT:
            *rString += std::string("VK_QUERY_RESULT_WAIT_BIT");
            return;
        case VK_QUERY_RESULT_WITH_AVAILABILITY_BIT:
            *rString += std::string("VK_QUERY_RESULT_WITH_AVAILABILITY_BIT");
            return;
        case VK_QUERY_RESULT_PARTIAL_BIT:
            *rString += std::string("VK_QUERY_RESULT_PARTIAL_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDependencyFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkDependencyFlagBits enumValue = static_cast<VkDependencyFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEPENDENCY_VIEW_LOCAL_BIT:
            *rString += std::string("VK_DEPENDENCY_VIEW_LOCAL_BIT");
            return;
        case VK_DEPENDENCY_DEVICE_GROUP_BIT:
            *rString += std::string("VK_DEPENDENCY_DEVICE_GROUP_BIT");
            return;
        case VK_DEPENDENCY_BY_REGION_BIT:
            *rString += std::string("VK_DEPENDENCY_BY_REGION_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSamplerCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkSamplerCreateFlagBits enumValue = static_cast<VkSamplerCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT:
            *rString += std::string("VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT");
            return;
        case VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT:
            *rString += std::string("VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkIndexType(std::string* rString, uint32_t enumValueInt32)
{
    VkIndexType enumValue = static_cast<VkIndexType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_INDEX_TYPE_UINT32:
            *rString += std::string("VK_INDEX_TYPE_UINT32");
            return;
        case VK_INDEX_TYPE_UINT8_EXT:
            *rString += std::string("VK_INDEX_TYPE_UINT8_EXT");
            return;
        case VK_INDEX_TYPE_UINT16:
            *rString += std::string("VK_INDEX_TYPE_UINT16");
            return;
        case VK_INDEX_TYPE_NONE_NV:
            *rString += std::string("VK_INDEX_TYPE_NONE_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCommandBufferResetFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkCommandBufferResetFlagBits enumValue = static_cast<VkCommandBufferResetFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT:
            *rString += std::string("VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSharingMode(std::string* rString, uint32_t enumValueInt32)
{
    VkSharingMode enumValue = static_cast<VkSharingMode>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SHARING_MODE_EXCLUSIVE:
            *rString += std::string("VK_SHARING_MODE_EXCLUSIVE");
            return;
        case VK_SHARING_MODE_CONCURRENT:
            *rString += std::string("VK_SHARING_MODE_CONCURRENT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSystemAllocationScope(std::string* rString, uint32_t enumValueInt32)
{
    VkSystemAllocationScope enumValue = static_cast<VkSystemAllocationScope>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SYSTEM_ALLOCATION_SCOPE_CACHE:
            *rString += std::string("VK_SYSTEM_ALLOCATION_SCOPE_CACHE");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_COMMAND:
            *rString += std::string("VK_SYSTEM_ALLOCATION_SCOPE_COMMAND");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE:
            *rString += std::string("VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_DEVICE:
            *rString += std::string("VK_SYSTEM_ALLOCATION_SCOPE_DEVICE");
            return;
        case VK_SYSTEM_ALLOCATION_SCOPE_OBJECT:
            *rString += std::string("VK_SYSTEM_ALLOCATION_SCOPE_OBJECT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkAttachmentDescriptionFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkAttachmentDescriptionFlagBits enumValue = static_cast<VkAttachmentDescriptionFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT:
            *rString += std::string("VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkImageAspectFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkImageAspectFlagBits enumValue = static_cast<VkImageAspectFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT:
            *rString += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT");
            return;
        case VK_IMAGE_ASPECT_STENCIL_BIT:
            *rString += std::string("VK_IMAGE_ASPECT_STENCIL_BIT");
            return;
        case VK_IMAGE_ASPECT_PLANE_1_BIT:
            *rString += std::string("VK_IMAGE_ASPECT_PLANE_1_BIT");
            return;
        case VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT:
            *rString += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT");
            return;
        case VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT:
            *rString += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT");
            return;
        case VK_IMAGE_ASPECT_METADATA_BIT:
            *rString += std::string("VK_IMAGE_ASPECT_METADATA_BIT");
            return;
        case VK_IMAGE_ASPECT_COLOR_BIT:
            *rString += std::string("VK_IMAGE_ASPECT_COLOR_BIT");
            return;
        case VK_IMAGE_ASPECT_PLANE_0_BIT:
            *rString += std::string("VK_IMAGE_ASPECT_PLANE_0_BIT");
            return;
        case VK_IMAGE_ASPECT_DEPTH_BIT:
            *rString += std::string("VK_IMAGE_ASPECT_DEPTH_BIT");
            return;
        case VK_IMAGE_ASPECT_PLANE_2_BIT:
            *rString += std::string("VK_IMAGE_ASPECT_PLANE_2_BIT");
            return;
        case VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT:
            *rString += std::string("VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkAccessFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkAccessFlagBits enumValue = static_cast<VkAccessFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_ACCESS_INDEX_READ_BIT:
            *rString += std::string("VK_ACCESS_INDEX_READ_BIT");
            return;
        case VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT:
            *rString += std::string("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT");
            return;
        case VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT:
            *rString += std::string("VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT");
            return;
        case VK_ACCESS_TRANSFER_WRITE_BIT:
            *rString += std::string("VK_ACCESS_TRANSFER_WRITE_BIT");
            return;
        case VK_ACCESS_HOST_READ_BIT:
            *rString += std::string("VK_ACCESS_HOST_READ_BIT");
            return;
        case VK_ACCESS_TRANSFER_READ_BIT:
            *rString += std::string("VK_ACCESS_TRANSFER_READ_BIT");
            return;
        case VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV:
            *rString += std::string("VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV");
            return;
        case VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT:
            *rString += std::string("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT");
            return;
        case VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT:
            *rString += std::string("VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT");
            return;
        case VK_ACCESS_UNIFORM_READ_BIT:
            *rString += std::string("VK_ACCESS_UNIFORM_READ_BIT");
            return;
        case VK_ACCESS_INDIRECT_COMMAND_READ_BIT:
            *rString += std::string("VK_ACCESS_INDIRECT_COMMAND_READ_BIT");
            return;
        case VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX:
            *rString += std::string("VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX");
            return;
        case VK_ACCESS_SHADER_WRITE_BIT:
            *rString += std::string("VK_ACCESS_SHADER_WRITE_BIT");
            return;
        case VK_ACCESS_INPUT_ATTACHMENT_READ_BIT:
            *rString += std::string("VK_ACCESS_INPUT_ATTACHMENT_READ_BIT");
            return;
        case VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT:
            *rString += std::string("VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT");
            return;
        case VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT:
            *rString += std::string("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT");
            return;
        case VK_ACCESS_SHADER_READ_BIT:
            *rString += std::string("VK_ACCESS_SHADER_READ_BIT");
            return;
        case VK_ACCESS_MEMORY_WRITE_BIT:
            *rString += std::string("VK_ACCESS_MEMORY_WRITE_BIT");
            return;
        case VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV:
            *rString += std::string("VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV");
            return;
        case VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT:
            *rString += std::string("VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT");
            return;
        case VK_ACCESS_HOST_WRITE_BIT:
            *rString += std::string("VK_ACCESS_HOST_WRITE_BIT");
            return;
        case VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT:
            *rString += std::string("VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT");
            return;
        case VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV:
            *rString += std::string("VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV");
            return;
        case VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX:
            *rString += std::string("VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX");
            return;
        case VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT:
            *rString += std::string("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT");
            return;
        case VK_ACCESS_COLOR_ATTACHMENT_READ_BIT:
            *rString += std::string("VK_ACCESS_COLOR_ATTACHMENT_READ_BIT");
            return;
        case VK_ACCESS_MEMORY_READ_BIT:
            *rString += std::string("VK_ACCESS_MEMORY_READ_BIT");
            return;
        case VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT:
            *rString += std::string("VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCommandPoolCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkCommandPoolCreateFlagBits enumValue = static_cast<VkCommandPoolCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMMAND_POOL_CREATE_PROTECTED_BIT:
            *rString += std::string("VK_COMMAND_POOL_CREATE_PROTECTED_BIT");
            return;
        case VK_COMMAND_POOL_CREATE_TRANSIENT_BIT:
            *rString += std::string("VK_COMMAND_POOL_CREATE_TRANSIENT_BIT");
            return;
        case VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT:
            *rString += std::string("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSubpassContents(std::string* rString, uint32_t enumValueInt32)
{
    VkSubpassContents enumValue = static_cast<VkSubpassContents>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS:
            *rString += std::string("VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS");
            return;
        case VK_SUBPASS_CONTENTS_INLINE:
            *rString += std::string("VK_SUBPASS_CONTENTS_INLINE");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkObjectType(std::string* rString, uint32_t enumValueInt32)
{
    VkObjectType enumValue = static_cast<VkObjectType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_OBJECT_TYPE_BUFFER:
            *rString += std::string("VK_OBJECT_TYPE_BUFFER");
            return;
        case VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION:
            *rString += std::string("VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_POOL:
            *rString += std::string("VK_OBJECT_TYPE_DESCRIPTOR_POOL");
            return;
        case VK_OBJECT_TYPE_FENCE:
            *rString += std::string("VK_OBJECT_TYPE_FENCE");
            return;
        case VK_OBJECT_TYPE_SWAPCHAIN_KHR:
            *rString += std::string("VK_OBJECT_TYPE_SWAPCHAIN_KHR");
            return;
        case VK_OBJECT_TYPE_QUEUE:
            *rString += std::string("VK_OBJECT_TYPE_QUEUE");
            return;
        case VK_OBJECT_TYPE_IMAGE:
            *rString += std::string("VK_OBJECT_TYPE_IMAGE");
            return;
        case VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX:
            *rString += std::string("VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX");
            return;
        case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
            *rString += std::string("VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT");
            return;
        case VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL:
            *rString += std::string("VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL");
            return;
        case VK_OBJECT_TYPE_UNKNOWN:
            *rString += std::string("VK_OBJECT_TYPE_UNKNOWN");
            return;
        case VK_OBJECT_TYPE_SEMAPHORE:
            *rString += std::string("VK_OBJECT_TYPE_SEMAPHORE");
            return;
        case VK_OBJECT_TYPE_EVENT:
            *rString += std::string("VK_OBJECT_TYPE_EVENT");
            return;
        case VK_OBJECT_TYPE_FRAMEBUFFER:
            *rString += std::string("VK_OBJECT_TYPE_FRAMEBUFFER");
            return;
        case VK_OBJECT_TYPE_COMMAND_POOL:
            *rString += std::string("VK_OBJECT_TYPE_COMMAND_POOL");
            return;
        case VK_OBJECT_TYPE_DEVICE_MEMORY:
            *rString += std::string("VK_OBJECT_TYPE_DEVICE_MEMORY");
            return;
        case VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT:
            *rString += std::string("VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT");
            return;
        case VK_OBJECT_TYPE_BUFFER_VIEW:
            *rString += std::string("VK_OBJECT_TYPE_BUFFER_VIEW");
            return;
        case VK_OBJECT_TYPE_PIPELINE:
            *rString += std::string("VK_OBJECT_TYPE_PIPELINE");
            return;
        case VK_OBJECT_TYPE_PIPELINE_LAYOUT:
            *rString += std::string("VK_OBJECT_TYPE_PIPELINE_LAYOUT");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE:
            *rString += std::string("VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE");
            return;
        case VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV:
            *rString += std::string("VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_SET:
            *rString += std::string("VK_OBJECT_TYPE_DESCRIPTOR_SET");
            return;
        case VK_OBJECT_TYPE_OBJECT_TABLE_NVX:
            *rString += std::string("VK_OBJECT_TYPE_OBJECT_TABLE_NVX");
            return;
        case VK_OBJECT_TYPE_QUERY_POOL:
            *rString += std::string("VK_OBJECT_TYPE_QUERY_POOL");
            return;
        case VK_OBJECT_TYPE_PIPELINE_CACHE:
            *rString += std::string("VK_OBJECT_TYPE_PIPELINE_CACHE");
            return;
        case VK_OBJECT_TYPE_DISPLAY_MODE_KHR:
            *rString += std::string("VK_OBJECT_TYPE_DISPLAY_MODE_KHR");
            return;
        case VK_OBJECT_TYPE_DISPLAY_KHR:
            *rString += std::string("VK_OBJECT_TYPE_DISPLAY_KHR");
            return;
        case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
            *rString += std::string("VK_OBJECT_TYPE_PHYSICAL_DEVICE");
            return;
        case VK_OBJECT_TYPE_RENDER_PASS:
            *rString += std::string("VK_OBJECT_TYPE_RENDER_PASS");
            return;
        case VK_OBJECT_TYPE_DEVICE:
            *rString += std::string("VK_OBJECT_TYPE_DEVICE");
            return;
        case VK_OBJECT_TYPE_VALIDATION_CACHE_EXT:
            *rString += std::string("VK_OBJECT_TYPE_VALIDATION_CACHE_EXT");
            return;
        case VK_OBJECT_TYPE_INSTANCE:
            *rString += std::string("VK_OBJECT_TYPE_INSTANCE");
            return;
        case VK_OBJECT_TYPE_SAMPLER:
            *rString += std::string("VK_OBJECT_TYPE_SAMPLER");
            return;
        case VK_OBJECT_TYPE_IMAGE_VIEW:
            *rString += std::string("VK_OBJECT_TYPE_IMAGE_VIEW");
            return;
        case VK_OBJECT_TYPE_COMMAND_BUFFER:
            *rString += std::string("VK_OBJECT_TYPE_COMMAND_BUFFER");
            return;
        case VK_OBJECT_TYPE_SURFACE_KHR:
            *rString += std::string("VK_OBJECT_TYPE_SURFACE_KHR");
            return;
        case VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT:
            *rString += std::string("VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT");
            return;
        case VK_OBJECT_TYPE_SHADER_MODULE:
            *rString += std::string("VK_OBJECT_TYPE_SHADER_MODULE");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkBlendOp(std::string* rString, uint32_t enumValueInt32)
{
    VkBlendOp enumValue = static_cast<VkBlendOp>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_BLEND_OP_INVERT_EXT:
            *rString += std::string("VK_BLEND_OP_INVERT_EXT");
            return;
        case VK_BLEND_OP_HARDLIGHT_EXT:
            *rString += std::string("VK_BLEND_OP_HARDLIGHT_EXT");
            return;
        case VK_BLEND_OP_DST_ATOP_EXT:
            *rString += std::string("VK_BLEND_OP_DST_ATOP_EXT");
            return;
        case VK_BLEND_OP_EXCLUSION_EXT:
            *rString += std::string("VK_BLEND_OP_EXCLUSION_EXT");
            return;
        case VK_BLEND_OP_BLUE_EXT:
            *rString += std::string("VK_BLEND_OP_BLUE_EXT");
            return;
        case VK_BLEND_OP_DIFFERENCE_EXT:
            *rString += std::string("VK_BLEND_OP_DIFFERENCE_EXT");
            return;
        case VK_BLEND_OP_HSL_COLOR_EXT:
            *rString += std::string("VK_BLEND_OP_HSL_COLOR_EXT");
            return;
        case VK_BLEND_OP_DST_OVER_EXT:
            *rString += std::string("VK_BLEND_OP_DST_OVER_EXT");
            return;
        case VK_BLEND_OP_PLUS_CLAMPED_EXT:
            *rString += std::string("VK_BLEND_OP_PLUS_CLAMPED_EXT");
            return;
        case VK_BLEND_OP_REVERSE_SUBTRACT:
            *rString += std::string("VK_BLEND_OP_REVERSE_SUBTRACT");
            return;
        case VK_BLEND_OP_LIGHTEN_EXT:
            *rString += std::string("VK_BLEND_OP_LIGHTEN_EXT");
            return;
        case VK_BLEND_OP_OVERLAY_EXT:
            *rString += std::string("VK_BLEND_OP_OVERLAY_EXT");
            return;
        case VK_BLEND_OP_PLUS_EXT:
            *rString += std::string("VK_BLEND_OP_PLUS_EXT");
            return;
        case VK_BLEND_OP_SOFTLIGHT_EXT:
            *rString += std::string("VK_BLEND_OP_SOFTLIGHT_EXT");
            return;
        case VK_BLEND_OP_COLORBURN_EXT:
            *rString += std::string("VK_BLEND_OP_COLORBURN_EXT");
            return;
        case VK_BLEND_OP_SRC_IN_EXT:
            *rString += std::string("VK_BLEND_OP_SRC_IN_EXT");
            return;
        case VK_BLEND_OP_DST_OUT_EXT:
            *rString += std::string("VK_BLEND_OP_DST_OUT_EXT");
            return;
        case VK_BLEND_OP_DARKEN_EXT:
            *rString += std::string("VK_BLEND_OP_DARKEN_EXT");
            return;
        case VK_BLEND_OP_ZERO_EXT:
            *rString += std::string("VK_BLEND_OP_ZERO_EXT");
            return;
        case VK_BLEND_OP_MINUS_EXT:
            *rString += std::string("VK_BLEND_OP_MINUS_EXT");
            return;
        case VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT:
            *rString += std::string("VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT");
            return;
        case VK_BLEND_OP_CONTRAST_EXT:
            *rString += std::string("VK_BLEND_OP_CONTRAST_EXT");
            return;
        case VK_BLEND_OP_HSL_SATURATION_EXT:
            *rString += std::string("VK_BLEND_OP_HSL_SATURATION_EXT");
            return;
        case VK_BLEND_OP_SRC_OVER_EXT:
            *rString += std::string("VK_BLEND_OP_SRC_OVER_EXT");
            return;
        case VK_BLEND_OP_LINEARLIGHT_EXT:
            *rString += std::string("VK_BLEND_OP_LINEARLIGHT_EXT");
            return;
        case VK_BLEND_OP_PLUS_DARKER_EXT:
            *rString += std::string("VK_BLEND_OP_PLUS_DARKER_EXT");
            return;
        case VK_BLEND_OP_SRC_OUT_EXT:
            *rString += std::string("VK_BLEND_OP_SRC_OUT_EXT");
            return;
        case VK_BLEND_OP_LINEARDODGE_EXT:
            *rString += std::string("VK_BLEND_OP_LINEARDODGE_EXT");
            return;
        case VK_BLEND_OP_SCREEN_EXT:
            *rString += std::string("VK_BLEND_OP_SCREEN_EXT");
            return;
        case VK_BLEND_OP_COLORDODGE_EXT:
            *rString += std::string("VK_BLEND_OP_COLORDODGE_EXT");
            return;
        case VK_BLEND_OP_LINEARBURN_EXT:
            *rString += std::string("VK_BLEND_OP_LINEARBURN_EXT");
            return;
        case VK_BLEND_OP_PINLIGHT_EXT:
            *rString += std::string("VK_BLEND_OP_PINLIGHT_EXT");
            return;
        case VK_BLEND_OP_ADD:
            *rString += std::string("VK_BLEND_OP_ADD");
            return;
        case VK_BLEND_OP_MIN:
            *rString += std::string("VK_BLEND_OP_MIN");
            return;
        case VK_BLEND_OP_SRC_ATOP_EXT:
            *rString += std::string("VK_BLEND_OP_SRC_ATOP_EXT");
            return;
        case VK_BLEND_OP_DST_EXT:
            *rString += std::string("VK_BLEND_OP_DST_EXT");
            return;
        case VK_BLEND_OP_DST_IN_EXT:
            *rString += std::string("VK_BLEND_OP_DST_IN_EXT");
            return;
        case VK_BLEND_OP_HSL_LUMINOSITY_EXT:
            *rString += std::string("VK_BLEND_OP_HSL_LUMINOSITY_EXT");
            return;
        case VK_BLEND_OP_MULTIPLY_EXT:
            *rString += std::string("VK_BLEND_OP_MULTIPLY_EXT");
            return;
        case VK_BLEND_OP_MINUS_CLAMPED_EXT:
            *rString += std::string("VK_BLEND_OP_MINUS_CLAMPED_EXT");
            return;
        case VK_BLEND_OP_GREEN_EXT:
            *rString += std::string("VK_BLEND_OP_GREEN_EXT");
            return;
        case VK_BLEND_OP_HARDMIX_EXT:
            *rString += std::string("VK_BLEND_OP_HARDMIX_EXT");
            return;
        case VK_BLEND_OP_SUBTRACT:
            *rString += std::string("VK_BLEND_OP_SUBTRACT");
            return;
        case VK_BLEND_OP_SRC_EXT:
            *rString += std::string("VK_BLEND_OP_SRC_EXT");
            return;
        case VK_BLEND_OP_XOR_EXT:
            *rString += std::string("VK_BLEND_OP_XOR_EXT");
            return;
        case VK_BLEND_OP_INVERT_RGB_EXT:
            *rString += std::string("VK_BLEND_OP_INVERT_RGB_EXT");
            return;
        case VK_BLEND_OP_HSL_HUE_EXT:
            *rString += std::string("VK_BLEND_OP_HSL_HUE_EXT");
            return;
        case VK_BLEND_OP_RED_EXT:
            *rString += std::string("VK_BLEND_OP_RED_EXT");
            return;
        case VK_BLEND_OP_MAX:
            *rString += std::string("VK_BLEND_OP_MAX");
            return;
        case VK_BLEND_OP_VIVIDLIGHT_EXT:
            *rString += std::string("VK_BLEND_OP_VIVIDLIGHT_EXT");
            return;
        case VK_BLEND_OP_INVERT_OVG_EXT:
            *rString += std::string("VK_BLEND_OP_INVERT_OVG_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDescriptorSetLayoutCreateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkDescriptorSetLayoutCreateFlagBits enumValue = static_cast<VkDescriptorSetLayoutCreateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR:
            *rString += std::string("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR");
            return;
        case VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT:
            *rString += std::string("VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkQueryType(std::string* rString, uint32_t enumValueInt32)
{
    VkQueryType enumValue = static_cast<VkQueryType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV:
            *rString += std::string("VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV");
            return;
        case VK_QUERY_TYPE_OCCLUSION:
            *rString += std::string("VK_QUERY_TYPE_OCCLUSION");
            return;
        case VK_QUERY_TYPE_PIPELINE_STATISTICS:
            *rString += std::string("VK_QUERY_TYPE_PIPELINE_STATISTICS");
            return;
        case VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL:
            *rString += std::string("VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL");
            return;
        case VK_QUERY_TYPE_TIMESTAMP:
            *rString += std::string("VK_QUERY_TYPE_TIMESTAMP");
            return;
        case VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT:
            *rString += std::string("VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSparseImageFormatFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkSparseImageFormatFlagBits enumValue = static_cast<VkSparseImageFormatFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT:
            *rString += std::string("VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT");
            return;
        case VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT:
            *rString += std::string("VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT");
            return;
        case VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT:
            *rString += std::string("VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkApplicationInfo>(std::string* rString, const Decoded_VkApplicationInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkInstanceCreateInfo>(std::string* rString, const Decoded_VkInstanceCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAllocationCallbacks>(std::string* rString, const Decoded_VkAllocationCallbacks &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceFeatures &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkFormatProperties>(std::string* rString, const Decoded_VkFormatProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExtent3D>(std::string* rString, const Decoded_VkExtent3D &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageFormatProperties>(std::string* rString, const Decoded_VkImageFormatProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceLimits>(std::string* rString, const Decoded_VkPhysicalDeviceLimits &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceSparseProperties>(std::string* rString, const Decoded_VkPhysicalDeviceSparseProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceProperties>(std::string* rString, const Decoded_VkPhysicalDeviceProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkQueueFamilyProperties>(std::string* rString, const Decoded_VkQueueFamilyProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryType>(std::string* rString, const Decoded_VkMemoryType &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryHeap>(std::string* rString, const Decoded_VkMemoryHeap &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceMemoryProperties>(std::string* rString, const Decoded_VkPhysicalDeviceMemoryProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceQueueCreateInfo>(std::string* rString, const Decoded_VkDeviceQueueCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceCreateInfo>(std::string* rString, const Decoded_VkDeviceCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExtensionProperties>(std::string* rString, const Decoded_VkExtensionProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkLayerProperties>(std::string* rString, const Decoded_VkLayerProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubmitInfo>(std::string* rString, const Decoded_VkSubmitInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryAllocateInfo>(std::string* rString, const Decoded_VkMemoryAllocateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMappedMemoryRange>(std::string* rString, const Decoded_VkMappedMemoryRange &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryRequirements>(std::string* rString, const Decoded_VkMemoryRequirements &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseImageFormatProperties>(std::string* rString, const Decoded_VkSparseImageFormatProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseImageMemoryRequirements>(std::string* rString, const Decoded_VkSparseImageMemoryRequirements &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseMemoryBind>(std::string* rString, const Decoded_VkSparseMemoryBind &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseBufferMemoryBindInfo>(std::string* rString, const Decoded_VkSparseBufferMemoryBindInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(std::string* rString, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageSubresource>(std::string* rString, const Decoded_VkImageSubresource &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkOffset3D>(std::string* rString, const Decoded_VkOffset3D &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseImageMemoryBind>(std::string* rString, const Decoded_VkSparseImageMemoryBind &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseImageMemoryBindInfo>(std::string* rString, const Decoded_VkSparseImageMemoryBindInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindSparseInfo>(std::string* rString, const Decoded_VkBindSparseInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkFenceCreateInfo>(std::string* rString, const Decoded_VkFenceCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSemaphoreCreateInfo>(std::string* rString, const Decoded_VkSemaphoreCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkEventCreateInfo>(std::string* rString, const Decoded_VkEventCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkQueryPoolCreateInfo>(std::string* rString, const Decoded_VkQueryPoolCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferCreateInfo>(std::string* rString, const Decoded_VkBufferCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferViewCreateInfo>(std::string* rString, const Decoded_VkBufferViewCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageCreateInfo>(std::string* rString, const Decoded_VkImageCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubresourceLayout>(std::string* rString, const Decoded_VkSubresourceLayout &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkComponentMapping>(std::string* rString, const Decoded_VkComponentMapping &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageSubresourceRange>(std::string* rString, const Decoded_VkImageSubresourceRange &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageViewCreateInfo>(std::string* rString, const Decoded_VkImageViewCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkShaderModuleCreateInfo>(std::string* rString, const Decoded_VkShaderModuleCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineCacheCreateInfo>(std::string* rString, const Decoded_VkPipelineCacheCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSpecializationMapEntry>(std::string* rString, const Decoded_VkSpecializationMapEntry &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSpecializationInfo>(std::string* rString, const Decoded_VkSpecializationInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineShaderStageCreateInfo>(std::string* rString, const Decoded_VkPipelineShaderStageCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkVertexInputBindingDescription>(std::string* rString, const Decoded_VkVertexInputBindingDescription &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkVertexInputAttributeDescription>(std::string* rString, const Decoded_VkVertexInputAttributeDescription &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(std::string* rString, const Decoded_VkPipelineVertexInputStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(std::string* rString, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineTessellationStateCreateInfo>(std::string* rString, const Decoded_VkPipelineTessellationStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkViewport>(std::string* rString, const Decoded_VkViewport &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkOffset2D>(std::string* rString, const Decoded_VkOffset2D &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExtent2D>(std::string* rString, const Decoded_VkExtent2D &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRect2D>(std::string* rString, const Decoded_VkRect2D &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineViewportStateCreateInfo>(std::string* rString, const Decoded_VkPipelineViewportStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(std::string* rString, const Decoded_VkPipelineRasterizationStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(std::string* rString, const Decoded_VkPipelineMultisampleStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkStencilOpState>(std::string* rString, const Decoded_VkStencilOpState &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(std::string* rString, const Decoded_VkPipelineDepthStencilStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineColorBlendAttachmentState>(std::string* rString, const Decoded_VkPipelineColorBlendAttachmentState &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(std::string* rString, const Decoded_VkPipelineColorBlendStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineDynamicStateCreateInfo>(std::string* rString, const Decoded_VkPipelineDynamicStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkGraphicsPipelineCreateInfo>(std::string* rString, const Decoded_VkGraphicsPipelineCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkComputePipelineCreateInfo>(std::string* rString, const Decoded_VkComputePipelineCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPushConstantRange>(std::string* rString, const Decoded_VkPushConstantRange &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineLayoutCreateInfo>(std::string* rString, const Decoded_VkPipelineLayoutCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSamplerCreateInfo>(std::string* rString, const Decoded_VkSamplerCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorSetLayoutBinding>(std::string* rString, const Decoded_VkDescriptorSetLayoutBinding &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(std::string* rString, const Decoded_VkDescriptorSetLayoutCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorPoolSize>(std::string* rString, const Decoded_VkDescriptorPoolSize &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorPoolCreateInfo>(std::string* rString, const Decoded_VkDescriptorPoolCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorSetAllocateInfo>(std::string* rString, const Decoded_VkDescriptorSetAllocateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorImageInfo>(std::string* rString, const Decoded_VkDescriptorImageInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorBufferInfo>(std::string* rString, const Decoded_VkDescriptorBufferInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkWriteDescriptorSet>(std::string* rString, const Decoded_VkWriteDescriptorSet &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCopyDescriptorSet>(std::string* rString, const Decoded_VkCopyDescriptorSet &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkFramebufferCreateInfo>(std::string* rString, const Decoded_VkFramebufferCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAttachmentDescription>(std::string* rString, const Decoded_VkAttachmentDescription &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAttachmentReference>(std::string* rString, const Decoded_VkAttachmentReference &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubpassDescription>(std::string* rString, const Decoded_VkSubpassDescription &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubpassDependency>(std::string* rString, const Decoded_VkSubpassDependency &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRenderPassCreateInfo>(std::string* rString, const Decoded_VkRenderPassCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCommandPoolCreateInfo>(std::string* rString, const Decoded_VkCommandPoolCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCommandBufferAllocateInfo>(std::string* rString, const Decoded_VkCommandBufferAllocateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCommandBufferInheritanceInfo>(std::string* rString, const Decoded_VkCommandBufferInheritanceInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCommandBufferBeginInfo>(std::string* rString, const Decoded_VkCommandBufferBeginInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferCopy>(std::string* rString, const Decoded_VkBufferCopy &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageSubresourceLayers>(std::string* rString, const Decoded_VkImageSubresourceLayers &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageCopy>(std::string* rString, const Decoded_VkImageCopy &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageBlit>(std::string* rString, const Decoded_VkImageBlit &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferImageCopy>(std::string* rString, const Decoded_VkBufferImageCopy &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkClearColorValue>(std::string* rString, const Decoded_VkClearColorValue &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkClearDepthStencilValue>(std::string* rString, const Decoded_VkClearDepthStencilValue &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkClearValue>(std::string* rString, const Decoded_VkClearValue &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkClearAttachment>(std::string* rString, const Decoded_VkClearAttachment &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkClearRect>(std::string* rString, const Decoded_VkClearRect &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageResolve>(std::string* rString, const Decoded_VkImageResolve &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryBarrier>(std::string* rString, const Decoded_VkMemoryBarrier &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferMemoryBarrier>(std::string* rString, const Decoded_VkBufferMemoryBarrier &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageMemoryBarrier>(std::string* rString, const Decoded_VkImageMemoryBarrier &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRenderPassBeginInfo>(std::string* rString, const Decoded_VkRenderPassBeginInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDispatchIndirectCommand>(std::string* rString, const Decoded_VkDispatchIndirectCommand &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDrawIndexedIndirectCommand>(std::string* rString, const Decoded_VkDrawIndexedIndirectCommand &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDrawIndirectCommand>(std::string* rString, const Decoded_VkDrawIndirectCommand &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkApplicationInfo>(std::string* rString, const Decoded_VkApplicationInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkApplicationInfo *pStruct = (const VkApplicationInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // const char* pApplicationName // SMB
    indentSpaces(rString, indent);
    *rString += "pApplicationName:               ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pApplicationName); // TGH
    *rString += "\n"; // GDS

    // uint32_t applicationVersion // SMB
    indentSpaces(rString, indent);
    *rString += "applicationVersion:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->applicationVersion);
    *rString += "\n"; // GDS

    // const char* pEngineName // SMB
    indentSpaces(rString, indent);
    *rString += "pEngineName:                    ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pEngineName); // TGH
    *rString += "\n"; // GDS

    // uint32_t engineVersion // SMB
    indentSpaces(rString, indent);
    *rString += "engineVersion:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->engineVersion);
    *rString += "\n"; // GDS

    // uint32_t apiVersion // SMB
    indentSpaces(rString, indent);
    *rString += "apiVersion:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->apiVersion);
}

template <>
void structureToString<Decoded_VkInstanceCreateInfo>(std::string* rString, const Decoded_VkInstanceCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkInstanceCreateInfo *pStruct = (const VkInstanceCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkInstanceCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkInstanceCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // const VkApplicationInfo* pApplicationInfo // SMB
    indentSpaces(rString, indent);
    *rString += "pApplicationInfo:               ";
    *rString += "const VkApplicationInfo* = "; // TEQ
    if (pStruct->pApplicationInfo == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pApplicationInfo->GetAddress()); // JHI
        structureToString<Decoded_VkApplicationInfo>(rString, *pStructIn.pApplicationInfo->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkInstanceCreateInfo, pApplicationInfo)); // GLM
    }
    *rString += "\n"; // GDS

    // uint32_t enabledLayerCount // SMB
    indentSpaces(rString, indent);
    *rString += "enabledLayerCount:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->enabledLayerCount);
    *rString += "\n"; // GDS

    // const char* const* ppEnabledLayerNames // SMB
    indentSpaces(rString, indent);
    *rString += "ppEnabledLayerNames:            ";
    *rString += "const char* const* = "; // TEQ
    if (pStruct->ppEnabledLayerNames == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.ppEnabledLayerNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        arrayToString<const char* const*>(rString, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pStructIn.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pStruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t enabledExtensionCount // SMB
    indentSpaces(rString, indent);
    *rString += "enabledExtensionCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->enabledExtensionCount);
    *rString += "\n"; // GDS

    // const char* const* ppEnabledExtensionNames // SMB
    indentSpaces(rString, indent);
    *rString += "ppEnabledExtensionNames:        ";
    *rString += "const char* const* = "; // TEQ
    if (pStruct->ppEnabledExtensionNames == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.ppEnabledExtensionNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        arrayToString<const char* const*>(rString, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pStructIn.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pStruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkAllocationCallbacks>(std::string* rString, const Decoded_VkAllocationCallbacks &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAllocationCallbacks *pStruct = (const VkAllocationCallbacks *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // void* pUserData // SMB
    indentSpaces(rString, indent);
    *rString += "pUserData:                      ";
    *rString += "void* = "; // TEQ
    if (pStruct->pUserData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pUserData); // PWR
    }
    *rString += "\n"; // GDS

    // PFN_vkAllocationFunction pfnAllocation // SMB
    indentSpaces(rString, indent);
    *rString += "pfnAllocation:                  ";
    *rString += "PFN_vkAllocationFunction = "; // TEQ
    addrToString(rString, reinterpret_cast<uint64_t>(pStruct->pfnAllocation)); // WRX
    *rString += "\n"; // GDS

    // PFN_vkReallocationFunction pfnReallocation // SMB
    indentSpaces(rString, indent);
    *rString += "pfnReallocation:                ";
    *rString += "PFN_vkReallocationFunction = "; // TEQ
    addrToString(rString, reinterpret_cast<uint64_t>(pStruct->pfnReallocation)); // WRX
    *rString += "\n"; // GDS

    // PFN_vkFreeFunction pfnFree // SMB
    indentSpaces(rString, indent);
    *rString += "pfnFree:                        ";
    *rString += "PFN_vkFreeFunction = "; // TEQ
    addrToString(rString, reinterpret_cast<uint64_t>(pStruct->pfnFree)); // WRX
    *rString += "\n"; // GDS

    // PFN_vkInternalAllocationNotification pfnInternalAllocation // SMB
    indentSpaces(rString, indent);
    *rString += "pfnInternalAllocation:          ";
    *rString += "PFN_vkInternalAllocationNotification = "; // TEQ
    addrToString(rString, reinterpret_cast<uint64_t>(pStruct->pfnInternalAllocation)); // WRX
    *rString += "\n"; // GDS

    // PFN_vkInternalFreeNotification pfnInternalFree // SMB
    indentSpaces(rString, indent);
    *rString += "pfnInternalFree:                ";
    *rString += "PFN_vkInternalFreeNotification = "; // TEQ
    addrToString(rString, reinterpret_cast<uint64_t>(pStruct->pfnInternalFree)); // WRX
}

template <>
void structureToString<Decoded_VkPhysicalDeviceFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceFeatures &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceFeatures *pStruct = (const VkPhysicalDeviceFeatures *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkBool32 robustBufferAccess // SMB
    indentSpaces(rString, indent);
    *rString += "robustBufferAccess:             ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->robustBufferAccess);
    *rString += "\n"; // GDS

    // VkBool32 fullDrawIndexUint32 // SMB
    indentSpaces(rString, indent);
    *rString += "fullDrawIndexUint32:            ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->fullDrawIndexUint32);
    *rString += "\n"; // GDS

    // VkBool32 imageCubeArray // SMB
    indentSpaces(rString, indent);
    *rString += "imageCubeArray:                 ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->imageCubeArray);
    *rString += "\n"; // GDS

    // VkBool32 independentBlend // SMB
    indentSpaces(rString, indent);
    *rString += "independentBlend:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->independentBlend);
    *rString += "\n"; // GDS

    // VkBool32 geometryShader // SMB
    indentSpaces(rString, indent);
    *rString += "geometryShader:                 ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->geometryShader);
    *rString += "\n"; // GDS

    // VkBool32 tessellationShader // SMB
    indentSpaces(rString, indent);
    *rString += "tessellationShader:             ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->tessellationShader);
    *rString += "\n"; // GDS

    // VkBool32 sampleRateShading // SMB
    indentSpaces(rString, indent);
    *rString += "sampleRateShading:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sampleRateShading);
    *rString += "\n"; // GDS

    // VkBool32 dualSrcBlend // SMB
    indentSpaces(rString, indent);
    *rString += "dualSrcBlend:                   ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->dualSrcBlend);
    *rString += "\n"; // GDS

    // VkBool32 logicOp // SMB
    indentSpaces(rString, indent);
    *rString += "logicOp:                        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->logicOp);
    *rString += "\n"; // GDS

    // VkBool32 multiDrawIndirect // SMB
    indentSpaces(rString, indent);
    *rString += "multiDrawIndirect:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->multiDrawIndirect);
    *rString += "\n"; // GDS

    // VkBool32 drawIndirectFirstInstance // SMB
    indentSpaces(rString, indent);
    *rString += "drawIndirectFirstInstance:      ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->drawIndirectFirstInstance);
    *rString += "\n"; // GDS

    // VkBool32 depthClamp // SMB
    indentSpaces(rString, indent);
    *rString += "depthClamp:                     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthClamp);
    *rString += "\n"; // GDS

    // VkBool32 depthBiasClamp // SMB
    indentSpaces(rString, indent);
    *rString += "depthBiasClamp:                 ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthBiasClamp);
    *rString += "\n"; // GDS

    // VkBool32 fillModeNonSolid // SMB
    indentSpaces(rString, indent);
    *rString += "fillModeNonSolid:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->fillModeNonSolid);
    *rString += "\n"; // GDS

    // VkBool32 depthBounds // SMB
    indentSpaces(rString, indent);
    *rString += "depthBounds:                    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthBounds);
    *rString += "\n"; // GDS

    // VkBool32 wideLines // SMB
    indentSpaces(rString, indent);
    *rString += "wideLines:                      ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->wideLines);
    *rString += "\n"; // GDS

    // VkBool32 largePoints // SMB
    indentSpaces(rString, indent);
    *rString += "largePoints:                    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->largePoints);
    *rString += "\n"; // GDS

    // VkBool32 alphaToOne // SMB
    indentSpaces(rString, indent);
    *rString += "alphaToOne:                     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->alphaToOne);
    *rString += "\n"; // GDS

    // VkBool32 multiViewport // SMB
    indentSpaces(rString, indent);
    *rString += "multiViewport:                  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->multiViewport);
    *rString += "\n"; // GDS

    // VkBool32 samplerAnisotropy // SMB
    indentSpaces(rString, indent);
    *rString += "samplerAnisotropy:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->samplerAnisotropy);
    *rString += "\n"; // GDS

    // VkBool32 textureCompressionETC2 // SMB
    indentSpaces(rString, indent);
    *rString += "textureCompressionETC2:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->textureCompressionETC2);
    *rString += "\n"; // GDS

    // VkBool32 textureCompressionASTC_LDR // SMB
    indentSpaces(rString, indent);
    *rString += "textureCompressionASTC_LDR:     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->textureCompressionASTC_LDR);
    *rString += "\n"; // GDS

    // VkBool32 textureCompressionBC // SMB
    indentSpaces(rString, indent);
    *rString += "textureCompressionBC:           ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->textureCompressionBC);
    *rString += "\n"; // GDS

    // VkBool32 occlusionQueryPrecise // SMB
    indentSpaces(rString, indent);
    *rString += "occlusionQueryPrecise:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->occlusionQueryPrecise);
    *rString += "\n"; // GDS

    // VkBool32 pipelineStatisticsQuery // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineStatisticsQuery:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->pipelineStatisticsQuery);
    *rString += "\n"; // GDS

    // VkBool32 vertexPipelineStoresAndAtomics // SMB
    indentSpaces(rString, indent);
    *rString += "vertexPipelineStoresAndAtomics: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->vertexPipelineStoresAndAtomics);
    *rString += "\n"; // GDS

    // VkBool32 fragmentStoresAndAtomics // SMB
    indentSpaces(rString, indent);
    *rString += "fragmentStoresAndAtomics:       ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->fragmentStoresAndAtomics);
    *rString += "\n"; // GDS

    // VkBool32 shaderTessellationAndGeometryPointSize // SMB
    indentSpaces(rString, indent);
    *rString += "shaderTessellationAndGeometryPointSize: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderTessellationAndGeometryPointSize);
    *rString += "\n"; // GDS

    // VkBool32 shaderImageGatherExtended // SMB
    indentSpaces(rString, indent);
    *rString += "shaderImageGatherExtended:      ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderImageGatherExtended);
    *rString += "\n"; // GDS

    // VkBool32 shaderStorageImageExtendedFormats // SMB
    indentSpaces(rString, indent);
    *rString += "shaderStorageImageExtendedFormats: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderStorageImageExtendedFormats);
    *rString += "\n"; // GDS

    // VkBool32 shaderStorageImageMultisample // SMB
    indentSpaces(rString, indent);
    *rString += "shaderStorageImageMultisample:  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderStorageImageMultisample);
    *rString += "\n"; // GDS

    // VkBool32 shaderStorageImageReadWithoutFormat // SMB
    indentSpaces(rString, indent);
    *rString += "shaderStorageImageReadWithoutFormat: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderStorageImageReadWithoutFormat);
    *rString += "\n"; // GDS

    // VkBool32 shaderStorageImageWriteWithoutFormat // SMB
    indentSpaces(rString, indent);
    *rString += "shaderStorageImageWriteWithoutFormat: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderStorageImageWriteWithoutFormat);
    *rString += "\n"; // GDS

    // VkBool32 shaderUniformBufferArrayDynamicIndexing // SMB
    indentSpaces(rString, indent);
    *rString += "shaderUniformBufferArrayDynamicIndexing: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderUniformBufferArrayDynamicIndexing);
    *rString += "\n"; // GDS

    // VkBool32 shaderSampledImageArrayDynamicIndexing // SMB
    indentSpaces(rString, indent);
    *rString += "shaderSampledImageArrayDynamicIndexing: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderSampledImageArrayDynamicIndexing);
    *rString += "\n"; // GDS

    // VkBool32 shaderStorageBufferArrayDynamicIndexing // SMB
    indentSpaces(rString, indent);
    *rString += "shaderStorageBufferArrayDynamicIndexing: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderStorageBufferArrayDynamicIndexing);
    *rString += "\n"; // GDS

    // VkBool32 shaderStorageImageArrayDynamicIndexing // SMB
    indentSpaces(rString, indent);
    *rString += "shaderStorageImageArrayDynamicIndexing: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderStorageImageArrayDynamicIndexing);
    *rString += "\n"; // GDS

    // VkBool32 shaderClipDistance // SMB
    indentSpaces(rString, indent);
    *rString += "shaderClipDistance:             ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderClipDistance);
    *rString += "\n"; // GDS

    // VkBool32 shaderCullDistance // SMB
    indentSpaces(rString, indent);
    *rString += "shaderCullDistance:             ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderCullDistance);
    *rString += "\n"; // GDS

    // VkBool32 shaderFloat64 // SMB
    indentSpaces(rString, indent);
    *rString += "shaderFloat64:                  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderFloat64);
    *rString += "\n"; // GDS

    // VkBool32 shaderInt64 // SMB
    indentSpaces(rString, indent);
    *rString += "shaderInt64:                    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderInt64);
    *rString += "\n"; // GDS

    // VkBool32 shaderInt16 // SMB
    indentSpaces(rString, indent);
    *rString += "shaderInt16:                    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderInt16);
    *rString += "\n"; // GDS

    // VkBool32 shaderResourceResidency // SMB
    indentSpaces(rString, indent);
    *rString += "shaderResourceResidency:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderResourceResidency);
    *rString += "\n"; // GDS

    // VkBool32 shaderResourceMinLod // SMB
    indentSpaces(rString, indent);
    *rString += "shaderResourceMinLod:           ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderResourceMinLod);
    *rString += "\n"; // GDS

    // VkBool32 sparseBinding // SMB
    indentSpaces(rString, indent);
    *rString += "sparseBinding:                  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseBinding);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidencyBuffer // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidencyBuffer:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidencyBuffer);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidencyImage2D // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidencyImage2D:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidencyImage2D);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidencyImage3D // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidencyImage3D:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidencyImage3D);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidency2Samples // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidency2Samples:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidency2Samples);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidency4Samples // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidency4Samples:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidency4Samples);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidency8Samples // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidency8Samples:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidency8Samples);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidency16Samples // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidency16Samples:       ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidency16Samples);
    *rString += "\n"; // GDS

    // VkBool32 sparseResidencyAliased // SMB
    indentSpaces(rString, indent);
    *rString += "sparseResidencyAliased:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseResidencyAliased);
    *rString += "\n"; // GDS

    // VkBool32 variableMultisampleRate // SMB
    indentSpaces(rString, indent);
    *rString += "variableMultisampleRate:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->variableMultisampleRate);
    *rString += "\n"; // GDS

    // VkBool32 inheritedQueries // SMB
    indentSpaces(rString, indent);
    *rString += "inheritedQueries:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->inheritedQueries);
}

template <>
void structureToString<Decoded_VkFormatProperties>(std::string* rString, const Decoded_VkFormatProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkFormatProperties *pStruct = (const VkFormatProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkFormatFeatureFlags linearTilingFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "linearTilingFeatures:           ";
    *rString += "VkFormatFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->linearTilingFeatures, enumToString_VkFormatFeatureFlagBits); // URW
    *rString += "\n"; // GDS

    // VkFormatFeatureFlags optimalTilingFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "optimalTilingFeatures:          ";
    *rString += "VkFormatFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->optimalTilingFeatures, enumToString_VkFormatFeatureFlagBits); // URW
    *rString += "\n"; // GDS

    // VkFormatFeatureFlags bufferFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "bufferFeatures:                 ";
    *rString += "VkFormatFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->bufferFeatures, enumToString_VkFormatFeatureFlagBits); // URW
}

template <>
void structureToString<Decoded_VkExtent3D>(std::string* rString, const Decoded_VkExtent3D &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExtent3D *pStruct = (const VkExtent3D *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t width // SMB
    indentSpaces(rString, indent);
    *rString += "width:                          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->width);
    *rString += "\n"; // GDS

    // uint32_t height // SMB
    indentSpaces(rString, indent);
    *rString += "height:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->height);
    *rString += "\n"; // GDS

    // uint32_t depth // SMB
    indentSpaces(rString, indent);
    *rString += "depth:                          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->depth);
}

template <>
void structureToString<Decoded_VkImageFormatProperties>(std::string* rString, const Decoded_VkImageFormatProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageFormatProperties *pStruct = (const VkImageFormatProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkExtent3D maxExtent // SMB
    indentSpaces(rString, indent);
    *rString += "maxExtent:                      ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.maxExtent, indent+1,  baseAddr + offsetof(VkImageFormatProperties, maxExtent)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t maxMipLevels // SMB
    indentSpaces(rString, indent);
    *rString += "maxMipLevels:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMipLevels);
    *rString += "\n"; // GDS

    // uint32_t maxArrayLayers // SMB
    indentSpaces(rString, indent);
    *rString += "maxArrayLayers:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxArrayLayers);
    *rString += "\n"; // GDS

    // VkSampleCountFlags sampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "sampleCounts:                   ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->sampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkDeviceSize maxResourceSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxResourceSize:                ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->maxResourceSize);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceLimits>(std::string* rString, const Decoded_VkPhysicalDeviceLimits &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceLimits *pStruct = (const VkPhysicalDeviceLimits *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t maxImageDimension1D // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageDimension1D:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageDimension1D);
    *rString += "\n"; // GDS

    // uint32_t maxImageDimension2D // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageDimension2D:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageDimension2D);
    *rString += "\n"; // GDS

    // uint32_t maxImageDimension3D // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageDimension3D:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageDimension3D);
    *rString += "\n"; // GDS

    // uint32_t maxImageDimensionCube // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageDimensionCube:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageDimensionCube);
    *rString += "\n"; // GDS

    // uint32_t maxImageArrayLayers // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageArrayLayers:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageArrayLayers);
    *rString += "\n"; // GDS

    // uint32_t maxTexelBufferElements // SMB
    indentSpaces(rString, indent);
    *rString += "maxTexelBufferElements:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTexelBufferElements);
    *rString += "\n"; // GDS

    // uint32_t maxUniformBufferRange // SMB
    indentSpaces(rString, indent);
    *rString += "maxUniformBufferRange:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxUniformBufferRange);
    *rString += "\n"; // GDS

    // uint32_t maxStorageBufferRange // SMB
    indentSpaces(rString, indent);
    *rString += "maxStorageBufferRange:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxStorageBufferRange);
    *rString += "\n"; // GDS

    // uint32_t maxPushConstantsSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxPushConstantsSize:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPushConstantsSize);
    *rString += "\n"; // GDS

    // uint32_t maxMemoryAllocationCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxMemoryAllocationCount:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMemoryAllocationCount);
    *rString += "\n"; // GDS

    // uint32_t maxSamplerAllocationCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxSamplerAllocationCount:      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxSamplerAllocationCount);
    *rString += "\n"; // GDS

    // VkDeviceSize bufferImageGranularity // SMB
    indentSpaces(rString, indent);
    *rString += "bufferImageGranularity:         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->bufferImageGranularity);
    *rString += "\n"; // GDS

    // VkDeviceSize sparseAddressSpaceSize // SMB
    indentSpaces(rString, indent);
    *rString += "sparseAddressSpaceSize:         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->sparseAddressSpaceSize);
    *rString += "\n"; // GDS

    // uint32_t maxBoundDescriptorSets // SMB
    indentSpaces(rString, indent);
    *rString += "maxBoundDescriptorSets:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxBoundDescriptorSets);
    *rString += "\n"; // GDS

    // uint32_t maxPerStageDescriptorSamplers // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerStageDescriptorSamplers:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerStageDescriptorSamplers);
    *rString += "\n"; // GDS

    // uint32_t maxPerStageDescriptorUniformBuffers // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerStageDescriptorUniformBuffers: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerStageDescriptorUniformBuffers);
    *rString += "\n"; // GDS

    // uint32_t maxPerStageDescriptorStorageBuffers // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerStageDescriptorStorageBuffers: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerStageDescriptorStorageBuffers);
    *rString += "\n"; // GDS

    // uint32_t maxPerStageDescriptorSampledImages // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerStageDescriptorSampledImages: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerStageDescriptorSampledImages);
    *rString += "\n"; // GDS

    // uint32_t maxPerStageDescriptorStorageImages // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerStageDescriptorStorageImages: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerStageDescriptorStorageImages);
    *rString += "\n"; // GDS

    // uint32_t maxPerStageDescriptorInputAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerStageDescriptorInputAttachments: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerStageDescriptorInputAttachments);
    *rString += "\n"; // GDS

    // uint32_t maxPerStageResources // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerStageResources:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerStageResources);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetSamplers // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetSamplers:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetSamplers);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetUniformBuffers // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetUniformBuffers: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetUniformBuffers);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetUniformBuffersDynamic // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetUniformBuffersDynamic: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetUniformBuffersDynamic);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetStorageBuffers // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetStorageBuffers: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetStorageBuffers);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetStorageBuffersDynamic // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetStorageBuffersDynamic: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetStorageBuffersDynamic);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetSampledImages // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetSampledImages:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetSampledImages);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetStorageImages // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetStorageImages:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetStorageImages);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetInputAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetInputAttachments: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetInputAttachments);
    *rString += "\n"; // GDS

    // uint32_t maxVertexInputAttributes // SMB
    indentSpaces(rString, indent);
    *rString += "maxVertexInputAttributes:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxVertexInputAttributes);
    *rString += "\n"; // GDS

    // uint32_t maxVertexInputBindings // SMB
    indentSpaces(rString, indent);
    *rString += "maxVertexInputBindings:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxVertexInputBindings);
    *rString += "\n"; // GDS

    // uint32_t maxVertexInputAttributeOffset // SMB
    indentSpaces(rString, indent);
    *rString += "maxVertexInputAttributeOffset:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxVertexInputAttributeOffset);
    *rString += "\n"; // GDS

    // uint32_t maxVertexInputBindingStride // SMB
    indentSpaces(rString, indent);
    *rString += "maxVertexInputBindingStride:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxVertexInputBindingStride);
    *rString += "\n"; // GDS

    // uint32_t maxVertexOutputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxVertexOutputComponents:      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxVertexOutputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationGenerationLevel // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationGenerationLevel: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationGenerationLevel);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationPatchSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationPatchSize:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationPatchSize);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationControlPerVertexInputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationControlPerVertexInputComponents: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationControlPerVertexInputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationControlPerVertexOutputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationControlPerVertexOutputComponents: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationControlPerVertexOutputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationControlPerPatchOutputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationControlPerPatchOutputComponents: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationControlPerPatchOutputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationControlTotalOutputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationControlTotalOutputComponents: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationControlTotalOutputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationEvaluationInputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationEvaluationInputComponents: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationEvaluationInputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxTessellationEvaluationOutputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxTessellationEvaluationOutputComponents: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTessellationEvaluationOutputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxGeometryShaderInvocations // SMB
    indentSpaces(rString, indent);
    *rString += "maxGeometryShaderInvocations:   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxGeometryShaderInvocations);
    *rString += "\n"; // GDS

    // uint32_t maxGeometryInputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxGeometryInputComponents:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxGeometryInputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxGeometryOutputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxGeometryOutputComponents:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxGeometryOutputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxGeometryOutputVertices // SMB
    indentSpaces(rString, indent);
    *rString += "maxGeometryOutputVertices:      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxGeometryOutputVertices);
    *rString += "\n"; // GDS

    // uint32_t maxGeometryTotalOutputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxGeometryTotalOutputComponents: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxGeometryTotalOutputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxFragmentInputComponents // SMB
    indentSpaces(rString, indent);
    *rString += "maxFragmentInputComponents:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxFragmentInputComponents);
    *rString += "\n"; // GDS

    // uint32_t maxFragmentOutputAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "maxFragmentOutputAttachments:   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxFragmentOutputAttachments);
    *rString += "\n"; // GDS

    // uint32_t maxFragmentDualSrcAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "maxFragmentDualSrcAttachments:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxFragmentDualSrcAttachments);
    *rString += "\n"; // GDS

    // uint32_t maxFragmentCombinedOutputResources // SMB
    indentSpaces(rString, indent);
    *rString += "maxFragmentCombinedOutputResources: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxFragmentCombinedOutputResources);
    *rString += "\n"; // GDS

    // uint32_t maxComputeSharedMemorySize // SMB
    indentSpaces(rString, indent);
    *rString += "maxComputeSharedMemorySize:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxComputeSharedMemorySize);
    *rString += "\n"; // GDS

    // uint32_t maxComputeWorkGroupCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxComputeWorkGroupCount:       ";
    *rString += "uint32_t[";
    *rString += "3";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupCount)); // IYY
    ValueToStringStruct vinfo_maxComputeWorkGroupCount = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->maxComputeWorkGroupCount), "maxComputeWorkGroupCount", 3, vinfo_maxComputeWorkGroupCount); // JPA
    *rString += "\n"; // GDS

    // uint32_t maxComputeWorkGroupInvocations // SMB
    indentSpaces(rString, indent);
    *rString += "maxComputeWorkGroupInvocations: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxComputeWorkGroupInvocations);
    *rString += "\n"; // GDS

    // uint32_t maxComputeWorkGroupSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxComputeWorkGroupSize:        ";
    *rString += "uint32_t[";
    *rString += "3";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_maxComputeWorkGroupSize = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->maxComputeWorkGroupSize), "maxComputeWorkGroupSize", 3, vinfo_maxComputeWorkGroupSize); // JPA
    *rString += "\n"; // GDS

    // uint32_t subPixelPrecisionBits // SMB
    indentSpaces(rString, indent);
    *rString += "subPixelPrecisionBits:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subPixelPrecisionBits);
    *rString += "\n"; // GDS

    // uint32_t subTexelPrecisionBits // SMB
    indentSpaces(rString, indent);
    *rString += "subTexelPrecisionBits:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subTexelPrecisionBits);
    *rString += "\n"; // GDS

    // uint32_t mipmapPrecisionBits // SMB
    indentSpaces(rString, indent);
    *rString += "mipmapPrecisionBits:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->mipmapPrecisionBits);
    *rString += "\n"; // GDS

    // uint32_t maxDrawIndexedIndexValue // SMB
    indentSpaces(rString, indent);
    *rString += "maxDrawIndexedIndexValue:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDrawIndexedIndexValue);
    *rString += "\n"; // GDS

    // uint32_t maxDrawIndirectCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxDrawIndirectCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDrawIndirectCount);
    *rString += "\n"; // GDS

    // float maxSamplerLodBias // SMB
    indentSpaces(rString, indent);
    *rString += "maxSamplerLodBias:              ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxSamplerLodBias);
    *rString += "\n"; // GDS

    // float maxSamplerAnisotropy // SMB
    indentSpaces(rString, indent);
    *rString += "maxSamplerAnisotropy:           ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxSamplerAnisotropy);
    *rString += "\n"; // GDS

    // uint32_t maxViewports // SMB
    indentSpaces(rString, indent);
    *rString += "maxViewports:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxViewports);
    *rString += "\n"; // GDS

    // uint32_t maxViewportDimensions // SMB
    indentSpaces(rString, indent);
    *rString += "maxViewportDimensions:          ";
    *rString += "uint32_t[";
    *rString += "2";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceLimits, maxViewportDimensions)); // IYY
    ValueToStringStruct vinfo_maxViewportDimensions = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->maxViewportDimensions), "maxViewportDimensions", 2, vinfo_maxViewportDimensions); // JPA
    *rString += "\n"; // GDS

    // float viewportBoundsRange // SMB
    indentSpaces(rString, indent);
    *rString += "viewportBoundsRange:            ";
    *rString += "float[";
    *rString += "2";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceLimits, viewportBoundsRange)); // IYY
    ValueToStringStruct vinfo_viewportBoundsRange = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->viewportBoundsRange), "viewportBoundsRange", 2, vinfo_viewportBoundsRange); // JPA
    *rString += "\n"; // GDS

    // uint32_t viewportSubPixelBits // SMB
    indentSpaces(rString, indent);
    *rString += "viewportSubPixelBits:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->viewportSubPixelBits);
    *rString += "\n"; // GDS

    // size_t minMemoryMapAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minMemoryMapAlignment:          ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->minMemoryMapAlignment);
    *rString += "\n"; // GDS

    // VkDeviceSize minTexelBufferOffsetAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minTexelBufferOffsetAlignment:  ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->minTexelBufferOffsetAlignment);
    *rString += "\n"; // GDS

    // VkDeviceSize minUniformBufferOffsetAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minUniformBufferOffsetAlignment: ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->minUniformBufferOffsetAlignment);
    *rString += "\n"; // GDS

    // VkDeviceSize minStorageBufferOffsetAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minStorageBufferOffsetAlignment: ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->minStorageBufferOffsetAlignment);
    *rString += "\n"; // GDS

    // int32_t minTexelOffset // SMB
    indentSpaces(rString, indent);
    *rString += "minTexelOffset:                 ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->minTexelOffset);
    *rString += "\n"; // GDS

    // uint32_t maxTexelOffset // SMB
    indentSpaces(rString, indent);
    *rString += "maxTexelOffset:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTexelOffset);
    *rString += "\n"; // GDS

    // int32_t minTexelGatherOffset // SMB
    indentSpaces(rString, indent);
    *rString += "minTexelGatherOffset:           ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->minTexelGatherOffset);
    *rString += "\n"; // GDS

    // uint32_t maxTexelGatherOffset // SMB
    indentSpaces(rString, indent);
    *rString += "maxTexelGatherOffset:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTexelGatherOffset);
    *rString += "\n"; // GDS

    // float minInterpolationOffset // SMB
    indentSpaces(rString, indent);
    *rString += "minInterpolationOffset:         ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->minInterpolationOffset);
    *rString += "\n"; // GDS

    // float maxInterpolationOffset // SMB
    indentSpaces(rString, indent);
    *rString += "maxInterpolationOffset:         ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxInterpolationOffset);
    *rString += "\n"; // GDS

    // uint32_t subPixelInterpolationOffsetBits // SMB
    indentSpaces(rString, indent);
    *rString += "subPixelInterpolationOffsetBits: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subPixelInterpolationOffsetBits);
    *rString += "\n"; // GDS

    // uint32_t maxFramebufferWidth // SMB
    indentSpaces(rString, indent);
    *rString += "maxFramebufferWidth:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxFramebufferWidth);
    *rString += "\n"; // GDS

    // uint32_t maxFramebufferHeight // SMB
    indentSpaces(rString, indent);
    *rString += "maxFramebufferHeight:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxFramebufferHeight);
    *rString += "\n"; // GDS

    // uint32_t maxFramebufferLayers // SMB
    indentSpaces(rString, indent);
    *rString += "maxFramebufferLayers:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxFramebufferLayers);
    *rString += "\n"; // GDS

    // VkSampleCountFlags framebufferColorSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "framebufferColorSampleCounts:   ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->framebufferColorSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags framebufferDepthSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "framebufferDepthSampleCounts:   ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->framebufferDepthSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags framebufferStencilSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "framebufferStencilSampleCounts: ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->framebufferStencilSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags framebufferNoAttachmentsSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "framebufferNoAttachmentsSampleCounts: ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->framebufferNoAttachmentsSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t maxColorAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "maxColorAttachments:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxColorAttachments);
    *rString += "\n"; // GDS

    // VkSampleCountFlags sampledImageColorSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "sampledImageColorSampleCounts:  ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->sampledImageColorSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags sampledImageIntegerSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "sampledImageIntegerSampleCounts: ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->sampledImageIntegerSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags sampledImageDepthSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "sampledImageDepthSampleCounts:  ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->sampledImageDepthSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags sampledImageStencilSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "sampledImageStencilSampleCounts: ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->sampledImageStencilSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags storageImageSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "storageImageSampleCounts:       ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->storageImageSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t maxSampleMaskWords // SMB
    indentSpaces(rString, indent);
    *rString += "maxSampleMaskWords:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxSampleMaskWords);
    *rString += "\n"; // GDS

    // VkBool32 timestampComputeAndGraphics // SMB
    indentSpaces(rString, indent);
    *rString += "timestampComputeAndGraphics:    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->timestampComputeAndGraphics);
    *rString += "\n"; // GDS

    // float timestampPeriod // SMB
    indentSpaces(rString, indent);
    *rString += "timestampPeriod:                ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->timestampPeriod);
    *rString += "\n"; // GDS

    // uint32_t maxClipDistances // SMB
    indentSpaces(rString, indent);
    *rString += "maxClipDistances:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxClipDistances);
    *rString += "\n"; // GDS

    // uint32_t maxCullDistances // SMB
    indentSpaces(rString, indent);
    *rString += "maxCullDistances:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxCullDistances);
    *rString += "\n"; // GDS

    // uint32_t maxCombinedClipAndCullDistances // SMB
    indentSpaces(rString, indent);
    *rString += "maxCombinedClipAndCullDistances: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxCombinedClipAndCullDistances);
    *rString += "\n"; // GDS

    // uint32_t discreteQueuePriorities // SMB
    indentSpaces(rString, indent);
    *rString += "discreteQueuePriorities:        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->discreteQueuePriorities);
    *rString += "\n"; // GDS

    // float pointSizeRange // SMB
    indentSpaces(rString, indent);
    *rString += "pointSizeRange:                 ";
    *rString += "float[";
    *rString += "2";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceLimits, pointSizeRange)); // IYY
    ValueToStringStruct vinfo_pointSizeRange = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->pointSizeRange), "pointSizeRange", 2, vinfo_pointSizeRange); // JPA
    *rString += "\n"; // GDS

    // float lineWidthRange // SMB
    indentSpaces(rString, indent);
    *rString += "lineWidthRange:                 ";
    *rString += "float[";
    *rString += "2";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceLimits, lineWidthRange)); // IYY
    ValueToStringStruct vinfo_lineWidthRange = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->lineWidthRange), "lineWidthRange", 2, vinfo_lineWidthRange); // JPA
    *rString += "\n"; // GDS

    // float pointSizeGranularity // SMB
    indentSpaces(rString, indent);
    *rString += "pointSizeGranularity:           ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->pointSizeGranularity);
    *rString += "\n"; // GDS

    // float lineWidthGranularity // SMB
    indentSpaces(rString, indent);
    *rString += "lineWidthGranularity:           ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->lineWidthGranularity);
    *rString += "\n"; // GDS

    // VkBool32 strictLines // SMB
    indentSpaces(rString, indent);
    *rString += "strictLines:                    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->strictLines);
    *rString += "\n"; // GDS

    // VkBool32 standardSampleLocations // SMB
    indentSpaces(rString, indent);
    *rString += "standardSampleLocations:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->standardSampleLocations);
    *rString += "\n"; // GDS

    // VkDeviceSize optimalBufferCopyOffsetAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "optimalBufferCopyOffsetAlignment: ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->optimalBufferCopyOffsetAlignment);
    *rString += "\n"; // GDS

    // VkDeviceSize optimalBufferCopyRowPitchAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "optimalBufferCopyRowPitchAlignment: ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->optimalBufferCopyRowPitchAlignment);
    *rString += "\n"; // GDS

    // VkDeviceSize nonCoherentAtomSize // SMB
    indentSpaces(rString, indent);
    *rString += "nonCoherentAtomSize:            ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->nonCoherentAtomSize);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceSparseProperties>(std::string* rString, const Decoded_VkPhysicalDeviceSparseProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceSparseProperties *pStruct = (const VkPhysicalDeviceSparseProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkBool32 residencyStandard2DBlockShape // SMB
    indentSpaces(rString, indent);
    *rString += "residencyStandard2DBlockShape:  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->residencyStandard2DBlockShape);
    *rString += "\n"; // GDS

    // VkBool32 residencyStandard2DMultisampleBlockShape // SMB
    indentSpaces(rString, indent);
    *rString += "residencyStandard2DMultisampleBlockShape: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->residencyStandard2DMultisampleBlockShape);
    *rString += "\n"; // GDS

    // VkBool32 residencyStandard3DBlockShape // SMB
    indentSpaces(rString, indent);
    *rString += "residencyStandard3DBlockShape:  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->residencyStandard3DBlockShape);
    *rString += "\n"; // GDS

    // VkBool32 residencyAlignedMipSize // SMB
    indentSpaces(rString, indent);
    *rString += "residencyAlignedMipSize:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->residencyAlignedMipSize);
    *rString += "\n"; // GDS

    // VkBool32 residencyNonResidentStrict // SMB
    indentSpaces(rString, indent);
    *rString += "residencyNonResidentStrict:     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->residencyNonResidentStrict);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceProperties>(std::string* rString, const Decoded_VkPhysicalDeviceProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceProperties *pStruct = (const VkPhysicalDeviceProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t apiVersion // SMB
    indentSpaces(rString, indent);
    *rString += "apiVersion:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->apiVersion);
    *rString += "\n"; // GDS

    // uint32_t driverVersion // SMB
    indentSpaces(rString, indent);
    *rString += "driverVersion:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->driverVersion);
    *rString += "\n"; // GDS

    // uint32_t vendorID // SMB
    indentSpaces(rString, indent);
    *rString += "vendorID:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->vendorID);
    *rString += "\n"; // GDS

    // uint32_t deviceID // SMB
    indentSpaces(rString, indent);
    *rString += "deviceID:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceID);
    *rString += "\n"; // GDS

    // VkPhysicalDeviceType deviceType // SMB
    indentSpaces(rString, indent);
    *rString += "deviceType:                     ";
    *rString += "VkPhysicalDeviceType = "; // TEQ
    enumToString_VkPhysicalDeviceType(rString, pStruct->deviceType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->deviceType);
    *rString += ")";
    *rString += "\n"; // GDS

    // char deviceName // SMB
    indentSpaces(rString, indent);
    *rString += "deviceName:                     ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_deviceName = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->deviceName), "deviceName", VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, vinfo_deviceName); // JPA
    *rString += "\n"; // GDS

    // uint8_t pipelineCacheUUID // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineCacheUUID:              ";
    *rString += "uint8_t[";
    *rString += "VK_UUID_SIZE";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceProperties, pipelineCacheUUID)); // IYY
    ValueToStringStruct vinfo_pipelineCacheUUID = {false, false, false, nullptr};
    arrayToString<uint8_t*>(rString, indent, 0, "uint8_t", const_cast<uint8_t*>(pStruct->pipelineCacheUUID), "pipelineCacheUUID", VK_UUID_SIZE, vinfo_pipelineCacheUUID); // JPA
    *rString += "\n"; // GDS

    // VkPhysicalDeviceLimits limits // SMB
    indentSpaces(rString, indent);
    *rString += "limits:                         ";
    *rString += "VkPhysicalDeviceLimits = "; // TEQ
    structureToString<Decoded_VkPhysicalDeviceLimits>(rString, *pStructIn.limits, indent+1,  baseAddr + offsetof(VkPhysicalDeviceProperties, limits)); // AZJ
    *rString += "\n"; // GDS

    // VkPhysicalDeviceSparseProperties sparseProperties // SMB
    indentSpaces(rString, indent);
    *rString += "sparseProperties:               ";
    *rString += "VkPhysicalDeviceSparseProperties = "; // TEQ
    structureToString<Decoded_VkPhysicalDeviceSparseProperties>(rString, *pStructIn.sparseProperties, indent+1,  baseAddr + offsetof(VkPhysicalDeviceProperties, sparseProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkQueueFamilyProperties>(std::string* rString, const Decoded_VkQueueFamilyProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkQueueFamilyProperties *pStruct = (const VkQueueFamilyProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkQueueFlags queueFlags // SMB
    indentSpaces(rString, indent);
    *rString += "queueFlags:                     ";
    *rString += "VkQueueFlags = "; // TEQ
    flagsToString(rString, pStruct->queueFlags, enumToString_VkQueueFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t queueCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueCount);
    *rString += "\n"; // GDS

    // uint32_t timestampValidBits // SMB
    indentSpaces(rString, indent);
    *rString += "timestampValidBits:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->timestampValidBits);
    *rString += "\n"; // GDS

    // VkExtent3D minImageTransferGranularity // SMB
    indentSpaces(rString, indent);
    *rString += "minImageTransferGranularity:    ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.minImageTransferGranularity, indent+1,  baseAddr + offsetof(VkQueueFamilyProperties, minImageTransferGranularity)); // AZJ
}

template <>
void structureToString<Decoded_VkMemoryType>(std::string* rString, const Decoded_VkMemoryType &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryType *pStruct = (const VkMemoryType *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkMemoryPropertyFlags propertyFlags // SMB
    indentSpaces(rString, indent);
    *rString += "propertyFlags:                  ";
    *rString += "VkMemoryPropertyFlags = "; // TEQ
    flagsToString(rString, pStruct->propertyFlags, enumToString_VkMemoryPropertyFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t heapIndex // SMB
    indentSpaces(rString, indent);
    *rString += "heapIndex:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->heapIndex);
}

template <>
void structureToString<Decoded_VkMemoryHeap>(std::string* rString, const Decoded_VkMemoryHeap &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryHeap *pStruct = (const VkMemoryHeap *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
    *rString += "\n"; // GDS

    // VkMemoryHeapFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkMemoryHeapFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkMemoryHeapFlagBits); // URW
}

template <>
void structureToString<Decoded_VkPhysicalDeviceMemoryProperties>(std::string* rString, const Decoded_VkPhysicalDeviceMemoryProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceMemoryProperties *pStruct = (const VkPhysicalDeviceMemoryProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t memoryTypeCount // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypeCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryTypeCount);
    *rString += "\n"; // GDS

    // VkMemoryType memoryTypes // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypes:                    ";
    *rString += "VkMemoryType[";
    unsignedDecimalToString(rString, pStruct->memoryTypeCount);
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceMemoryProperties, memoryTypes)); // IYY
    arrayOfStructsToString<Decoded_VkMemoryType>(rString, indent+1, 0, "VkMemoryType", pStructIn.memoryTypes->GetMetaStructPointer(), "memoryTypes", pStruct->memoryTypeCount , false, pStructIn.memoryTypes->GetAddress()); // EPB
    *rString += "\n"; // GDS

    // uint32_t memoryHeapCount // SMB
    indentSpaces(rString, indent);
    *rString += "memoryHeapCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryHeapCount);
    *rString += "\n"; // GDS

    // VkMemoryHeap memoryHeaps // SMB
    indentSpaces(rString, indent);
    *rString += "memoryHeaps:                    ";
    *rString += "VkMemoryHeap[";
    unsignedDecimalToString(rString, pStruct->memoryHeapCount);
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceMemoryProperties, memoryHeaps)); // IYY
    arrayOfStructsToString<Decoded_VkMemoryHeap>(rString, indent+1, 0, "VkMemoryHeap", pStructIn.memoryHeaps->GetMetaStructPointer(), "memoryHeaps", pStruct->memoryHeapCount , false, pStructIn.memoryHeaps->GetAddress()); // EPB
}

template <>
void structureToString<Decoded_VkDeviceQueueCreateInfo>(std::string* rString, const Decoded_VkDeviceQueueCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceQueueCreateInfo *pStruct = (const VkDeviceQueueCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceQueueCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDeviceQueueCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkDeviceQueueCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t queueFamilyIndex // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyIndex:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueFamilyIndex);
    *rString += "\n"; // GDS

    // uint32_t queueCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueCount);
    *rString += "\n"; // GDS

    // const float* pQueuePriorities // SMB
    indentSpaces(rString, indent);
    *rString += "pQueuePriorities:               ";
    *rString += "const float* = "; // TEQ
    if (pStruct->pQueuePriorities == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pQueuePriorities.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueuePriorities = {false, false, false, nullptr};
        arrayToString<const float*>(rString, indent, 1, "const float*", reinterpret_cast<const float*>(pStructIn.pQueuePriorities.GetPointer()), "pQueuePriorities", pStruct->queueCount,  vinfo_pQueuePriorities);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkDeviceCreateInfo>(std::string* rString, const Decoded_VkDeviceCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceCreateInfo *pStruct = (const VkDeviceCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDeviceCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t queueCreateInfoCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueCreateInfoCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueCreateInfoCount);
    *rString += "\n"; // GDS

    // const VkDeviceQueueCreateInfo* pQueueCreateInfos // SMB
    indentSpaces(rString, indent);
    *rString += "pQueueCreateInfos:              ";
    *rString += "const VkDeviceQueueCreateInfo* = "; // TEQ
    if (pStruct->pQueueCreateInfos == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pQueueCreateInfos->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDeviceQueueCreateInfo>(rString, indent+1, 1, "VkDeviceQueueCreateInfo", pStructIn.pQueueCreateInfos->GetMetaStructPointer(), "pQueueCreateInfos", pStruct->queueCreateInfoCount, false, pStructIn.pQueueCreateInfos->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t enabledLayerCount // SMB
    indentSpaces(rString, indent);
    *rString += "enabledLayerCount:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->enabledLayerCount);
    *rString += "\n"; // GDS

    // const char* const* ppEnabledLayerNames // SMB
    indentSpaces(rString, indent);
    *rString += "ppEnabledLayerNames:            ";
    *rString += "const char* const* = "; // TEQ
    if (pStruct->ppEnabledLayerNames == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.ppEnabledLayerNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        arrayToString<const char* const*>(rString, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pStructIn.ppEnabledLayerNames.GetPointer()), "ppEnabledLayerNames", pStruct->enabledLayerCount,  vinfo_ppEnabledLayerNames);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t enabledExtensionCount // SMB
    indentSpaces(rString, indent);
    *rString += "enabledExtensionCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->enabledExtensionCount);
    *rString += "\n"; // GDS

    // const char* const* ppEnabledExtensionNames // SMB
    indentSpaces(rString, indent);
    *rString += "ppEnabledExtensionNames:        ";
    *rString += "const char* const* = "; // TEQ
    if (pStruct->ppEnabledExtensionNames == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.ppEnabledExtensionNames.GetAddress()); // PAZ
        ValueToStringStruct vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        arrayToString<const char* const*>(rString, indent, 2, "const char* const*", reinterpret_cast<const char* const*>(pStructIn.ppEnabledExtensionNames.GetPointer()), "ppEnabledExtensionNames", pStruct->enabledExtensionCount,  vinfo_ppEnabledExtensionNames);  // CCQ
    }
    *rString += "\n"; // GDS

    // const VkPhysicalDeviceFeatures* pEnabledFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "pEnabledFeatures:               ";
    *rString += "const VkPhysicalDeviceFeatures* = "; // TEQ
    if (pStruct->pEnabledFeatures == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pEnabledFeatures->GetAddress()); // JHI
        structureToString<Decoded_VkPhysicalDeviceFeatures>(rString, *pStructIn.pEnabledFeatures->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkDeviceCreateInfo, pEnabledFeatures)); // GLM
    }
}

template <>
void structureToString<Decoded_VkExtensionProperties>(std::string* rString, const Decoded_VkExtensionProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExtensionProperties *pStruct = (const VkExtensionProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // char extensionName // SMB
    indentSpaces(rString, indent);
    *rString += "extensionName:                  ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_extensionName = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->extensionName), "extensionName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_extensionName); // JPA
    *rString += "\n"; // GDS

    // uint32_t specVersion // SMB
    indentSpaces(rString, indent);
    *rString += "specVersion:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->specVersion);
}

template <>
void structureToString<Decoded_VkLayerProperties>(std::string* rString, const Decoded_VkLayerProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkLayerProperties *pStruct = (const VkLayerProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // char layerName // SMB
    indentSpaces(rString, indent);
    *rString += "layerName:                      ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_layerName = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->layerName), "layerName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_layerName); // JPA
    *rString += "\n"; // GDS

    // uint32_t specVersion // SMB
    indentSpaces(rString, indent);
    *rString += "specVersion:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->specVersion);
    *rString += "\n"; // GDS

    // uint32_t implementationVersion // SMB
    indentSpaces(rString, indent);
    *rString += "implementationVersion:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->implementationVersion);
    *rString += "\n"; // GDS

    // char description // SMB
    indentSpaces(rString, indent);
    *rString += "description:                    ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
}

template <>
void structureToString<Decoded_VkSubmitInfo>(std::string* rString, const Decoded_VkSubmitInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubmitInfo *pStruct = (const VkSubmitInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "waitSemaphoreCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->waitSemaphoreCount);
    *rString += "\n"; // GDS

    // const VkSemaphore* pWaitSemaphores // SMB
    indentSpaces(rString, indent);
    *rString += "pWaitSemaphores:                ";
    *rString += "const VkSemaphore* = "; // TEQ
    if (pStruct->pWaitSemaphores == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pWaitSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        arrayToString<const VkSemaphore*>(rString, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pStructIn.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pStruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CCQ
    }
    *rString += "\n"; // GDS

    // const VkPipelineStageFlags* pWaitDstStageMask // SMB
    indentSpaces(rString, indent);
    *rString += "pWaitDstStageMask:              ";
    *rString += "const VkPipelineStageFlags* = "; // TEQ
    if (pStruct->pWaitDstStageMask == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pWaitDstStageMask.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitDstStageMask = {false, false, true, enumToString_VkPipelineStageFlagBits};
        arrayToString<const VkPipelineStageFlags*>(rString, indent, 1, "const VkPipelineStageFlags*", reinterpret_cast<const VkPipelineStageFlags*>(pStructIn.pWaitDstStageMask.GetPointer()), "pWaitDstStageMask", pStruct->waitSemaphoreCount,  vinfo_pWaitDstStageMask);  // CCR
    }
    *rString += "\n"; // GDS

    // uint32_t commandBufferCount // SMB
    indentSpaces(rString, indent);
    *rString += "commandBufferCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->commandBufferCount);
    *rString += "\n"; // GDS

    // const VkCommandBuffer* pCommandBuffers // SMB
    indentSpaces(rString, indent);
    *rString += "pCommandBuffers:                ";
    *rString += "const VkCommandBuffer* = "; // TEQ
    if (pStruct->pCommandBuffers == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCommandBuffers.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        arrayToString<const VkCommandBuffer*>(rString, indent, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pStructIn.pCommandBuffers.GetPointer()), "pCommandBuffers", pStruct->commandBufferCount,  vinfo_pCommandBuffers);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t signalSemaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "signalSemaphoreCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->signalSemaphoreCount);
    *rString += "\n"; // GDS

    // const VkSemaphore* pSignalSemaphores // SMB
    indentSpaces(rString, indent);
    *rString += "pSignalSemaphores:              ";
    *rString += "const VkSemaphore* = "; // TEQ
    if (pStruct->pSignalSemaphores == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSignalSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        arrayToString<const VkSemaphore*>(rString, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pStructIn.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pStruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkMemoryAllocateInfo>(std::string* rString, const Decoded_VkMemoryAllocateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryAllocateInfo *pStruct = (const VkMemoryAllocateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceSize allocationSize // SMB
    indentSpaces(rString, indent);
    *rString += "allocationSize:                 ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->allocationSize);
    *rString += "\n"; // GDS

    // uint32_t memoryTypeIndex // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypeIndex:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryTypeIndex);
}

template <>
void structureToString<Decoded_VkMappedMemoryRange>(std::string* rString, const Decoded_VkMappedMemoryRange &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMappedMemoryRange *pStruct = (const VkMappedMemoryRange *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
}

template <>
void structureToString<Decoded_VkMemoryRequirements>(std::string* rString, const Decoded_VkMemoryRequirements &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryRequirements *pStruct = (const VkMemoryRequirements *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
    *rString += "\n"; // GDS

    // VkDeviceSize alignment // SMB
    indentSpaces(rString, indent);
    *rString += "alignment:                      ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->alignment);
    *rString += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypeBits:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryTypeBits);
}

template <>
void structureToString<Decoded_VkSparseImageFormatProperties>(std::string* rString, const Decoded_VkSparseImageFormatProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseImageFormatProperties *pStruct = (const VkSparseImageFormatProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    indentSpaces(rString, indent);
    *rString += "aspectMask:                     ";
    *rString += "VkImageAspectFlags = "; // TEQ
    flagsToString(rString, pStruct->aspectMask, enumToString_VkImageAspectFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExtent3D imageGranularity // SMB
    indentSpaces(rString, indent);
    *rString += "imageGranularity:               ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.imageGranularity, indent+1,  baseAddr + offsetof(VkSparseImageFormatProperties, imageGranularity)); // AZJ
    *rString += "\n"; // GDS

    // VkSparseImageFormatFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSparseImageFormatFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSparseImageFormatFlagBits); // URW
}

template <>
void structureToString<Decoded_VkSparseImageMemoryRequirements>(std::string* rString, const Decoded_VkSparseImageMemoryRequirements &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseImageMemoryRequirements *pStruct = (const VkSparseImageMemoryRequirements *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkSparseImageFormatProperties formatProperties // SMB
    indentSpaces(rString, indent);
    *rString += "formatProperties:               ";
    *rString += "VkSparseImageFormatProperties = "; // TEQ
    structureToString<Decoded_VkSparseImageFormatProperties>(rString, *pStructIn.formatProperties, indent+1,  baseAddr + offsetof(VkSparseImageMemoryRequirements, formatProperties)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t imageMipTailFirstLod // SMB
    indentSpaces(rString, indent);
    *rString += "imageMipTailFirstLod:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->imageMipTailFirstLod);
    *rString += "\n"; // GDS

    // VkDeviceSize imageMipTailSize // SMB
    indentSpaces(rString, indent);
    *rString += "imageMipTailSize:               ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->imageMipTailSize);
    *rString += "\n"; // GDS

    // VkDeviceSize imageMipTailOffset // SMB
    indentSpaces(rString, indent);
    *rString += "imageMipTailOffset:             ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->imageMipTailOffset);
    *rString += "\n"; // GDS

    // VkDeviceSize imageMipTailStride // SMB
    indentSpaces(rString, indent);
    *rString += "imageMipTailStride:             ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->imageMipTailStride);
}

template <>
void structureToString<Decoded_VkSparseMemoryBind>(std::string* rString, const Decoded_VkSparseMemoryBind &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseMemoryBind *pStruct = (const VkSparseMemoryBind *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDeviceSize resourceOffset // SMB
    indentSpaces(rString, indent);
    *rString += "resourceOffset:                 ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->resourceOffset);
    *rString += "\n"; // GDS

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    indentSpaces(rString, indent);
    *rString += "memoryOffset:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->memoryOffset);
    *rString += "\n"; // GDS

    // VkSparseMemoryBindFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSparseMemoryBindFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSparseMemoryBindFlagBits); // URW
}

template <>
void structureToString<Decoded_VkSparseBufferMemoryBindInfo>(std::string* rString, const Decoded_VkSparseBufferMemoryBindInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseBufferMemoryBindInfo *pStruct = (const VkSparseBufferMemoryBindInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t bindCount // SMB
    indentSpaces(rString, indent);
    *rString += "bindCount:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bindCount);
    *rString += "\n"; // GDS

    // const VkSparseMemoryBind* pBinds // SMB
    indentSpaces(rString, indent);
    *rString += "pBinds:                         ";
    *rString += "const VkSparseMemoryBind* = "; // TEQ
    if (pStruct->pBinds == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pBinds->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSparseMemoryBind>(rString, indent+1, 1, "VkSparseMemoryBind", pStructIn.pBinds->GetMetaStructPointer(), "pBinds", pStruct->bindCount, false, pStructIn.pBinds->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(std::string* rString, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseImageOpaqueMemoryBindInfo *pStruct = (const VkSparseImageOpaqueMemoryBindInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t bindCount // SMB
    indentSpaces(rString, indent);
    *rString += "bindCount:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bindCount);
    *rString += "\n"; // GDS

    // const VkSparseMemoryBind* pBinds // SMB
    indentSpaces(rString, indent);
    *rString += "pBinds:                         ";
    *rString += "const VkSparseMemoryBind* = "; // TEQ
    if (pStruct->pBinds == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pBinds->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSparseMemoryBind>(rString, indent+1, 1, "VkSparseMemoryBind", pStructIn.pBinds->GetMetaStructPointer(), "pBinds", pStruct->bindCount, false, pStructIn.pBinds->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkImageSubresource>(std::string* rString, const Decoded_VkImageSubresource &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageSubresource *pStruct = (const VkImageSubresource *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    indentSpaces(rString, indent);
    *rString += "aspectMask:                     ";
    *rString += "VkImageAspectFlags = "; // TEQ
    flagsToString(rString, pStruct->aspectMask, enumToString_VkImageAspectFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t mipLevel // SMB
    indentSpaces(rString, indent);
    *rString += "mipLevel:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->mipLevel);
    *rString += "\n"; // GDS

    // uint32_t arrayLayer // SMB
    indentSpaces(rString, indent);
    *rString += "arrayLayer:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->arrayLayer);
}

template <>
void structureToString<Decoded_VkOffset3D>(std::string* rString, const Decoded_VkOffset3D &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkOffset3D *pStruct = (const VkOffset3D *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // int32_t x // SMB
    indentSpaces(rString, indent);
    *rString += "x:                              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->x);
    *rString += "\n"; // GDS

    // int32_t y // SMB
    indentSpaces(rString, indent);
    *rString += "y:                              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->y);
    *rString += "\n"; // GDS

    // int32_t z // SMB
    indentSpaces(rString, indent);
    *rString += "z:                              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->z);
}

template <>
void structureToString<Decoded_VkSparseImageMemoryBind>(std::string* rString, const Decoded_VkSparseImageMemoryBind &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseImageMemoryBind *pStruct = (const VkSparseImageMemoryBind *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageSubresource subresource // SMB
    indentSpaces(rString, indent);
    *rString += "subresource:                    ";
    *rString += "VkImageSubresource = "; // TEQ
    structureToString<Decoded_VkImageSubresource>(rString, *pStructIn.subresource, indent+1,  baseAddr + offsetof(VkSparseImageMemoryBind, subresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkOffset3D = "; // TEQ
    structureToString<Decoded_VkOffset3D>(rString, *pStructIn.offset, indent+1,  baseAddr + offsetof(VkSparseImageMemoryBind, offset)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent3D extent // SMB
    indentSpaces(rString, indent);
    *rString += "extent:                         ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.extent, indent+1,  baseAddr + offsetof(VkSparseImageMemoryBind, extent)); // AZJ
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    indentSpaces(rString, indent);
    *rString += "memoryOffset:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->memoryOffset);
    *rString += "\n"; // GDS

    // VkSparseMemoryBindFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSparseMemoryBindFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSparseMemoryBindFlagBits); // URW
}

template <>
void structureToString<Decoded_VkSparseImageMemoryBindInfo>(std::string* rString, const Decoded_VkSparseImageMemoryBindInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseImageMemoryBindInfo *pStruct = (const VkSparseImageMemoryBindInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t bindCount // SMB
    indentSpaces(rString, indent);
    *rString += "bindCount:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bindCount);
    *rString += "\n"; // GDS

    // const VkSparseImageMemoryBind* pBinds // SMB
    indentSpaces(rString, indent);
    *rString += "pBinds:                         ";
    *rString += "const VkSparseImageMemoryBind* = "; // TEQ
    if (pStruct->pBinds == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pBinds->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSparseImageMemoryBind>(rString, indent+1, 1, "VkSparseImageMemoryBind", pStructIn.pBinds->GetMetaStructPointer(), "pBinds", pStruct->bindCount, false, pStructIn.pBinds->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkBindSparseInfo>(std::string* rString, const Decoded_VkBindSparseInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindSparseInfo *pStruct = (const VkBindSparseInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "waitSemaphoreCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->waitSemaphoreCount);
    *rString += "\n"; // GDS

    // const VkSemaphore* pWaitSemaphores // SMB
    indentSpaces(rString, indent);
    *rString += "pWaitSemaphores:                ";
    *rString += "const VkSemaphore* = "; // TEQ
    if (pStruct->pWaitSemaphores == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pWaitSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        arrayToString<const VkSemaphore*>(rString, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pStructIn.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pStruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t bufferBindCount // SMB
    indentSpaces(rString, indent);
    *rString += "bufferBindCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bufferBindCount);
    *rString += "\n"; // GDS

    // const VkSparseBufferMemoryBindInfo* pBufferBinds // SMB
    indentSpaces(rString, indent);
    *rString += "pBufferBinds:                   ";
    *rString += "const VkSparseBufferMemoryBindInfo* = "; // TEQ
    if (pStruct->pBufferBinds == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pBufferBinds->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSparseBufferMemoryBindInfo>(rString, indent+1, 1, "VkSparseBufferMemoryBindInfo", pStructIn.pBufferBinds->GetMetaStructPointer(), "pBufferBinds", pStruct->bufferBindCount, false, pStructIn.pBufferBinds->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t imageOpaqueBindCount // SMB
    indentSpaces(rString, indent);
    *rString += "imageOpaqueBindCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->imageOpaqueBindCount);
    *rString += "\n"; // GDS

    // const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds // SMB
    indentSpaces(rString, indent);
    *rString += "pImageOpaqueBinds:              ";
    *rString += "const VkSparseImageOpaqueMemoryBindInfo* = "; // TEQ
    if (pStruct->pImageOpaqueBinds == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pImageOpaqueBinds->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSparseImageOpaqueMemoryBindInfo>(rString, indent+1, 1, "VkSparseImageOpaqueMemoryBindInfo", pStructIn.pImageOpaqueBinds->GetMetaStructPointer(), "pImageOpaqueBinds", pStruct->imageOpaqueBindCount, false, pStructIn.pImageOpaqueBinds->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t imageBindCount // SMB
    indentSpaces(rString, indent);
    *rString += "imageBindCount:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->imageBindCount);
    *rString += "\n"; // GDS

    // const VkSparseImageMemoryBindInfo* pImageBinds // SMB
    indentSpaces(rString, indent);
    *rString += "pImageBinds:                    ";
    *rString += "const VkSparseImageMemoryBindInfo* = "; // TEQ
    if (pStruct->pImageBinds == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pImageBinds->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSparseImageMemoryBindInfo>(rString, indent+1, 1, "VkSparseImageMemoryBindInfo", pStructIn.pImageBinds->GetMetaStructPointer(), "pImageBinds", pStruct->imageBindCount, false, pStructIn.pImageBinds->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t signalSemaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "signalSemaphoreCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->signalSemaphoreCount);
    *rString += "\n"; // GDS

    // const VkSemaphore* pSignalSemaphores // SMB
    indentSpaces(rString, indent);
    *rString += "pSignalSemaphores:              ";
    *rString += "const VkSemaphore* = "; // TEQ
    if (pStruct->pSignalSemaphores == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSignalSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphores = {true, false, false, nullptr};
        arrayToString<const VkSemaphore*>(rString, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pStructIn.pSignalSemaphores.GetPointer()), "pSignalSemaphores", pStruct->signalSemaphoreCount,  vinfo_pSignalSemaphores);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkFenceCreateInfo>(std::string* rString, const Decoded_VkFenceCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkFenceCreateInfo *pStruct = (const VkFenceCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFenceCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkFenceCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkFenceCreateFlagBits); // URW
}

template <>
void structureToString<Decoded_VkSemaphoreCreateInfo>(std::string* rString, const Decoded_VkSemaphoreCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSemaphoreCreateInfo *pStruct = (const VkSemaphoreCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphoreCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSemaphoreCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
}

template <>
void structureToString<Decoded_VkEventCreateInfo>(std::string* rString, const Decoded_VkEventCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkEventCreateInfo *pStruct = (const VkEventCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkEventCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkEventCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
}

template <>
void structureToString<Decoded_VkQueryPoolCreateInfo>(std::string* rString, const Decoded_VkQueryPoolCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkQueryPoolCreateInfo *pStruct = (const VkQueryPoolCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkQueryPoolCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkQueryPoolCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkQueryType queryType // SMB
    indentSpaces(rString, indent);
    *rString += "queryType:                      ";
    *rString += "VkQueryType = "; // TEQ
    enumToString_VkQueryType(rString, pStruct->queryType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->queryType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t queryCount // SMB
    indentSpaces(rString, indent);
    *rString += "queryCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queryCount);
    *rString += "\n"; // GDS

    // VkQueryPipelineStatisticFlags pipelineStatistics // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineStatistics:             ";
    *rString += "VkQueryPipelineStatisticFlags = "; // TEQ
    flagsToString(rString, pStruct->pipelineStatistics, enumToString_VkQueryPipelineStatisticFlagBits); // URW
}

template <>
void structureToString<Decoded_VkBufferCreateInfo>(std::string* rString, const Decoded_VkBufferCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferCreateInfo *pStruct = (const VkBufferCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBufferCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkBufferCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkBufferCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
    *rString += "\n"; // GDS

    // VkBufferUsageFlags usage // SMB
    indentSpaces(rString, indent);
    *rString += "usage:                          ";
    *rString += "VkBufferUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->usage, enumToString_VkBufferUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSharingMode sharingMode // SMB
    indentSpaces(rString, indent);
    *rString += "sharingMode:                    ";
    *rString += "VkSharingMode = "; // TEQ
    enumToString_VkSharingMode(rString, pStruct->sharingMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sharingMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyIndexCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueFamilyIndexCount);
    *rString += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pQueueFamilyIndices:            ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pStruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkBufferViewCreateInfo>(std::string* rString, const Decoded_VkBufferViewCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferViewCreateInfo *pStruct = (const VkBufferViewCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBufferViewCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkBufferViewCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // VkDeviceSize range // SMB
    indentSpaces(rString, indent);
    *rString += "range:                          ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->range);
}

template <>
void structureToString<Decoded_VkImageCreateInfo>(std::string* rString, const Decoded_VkImageCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageCreateInfo *pStruct = (const VkImageCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkImageCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkImageCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkImageType imageType // SMB
    indentSpaces(rString, indent);
    *rString += "imageType:                      ";
    *rString += "VkImageType = "; // TEQ
    enumToString_VkImageType(rString, pStruct->imageType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->imageType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkExtent3D extent // SMB
    indentSpaces(rString, indent);
    *rString += "extent:                         ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.extent, indent+1,  baseAddr + offsetof(VkImageCreateInfo, extent)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t mipLevels // SMB
    indentSpaces(rString, indent);
    *rString += "mipLevels:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->mipLevels);
    *rString += "\n"; // GDS

    // uint32_t arrayLayers // SMB
    indentSpaces(rString, indent);
    *rString += "arrayLayers:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->arrayLayers);
    *rString += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    indentSpaces(rString, indent);
    *rString += "samples:                        ";
    *rString += "VkSampleCountFlagBits = "; // TEQ
    enumToString_VkSampleCountFlagBits(rString, pStruct->samples);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->samples);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageTiling tiling // SMB
    indentSpaces(rString, indent);
    *rString += "tiling:                         ";
    *rString += "VkImageTiling = "; // TEQ
    enumToString_VkImageTiling(rString, pStruct->tiling);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->tiling);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    indentSpaces(rString, indent);
    *rString += "usage:                          ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->usage, enumToString_VkImageUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSharingMode sharingMode // SMB
    indentSpaces(rString, indent);
    *rString += "sharingMode:                    ";
    *rString += "VkSharingMode = "; // TEQ
    enumToString_VkSharingMode(rString, pStruct->sharingMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sharingMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyIndexCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueFamilyIndexCount);
    *rString += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pQueueFamilyIndices:            ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pStruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
    *rString += "\n"; // GDS

    // VkImageLayout initialLayout // SMB
    indentSpaces(rString, indent);
    *rString += "initialLayout:                  ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->initialLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->initialLayout);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkSubresourceLayout>(std::string* rString, const Decoded_VkSubresourceLayout &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubresourceLayout *pStruct = (const VkSubresourceLayout *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
    *rString += "\n"; // GDS

    // VkDeviceSize rowPitch // SMB
    indentSpaces(rString, indent);
    *rString += "rowPitch:                       ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->rowPitch);
    *rString += "\n"; // GDS

    // VkDeviceSize arrayPitch // SMB
    indentSpaces(rString, indent);
    *rString += "arrayPitch:                     ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->arrayPitch);
    *rString += "\n"; // GDS

    // VkDeviceSize depthPitch // SMB
    indentSpaces(rString, indent);
    *rString += "depthPitch:                     ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->depthPitch);
}

template <>
void structureToString<Decoded_VkComponentMapping>(std::string* rString, const Decoded_VkComponentMapping &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkComponentMapping *pStruct = (const VkComponentMapping *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkComponentSwizzle r // SMB
    indentSpaces(rString, indent);
    *rString += "r:                              ";
    *rString += "VkComponentSwizzle = "; // TEQ
    enumToString_VkComponentSwizzle(rString, pStruct->r);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->r);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentSwizzle g // SMB
    indentSpaces(rString, indent);
    *rString += "g:                              ";
    *rString += "VkComponentSwizzle = "; // TEQ
    enumToString_VkComponentSwizzle(rString, pStruct->g);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->g);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentSwizzle b // SMB
    indentSpaces(rString, indent);
    *rString += "b:                              ";
    *rString += "VkComponentSwizzle = "; // TEQ
    enumToString_VkComponentSwizzle(rString, pStruct->b);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->b);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentSwizzle a // SMB
    indentSpaces(rString, indent);
    *rString += "a:                              ";
    *rString += "VkComponentSwizzle = "; // TEQ
    enumToString_VkComponentSwizzle(rString, pStruct->a);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->a);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkImageSubresourceRange>(std::string* rString, const Decoded_VkImageSubresourceRange &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageSubresourceRange *pStruct = (const VkImageSubresourceRange *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    indentSpaces(rString, indent);
    *rString += "aspectMask:                     ";
    *rString += "VkImageAspectFlags = "; // TEQ
    flagsToString(rString, pStruct->aspectMask, enumToString_VkImageAspectFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t baseMipLevel // SMB
    indentSpaces(rString, indent);
    *rString += "baseMipLevel:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->baseMipLevel);
    *rString += "\n"; // GDS

    // uint32_t levelCount // SMB
    indentSpaces(rString, indent);
    *rString += "levelCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->levelCount);
    *rString += "\n"; // GDS

    // uint32_t baseArrayLayer // SMB
    indentSpaces(rString, indent);
    *rString += "baseArrayLayer:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->baseArrayLayer);
    *rString += "\n"; // GDS

    // uint32_t layerCount // SMB
    indentSpaces(rString, indent);
    *rString += "layerCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->layerCount);
}

template <>
void structureToString<Decoded_VkImageViewCreateInfo>(std::string* rString, const Decoded_VkImageViewCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageViewCreateInfo *pStruct = (const VkImageViewCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageViewCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkImageViewCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkImageViewCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
    *rString += "\n"; // GDS

    // VkImageViewType viewType // SMB
    indentSpaces(rString, indent);
    *rString += "viewType:                       ";
    *rString += "VkImageViewType = "; // TEQ
    enumToString_VkImageViewType(rString, pStruct->viewType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->viewType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentMapping components // SMB
    indentSpaces(rString, indent);
    *rString += "components:                     ";
    *rString += "VkComponentMapping = "; // TEQ
    structureToString<Decoded_VkComponentMapping>(rString, *pStructIn.components, indent+1,  baseAddr + offsetof(VkImageViewCreateInfo, components)); // AZJ
    *rString += "\n"; // GDS

    // VkImageSubresourceRange subresourceRange // SMB
    indentSpaces(rString, indent);
    *rString += "subresourceRange:               ";
    *rString += "VkImageSubresourceRange = "; // TEQ
    structureToString<Decoded_VkImageSubresourceRange>(rString, *pStructIn.subresourceRange, indent+1,  baseAddr + offsetof(VkImageViewCreateInfo, subresourceRange)); // AZJ
}

template <>
void structureToString<Decoded_VkShaderModuleCreateInfo>(std::string* rString, const Decoded_VkShaderModuleCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkShaderModuleCreateInfo *pStruct = (const VkShaderModuleCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkShaderModuleCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkShaderModuleCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkShaderModuleCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // size_t codeSize // SMB
    indentSpaces(rString, indent);
    *rString += "codeSize:                       ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->codeSize);
    *rString += "\n"; // GDS

    // const uint32_t* pCode // SMB
    indentSpaces(rString, indent);
    *rString += "pCode:                          ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pCode == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCode.GetAddress()); // WUX
        if (printShaderCode)
        {
            ValueToStringStruct vinfo_pCode = {false, false, false, nullptr};
            arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pCode.GetPointer()), "pCode", pStruct->codeSize / 4 / 4, vinfo_pCode);  // CCY
        }
    }
}

template <>
void structureToString<Decoded_VkPipelineCacheCreateInfo>(std::string* rString, const Decoded_VkPipelineCacheCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineCacheCreateInfo *pStruct = (const VkPipelineCacheCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineCacheCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineCacheCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // size_t initialDataSize // SMB
    indentSpaces(rString, indent);
    *rString += "initialDataSize:                ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->initialDataSize);
    *rString += "\n"; // GDS

    // const void* pInitialData // SMB
    indentSpaces(rString, indent);
    *rString += "pInitialData:                   ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pInitialData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pInitialData.GetAddress()); // AHW
    }
}

template <>
void structureToString<Decoded_VkSpecializationMapEntry>(std::string* rString, const Decoded_VkSpecializationMapEntry &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSpecializationMapEntry *pStruct = (const VkSpecializationMapEntry *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t constantID // SMB
    indentSpaces(rString, indent);
    *rString += "constantID:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->constantID);
    *rString += "\n"; // GDS

    // uint32_t offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // size_t size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->size);
}

template <>
void structureToString<Decoded_VkSpecializationInfo>(std::string* rString, const Decoded_VkSpecializationInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSpecializationInfo *pStruct = (const VkSpecializationInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t mapEntryCount // SMB
    indentSpaces(rString, indent);
    *rString += "mapEntryCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->mapEntryCount);
    *rString += "\n"; // GDS

    // const VkSpecializationMapEntry* pMapEntries // SMB
    indentSpaces(rString, indent);
    *rString += "pMapEntries:                    ";
    *rString += "const VkSpecializationMapEntry* = "; // TEQ
    if (pStruct->pMapEntries == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pMapEntries->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSpecializationMapEntry>(rString, indent+1, 1, "VkSpecializationMapEntry", pStructIn.pMapEntries->GetMetaStructPointer(), "pMapEntries", pStruct->mapEntryCount, false, pStructIn.pMapEntries->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // size_t dataSize // SMB
    indentSpaces(rString, indent);
    *rString += "dataSize:                       ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dataSize);
    *rString += "\n"; // GDS

    // const void* pData // SMB
    indentSpaces(rString, indent);
    *rString += "pData:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pData.GetAddress()); // AHW
    }
}

template <>
void structureToString<Decoded_VkPipelineShaderStageCreateInfo>(std::string* rString, const Decoded_VkPipelineShaderStageCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineShaderStageCreateInfo *pStruct = (const VkPipelineShaderStageCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineShaderStageCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineShaderStageCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkPipelineShaderStageCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkShaderStageFlagBits stage // SMB
    indentSpaces(rString, indent);
    *rString += "stage:                          ";
    *rString += "VkShaderStageFlagBits = "; // TEQ
    enumToString_VkShaderStageFlagBits(rString, pStruct->stage);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->stage);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkShaderModule module // SMB
    indentSpaces(rString, indent);
    *rString += "module:                         ";
    *rString += "VkShaderModule = "; // TEQ
    addrToString(rString, pStructIn.module); // PAQ  
    *rString += "\n"; // GDS

    // const char* pName // SMB
    indentSpaces(rString, indent);
    *rString += "pName:                          ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pName); // TGH
    *rString += "\n"; // GDS

    // const VkSpecializationInfo* pSpecializationInfo // SMB
    indentSpaces(rString, indent);
    *rString += "pSpecializationInfo:            ";
    *rString += "const VkSpecializationInfo* = "; // TEQ
    if (pStruct->pSpecializationInfo == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSpecializationInfo->GetAddress()); // JHI
        structureToString<Decoded_VkSpecializationInfo>(rString, *pStructIn.pSpecializationInfo->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkPipelineShaderStageCreateInfo, pSpecializationInfo)); // GLM
    }
}

template <>
void structureToString<Decoded_VkVertexInputBindingDescription>(std::string* rString, const Decoded_VkVertexInputBindingDescription &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkVertexInputBindingDescription *pStruct = (const VkVertexInputBindingDescription *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t binding // SMB
    indentSpaces(rString, indent);
    *rString += "binding:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->binding);
    *rString += "\n"; // GDS

    // uint32_t stride // SMB
    indentSpaces(rString, indent);
    *rString += "stride:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->stride);
    *rString += "\n"; // GDS

    // VkVertexInputRate inputRate // SMB
    indentSpaces(rString, indent);
    *rString += "inputRate:                      ";
    *rString += "VkVertexInputRate = "; // TEQ
    enumToString_VkVertexInputRate(rString, pStruct->inputRate);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->inputRate);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkVertexInputAttributeDescription>(std::string* rString, const Decoded_VkVertexInputAttributeDescription &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkVertexInputAttributeDescription *pStruct = (const VkVertexInputAttributeDescription *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t location // SMB
    indentSpaces(rString, indent);
    *rString += "location:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->location);
    *rString += "\n"; // GDS

    // uint32_t binding // SMB
    indentSpaces(rString, indent);
    *rString += "binding:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->binding);
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->offset);
}

template <>
void structureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(std::string* rString, const Decoded_VkPipelineVertexInputStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineVertexInputStateCreateInfo *pStruct = (const VkPipelineVertexInputStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineVertexInputStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineVertexInputStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t vertexBindingDescriptionCount // SMB
    indentSpaces(rString, indent);
    *rString += "vertexBindingDescriptionCount:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->vertexBindingDescriptionCount);
    *rString += "\n"; // GDS

    // const VkVertexInputBindingDescription* pVertexBindingDescriptions // SMB
    indentSpaces(rString, indent);
    *rString += "pVertexBindingDescriptions:     ";
    *rString += "const VkVertexInputBindingDescription* = "; // TEQ
    if (pStruct->pVertexBindingDescriptions == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pVertexBindingDescriptions->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkVertexInputBindingDescription>(rString, indent+1, 1, "VkVertexInputBindingDescription", pStructIn.pVertexBindingDescriptions->GetMetaStructPointer(), "pVertexBindingDescriptions", pStruct->vertexBindingDescriptionCount, false, pStructIn.pVertexBindingDescriptions->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t vertexAttributeDescriptionCount // SMB
    indentSpaces(rString, indent);
    *rString += "vertexAttributeDescriptionCount: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->vertexAttributeDescriptionCount);
    *rString += "\n"; // GDS

    // const VkVertexInputAttributeDescription* pVertexAttributeDescriptions // SMB
    indentSpaces(rString, indent);
    *rString += "pVertexAttributeDescriptions:   ";
    *rString += "const VkVertexInputAttributeDescription* = "; // TEQ
    if (pStruct->pVertexAttributeDescriptions == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pVertexAttributeDescriptions->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkVertexInputAttributeDescription>(rString, indent+1, 1, "VkVertexInputAttributeDescription", pStructIn.pVertexAttributeDescriptions->GetMetaStructPointer(), "pVertexAttributeDescriptions", pStruct->vertexAttributeDescriptionCount, false, pStructIn.pVertexAttributeDescriptions->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(std::string* rString, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineInputAssemblyStateCreateInfo *pStruct = (const VkPipelineInputAssemblyStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineInputAssemblyStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineInputAssemblyStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkPrimitiveTopology topology // SMB
    indentSpaces(rString, indent);
    *rString += "topology:                       ";
    *rString += "VkPrimitiveTopology = "; // TEQ
    enumToString_VkPrimitiveTopology(rString, pStruct->topology);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->topology);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 primitiveRestartEnable // SMB
    indentSpaces(rString, indent);
    *rString += "primitiveRestartEnable:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->primitiveRestartEnable);
}

template <>
void structureToString<Decoded_VkPipelineTessellationStateCreateInfo>(std::string* rString, const Decoded_VkPipelineTessellationStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineTessellationStateCreateInfo *pStruct = (const VkPipelineTessellationStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineTessellationStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineTessellationStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t patchControlPoints // SMB
    indentSpaces(rString, indent);
    *rString += "patchControlPoints:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->patchControlPoints);
}

template <>
void structureToString<Decoded_VkViewport>(std::string* rString, const Decoded_VkViewport &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkViewport *pStruct = (const VkViewport *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // float x // SMB
    indentSpaces(rString, indent);
    *rString += "x:                              ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->x);
    *rString += "\n"; // GDS

    // float y // SMB
    indentSpaces(rString, indent);
    *rString += "y:                              ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->y);
    *rString += "\n"; // GDS

    // float width // SMB
    indentSpaces(rString, indent);
    *rString += "width:                          ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->width);
    *rString += "\n"; // GDS

    // float height // SMB
    indentSpaces(rString, indent);
    *rString += "height:                         ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->height);
    *rString += "\n"; // GDS

    // float minDepth // SMB
    indentSpaces(rString, indent);
    *rString += "minDepth:                       ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->minDepth);
    *rString += "\n"; // GDS

    // float maxDepth // SMB
    indentSpaces(rString, indent);
    *rString += "maxDepth:                       ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxDepth);
}

template <>
void structureToString<Decoded_VkOffset2D>(std::string* rString, const Decoded_VkOffset2D &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkOffset2D *pStruct = (const VkOffset2D *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // int32_t x // SMB
    indentSpaces(rString, indent);
    *rString += "x:                              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->x);
    *rString += "\n"; // GDS

    // int32_t y // SMB
    indentSpaces(rString, indent);
    *rString += "y:                              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->y);
}

template <>
void structureToString<Decoded_VkExtent2D>(std::string* rString, const Decoded_VkExtent2D &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExtent2D *pStruct = (const VkExtent2D *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t width // SMB
    indentSpaces(rString, indent);
    *rString += "width:                          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->width);
    *rString += "\n"; // GDS

    // uint32_t height // SMB
    indentSpaces(rString, indent);
    *rString += "height:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->height);
}

template <>
void structureToString<Decoded_VkRect2D>(std::string* rString, const Decoded_VkRect2D &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRect2D *pStruct = (const VkRect2D *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkOffset2D offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkOffset2D = "; // TEQ
    structureToString<Decoded_VkOffset2D>(rString, *pStructIn.offset, indent+1,  baseAddr + offsetof(VkRect2D, offset)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D extent // SMB
    indentSpaces(rString, indent);
    *rString += "extent:                         ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.extent, indent+1,  baseAddr + offsetof(VkRect2D, extent)); // AZJ
}

template <>
void structureToString<Decoded_VkPipelineViewportStateCreateInfo>(std::string* rString, const Decoded_VkPipelineViewportStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineViewportStateCreateInfo *pStruct = (const VkPipelineViewportStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineViewportStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineViewportStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t viewportCount // SMB
    indentSpaces(rString, indent);
    *rString += "viewportCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->viewportCount);
    *rString += "\n"; // GDS

    // const VkViewport* pViewports // SMB
    indentSpaces(rString, indent);
    *rString += "pViewports:                     ";
    *rString += "const VkViewport* = "; // TEQ
    if (pStruct->pViewports == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pViewports->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkViewport>(rString, indent+1, 1, "VkViewport", pStructIn.pViewports->GetMetaStructPointer(), "pViewports", pStruct->viewportCount, false, pStructIn.pViewports->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t scissorCount // SMB
    indentSpaces(rString, indent);
    *rString += "scissorCount:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->scissorCount);
    *rString += "\n"; // GDS

    // const VkRect2D* pScissors // SMB
    indentSpaces(rString, indent);
    *rString += "pScissors:                      ";
    *rString += "const VkRect2D* = "; // TEQ
    if (pStruct->pScissors == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pScissors->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkRect2D>(rString, indent+1, 1, "VkRect2D", pStructIn.pScissors->GetMetaStructPointer(), "pScissors", pStruct->scissorCount, false, pStructIn.pScissors->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(std::string* rString, const Decoded_VkPipelineRasterizationStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineRasterizationStateCreateInfo *pStruct = (const VkPipelineRasterizationStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineRasterizationStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineRasterizationStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkBool32 depthClampEnable // SMB
    indentSpaces(rString, indent);
    *rString += "depthClampEnable:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthClampEnable);
    *rString += "\n"; // GDS

    // VkBool32 rasterizerDiscardEnable // SMB
    indentSpaces(rString, indent);
    *rString += "rasterizerDiscardEnable:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->rasterizerDiscardEnable);
    *rString += "\n"; // GDS

    // VkPolygonMode polygonMode // SMB
    indentSpaces(rString, indent);
    *rString += "polygonMode:                    ";
    *rString += "VkPolygonMode = "; // TEQ
    enumToString_VkPolygonMode(rString, pStruct->polygonMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->polygonMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkCullModeFlags cullMode // SMB
    indentSpaces(rString, indent);
    *rString += "cullMode:                       ";
    *rString += "VkCullModeFlags = "; // TEQ
    flagsToString(rString, pStruct->cullMode, enumToString_VkCullModeFlagBits); // URW
    *rString += "\n"; // GDS

    // VkFrontFace frontFace // SMB
    indentSpaces(rString, indent);
    *rString += "frontFace:                      ";
    *rString += "VkFrontFace = "; // TEQ
    enumToString_VkFrontFace(rString, pStruct->frontFace);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->frontFace);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 depthBiasEnable // SMB
    indentSpaces(rString, indent);
    *rString += "depthBiasEnable:                ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthBiasEnable);
    *rString += "\n"; // GDS

    // float depthBiasConstantFactor // SMB
    indentSpaces(rString, indent);
    *rString += "depthBiasConstantFactor:        ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->depthBiasConstantFactor);
    *rString += "\n"; // GDS

    // float depthBiasClamp // SMB
    indentSpaces(rString, indent);
    *rString += "depthBiasClamp:                 ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->depthBiasClamp);
    *rString += "\n"; // GDS

    // float depthBiasSlopeFactor // SMB
    indentSpaces(rString, indent);
    *rString += "depthBiasSlopeFactor:           ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->depthBiasSlopeFactor);
    *rString += "\n"; // GDS

    // float lineWidth // SMB
    indentSpaces(rString, indent);
    *rString += "lineWidth:                      ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->lineWidth);
}

template <>
void structureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(std::string* rString, const Decoded_VkPipelineMultisampleStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineMultisampleStateCreateInfo *pStruct = (const VkPipelineMultisampleStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineMultisampleStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineMultisampleStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkSampleCountFlagBits rasterizationSamples // SMB
    indentSpaces(rString, indent);
    *rString += "rasterizationSamples:           ";
    *rString += "VkSampleCountFlagBits = "; // TEQ
    enumToString_VkSampleCountFlagBits(rString, pStruct->rasterizationSamples);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->rasterizationSamples);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 sampleShadingEnable // SMB
    indentSpaces(rString, indent);
    *rString += "sampleShadingEnable:            ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sampleShadingEnable);
    *rString += "\n"; // GDS

    // float minSampleShading // SMB
    indentSpaces(rString, indent);
    *rString += "minSampleShading:               ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->minSampleShading);
    *rString += "\n"; // GDS

    // const VkSampleMask* pSampleMask // SMB
    indentSpaces(rString, indent);
    *rString += "pSampleMask:                    ";
    *rString += "const VkSampleMask* = "; // TEQ
    if (pStruct->pSampleMask == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSampleMask.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSampleMask = {false, false, false, nullptr};
        arrayToString<const VkSampleMask*>(rString, indent, 1, "const VkSampleMask*", reinterpret_cast<const VkSampleMask*>(pStructIn.pSampleMask.GetPointer()), "pSampleMask", pStruct->rasterizationSamples,  vinfo_pSampleMask);  // CCQ
    }
    *rString += "\n"; // GDS

    // VkBool32 alphaToCoverageEnable // SMB
    indentSpaces(rString, indent);
    *rString += "alphaToCoverageEnable:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->alphaToCoverageEnable);
    *rString += "\n"; // GDS

    // VkBool32 alphaToOneEnable // SMB
    indentSpaces(rString, indent);
    *rString += "alphaToOneEnable:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->alphaToOneEnable);
}

template <>
void structureToString<Decoded_VkStencilOpState>(std::string* rString, const Decoded_VkStencilOpState &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkStencilOpState *pStruct = (const VkStencilOpState *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStencilOp failOp // SMB
    indentSpaces(rString, indent);
    *rString += "failOp:                         ";
    *rString += "VkStencilOp = "; // TEQ
    enumToString_VkStencilOp(rString, pStruct->failOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->failOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkStencilOp passOp // SMB
    indentSpaces(rString, indent);
    *rString += "passOp:                         ";
    *rString += "VkStencilOp = "; // TEQ
    enumToString_VkStencilOp(rString, pStruct->passOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->passOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkStencilOp depthFailOp // SMB
    indentSpaces(rString, indent);
    *rString += "depthFailOp:                    ";
    *rString += "VkStencilOp = "; // TEQ
    enumToString_VkStencilOp(rString, pStruct->depthFailOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->depthFailOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkCompareOp compareOp // SMB
    indentSpaces(rString, indent);
    *rString += "compareOp:                      ";
    *rString += "VkCompareOp = "; // TEQ
    enumToString_VkCompareOp(rString, pStruct->compareOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->compareOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t compareMask // SMB
    indentSpaces(rString, indent);
    *rString += "compareMask:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->compareMask);
    *rString += "\n"; // GDS

    // uint32_t writeMask // SMB
    indentSpaces(rString, indent);
    *rString += "writeMask:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->writeMask);
    *rString += "\n"; // GDS

    // uint32_t reference // SMB
    indentSpaces(rString, indent);
    *rString += "reference:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->reference);
}

template <>
void structureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(std::string* rString, const Decoded_VkPipelineDepthStencilStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineDepthStencilStateCreateInfo *pStruct = (const VkPipelineDepthStencilStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineDepthStencilStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineDepthStencilStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkBool32 depthTestEnable // SMB
    indentSpaces(rString, indent);
    *rString += "depthTestEnable:                ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthTestEnable);
    *rString += "\n"; // GDS

    // VkBool32 depthWriteEnable // SMB
    indentSpaces(rString, indent);
    *rString += "depthWriteEnable:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthWriteEnable);
    *rString += "\n"; // GDS

    // VkCompareOp depthCompareOp // SMB
    indentSpaces(rString, indent);
    *rString += "depthCompareOp:                 ";
    *rString += "VkCompareOp = "; // TEQ
    enumToString_VkCompareOp(rString, pStruct->depthCompareOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->depthCompareOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 depthBoundsTestEnable // SMB
    indentSpaces(rString, indent);
    *rString += "depthBoundsTestEnable:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->depthBoundsTestEnable);
    *rString += "\n"; // GDS

    // VkBool32 stencilTestEnable // SMB
    indentSpaces(rString, indent);
    *rString += "stencilTestEnable:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->stencilTestEnable);
    *rString += "\n"; // GDS

    // VkStencilOpState front // SMB
    indentSpaces(rString, indent);
    *rString += "front:                          ";
    *rString += "VkStencilOpState = "; // TEQ
    structureToString<Decoded_VkStencilOpState>(rString, *pStructIn.front, indent+1,  baseAddr + offsetof(VkPipelineDepthStencilStateCreateInfo, front)); // AZJ
    *rString += "\n"; // GDS

    // VkStencilOpState back // SMB
    indentSpaces(rString, indent);
    *rString += "back:                           ";
    *rString += "VkStencilOpState = "; // TEQ
    structureToString<Decoded_VkStencilOpState>(rString, *pStructIn.back, indent+1,  baseAddr + offsetof(VkPipelineDepthStencilStateCreateInfo, back)); // AZJ
    *rString += "\n"; // GDS

    // float minDepthBounds // SMB
    indentSpaces(rString, indent);
    *rString += "minDepthBounds:                 ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->minDepthBounds);
    *rString += "\n"; // GDS

    // float maxDepthBounds // SMB
    indentSpaces(rString, indent);
    *rString += "maxDepthBounds:                 ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxDepthBounds);
}

template <>
void structureToString<Decoded_VkPipelineColorBlendAttachmentState>(std::string* rString, const Decoded_VkPipelineColorBlendAttachmentState &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineColorBlendAttachmentState *pStruct = (const VkPipelineColorBlendAttachmentState *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkBool32 blendEnable // SMB
    indentSpaces(rString, indent);
    *rString += "blendEnable:                    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->blendEnable);
    *rString += "\n"; // GDS

    // VkBlendFactor srcColorBlendFactor // SMB
    indentSpaces(rString, indent);
    *rString += "srcColorBlendFactor:            ";
    *rString += "VkBlendFactor = "; // TEQ
    enumToString_VkBlendFactor(rString, pStruct->srcColorBlendFactor);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->srcColorBlendFactor);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBlendFactor dstColorBlendFactor // SMB
    indentSpaces(rString, indent);
    *rString += "dstColorBlendFactor:            ";
    *rString += "VkBlendFactor = "; // TEQ
    enumToString_VkBlendFactor(rString, pStruct->dstColorBlendFactor);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->dstColorBlendFactor);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBlendOp colorBlendOp // SMB
    indentSpaces(rString, indent);
    *rString += "colorBlendOp:                   ";
    *rString += "VkBlendOp = "; // TEQ
    enumToString_VkBlendOp(rString, pStruct->colorBlendOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->colorBlendOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBlendFactor srcAlphaBlendFactor // SMB
    indentSpaces(rString, indent);
    *rString += "srcAlphaBlendFactor:            ";
    *rString += "VkBlendFactor = "; // TEQ
    enumToString_VkBlendFactor(rString, pStruct->srcAlphaBlendFactor);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->srcAlphaBlendFactor);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBlendFactor dstAlphaBlendFactor // SMB
    indentSpaces(rString, indent);
    *rString += "dstAlphaBlendFactor:            ";
    *rString += "VkBlendFactor = "; // TEQ
    enumToString_VkBlendFactor(rString, pStruct->dstAlphaBlendFactor);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->dstAlphaBlendFactor);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBlendOp alphaBlendOp // SMB
    indentSpaces(rString, indent);
    *rString += "alphaBlendOp:                   ";
    *rString += "VkBlendOp = "; // TEQ
    enumToString_VkBlendOp(rString, pStruct->alphaBlendOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->alphaBlendOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkColorComponentFlags colorWriteMask // SMB
    indentSpaces(rString, indent);
    *rString += "colorWriteMask:                 ";
    *rString += "VkColorComponentFlags = "; // TEQ
    flagsToString(rString, pStruct->colorWriteMask, enumToString_VkColorComponentFlagBits); // URW
}

template <>
void structureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(std::string* rString, const Decoded_VkPipelineColorBlendStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineColorBlendStateCreateInfo *pStruct = (const VkPipelineColorBlendStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineColorBlendStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineColorBlendStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkBool32 logicOpEnable // SMB
    indentSpaces(rString, indent);
    *rString += "logicOpEnable:                  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->logicOpEnable);
    *rString += "\n"; // GDS

    // VkLogicOp logicOp // SMB
    indentSpaces(rString, indent);
    *rString += "logicOp:                        ";
    *rString += "VkLogicOp = "; // TEQ
    enumToString_VkLogicOp(rString, pStruct->logicOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->logicOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "attachmentCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachmentCount);
    *rString += "\n"; // GDS

    // const VkPipelineColorBlendAttachmentState* pAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pAttachments:                   ";
    *rString += "const VkPipelineColorBlendAttachmentState* = "; // TEQ
    if (pStruct->pAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkPipelineColorBlendAttachmentState>(rString, indent+1, 1, "VkPipelineColorBlendAttachmentState", pStructIn.pAttachments->GetMetaStructPointer(), "pAttachments", pStruct->attachmentCount, false, pStructIn.pAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // float blendConstants // SMB
    indentSpaces(rString, indent);
    *rString += "blendConstants:                 ";
    *rString += "float[";
    *rString += "4";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPipelineColorBlendStateCreateInfo, blendConstants)); // IYY
    ValueToStringStruct vinfo_blendConstants = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->blendConstants), "blendConstants", 4, vinfo_blendConstants); // JPA
}

template <>
void structureToString<Decoded_VkPipelineDynamicStateCreateInfo>(std::string* rString, const Decoded_VkPipelineDynamicStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineDynamicStateCreateInfo *pStruct = (const VkPipelineDynamicStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineDynamicStateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineDynamicStateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t dynamicStateCount // SMB
    indentSpaces(rString, indent);
    *rString += "dynamicStateCount:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dynamicStateCount);
    *rString += "\n"; // GDS

    // const VkDynamicState* pDynamicStates // SMB
    indentSpaces(rString, indent);
    *rString += "pDynamicStates:                 ";
    *rString += "const VkDynamicState* = "; // TEQ
    if (pStruct->pDynamicStates == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDynamicStates.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDynamicStates = {false, true, false, enumToString_VkDynamicState};
        arrayToString<const VkDynamicState*>(rString, indent, 1, "const VkDynamicState*", reinterpret_cast<const VkDynamicState*>(pStructIn.pDynamicStates.GetPointer()), "pDynamicStates", pStruct->dynamicStateCount,  vinfo_pDynamicStates);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkGraphicsPipelineCreateInfo>(std::string* rString, const Decoded_VkGraphicsPipelineCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkGraphicsPipelineCreateInfo *pStruct = (const VkGraphicsPipelineCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkPipelineCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t stageCount // SMB
    indentSpaces(rString, indent);
    *rString += "stageCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->stageCount);
    *rString += "\n"; // GDS

    // const VkPipelineShaderStageCreateInfo* pStages // SMB
    indentSpaces(rString, indent);
    *rString += "pStages:                        ";
    *rString += "const VkPipelineShaderStageCreateInfo* = "; // TEQ
    if (pStruct->pStages == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pStages->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(rString, indent+1, 1, "VkPipelineShaderStageCreateInfo", pStructIn.pStages->GetMetaStructPointer(), "pStages", pStruct->stageCount, false, pStructIn.pStages->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // const VkPipelineVertexInputStateCreateInfo* pVertexInputState // SMB
    indentSpaces(rString, indent);
    *rString += "pVertexInputState:              ";
    *rString += "const VkPipelineVertexInputStateCreateInfo* = "; // TEQ
    if (pStruct->pVertexInputState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pVertexInputState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineVertexInputStateCreateInfo>(rString, *pStructIn.pVertexInputState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pVertexInputState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState // SMB
    indentSpaces(rString, indent);
    *rString += "pInputAssemblyState:            ";
    *rString += "const VkPipelineInputAssemblyStateCreateInfo* = "; // TEQ
    if (pStruct->pInputAssemblyState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pInputAssemblyState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineInputAssemblyStateCreateInfo>(rString, *pStructIn.pInputAssemblyState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pInputAssemblyState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineTessellationStateCreateInfo* pTessellationState // SMB
    indentSpaces(rString, indent);
    *rString += "pTessellationState:             ";
    *rString += "const VkPipelineTessellationStateCreateInfo* = "; // TEQ
    if (pStruct->pTessellationState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pTessellationState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineTessellationStateCreateInfo>(rString, *pStructIn.pTessellationState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pTessellationState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineViewportStateCreateInfo* pViewportState // SMB
    indentSpaces(rString, indent);
    *rString += "pViewportState:                 ";
    *rString += "const VkPipelineViewportStateCreateInfo* = "; // TEQ
    if (pStruct->pViewportState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pViewportState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineViewportStateCreateInfo>(rString, *pStructIn.pViewportState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pViewportState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineRasterizationStateCreateInfo* pRasterizationState // SMB
    indentSpaces(rString, indent);
    *rString += "pRasterizationState:            ";
    *rString += "const VkPipelineRasterizationStateCreateInfo* = "; // TEQ
    if (pStruct->pRasterizationState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pRasterizationState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineRasterizationStateCreateInfo>(rString, *pStructIn.pRasterizationState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pRasterizationState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineMultisampleStateCreateInfo* pMultisampleState // SMB
    indentSpaces(rString, indent);
    *rString += "pMultisampleState:              ";
    *rString += "const VkPipelineMultisampleStateCreateInfo* = "; // TEQ
    if (pStruct->pMultisampleState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pMultisampleState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineMultisampleStateCreateInfo>(rString, *pStructIn.pMultisampleState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pMultisampleState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineDepthStencilStateCreateInfo* pDepthStencilState // SMB
    indentSpaces(rString, indent);
    *rString += "pDepthStencilState:             ";
    *rString += "const VkPipelineDepthStencilStateCreateInfo* = "; // TEQ
    if (pStruct->pDepthStencilState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDepthStencilState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineDepthStencilStateCreateInfo>(rString, *pStructIn.pDepthStencilState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pDepthStencilState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineColorBlendStateCreateInfo* pColorBlendState // SMB
    indentSpaces(rString, indent);
    *rString += "pColorBlendState:               ";
    *rString += "const VkPipelineColorBlendStateCreateInfo* = "; // TEQ
    if (pStruct->pColorBlendState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pColorBlendState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineColorBlendStateCreateInfo>(rString, *pStructIn.pColorBlendState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pColorBlendState)); // GLM
    }
    *rString += "\n"; // GDS

    // const VkPipelineDynamicStateCreateInfo* pDynamicState // SMB
    indentSpaces(rString, indent);
    *rString += "pDynamicState:                  ";
    *rString += "const VkPipelineDynamicStateCreateInfo* = "; // TEQ
    if (pStruct->pDynamicState == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDynamicState->GetAddress()); // JHI
        structureToString<Decoded_VkPipelineDynamicStateCreateInfo>(rString, *pStructIn.pDynamicState->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkGraphicsPipelineCreateInfo, pDynamicState)); // GLM
    }
    *rString += "\n"; // GDS

    // VkPipelineLayout layout // SMB
    indentSpaces(rString, indent);
    *rString += "layout:                         ";
    *rString += "VkPipelineLayout = "; // TEQ
    addrToString(rString, pStructIn.layout); // PAQ  
    *rString += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    indentSpaces(rString, indent);
    *rString += "renderPass:                     ";
    *rString += "VkRenderPass = "; // TEQ
    addrToString(rString, pStructIn.renderPass); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t subpass // SMB
    indentSpaces(rString, indent);
    *rString += "subpass:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subpass);
    *rString += "\n"; // GDS

    // VkPipeline basePipelineHandle // SMB
    indentSpaces(rString, indent);
    *rString += "basePipelineHandle:             ";
    *rString += "VkPipeline = "; // TEQ
    addrToString(rString, pStructIn.basePipelineHandle); // PAQ  
    *rString += "\n"; // GDS

    // int32_t basePipelineIndex // SMB
    indentSpaces(rString, indent);
    *rString += "basePipelineIndex:              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->basePipelineIndex);
}

template <>
void structureToString<Decoded_VkComputePipelineCreateInfo>(std::string* rString, const Decoded_VkComputePipelineCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkComputePipelineCreateInfo *pStruct = (const VkComputePipelineCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkPipelineCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkPipelineShaderStageCreateInfo stage // SMB
    indentSpaces(rString, indent);
    *rString += "stage:                          ";
    *rString += "VkPipelineShaderStageCreateInfo = "; // TEQ
    structureToString<Decoded_VkPipelineShaderStageCreateInfo>(rString, *pStructIn.stage, indent+1,  baseAddr + offsetof(VkComputePipelineCreateInfo, stage)); // AZJ
    *rString += "\n"; // GDS

    // VkPipelineLayout layout // SMB
    indentSpaces(rString, indent);
    *rString += "layout:                         ";
    *rString += "VkPipelineLayout = "; // TEQ
    addrToString(rString, pStructIn.layout); // PAQ  
    *rString += "\n"; // GDS

    // VkPipeline basePipelineHandle // SMB
    indentSpaces(rString, indent);
    *rString += "basePipelineHandle:             ";
    *rString += "VkPipeline = "; // TEQ
    addrToString(rString, pStructIn.basePipelineHandle); // PAQ  
    *rString += "\n"; // GDS

    // int32_t basePipelineIndex // SMB
    indentSpaces(rString, indent);
    *rString += "basePipelineIndex:              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->basePipelineIndex);
}

template <>
void structureToString<Decoded_VkPushConstantRange>(std::string* rString, const Decoded_VkPushConstantRange &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPushConstantRange *pStruct = (const VkPushConstantRange *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkShaderStageFlags stageFlags // SMB
    indentSpaces(rString, indent);
    *rString += "stageFlags:                     ";
    *rString += "VkShaderStageFlags = "; // TEQ
    flagsToString(rString, pStruct->stageFlags, enumToString_VkShaderStageFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // uint32_t size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->size);
}

template <>
void structureToString<Decoded_VkPipelineLayoutCreateInfo>(std::string* rString, const Decoded_VkPipelineLayoutCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineLayoutCreateInfo *pStruct = (const VkPipelineLayoutCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineLayoutCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineLayoutCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t setLayoutCount // SMB
    indentSpaces(rString, indent);
    *rString += "setLayoutCount:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->setLayoutCount);
    *rString += "\n"; // GDS

    // const VkDescriptorSetLayout* pSetLayouts // SMB
    indentSpaces(rString, indent);
    *rString += "pSetLayouts:                    ";
    *rString += "const VkDescriptorSetLayout* = "; // TEQ
    if (pStruct->pSetLayouts == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSetLayouts.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        arrayToString<const VkDescriptorSetLayout*>(rString, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pStructIn.pSetLayouts.GetPointer()), "pSetLayouts", pStruct->setLayoutCount,  vinfo_pSetLayouts);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t pushConstantRangeCount // SMB
    indentSpaces(rString, indent);
    *rString += "pushConstantRangeCount:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->pushConstantRangeCount);
    *rString += "\n"; // GDS

    // const VkPushConstantRange* pPushConstantRanges // SMB
    indentSpaces(rString, indent);
    *rString += "pPushConstantRanges:            ";
    *rString += "const VkPushConstantRange* = "; // TEQ
    if (pStruct->pPushConstantRanges == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pPushConstantRanges->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkPushConstantRange>(rString, indent+1, 1, "VkPushConstantRange", pStructIn.pPushConstantRanges->GetMetaStructPointer(), "pPushConstantRanges", pStruct->pushConstantRangeCount, false, pStructIn.pPushConstantRanges->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkSamplerCreateInfo>(std::string* rString, const Decoded_VkSamplerCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSamplerCreateInfo *pStruct = (const VkSamplerCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSamplerCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSamplerCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSamplerCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkFilter magFilter // SMB
    indentSpaces(rString, indent);
    *rString += "magFilter:                      ";
    *rString += "VkFilter = "; // TEQ
    enumToString_VkFilter(rString, pStruct->magFilter);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->magFilter);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkFilter minFilter // SMB
    indentSpaces(rString, indent);
    *rString += "minFilter:                      ";
    *rString += "VkFilter = "; // TEQ
    enumToString_VkFilter(rString, pStruct->minFilter);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->minFilter);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSamplerMipmapMode mipmapMode // SMB
    indentSpaces(rString, indent);
    *rString += "mipmapMode:                     ";
    *rString += "VkSamplerMipmapMode = "; // TEQ
    enumToString_VkSamplerMipmapMode(rString, pStruct->mipmapMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->mipmapMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSamplerAddressMode addressModeU // SMB
    indentSpaces(rString, indent);
    *rString += "addressModeU:                   ";
    *rString += "VkSamplerAddressMode = "; // TEQ
    enumToString_VkSamplerAddressMode(rString, pStruct->addressModeU);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->addressModeU);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSamplerAddressMode addressModeV // SMB
    indentSpaces(rString, indent);
    *rString += "addressModeV:                   ";
    *rString += "VkSamplerAddressMode = "; // TEQ
    enumToString_VkSamplerAddressMode(rString, pStruct->addressModeV);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->addressModeV);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSamplerAddressMode addressModeW // SMB
    indentSpaces(rString, indent);
    *rString += "addressModeW:                   ";
    *rString += "VkSamplerAddressMode = "; // TEQ
    enumToString_VkSamplerAddressMode(rString, pStruct->addressModeW);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->addressModeW);
    *rString += ")";
    *rString += "\n"; // GDS

    // float mipLodBias // SMB
    indentSpaces(rString, indent);
    *rString += "mipLodBias:                     ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->mipLodBias);
    *rString += "\n"; // GDS

    // VkBool32 anisotropyEnable // SMB
    indentSpaces(rString, indent);
    *rString += "anisotropyEnable:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->anisotropyEnable);
    *rString += "\n"; // GDS

    // float maxAnisotropy // SMB
    indentSpaces(rString, indent);
    *rString += "maxAnisotropy:                  ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxAnisotropy);
    *rString += "\n"; // GDS

    // VkBool32 compareEnable // SMB
    indentSpaces(rString, indent);
    *rString += "compareEnable:                  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->compareEnable);
    *rString += "\n"; // GDS

    // VkCompareOp compareOp // SMB
    indentSpaces(rString, indent);
    *rString += "compareOp:                      ";
    *rString += "VkCompareOp = "; // TEQ
    enumToString_VkCompareOp(rString, pStruct->compareOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->compareOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // float minLod // SMB
    indentSpaces(rString, indent);
    *rString += "minLod:                         ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->minLod);
    *rString += "\n"; // GDS

    // float maxLod // SMB
    indentSpaces(rString, indent);
    *rString += "maxLod:                         ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxLod);
    *rString += "\n"; // GDS

    // VkBorderColor borderColor // SMB
    indentSpaces(rString, indent);
    *rString += "borderColor:                    ";
    *rString += "VkBorderColor = "; // TEQ
    enumToString_VkBorderColor(rString, pStruct->borderColor);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->borderColor);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 unnormalizedCoordinates // SMB
    indentSpaces(rString, indent);
    *rString += "unnormalizedCoordinates:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->unnormalizedCoordinates);
}

template <>
void structureToString<Decoded_VkDescriptorSetLayoutBinding>(std::string* rString, const Decoded_VkDescriptorSetLayoutBinding &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorSetLayoutBinding *pStruct = (const VkDescriptorSetLayoutBinding *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t binding // SMB
    indentSpaces(rString, indent);
    *rString += "binding:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->binding);
    *rString += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorType:                 ";
    *rString += "VkDescriptorType = "; // TEQ
    enumToString_VkDescriptorType(rString, pStruct->descriptorType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->descriptorType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->descriptorCount);
    *rString += "\n"; // GDS

    // VkShaderStageFlags stageFlags // SMB
    indentSpaces(rString, indent);
    *rString += "stageFlags:                     ";
    *rString += "VkShaderStageFlags = "; // TEQ
    flagsToString(rString, pStruct->stageFlags, enumToString_VkShaderStageFlagBits); // URW
    *rString += "\n"; // GDS

    // const VkSampler* pImmutableSamplers // SMB
    indentSpaces(rString, indent);
    *rString += "pImmutableSamplers:             ";
    *rString += "const VkSampler* = "; // TEQ
    if (pStruct->pImmutableSamplers == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pImmutableSamplers.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pImmutableSamplers = {true, false, false, nullptr};
        arrayToString<const VkSampler*>(rString, indent, 1, "const VkSampler*", reinterpret_cast<const VkSampler*>(pStructIn.pImmutableSamplers.GetPointer()), "pImmutableSamplers", pStruct->descriptorCount,  vinfo_pImmutableSamplers);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(std::string* rString, const Decoded_VkDescriptorSetLayoutCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorSetLayoutCreateInfo *pStruct = (const VkDescriptorSetLayoutCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDescriptorSetLayoutCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDescriptorSetLayoutCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkDescriptorSetLayoutCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t bindingCount // SMB
    indentSpaces(rString, indent);
    *rString += "bindingCount:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bindingCount);
    *rString += "\n"; // GDS

    // const VkDescriptorSetLayoutBinding* pBindings // SMB
    indentSpaces(rString, indent);
    *rString += "pBindings:                      ";
    *rString += "const VkDescriptorSetLayoutBinding* = "; // TEQ
    if (pStruct->pBindings == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pBindings->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDescriptorSetLayoutBinding>(rString, indent+1, 1, "VkDescriptorSetLayoutBinding", pStructIn.pBindings->GetMetaStructPointer(), "pBindings", pStruct->bindingCount, false, pStructIn.pBindings->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkDescriptorPoolSize>(std::string* rString, const Decoded_VkDescriptorPoolSize &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorPoolSize *pStruct = (const VkDescriptorPoolSize *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDescriptorType type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkDescriptorType = "; // TEQ
    enumToString_VkDescriptorType(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->descriptorCount);
}

template <>
void structureToString<Decoded_VkDescriptorPoolCreateInfo>(std::string* rString, const Decoded_VkDescriptorPoolCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorPoolCreateInfo *pStruct = (const VkDescriptorPoolCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDescriptorPoolCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDescriptorPoolCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkDescriptorPoolCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t maxSets // SMB
    indentSpaces(rString, indent);
    *rString += "maxSets:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxSets);
    *rString += "\n"; // GDS

    // uint32_t poolSizeCount // SMB
    indentSpaces(rString, indent);
    *rString += "poolSizeCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->poolSizeCount);
    *rString += "\n"; // GDS

    // const VkDescriptorPoolSize* pPoolSizes // SMB
    indentSpaces(rString, indent);
    *rString += "pPoolSizes:                     ";
    *rString += "const VkDescriptorPoolSize* = "; // TEQ
    if (pStruct->pPoolSizes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pPoolSizes->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDescriptorPoolSize>(rString, indent+1, 1, "VkDescriptorPoolSize", pStructIn.pPoolSizes->GetMetaStructPointer(), "pPoolSizes", pStruct->poolSizeCount, false, pStructIn.pPoolSizes->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkDescriptorSetAllocateInfo>(std::string* rString, const Decoded_VkDescriptorSetAllocateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorSetAllocateInfo *pStruct = (const VkDescriptorSetAllocateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDescriptorPool descriptorPool // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorPool:                 ";
    *rString += "VkDescriptorPool = "; // TEQ
    addrToString(rString, pStructIn.descriptorPool); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t descriptorSetCount // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorSetCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->descriptorSetCount);
    *rString += "\n"; // GDS

    // const VkDescriptorSetLayout* pSetLayouts // SMB
    indentSpaces(rString, indent);
    *rString += "pSetLayouts:                    ";
    *rString += "const VkDescriptorSetLayout* = "; // TEQ
    if (pStruct->pSetLayouts == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSetLayouts.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSetLayouts = {true, false, false, nullptr};
        arrayToString<const VkDescriptorSetLayout*>(rString, indent, 1, "const VkDescriptorSetLayout*", reinterpret_cast<const VkDescriptorSetLayout*>(pStructIn.pSetLayouts.GetPointer()), "pSetLayouts", pStruct->descriptorSetCount,  vinfo_pSetLayouts);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkDescriptorImageInfo>(std::string* rString, const Decoded_VkDescriptorImageInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorImageInfo *pStruct = (const VkDescriptorImageInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkSampler sampler // SMB
    indentSpaces(rString, indent);
    *rString += "sampler:                        ";
    *rString += "VkSampler = "; // TEQ
    addrToString(rString, pStructIn.sampler); // PAQ  
    *rString += "\n"; // GDS

    // VkImageView imageView // SMB
    indentSpaces(rString, indent);
    *rString += "imageView:                      ";
    *rString += "VkImageView = "; // TEQ
    addrToString(rString, pStructIn.imageView); // PAQ  
    *rString += "\n"; // GDS

    // VkImageLayout imageLayout // SMB
    indentSpaces(rString, indent);
    *rString += "imageLayout:                    ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->imageLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->imageLayout);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkDescriptorBufferInfo>(std::string* rString, const Decoded_VkDescriptorBufferInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorBufferInfo *pStruct = (const VkDescriptorBufferInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // VkDeviceSize range // SMB
    indentSpaces(rString, indent);
    *rString += "range:                          ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->range);
}

template <>
void structureToString<Decoded_VkWriteDescriptorSet>(std::string* rString, const Decoded_VkWriteDescriptorSet &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkWriteDescriptorSet *pStruct = (const VkWriteDescriptorSet *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDescriptorSet dstSet // SMB
    indentSpaces(rString, indent);
    *rString += "dstSet:                         ";
    *rString += "VkDescriptorSet = "; // TEQ
    addrToString(rString, pStructIn.dstSet); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t dstBinding // SMB
    indentSpaces(rString, indent);
    *rString += "dstBinding:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstBinding);
    *rString += "\n"; // GDS

    // uint32_t dstArrayElement // SMB
    indentSpaces(rString, indent);
    *rString += "dstArrayElement:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstArrayElement);
    *rString += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->descriptorCount);
    *rString += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorType:                 ";
    *rString += "VkDescriptorType = "; // TEQ
    enumToString_VkDescriptorType(rString, pStruct->descriptorType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->descriptorType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const VkDescriptorImageInfo* pImageInfo // SMB
    indentSpaces(rString, indent);
    *rString += "pImageInfo:                     ";
    *rString += "const VkDescriptorImageInfo* = "; // TEQ
    if (pStruct->pImageInfo == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pImageInfo->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDescriptorImageInfo>(rString, indent+1, 1, "VkDescriptorImageInfo", pStructIn.pImageInfo->GetMetaStructPointer(), "pImageInfo", pStruct->descriptorCount, false, pStructIn.pImageInfo->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // const VkDescriptorBufferInfo* pBufferInfo // SMB
    indentSpaces(rString, indent);
    *rString += "pBufferInfo:                    ";
    *rString += "const VkDescriptorBufferInfo* = "; // TEQ
    if (pStruct->pBufferInfo == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pBufferInfo->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDescriptorBufferInfo>(rString, indent+1, 1, "VkDescriptorBufferInfo", pStructIn.pBufferInfo->GetMetaStructPointer(), "pBufferInfo", pStruct->descriptorCount, false, pStructIn.pBufferInfo->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // const VkBufferView* pTexelBufferView // SMB
    indentSpaces(rString, indent);
    *rString += "pTexelBufferView:               ";
    *rString += "const VkBufferView* = "; // TEQ
    if (pStruct->pTexelBufferView == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pTexelBufferView.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pTexelBufferView = {true, false, false, nullptr};
        arrayToString<const VkBufferView*>(rString, indent, 1, "const VkBufferView*", reinterpret_cast<const VkBufferView*>(pStructIn.pTexelBufferView.GetPointer()), "pTexelBufferView", pStruct->descriptorCount,  vinfo_pTexelBufferView);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkCopyDescriptorSet>(std::string* rString, const Decoded_VkCopyDescriptorSet &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCopyDescriptorSet *pStruct = (const VkCopyDescriptorSet *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDescriptorSet srcSet // SMB
    indentSpaces(rString, indent);
    *rString += "srcSet:                         ";
    *rString += "VkDescriptorSet = "; // TEQ
    addrToString(rString, pStructIn.srcSet); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t srcBinding // SMB
    indentSpaces(rString, indent);
    *rString += "srcBinding:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->srcBinding);
    *rString += "\n"; // GDS

    // uint32_t srcArrayElement // SMB
    indentSpaces(rString, indent);
    *rString += "srcArrayElement:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->srcArrayElement);
    *rString += "\n"; // GDS

    // VkDescriptorSet dstSet // SMB
    indentSpaces(rString, indent);
    *rString += "dstSet:                         ";
    *rString += "VkDescriptorSet = "; // TEQ
    addrToString(rString, pStructIn.dstSet); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t dstBinding // SMB
    indentSpaces(rString, indent);
    *rString += "dstBinding:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstBinding);
    *rString += "\n"; // GDS

    // uint32_t dstArrayElement // SMB
    indentSpaces(rString, indent);
    *rString += "dstArrayElement:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstArrayElement);
    *rString += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->descriptorCount);
}

template <>
void structureToString<Decoded_VkFramebufferCreateInfo>(std::string* rString, const Decoded_VkFramebufferCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkFramebufferCreateInfo *pStruct = (const VkFramebufferCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFramebufferCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkFramebufferCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkFramebufferCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    indentSpaces(rString, indent);
    *rString += "renderPass:                     ";
    *rString += "VkRenderPass = "; // TEQ
    addrToString(rString, pStructIn.renderPass); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "attachmentCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachmentCount);
    *rString += "\n"; // GDS

    // const VkImageView* pAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pAttachments:                   ";
    *rString += "const VkImageView* = "; // TEQ
    if (pStruct->pAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttachments.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pAttachments = {true, false, false, nullptr};
        arrayToString<const VkImageView*>(rString, indent, 1, "const VkImageView*", reinterpret_cast<const VkImageView*>(pStructIn.pAttachments.GetPointer()), "pAttachments", pStruct->attachmentCount,  vinfo_pAttachments);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t width // SMB
    indentSpaces(rString, indent);
    *rString += "width:                          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->width);
    *rString += "\n"; // GDS

    // uint32_t height // SMB
    indentSpaces(rString, indent);
    *rString += "height:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->height);
    *rString += "\n"; // GDS

    // uint32_t layers // SMB
    indentSpaces(rString, indent);
    *rString += "layers:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->layers);
}

template <>
void structureToString<Decoded_VkAttachmentDescription>(std::string* rString, const Decoded_VkAttachmentDescription &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAttachmentDescription *pStruct = (const VkAttachmentDescription *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkAttachmentDescriptionFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkAttachmentDescriptionFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkAttachmentDescriptionFlagBits); // URW
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    indentSpaces(rString, indent);
    *rString += "samples:                        ";
    *rString += "VkSampleCountFlagBits = "; // TEQ
    enumToString_VkSampleCountFlagBits(rString, pStruct->samples);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->samples);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentLoadOp loadOp // SMB
    indentSpaces(rString, indent);
    *rString += "loadOp:                         ";
    *rString += "VkAttachmentLoadOp = "; // TEQ
    enumToString_VkAttachmentLoadOp(rString, pStruct->loadOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->loadOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentStoreOp storeOp // SMB
    indentSpaces(rString, indent);
    *rString += "storeOp:                        ";
    *rString += "VkAttachmentStoreOp = "; // TEQ
    enumToString_VkAttachmentStoreOp(rString, pStruct->storeOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->storeOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentLoadOp stencilLoadOp // SMB
    indentSpaces(rString, indent);
    *rString += "stencilLoadOp:                  ";
    *rString += "VkAttachmentLoadOp = "; // TEQ
    enumToString_VkAttachmentLoadOp(rString, pStruct->stencilLoadOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->stencilLoadOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentStoreOp stencilStoreOp // SMB
    indentSpaces(rString, indent);
    *rString += "stencilStoreOp:                 ";
    *rString += "VkAttachmentStoreOp = "; // TEQ
    enumToString_VkAttachmentStoreOp(rString, pStruct->stencilStoreOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->stencilStoreOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageLayout initialLayout // SMB
    indentSpaces(rString, indent);
    *rString += "initialLayout:                  ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->initialLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->initialLayout);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageLayout finalLayout // SMB
    indentSpaces(rString, indent);
    *rString += "finalLayout:                    ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->finalLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->finalLayout);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkAttachmentReference>(std::string* rString, const Decoded_VkAttachmentReference &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAttachmentReference *pStruct = (const VkAttachmentReference *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t attachment // SMB
    indentSpaces(rString, indent);
    *rString += "attachment:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachment);
    *rString += "\n"; // GDS

    // VkImageLayout layout // SMB
    indentSpaces(rString, indent);
    *rString += "layout:                         ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->layout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->layout);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkSubpassDescription>(std::string* rString, const Decoded_VkSubpassDescription &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubpassDescription *pStruct = (const VkSubpassDescription *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkSubpassDescriptionFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSubpassDescriptionFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSubpassDescriptionFlagBits); // URW
    *rString += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineBindPoint:              ";
    *rString += "VkPipelineBindPoint = "; // TEQ
    enumToString_VkPipelineBindPoint(rString, pStruct->pipelineBindPoint);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->pipelineBindPoint);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t inputAttachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "inputAttachmentCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->inputAttachmentCount);
    *rString += "\n"; // GDS

    // const VkAttachmentReference* pInputAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pInputAttachments:              ";
    *rString += "const VkAttachmentReference* = "; // TEQ
    if (pStruct->pInputAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pInputAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentReference>(rString, indent+1, 1, "VkAttachmentReference", pStructIn.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pStruct->inputAttachmentCount, false, pStructIn.pInputAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t colorAttachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "colorAttachmentCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->colorAttachmentCount);
    *rString += "\n"; // GDS

    // const VkAttachmentReference* pColorAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pColorAttachments:              ";
    *rString += "const VkAttachmentReference* = "; // TEQ
    if (pStruct->pColorAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pColorAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentReference>(rString, indent+1, 1, "VkAttachmentReference", pStructIn.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pStruct->colorAttachmentCount, false, pStructIn.pColorAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // const VkAttachmentReference* pResolveAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pResolveAttachments:            ";
    *rString += "const VkAttachmentReference* = "; // TEQ
    if (pStruct->pResolveAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pResolveAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentReference>(rString, indent+1, 1, "VkAttachmentReference", pStructIn.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pStruct->colorAttachmentCount, false, pStructIn.pResolveAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // const VkAttachmentReference* pDepthStencilAttachment // SMB
    indentSpaces(rString, indent);
    *rString += "pDepthStencilAttachment:        ";
    *rString += "const VkAttachmentReference* = "; // TEQ
    if (pStruct->pDepthStencilAttachment == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDepthStencilAttachment->GetAddress()); // JHI
        structureToString<Decoded_VkAttachmentReference>(rString, *pStructIn.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkSubpassDescription, pDepthStencilAttachment)); // GLM
    }
    *rString += "\n"; // GDS

    // uint32_t preserveAttachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "preserveAttachmentCount:        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->preserveAttachmentCount);
    *rString += "\n"; // GDS

    // const uint32_t* pPreserveAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pPreserveAttachments:           ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pPreserveAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pPreserveAttachments.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pStruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkSubpassDependency>(std::string* rString, const Decoded_VkSubpassDependency &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubpassDependency *pStruct = (const VkSubpassDependency *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t srcSubpass // SMB
    indentSpaces(rString, indent);
    *rString += "srcSubpass:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->srcSubpass);
    *rString += "\n"; // GDS

    // uint32_t dstSubpass // SMB
    indentSpaces(rString, indent);
    *rString += "dstSubpass:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstSubpass);
    *rString += "\n"; // GDS

    // VkPipelineStageFlags srcStageMask // SMB
    indentSpaces(rString, indent);
    *rString += "srcStageMask:                   ";
    *rString += "VkPipelineStageFlags = "; // TEQ
    flagsToString(rString, pStruct->srcStageMask, enumToString_VkPipelineStageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkPipelineStageFlags dstStageMask // SMB
    indentSpaces(rString, indent);
    *rString += "dstStageMask:                   ";
    *rString += "VkPipelineStageFlags = "; // TEQ
    flagsToString(rString, pStruct->dstStageMask, enumToString_VkPipelineStageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "srcAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->srcAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "dstAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->dstAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkDependencyFlags dependencyFlags // SMB
    indentSpaces(rString, indent);
    *rString += "dependencyFlags:                ";
    *rString += "VkDependencyFlags = "; // TEQ
    flagsToString(rString, pStruct->dependencyFlags, enumToString_VkDependencyFlagBits); // URW
}

template <>
void structureToString<Decoded_VkRenderPassCreateInfo>(std::string* rString, const Decoded_VkRenderPassCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRenderPassCreateInfo *pStruct = (const VkRenderPassCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkRenderPassCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkRenderPassCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkRenderPassCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "attachmentCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachmentCount);
    *rString += "\n"; // GDS

    // const VkAttachmentDescription* pAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pAttachments:                   ";
    *rString += "const VkAttachmentDescription* = "; // TEQ
    if (pStruct->pAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentDescription>(rString, indent+1, 1, "VkAttachmentDescription", pStructIn.pAttachments->GetMetaStructPointer(), "pAttachments", pStruct->attachmentCount, false, pStructIn.pAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t subpassCount // SMB
    indentSpaces(rString, indent);
    *rString += "subpassCount:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subpassCount);
    *rString += "\n"; // GDS

    // const VkSubpassDescription* pSubpasses // SMB
    indentSpaces(rString, indent);
    *rString += "pSubpasses:                     ";
    *rString += "const VkSubpassDescription* = "; // TEQ
    if (pStruct->pSubpasses == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSubpasses->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSubpassDescription>(rString, indent+1, 1, "VkSubpassDescription", pStructIn.pSubpasses->GetMetaStructPointer(), "pSubpasses", pStruct->subpassCount, false, pStructIn.pSubpasses->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t dependencyCount // SMB
    indentSpaces(rString, indent);
    *rString += "dependencyCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dependencyCount);
    *rString += "\n"; // GDS

    // const VkSubpassDependency* pDependencies // SMB
    indentSpaces(rString, indent);
    *rString += "pDependencies:                  ";
    *rString += "const VkSubpassDependency* = "; // TEQ
    if (pStruct->pDependencies == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDependencies->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSubpassDependency>(rString, indent+1, 1, "VkSubpassDependency", pStructIn.pDependencies->GetMetaStructPointer(), "pDependencies", pStruct->dependencyCount, false, pStructIn.pDependencies->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkCommandPoolCreateInfo>(std::string* rString, const Decoded_VkCommandPoolCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCommandPoolCreateInfo *pStruct = (const VkCommandPoolCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkCommandPoolCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkCommandPoolCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkCommandPoolCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t queueFamilyIndex // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyIndex:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueFamilyIndex);
}

template <>
void structureToString<Decoded_VkCommandBufferAllocateInfo>(std::string* rString, const Decoded_VkCommandBufferAllocateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCommandBufferAllocateInfo *pStruct = (const VkCommandBufferAllocateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkCommandPool commandPool // SMB
    indentSpaces(rString, indent);
    *rString += "commandPool:                    ";
    *rString += "VkCommandPool = "; // TEQ
    addrToString(rString, pStructIn.commandPool); // PAQ  
    *rString += "\n"; // GDS

    // VkCommandBufferLevel level // SMB
    indentSpaces(rString, indent);
    *rString += "level:                          ";
    *rString += "VkCommandBufferLevel = "; // TEQ
    enumToString_VkCommandBufferLevel(rString, pStruct->level);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->level);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t commandBufferCount // SMB
    indentSpaces(rString, indent);
    *rString += "commandBufferCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->commandBufferCount);
}

template <>
void structureToString<Decoded_VkCommandBufferInheritanceInfo>(std::string* rString, const Decoded_VkCommandBufferInheritanceInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCommandBufferInheritanceInfo *pStruct = (const VkCommandBufferInheritanceInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    indentSpaces(rString, indent);
    *rString += "renderPass:                     ";
    *rString += "VkRenderPass = "; // TEQ
    addrToString(rString, pStructIn.renderPass); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t subpass // SMB
    indentSpaces(rString, indent);
    *rString += "subpass:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subpass);
    *rString += "\n"; // GDS

    // VkFramebuffer framebuffer // SMB
    indentSpaces(rString, indent);
    *rString += "framebuffer:                    ";
    *rString += "VkFramebuffer = "; // TEQ
    addrToString(rString, pStructIn.framebuffer); // PAQ  
    *rString += "\n"; // GDS

    // VkBool32 occlusionQueryEnable // SMB
    indentSpaces(rString, indent);
    *rString += "occlusionQueryEnable:           ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->occlusionQueryEnable);
    *rString += "\n"; // GDS

    // VkQueryControlFlags queryFlags // SMB
    indentSpaces(rString, indent);
    *rString += "queryFlags:                     ";
    *rString += "VkQueryControlFlags = "; // TEQ
    flagsToString(rString, pStruct->queryFlags, enumToString_VkQueryControlFlagBits); // URW
    *rString += "\n"; // GDS

    // VkQueryPipelineStatisticFlags pipelineStatistics // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineStatistics:             ";
    *rString += "VkQueryPipelineStatisticFlags = "; // TEQ
    flagsToString(rString, pStruct->pipelineStatistics, enumToString_VkQueryPipelineStatisticFlagBits); // URW
}

template <>
void structureToString<Decoded_VkCommandBufferBeginInfo>(std::string* rString, const Decoded_VkCommandBufferBeginInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCommandBufferBeginInfo *pStruct = (const VkCommandBufferBeginInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkCommandBufferUsageFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkCommandBufferUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkCommandBufferUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // const VkCommandBufferInheritanceInfo* pInheritanceInfo // SMB
    indentSpaces(rString, indent);
    *rString += "pInheritanceInfo:               ";
    *rString += "const VkCommandBufferInheritanceInfo* = "; // TEQ
    if (pStruct->pInheritanceInfo == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pInheritanceInfo->GetAddress()); // JHI
        structureToString<Decoded_VkCommandBufferInheritanceInfo>(rString, *pStructIn.pInheritanceInfo->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkCommandBufferBeginInfo, pInheritanceInfo)); // GLM
    }
}

template <>
void structureToString<Decoded_VkBufferCopy>(std::string* rString, const Decoded_VkBufferCopy &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferCopy *pStruct = (const VkBufferCopy *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDeviceSize srcOffset // SMB
    indentSpaces(rString, indent);
    *rString += "srcOffset:                      ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->srcOffset);
    *rString += "\n"; // GDS

    // VkDeviceSize dstOffset // SMB
    indentSpaces(rString, indent);
    *rString += "dstOffset:                      ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->dstOffset);
    *rString += "\n"; // GDS

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
}

template <>
void structureToString<Decoded_VkImageSubresourceLayers>(std::string* rString, const Decoded_VkImageSubresourceLayers &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageSubresourceLayers *pStruct = (const VkImageSubresourceLayers *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    indentSpaces(rString, indent);
    *rString += "aspectMask:                     ";
    *rString += "VkImageAspectFlags = "; // TEQ
    flagsToString(rString, pStruct->aspectMask, enumToString_VkImageAspectFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t mipLevel // SMB
    indentSpaces(rString, indent);
    *rString += "mipLevel:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->mipLevel);
    *rString += "\n"; // GDS

    // uint32_t baseArrayLayer // SMB
    indentSpaces(rString, indent);
    *rString += "baseArrayLayer:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->baseArrayLayer);
    *rString += "\n"; // GDS

    // uint32_t layerCount // SMB
    indentSpaces(rString, indent);
    *rString += "layerCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->layerCount);
}

template <>
void structureToString<Decoded_VkImageCopy>(std::string* rString, const Decoded_VkImageCopy &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageCopy *pStruct = (const VkImageCopy *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageSubresourceLayers srcSubresource // SMB
    indentSpaces(rString, indent);
    *rString += "srcSubresource:                 ";
    *rString += "VkImageSubresourceLayers = "; // TEQ
    structureToString<Decoded_VkImageSubresourceLayers>(rString, *pStructIn.srcSubresource, indent+1,  baseAddr + offsetof(VkImageCopy, srcSubresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D srcOffset // SMB
    indentSpaces(rString, indent);
    *rString += "srcOffset:                      ";
    *rString += "VkOffset3D = "; // TEQ
    structureToString<Decoded_VkOffset3D>(rString, *pStructIn.srcOffset, indent+1,  baseAddr + offsetof(VkImageCopy, srcOffset)); // AZJ
    *rString += "\n"; // GDS

    // VkImageSubresourceLayers dstSubresource // SMB
    indentSpaces(rString, indent);
    *rString += "dstSubresource:                 ";
    *rString += "VkImageSubresourceLayers = "; // TEQ
    structureToString<Decoded_VkImageSubresourceLayers>(rString, *pStructIn.dstSubresource, indent+1,  baseAddr + offsetof(VkImageCopy, dstSubresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D dstOffset // SMB
    indentSpaces(rString, indent);
    *rString += "dstOffset:                      ";
    *rString += "VkOffset3D = "; // TEQ
    structureToString<Decoded_VkOffset3D>(rString, *pStructIn.dstOffset, indent+1,  baseAddr + offsetof(VkImageCopy, dstOffset)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent3D extent // SMB
    indentSpaces(rString, indent);
    *rString += "extent:                         ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.extent, indent+1,  baseAddr + offsetof(VkImageCopy, extent)); // AZJ
}

template <>
void structureToString<Decoded_VkImageBlit>(std::string* rString, const Decoded_VkImageBlit &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageBlit *pStruct = (const VkImageBlit *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageSubresourceLayers srcSubresource // SMB
    indentSpaces(rString, indent);
    *rString += "srcSubresource:                 ";
    *rString += "VkImageSubresourceLayers = "; // TEQ
    structureToString<Decoded_VkImageSubresourceLayers>(rString, *pStructIn.srcSubresource, indent+1,  baseAddr + offsetof(VkImageBlit, srcSubresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D srcOffsets // SMB
    indentSpaces(rString, indent);
    *rString += "srcOffsets:                     ";
    *rString += "VkOffset3D[";
    *rString += "2";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkImageBlit, srcOffsets)); // IYY
    arrayOfStructsToString<Decoded_VkOffset3D>(rString, indent+1, 0, "VkOffset3D", pStructIn.srcOffsets->GetMetaStructPointer(), "srcOffsets", 2 , false, pStructIn.srcOffsets->GetAddress()); // EPB
    *rString += "\n"; // GDS

    // VkImageSubresourceLayers dstSubresource // SMB
    indentSpaces(rString, indent);
    *rString += "dstSubresource:                 ";
    *rString += "VkImageSubresourceLayers = "; // TEQ
    structureToString<Decoded_VkImageSubresourceLayers>(rString, *pStructIn.dstSubresource, indent+1,  baseAddr + offsetof(VkImageBlit, dstSubresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D dstOffsets // SMB
    indentSpaces(rString, indent);
    *rString += "dstOffsets:                     ";
    *rString += "VkOffset3D[";
    *rString += "2";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkImageBlit, dstOffsets)); // IYY
    arrayOfStructsToString<Decoded_VkOffset3D>(rString, indent+1, 0, "VkOffset3D", pStructIn.dstOffsets->GetMetaStructPointer(), "dstOffsets", 2 , false, pStructIn.dstOffsets->GetAddress()); // EPB
}

template <>
void structureToString<Decoded_VkBufferImageCopy>(std::string* rString, const Decoded_VkBufferImageCopy &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferImageCopy *pStruct = (const VkBufferImageCopy *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDeviceSize bufferOffset // SMB
    indentSpaces(rString, indent);
    *rString += "bufferOffset:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->bufferOffset);
    *rString += "\n"; // GDS

    // uint32_t bufferRowLength // SMB
    indentSpaces(rString, indent);
    *rString += "bufferRowLength:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bufferRowLength);
    *rString += "\n"; // GDS

    // uint32_t bufferImageHeight // SMB
    indentSpaces(rString, indent);
    *rString += "bufferImageHeight:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bufferImageHeight);
    *rString += "\n"; // GDS

    // VkImageSubresourceLayers imageSubresource // SMB
    indentSpaces(rString, indent);
    *rString += "imageSubresource:               ";
    *rString += "VkImageSubresourceLayers = "; // TEQ
    structureToString<Decoded_VkImageSubresourceLayers>(rString, *pStructIn.imageSubresource, indent+1,  baseAddr + offsetof(VkBufferImageCopy, imageSubresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D imageOffset // SMB
    indentSpaces(rString, indent);
    *rString += "imageOffset:                    ";
    *rString += "VkOffset3D = "; // TEQ
    structureToString<Decoded_VkOffset3D>(rString, *pStructIn.imageOffset, indent+1,  baseAddr + offsetof(VkBufferImageCopy, imageOffset)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent3D imageExtent // SMB
    indentSpaces(rString, indent);
    *rString += "imageExtent:                    ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.imageExtent, indent+1,  baseAddr + offsetof(VkBufferImageCopy, imageExtent)); // AZJ
}

template <>
void structureToString<Decoded_VkClearColorValue>(std::string* rString, const Decoded_VkClearColorValue &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkClearColorValue *pStruct = (const VkClearColorValue *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // float float32 // SMB
    indentSpaces(rString, indent);
    *rString += "float32:                        ";
    *rString += "float[";
    *rString += "4";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkClearColorValue, float32)); // IYY
    ValueToStringStruct vinfo_float32 = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->float32), "float32", 4, vinfo_float32); // JPA
    *rString += "\n"; // GDS

    // int32_t int32 // SMB
    indentSpaces(rString, indent);
    *rString += "int32:                          ";
    *rString += "int32_t[";
    *rString += "4";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkClearColorValue, int32)); // IYY
    ValueToStringStruct vinfo_int32 = {false, false, false, nullptr};
    arrayToString<int32_t*>(rString, indent, 0, "int32_t", const_cast<int32_t*>(pStruct->int32), "int32", 4, vinfo_int32); // JPA
    *rString += "\n"; // GDS

    // uint32_t uint32 // SMB
    indentSpaces(rString, indent);
    *rString += "uint32:                         ";
    *rString += "uint32_t[";
    *rString += "4";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkClearColorValue, uint32)); // IYY
    ValueToStringStruct vinfo_uint32 = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->uint32), "uint32", 4, vinfo_uint32); // JPA
}

template <>
void structureToString<Decoded_VkClearDepthStencilValue>(std::string* rString, const Decoded_VkClearDepthStencilValue &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkClearDepthStencilValue *pStruct = (const VkClearDepthStencilValue *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // float depth // SMB
    indentSpaces(rString, indent);
    *rString += "depth:                          ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->depth);
    *rString += "\n"; // GDS

    // uint32_t stencil // SMB
    indentSpaces(rString, indent);
    *rString += "stencil:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->stencil);
}

template <>
void structureToString<Decoded_VkClearValue>(std::string* rString, const Decoded_VkClearValue &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkClearValue *pStruct = (const VkClearValue *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkClearColorValue color // SMB
    indentSpaces(rString, indent);
    *rString += "color:                          ";
    *rString += "VkClearColorValue = "; // TEQ
    *rString += "(Union):"; // RGT
    structureToString<Decoded_VkClearColorValue>(rString, (Decoded_VkClearColorValue&)pStructIn, indent+1,  baseAddr + offsetof(VkClearValue, color)); // RLN
    *rString += "\n"; // GDS

    // VkClearDepthStencilValue depthStencil // SMB
    indentSpaces(rString, indent);
    *rString += "depthStencil:                   ";
    *rString += "VkClearDepthStencilValue = "; // TEQ
    structureToString<Decoded_VkClearDepthStencilValue>(rString, (Decoded_VkClearDepthStencilValue&)pStructIn, indent+1,  baseAddr + offsetof(VkClearValue, depthStencil)); // RLN
}

template <>
void structureToString<Decoded_VkClearAttachment>(std::string* rString, const Decoded_VkClearAttachment &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkClearAttachment *pStruct = (const VkClearAttachment *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageAspectFlags aspectMask // SMB
    indentSpaces(rString, indent);
    *rString += "aspectMask:                     ";
    *rString += "VkImageAspectFlags = "; // TEQ
    flagsToString(rString, pStruct->aspectMask, enumToString_VkImageAspectFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t colorAttachment // SMB
    indentSpaces(rString, indent);
    *rString += "colorAttachment:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->colorAttachment);
    *rString += "\n"; // GDS

    // VkClearValue clearValue // SMB
    indentSpaces(rString, indent);
    *rString += "clearValue:                     ";
    *rString += "VkClearValue = "; // TEQ
    *rString += "(Union):"; // RGT
    structureToString<Decoded_VkClearValue>(rString, *pStructIn.clearValue, indent+1,  baseAddr + offsetof(VkClearAttachment, clearValue)); // AZJ
}

template <>
void structureToString<Decoded_VkClearRect>(std::string* rString, const Decoded_VkClearRect &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkClearRect *pStruct = (const VkClearRect *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkRect2D rect // SMB
    indentSpaces(rString, indent);
    *rString += "rect:                           ";
    *rString += "VkRect2D = "; // TEQ
    structureToString<Decoded_VkRect2D>(rString, *pStructIn.rect, indent+1,  baseAddr + offsetof(VkClearRect, rect)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t baseArrayLayer // SMB
    indentSpaces(rString, indent);
    *rString += "baseArrayLayer:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->baseArrayLayer);
    *rString += "\n"; // GDS

    // uint32_t layerCount // SMB
    indentSpaces(rString, indent);
    *rString += "layerCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->layerCount);
}

template <>
void structureToString<Decoded_VkImageResolve>(std::string* rString, const Decoded_VkImageResolve &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageResolve *pStruct = (const VkImageResolve *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageSubresourceLayers srcSubresource // SMB
    indentSpaces(rString, indent);
    *rString += "srcSubresource:                 ";
    *rString += "VkImageSubresourceLayers = "; // TEQ
    structureToString<Decoded_VkImageSubresourceLayers>(rString, *pStructIn.srcSubresource, indent+1,  baseAddr + offsetof(VkImageResolve, srcSubresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D srcOffset // SMB
    indentSpaces(rString, indent);
    *rString += "srcOffset:                      ";
    *rString += "VkOffset3D = "; // TEQ
    structureToString<Decoded_VkOffset3D>(rString, *pStructIn.srcOffset, indent+1,  baseAddr + offsetof(VkImageResolve, srcOffset)); // AZJ
    *rString += "\n"; // GDS

    // VkImageSubresourceLayers dstSubresource // SMB
    indentSpaces(rString, indent);
    *rString += "dstSubresource:                 ";
    *rString += "VkImageSubresourceLayers = "; // TEQ
    structureToString<Decoded_VkImageSubresourceLayers>(rString, *pStructIn.dstSubresource, indent+1,  baseAddr + offsetof(VkImageResolve, dstSubresource)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset3D dstOffset // SMB
    indentSpaces(rString, indent);
    *rString += "dstOffset:                      ";
    *rString += "VkOffset3D = "; // TEQ
    structureToString<Decoded_VkOffset3D>(rString, *pStructIn.dstOffset, indent+1,  baseAddr + offsetof(VkImageResolve, dstOffset)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent3D extent // SMB
    indentSpaces(rString, indent);
    *rString += "extent:                         ";
    *rString += "VkExtent3D = "; // TEQ
    structureToString<Decoded_VkExtent3D>(rString, *pStructIn.extent, indent+1,  baseAddr + offsetof(VkImageResolve, extent)); // AZJ
}

template <>
void structureToString<Decoded_VkMemoryBarrier>(std::string* rString, const Decoded_VkMemoryBarrier &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryBarrier *pStruct = (const VkMemoryBarrier *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "srcAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->srcAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "dstAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->dstAccessMask, enumToString_VkAccessFlagBits); // URW
}

template <>
void structureToString<Decoded_VkBufferMemoryBarrier>(std::string* rString, const Decoded_VkBufferMemoryBarrier &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferMemoryBarrier *pStruct = (const VkBufferMemoryBarrier *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "srcAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->srcAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "dstAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->dstAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t srcQueueFamilyIndex // SMB
    indentSpaces(rString, indent);
    *rString += "srcQueueFamilyIndex:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->srcQueueFamilyIndex);
    *rString += "\n"; // GDS

    // uint32_t dstQueueFamilyIndex // SMB
    indentSpaces(rString, indent);
    *rString += "dstQueueFamilyIndex:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstQueueFamilyIndex);
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // VkDeviceSize size // SMB
    indentSpaces(rString, indent);
    *rString += "size:                           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->size);
}

template <>
void structureToString<Decoded_VkImageMemoryBarrier>(std::string* rString, const Decoded_VkImageMemoryBarrier &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageMemoryBarrier *pStruct = (const VkImageMemoryBarrier *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "srcAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->srcAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "dstAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->dstAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkImageLayout oldLayout // SMB
    indentSpaces(rString, indent);
    *rString += "oldLayout:                      ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->oldLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->oldLayout);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageLayout newLayout // SMB
    indentSpaces(rString, indent);
    *rString += "newLayout:                      ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->newLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->newLayout);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t srcQueueFamilyIndex // SMB
    indentSpaces(rString, indent);
    *rString += "srcQueueFamilyIndex:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->srcQueueFamilyIndex);
    *rString += "\n"; // GDS

    // uint32_t dstQueueFamilyIndex // SMB
    indentSpaces(rString, indent);
    *rString += "dstQueueFamilyIndex:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstQueueFamilyIndex);
    *rString += "\n"; // GDS

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
    *rString += "\n"; // GDS

    // VkImageSubresourceRange subresourceRange // SMB
    indentSpaces(rString, indent);
    *rString += "subresourceRange:               ";
    *rString += "VkImageSubresourceRange = "; // TEQ
    structureToString<Decoded_VkImageSubresourceRange>(rString, *pStructIn.subresourceRange, indent+1,  baseAddr + offsetof(VkImageMemoryBarrier, subresourceRange)); // AZJ
}

template <>
void structureToString<Decoded_VkRenderPassBeginInfo>(std::string* rString, const Decoded_VkRenderPassBeginInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRenderPassBeginInfo *pStruct = (const VkRenderPassBeginInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkRenderPass renderPass // SMB
    indentSpaces(rString, indent);
    *rString += "renderPass:                     ";
    *rString += "VkRenderPass = "; // TEQ
    addrToString(rString, pStructIn.renderPass); // PAQ  
    *rString += "\n"; // GDS

    // VkFramebuffer framebuffer // SMB
    indentSpaces(rString, indent);
    *rString += "framebuffer:                    ";
    *rString += "VkFramebuffer = "; // TEQ
    addrToString(rString, pStructIn.framebuffer); // PAQ  
    *rString += "\n"; // GDS

    // VkRect2D renderArea // SMB
    indentSpaces(rString, indent);
    *rString += "renderArea:                     ";
    *rString += "VkRect2D = "; // TEQ
    structureToString<Decoded_VkRect2D>(rString, *pStructIn.renderArea, indent+1,  baseAddr + offsetof(VkRenderPassBeginInfo, renderArea)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t clearValueCount // SMB
    indentSpaces(rString, indent);
    *rString += "clearValueCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->clearValueCount);
    *rString += "\n"; // GDS

    // const VkClearValue* pClearValues // SMB
    indentSpaces(rString, indent);
    *rString += "pClearValues:                   ";
    *rString += "const VkClearValue* = "; // TEQ
    if (pStruct->pClearValues == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pClearValues->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkClearValue>(rString, indent+1, 1, "VkClearValue", pStructIn.pClearValues->GetMetaStructPointer(), "pClearValues", pStruct->clearValueCount, true, pStructIn.pClearValues->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkDispatchIndirectCommand>(std::string* rString, const Decoded_VkDispatchIndirectCommand &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDispatchIndirectCommand *pStruct = (const VkDispatchIndirectCommand *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t x // SMB
    indentSpaces(rString, indent);
    *rString += "x:                              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->x);
    *rString += "\n"; // GDS

    // uint32_t y // SMB
    indentSpaces(rString, indent);
    *rString += "y:                              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->y);
    *rString += "\n"; // GDS

    // uint32_t z // SMB
    indentSpaces(rString, indent);
    *rString += "z:                              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->z);
}

template <>
void structureToString<Decoded_VkDrawIndexedIndirectCommand>(std::string* rString, const Decoded_VkDrawIndexedIndirectCommand &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDrawIndexedIndirectCommand *pStruct = (const VkDrawIndexedIndirectCommand *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t indexCount // SMB
    indentSpaces(rString, indent);
    *rString += "indexCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->indexCount);
    *rString += "\n"; // GDS

    // uint32_t instanceCount // SMB
    indentSpaces(rString, indent);
    *rString += "instanceCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->instanceCount);
    *rString += "\n"; // GDS

    // uint32_t firstIndex // SMB
    indentSpaces(rString, indent);
    *rString += "firstIndex:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->firstIndex);
    *rString += "\n"; // GDS

    // int32_t vertexOffset // SMB
    indentSpaces(rString, indent);
    *rString += "vertexOffset:                   ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->vertexOffset);
    *rString += "\n"; // GDS

    // uint32_t firstInstance // SMB
    indentSpaces(rString, indent);
    *rString += "firstInstance:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->firstInstance);
}

template <>
void structureToString<Decoded_VkDrawIndirectCommand>(std::string* rString, const Decoded_VkDrawIndirectCommand &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDrawIndirectCommand *pStruct = (const VkDrawIndirectCommand *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t vertexCount // SMB
    indentSpaces(rString, indent);
    *rString += "vertexCount:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->vertexCount);
    *rString += "\n"; // GDS

    // uint32_t instanceCount // SMB
    indentSpaces(rString, indent);
    *rString += "instanceCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->instanceCount);
    *rString += "\n"; // GDS

    // uint32_t firstVertex // SMB
    indentSpaces(rString, indent);
    *rString += "firstVertex:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->firstVertex);
    *rString += "\n"; // GDS

    // uint32_t firstInstance // SMB
    indentSpaces(rString, indent);
    *rString += "firstInstance:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->firstInstance);
}

void VulkanAsciiConsumer::Process_vkCreateInstance(
    VkResult                                    returnValue,
    const StructPointerDecoder<Decoded_VkInstanceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkInstance>&     pInstance)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateInstance(pCreateInfo, pAllocator, pInstance)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // const VkInstanceCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkInstanceCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkInstanceCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkInstanceCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkInstance* pInstance // ARG
    if (pInstance.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkInstance* = NULL", indentString.c_str(), "pInstance:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkInstance* = ", indentString.c_str(), "pInstance:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pInstance.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyInstance(
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyInstance(instance, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDevices(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceCount,
    const HandlePointerDecoder<VkPhysicalDevice>& pPhysicalDevices)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPhysicalDeviceCount // ARG
    if (pPhysicalDeviceCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPhysicalDeviceCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPhysicalDeviceCount:", static_cast<uint64_t>(*pPhysicalDeviceCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDevice* pPhysicalDevices // ARG
    if (pPhysicalDevices.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDevice* = NULL", indentString.c_str(), "pPhysicalDevices:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDevice* = ", indentString.c_str(), "pPhysicalDevices:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pPhysicalDevices.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pPhysicalDevices = {true, false, false, nullptr};
        arrayToString<VkPhysicalDevice*>(&tmpString, 1, 1, "VkPhysicalDevice*", reinterpret_cast<VkPhysicalDevice*>(pPhysicalDevices.GetPointer()), "pPhysicalDevices", *pPhysicalDeviceCount.GetPointer(), vinfo_pPhysicalDevices); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures>& pFeatures)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceFeatures* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures* = NULL", indentString.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures* = ", indentString.c_str(), "pFeatures:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceFeatures>(&tmpString, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties>& pFormatProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmpString = "";
    enumToString_VkFormat(&tmpString,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indentString.c_str(), "format:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkFormatProperties* pFormatProperties // ARG
    if (pFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties* = NULL", indentString.c_str(), "pFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties* = ", indentString.c_str(), "pFormatProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkFormatProperties>(&tmpString, *pFormatProperties.GetMetaStructPointer(), 2, pFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    const StructPointerDecoder<Decoded_VkImageFormatProperties>& pImageFormatProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmpString = "";
    enumToString_VkFormat(&tmpString,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indentString.c_str(), "format:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageType type // ARG
    tmpString = "";
    enumToString_VkImageType(&tmpString,type); // EPW
    fprintf(GetFile(), "%s%-32sVkImageType = %s", indentString.c_str(), "type:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageTiling tiling // ARG
    tmpString = "";
    enumToString_VkImageTiling(&tmpString,tiling); // EPW
    fprintf(GetFile(), "%s%-32sVkImageTiling = %s", indentString.c_str(), "tiling:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageUsageFlags usage // ARG
    tmpString = "";
    flagsToString(&tmpString, usage, enumToString_VkImageUsageFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageUsageFlags = %s", indentString.c_str(), "usage:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageCreateFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkImageCreateFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageCreateFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageFormatProperties* pImageFormatProperties // ARG
    if (pImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties* = NULL", indentString.c_str(), "pImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties* = ", indentString.c_str(), "pImageFormatProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageFormatProperties>(&tmpString, *pImageFormatProperties.GetMetaStructPointer(), 2, pImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceProperties* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties* = NULL", indentString.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties* = ", indentString.c_str(), "pProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceProperties>(&tmpString, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties>& pQueueFamilyProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pQueueFamilyPropertyCount // ARG
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pQueueFamilyPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pQueueFamilyPropertyCount:", static_cast<uint64_t>(*pQueueFamilyPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueueFamilyProperties* pQueueFamilyProperties // ARG
    if (pQueueFamilyProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties* = NULL", indentString.c_str(), "pQueueFamilyProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties* = ", indentString.c_str(), "pQueueFamilyProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pQueueFamilyProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkQueueFamilyProperties>(&tmpString, 2, 1, "VkQueueFamilyProperties",
            pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties>& pMemoryProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceMemoryProperties* pMemoryProperties // ARG
    if (pMemoryProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties* = NULL", indentString.c_str(), "pMemoryProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties* = ", indentString.c_str(), "pMemoryProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceMemoryProperties>(&tmpString, *pMemoryProperties.GetMetaStructPointer(), 2, pMemoryProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDevice(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDeviceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDevice>&       pDevice)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDeviceCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDevice* pDevice // ARG
    if (pDevice.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDevice* = NULL", indentString.c_str(), "pDevice:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDevice* = ", indentString.c_str(), "pDevice:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pDevice.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDevice(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyDevice(device, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceQueue(
    format::HandleId                            device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    const HandlePointerDecoder<VkQueue>&        pQueue)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queueIndex:", queueIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueue* pQueue // ARG
    if (pQueue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = NULL", indentString.c_str(), "pQueue:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = ", indentString.c_str(), "pQueue:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pQueue.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueSubmit(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    submitCount,
    const StructPointerDecoder<Decoded_VkSubmitInfo>& pSubmits,
    format::HandleId                            fence)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueueSubmit(queue, submitCount, pSubmits, fence)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t submitCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "submitCount:", submitCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubmitInfo* pSubmits // ARG
    if (pSubmits.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubmitInfo* = NULL", indentString.c_str(), "pSubmits:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubmitInfo* = ", indentString.c_str(), "pSubmits:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pSubmits.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSubmitInfo>(&tmpString, 2, 1, "VkSubmitInfo",
            pSubmits.GetMetaStructPointer(), "pSubmits", submitCount, false, pSubmits.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indentString.c_str(), "fence:"); // TRP
    tmpString = "";
    addrToString(&tmpString, fence);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueWaitIdle(
    VkResult                                    returnValue,
    format::HandleId                            queue)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueueWaitIdle(queue)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDeviceWaitIdle(
    VkResult                                    returnValue,
    format::HandleId                            device)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDeviceWaitIdle(device)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryAllocateInfo>& pAllocateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDeviceMemory>& pMemory)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryAllocateInfo* pAllocateInfo // ARG
    if (pAllocateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryAllocateInfo* = NULL", indentString.c_str(), "pAllocateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryAllocateInfo* = ", indentString.c_str(), "pAllocateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryAllocateInfo>(&tmpString, *pAllocateInfo.GetMetaStructPointer(), 2, pAllocateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory* pMemory // ARG
    if (pMemory.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceMemory* = NULL", indentString.c_str(), "pMemory:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceMemory* = ", indentString.c_str(), "pMemory:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pMemory.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeMemory(
    format::HandleId                            device,
    format::HandleId                            memory,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkFreeMemory(device, memory, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indentString.c_str(), "memory:"); // TRP
    tmpString = "";
    addrToString(&tmpString, memory);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkMapMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    const PointerDecoder<uint64_t>&             ppData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkMapMemory(device, memory, offset, size, flags, ppData)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indentString.c_str(), "memory:"); // TRP
    tmpString = "";
    addrToString(&tmpString, memory);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize size // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "size:", size); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryMapFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkMemoryMapFlags = %d", indentString.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    // void** ppData // ARG
    if (ppData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indentString.c_str(), "ppData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indentString.c_str(), "ppData:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(ppData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkUnmapMemory(
    format::HandleId                            device,
    format::HandleId                            memory)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkUnmapMemory(device, memory)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indentString.c_str(), "memory:"); // TRP
    tmpString = "";
    addrToString(&tmpString, memory);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkFlushMappedMemoryRanges(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    const StructPointerDecoder<Decoded_VkMappedMemoryRange>& pMemoryRanges)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryRangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "memoryRangeCount:", memoryRangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMappedMemoryRange* pMemoryRanges // ARG
    if (pMemoryRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = NULL", indentString.c_str(), "pMemoryRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = ", indentString.c_str(), "pMemoryRanges:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pMemoryRanges.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkMappedMemoryRange>(&tmpString, 2, 1, "VkMappedMemoryRange",
            pMemoryRanges.GetMetaStructPointer(), "pMemoryRanges", memoryRangeCount, false, pMemoryRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkInvalidateMappedMemoryRanges(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    const StructPointerDecoder<Decoded_VkMappedMemoryRange>& pMemoryRanges)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryRangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "memoryRangeCount:", memoryRangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMappedMemoryRange* pMemoryRanges // ARG
    if (pMemoryRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = NULL", indentString.c_str(), "pMemoryRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMappedMemoryRange* = ", indentString.c_str(), "pMemoryRanges:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pMemoryRanges.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkMappedMemoryRange>(&tmpString, 2, 1, "VkMappedMemoryRange",
            pMemoryRanges.GetMetaStructPointer(), "pMemoryRanges", memoryRangeCount, false, pMemoryRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceMemoryCommitment(
    format::HandleId                            device,
    format::HandleId                            memory,
    const PointerDecoder<VkDeviceSize>&         pCommittedMemoryInBytes)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indentString.c_str(), "memory:"); // TRP
    tmpString = "";
    addrToString(&tmpString, memory);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize* pCommittedMemoryInBytes // ARG
    if (pCommittedMemoryInBytes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceSize* = NULL", indentString.c_str(), "pCommittedMemoryInBytes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceSize* = %" PRId64 "", indentString.c_str(), "pCommittedMemoryInBytes:", static_cast<uint64_t>(*pCommittedMemoryInBytes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindBufferMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            buffer,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBindBufferMemory(device, buffer, memory, memoryOffset)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indentString.c_str(), "memory:"); // TRP
    tmpString = "";
    addrToString(&tmpString, memory);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize memoryOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "memoryOffset:", memoryOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBindImageMemory(device, image, memory, memoryOffset)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indentString.c_str(), "memory:"); // TRP
    tmpString = "";
    addrToString(&tmpString, memory);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize memoryOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "memoryOffset:", memoryOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            buffer,
    const StructPointerDecoder<Decoded_VkMemoryRequirements>& pMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = NULL", indentString.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = ", indentString.c_str(), "pMemoryRequirements:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryRequirements>(&tmpString, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkMemoryRequirements>& pMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageMemoryRequirements(device, image, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = NULL", indentString.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements* = ", indentString.c_str(), "pMemoryRequirements:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryRequirements>(&tmpString, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements(
    format::HandleId                            device,
    format::HandleId                            image,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements>& pSparseMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSparseMemoryRequirementCount // ARG
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pSparseMemoryRequirementCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pSparseMemoryRequirementCount:", static_cast<uint64_t>(*pSparseMemoryRequirementCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageMemoryRequirements* pSparseMemoryRequirements // ARG
    if (pSparseMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements* = NULL", indentString.c_str(), "pSparseMemoryRequirements:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements* = ", indentString.c_str(), "pSparseMemoryRequirements:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pSparseMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements>(&tmpString, 2, 1, "VkSparseImageMemoryRequirements",
            pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmpString = "";
    enumToString_VkFormat(&tmpString,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indentString.c_str(), "format:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageType type // ARG
    tmpString = "";
    enumToString_VkImageType(&tmpString,type); // EPW
    fprintf(GetFile(), "%s%-32sVkImageType = %s", indentString.c_str(), "type:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkSampleCountFlagBits samples // ARG
    tmpString = "";
    enumToString_VkSampleCountFlagBits(&tmpString,samples); // EPW
    fprintf(GetFile(), "%s%-32sVkSampleCountFlagBits = %s", indentString.c_str(), "samples:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageUsageFlags usage // ARG
    tmpString = "";
    flagsToString(&tmpString, usage, enumToString_VkImageUsageFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageUsageFlags = %s", indentString.c_str(), "usage:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageTiling tiling // ARG
    tmpString = "";
    enumToString_VkImageTiling(&tmpString,tiling); // EPW
    fprintf(GetFile(), "%s%-32sVkImageTiling = %s", indentString.c_str(), "tiling:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageFormatProperties* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSparseImageFormatProperties>(&tmpString, 2, 1, "VkSparseImageFormatProperties",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueBindSparse(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindSparseInfo>& pBindInfo,
    format::HandleId                            fence)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindSparseInfo* pBindInfo // ARG
    if (pBindInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindSparseInfo* = NULL", indentString.c_str(), "pBindInfo:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindSparseInfo* = ", indentString.c_str(), "pBindInfo:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBindInfo.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBindSparseInfo>(&tmpString, 2, 1, "VkBindSparseInfo",
            pBindInfo.GetMetaStructPointer(), "pBindInfo", bindInfoCount, false, pBindInfo.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indentString.c_str(), "fence:"); // TRP
    tmpString = "";
    addrToString(&tmpString, fence);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateFence(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateFence(device, pCreateInfo, pAllocator, pFence)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFenceCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkFenceCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence* pFence // ARG
    if (pFence.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFence* = NULL", indentString.c_str(), "pFence:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFence* = ", indentString.c_str(), "pFence:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pFence.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyFence(
    format::HandleId                            device,
    format::HandleId                            fence,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyFence(device, fence, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indentString.c_str(), "fence:"); // TRP
    tmpString = "";
    addrToString(&tmpString, fence);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetFences(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    const HandlePointerDecoder<VkFence>&        pFences)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkResetFences(device, fenceCount, pFences)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t fenceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "fenceCount:", fenceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkFence* pFences // ARG
    if (pFences.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = NULL", indentString.c_str(), "pFences:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = ", indentString.c_str(), "pFences:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pFences.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pFences = {true, false, false, nullptr};
        arrayToString<const VkFence*>(&tmpString, 1, 1, "const VkFence*", reinterpret_cast<const VkFence*>(pFences.GetPointer()), "pFences", fenceCount, vinfo_pFences); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetFenceStatus(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            fence)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetFenceStatus(device, fence)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indentString.c_str(), "fence:"); // TRP
    tmpString = "";
    addrToString(&tmpString, fence);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkWaitForFences(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    const HandlePointerDecoder<VkFence>&        pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkWaitForFences(device, fenceCount, pFences, waitAll, timeout)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t fenceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "fenceCount:", fenceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkFence* pFences // ARG
    if (pFences.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = NULL", indentString.c_str(), "pFences:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFence* = ", indentString.c_str(), "pFences:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pFences.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pFences = {true, false, false, nullptr};
        arrayToString<const VkFence*>(&tmpString, 1, 1, "const VkFence*", reinterpret_cast<const VkFence*>(pFences.GetPointer()), "pFences", fenceCount, vinfo_pFences); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32 waitAll // ARG
    fprintf(GetFile(), "%s%-32sVkBool32 = %u", indentString.c_str(), "waitAll:", waitAll); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t timeout // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indentString.c_str(), "timeout:", timeout); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSemaphore(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSemaphore>&    pSemaphore)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSemaphoreCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore* pSemaphore // ARG
    if (pSemaphore.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSemaphore* = NULL", indentString.c_str(), "pSemaphore:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSemaphore* = ", indentString.c_str(), "pSemaphore:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSemaphore.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySemaphore(
    format::HandleId                            device,
    format::HandleId                            semaphore,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroySemaphore(device, semaphore, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore semaphore // ARG
    fprintf(GetFile(), "%s%-32sVkSemaphore = ", indentString.c_str(), "semaphore:"); // TRP
    tmpString = "";
    addrToString(&tmpString, semaphore);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkEventCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkEvent>&        pEvent)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateEvent(device, pCreateInfo, pAllocator, pEvent)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkEventCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkEventCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkEventCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkEventCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent* pEvent // ARG
    if (pEvent.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkEvent* = NULL", indentString.c_str(), "pEvent:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkEvent* = ", indentString.c_str(), "pEvent:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pEvent.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyEvent(
    format::HandleId                            device,
    format::HandleId                            event,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyEvent(device, event, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indentString.c_str(), "event:"); // TRP
    tmpString = "";
    addrToString(&tmpString, event);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetEventStatus(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetEventStatus(device, event)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indentString.c_str(), "event:"); // TRP
    tmpString = "";
    addrToString(&tmpString, event);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkSetEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkSetEvent(device, event)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indentString.c_str(), "event:"); // TRP
    tmpString = "";
    addrToString(&tmpString, event);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetEvent(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkResetEvent(device, event)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indentString.c_str(), "event:"); // TRP
    tmpString = "";
    addrToString(&tmpString, event);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateQueryPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkQueryPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkQueryPool>&    pQueryPool)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkQueryPoolCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkQueryPoolCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkQueryPoolCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkQueryPoolCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool* pQueryPool // ARG
    if (pQueryPool.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueryPool* = NULL", indentString.c_str(), "pQueryPool:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueryPool* = ", indentString.c_str(), "pQueryPool:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pQueryPool.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyQueryPool(
    format::HandleId                            device,
    format::HandleId                            queryPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyQueryPool(device, queryPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetQueryPoolResults(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // size_t dataSize // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indentString.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indentString.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indentString.c_str(), "pData:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize stride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryResultFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkQueryResultFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryResultFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateBuffer(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkBuffer>&       pBuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkBufferCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer* pBuffer // ARG
    if (pBuffer.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkBuffer* = NULL", indentString.c_str(), "pBuffer:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkBuffer* = ", indentString.c_str(), "pBuffer:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pBuffer.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyBuffer(
    format::HandleId                            device,
    format::HandleId                            buffer,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyBuffer(device, buffer, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateBufferView(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferViewCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkBufferView>&   pView)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateBufferView(device, pCreateInfo, pAllocator, pView)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferViewCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferViewCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferViewCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkBufferViewCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBufferView* pView // ARG
    if (pView.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkBufferView* = NULL", indentString.c_str(), "pView:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkBufferView* = ", indentString.c_str(), "pView:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pView.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyBufferView(
    format::HandleId                            device,
    format::HandleId                            bufferView,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyBufferView(device, bufferView, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBufferView bufferView // ARG
    fprintf(GetFile(), "%s%-32sVkBufferView = ", indentString.c_str(), "bufferView:"); // TRP
    tmpString = "";
    addrToString(&tmpString, bufferView);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateImage(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkImage>&        pImage)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateImage(device, pCreateInfo, pAllocator, pImage)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImage* pImage // ARG
    if (pImage.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImage* = NULL", indentString.c_str(), "pImage:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImage* = ", indentString.c_str(), "pImage:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pImage.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyImage(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyImage(device, image, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSubresourceLayout(
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkImageSubresource>& pSubresource,
    const StructPointerDecoder<Decoded_VkSubresourceLayout>& pLayout)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageSubresourceLayout(device, image, pSubresource, pLayout)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSubresource* pSubresource // ARG
    if (pSubresource.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresource* = NULL", indentString.c_str(), "pSubresource:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresource* = ", indentString.c_str(), "pSubresource:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSubresource.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageSubresource>(&tmpString, *pSubresource.GetMetaStructPointer(), 2, pSubresource.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSubresourceLayout* pLayout // ARG
    if (pLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSubresourceLayout* = NULL", indentString.c_str(), "pLayout:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSubresourceLayout* = ", indentString.c_str(), "pLayout:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pLayout.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSubresourceLayout>(&tmpString, *pLayout.GetMetaStructPointer(), 2, pLayout.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateImageView(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageViewCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkImageView>&    pView)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateImageView(device, pCreateInfo, pAllocator, pView)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageViewCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageViewCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImageView* pView // ARG
    if (pView.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageView* = NULL", indentString.c_str(), "pView:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageView* = ", indentString.c_str(), "pView:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pView.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyImageView(
    format::HandleId                            device,
    format::HandleId                            imageView,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyImageView(device, imageView, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageView imageView // ARG
    fprintf(GetFile(), "%s%-32sVkImageView = ", indentString.c_str(), "imageView:"); // TRP
    tmpString = "";
    addrToString(&tmpString, imageView);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateShaderModule(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkShaderModuleCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkShaderModule>& pShaderModule)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkShaderModuleCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkShaderModuleCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkShaderModuleCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkShaderModuleCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderModule* pShaderModule // ARG
    if (pShaderModule.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkShaderModule* = NULL", indentString.c_str(), "pShaderModule:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkShaderModule* = ", indentString.c_str(), "pShaderModule:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pShaderModule.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyShaderModule(
    format::HandleId                            device,
    format::HandleId                            shaderModule,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyShaderModule(device, shaderModule, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderModule shaderModule // ARG
    fprintf(GetFile(), "%s%-32sVkShaderModule = ", indentString.c_str(), "shaderModule:"); // TRP
    tmpString = "";
    addrToString(&tmpString, shaderModule);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreatePipelineCache(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineCacheCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipelineCache>& pPipelineCache)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineCacheCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCacheCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCacheCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPipelineCacheCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache* pPipelineCache // ARG
    if (pPipelineCache.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineCache* = NULL", indentString.c_str(), "pPipelineCache:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineCache* = ", indentString.c_str(), "pPipelineCache:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pPipelineCache.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipelineCache(
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyPipelineCache(device, pipelineCache, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indentString.c_str(), "pipelineCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipelineCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineCacheData(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    const PointerDecoder<size_t>&               pDataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indentString.c_str(), "pipelineCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipelineCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // size_t* pDataSize // ARG
    if (pDataSize.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32ssize_t* = NULL", indentString.c_str(), "pDataSize:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32ssize_t* = %" PRId64 "", indentString.c_str(), "pDataSize:", static_cast<uint64_t>(*pDataSize.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indentString.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indentString.c_str(), "pData:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkMergePipelineCaches(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    const HandlePointerDecoder<VkPipelineCache>& pSrcCaches)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache dstCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indentString.c_str(), "dstCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t srcCacheCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "srcCacheCount:", srcCacheCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineCache* pSrcCaches // ARG
    if (pSrcCaches.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCache* = NULL", indentString.c_str(), "pSrcCaches:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineCache* = ", indentString.c_str(), "pSrcCaches:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pSrcCaches.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pSrcCaches = {true, false, false, nullptr};
        arrayToString<const VkPipelineCache*>(&tmpString, 1, 1, "const VkPipelineCache*", reinterpret_cast<const VkPipelineCache*>(pSrcCaches.GetPointer()), "pSrcCaches", srcCacheCount, vinfo_pSrcCaches); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateGraphicsPipelines(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkGraphicsPipelineCreateInfo>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indentString.c_str(), "pipelineCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipelineCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t createInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "createInfoCount:", createInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkGraphicsPipelineCreateInfo* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkGraphicsPipelineCreateInfo* = NULL", indentString.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkGraphicsPipelineCreateInfo* = ", indentString.c_str(), "pCreateInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkGraphicsPipelineCreateInfo>(&tmpString, 2, 1, "VkGraphicsPipelineCreateInfo",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline* pPipelines // ARG
    if (pPipelines.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = NULL", indentString.c_str(), "pPipelines:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = ", indentString.c_str(), "pPipelines:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pPipelines.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        arrayToString<VkPipeline*>(&tmpString, 1, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount, vinfo_pPipelines); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateComputePipelines(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkComputePipelineCreateInfo>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indentString.c_str(), "pipelineCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipelineCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t createInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "createInfoCount:", createInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkComputePipelineCreateInfo* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkComputePipelineCreateInfo* = NULL", indentString.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkComputePipelineCreateInfo* = ", indentString.c_str(), "pCreateInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkComputePipelineCreateInfo>(&tmpString, 2, 1, "VkComputePipelineCreateInfo",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline* pPipelines // ARG
    if (pPipelines.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = NULL", indentString.c_str(), "pPipelines:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = ", indentString.c_str(), "pPipelines:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pPipelines.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        arrayToString<VkPipeline*>(&tmpString, 1, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount, vinfo_pPipelines); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipeline(
    format::HandleId                            device,
    format::HandleId                            pipeline,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyPipeline(device, pipeline, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indentString.c_str(), "pipeline:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipeline);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreatePipelineLayout(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipelineLayout>& pPipelineLayout)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineLayoutCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineLayoutCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPipelineLayoutCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout* pPipelineLayout // ARG
    if (pPipelineLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineLayout* = NULL", indentString.c_str(), "pPipelineLayout:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineLayout* = ", indentString.c_str(), "pPipelineLayout:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pPipelineLayout.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyPipelineLayout(
    format::HandleId                            device,
    format::HandleId                            pipelineLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyPipelineLayout(device, pipelineLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout pipelineLayout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indentString.c_str(), "pipelineLayout:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipelineLayout);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSampler(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSampler>&      pSampler)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateSampler(device, pCreateInfo, pAllocator, pSampler)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSamplerCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSamplerCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSampler* pSampler // ARG
    if (pSampler.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSampler* = NULL", indentString.c_str(), "pSampler:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSampler* = ", indentString.c_str(), "pSampler:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSampler.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySampler(
    format::HandleId                            device,
    format::HandleId                            sampler,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroySampler(device, sampler, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSampler sampler // ARG
    fprintf(GetFile(), "%s%-32sVkSampler = ", indentString.c_str(), "sampler:"); // TRP
    tmpString = "";
    addrToString(&tmpString, sampler);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorSetLayout(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorSetLayout>& pSetLayout)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayout* pSetLayout // ARG
    if (pSetLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayout* = NULL", indentString.c_str(), "pSetLayout:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayout* = ", indentString.c_str(), "pSetLayout:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSetLayout.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorSetLayout(
    format::HandleId                            device,
    format::HandleId                            descriptorSetLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayout descriptorSetLayout // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorSetLayout = ", indentString.c_str(), "descriptorSetLayout:"); // TRP
    tmpString = "";
    addrToString(&tmpString, descriptorSetLayout);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorPool>& pDescriptorPool)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorPoolCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorPoolCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorPoolCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorPoolCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool* pDescriptorPool // ARG
    if (pDescriptorPool.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorPool* = NULL", indentString.c_str(), "pDescriptorPool:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorPool* = ", indentString.c_str(), "pDescriptorPool:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pDescriptorPool.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorPool(
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyDescriptorPool(device, descriptorPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool descriptorPool // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPool = ", indentString.c_str(), "descriptorPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, descriptorPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetDescriptorPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkResetDescriptorPool(device, descriptorPool, flags)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool descriptorPool // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPool = ", indentString.c_str(), "descriptorPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, descriptorPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPoolResetFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPoolResetFlags = %d", indentString.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateDescriptorSets(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetAllocateInfo>& pAllocateInfo,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetAllocateInfo* pAllocateInfo // ARG
    if (pAllocateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetAllocateInfo* = NULL", indentString.c_str(), "pAllocateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetAllocateInfo* = ", indentString.c_str(), "pAllocateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorSetAllocateInfo>(&tmpString, *pAllocateInfo.GetMetaStructPointer(), 2, pAllocateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSet* pDescriptorSets // ARG
    if (pDescriptorSets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSet* = NULL", indentString.c_str(), "pDescriptorSets:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSet* = ", indentString.c_str(), "pDescriptorSets:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pDescriptorSets.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        arrayToString<VkDescriptorSet*>(&tmpString, 1, 1, "VkDescriptorSet*", reinterpret_cast<VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", pAllocateInfo.GetPointer()->descriptorSetCount, vinfo_pDescriptorSets); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeDescriptorSets(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorPool descriptorPool // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorPool = ", indentString.c_str(), "descriptorPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, descriptorPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorSetCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "descriptorSetCount:", descriptorSetCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSet* pDescriptorSets // ARG
    if (pDescriptorSets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = NULL", indentString.c_str(), "pDescriptorSets:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = ", indentString.c_str(), "pDescriptorSets:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pDescriptorSets.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        arrayToString<const VkDescriptorSet*>(&tmpString, 1, 1, "const VkDescriptorSet*", reinterpret_cast<const VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", descriptorSetCount, vinfo_pDescriptorSets); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkUpdateDescriptorSets(
    format::HandleId                            device,
    uint32_t                                    descriptorWriteCount,
    const StructPointerDecoder<Decoded_VkWriteDescriptorSet>& pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const StructPointerDecoder<Decoded_VkCopyDescriptorSet>& pDescriptorCopies)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorWriteCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "descriptorWriteCount:", descriptorWriteCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkWriteDescriptorSet* pDescriptorWrites // ARG
    if (pDescriptorWrites.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = NULL", indentString.c_str(), "pDescriptorWrites:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = ", indentString.c_str(), "pDescriptorWrites:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pDescriptorWrites.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkWriteDescriptorSet>(&tmpString, 2, 1, "VkWriteDescriptorSet",
            pDescriptorWrites.GetMetaStructPointer(), "pDescriptorWrites", descriptorWriteCount, false, pDescriptorWrites.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorCopyCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "descriptorCopyCount:", descriptorCopyCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCopyDescriptorSet* pDescriptorCopies // ARG
    if (pDescriptorCopies.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCopyDescriptorSet* = NULL", indentString.c_str(), "pDescriptorCopies:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCopyDescriptorSet* = ", indentString.c_str(), "pDescriptorCopies:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pDescriptorCopies.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkCopyDescriptorSet>(&tmpString, 2, 1, "VkCopyDescriptorSet",
            pDescriptorCopies.GetMetaStructPointer(), "pDescriptorCopies", descriptorCopyCount, false, pDescriptorCopies.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateFramebuffer(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFramebufferCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFramebuffer>&  pFramebuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFramebufferCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFramebufferCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFramebufferCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkFramebufferCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFramebuffer* pFramebuffer // ARG
    if (pFramebuffer.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFramebuffer* = NULL", indentString.c_str(), "pFramebuffer:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFramebuffer* = ", indentString.c_str(), "pFramebuffer:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pFramebuffer.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyFramebuffer(
    format::HandleId                            device,
    format::HandleId                            framebuffer,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyFramebuffer(device, framebuffer, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFramebuffer framebuffer // ARG
    fprintf(GetFile(), "%s%-32sVkFramebuffer = ", indentString.c_str(), "framebuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, framebuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateRenderPass(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkRenderPassCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkRenderPass>&   pRenderPass)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkRenderPassCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass* pRenderPass // ARG
    if (pRenderPass.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = NULL", indentString.c_str(), "pRenderPass:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = ", indentString.c_str(), "pRenderPass:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pRenderPass.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyRenderPass(
    format::HandleId                            device,
    format::HandleId                            renderPass,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyRenderPass(device, renderPass, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass renderPass // ARG
    fprintf(GetFile(), "%s%-32sVkRenderPass = ", indentString.c_str(), "renderPass:"); // TRP
    tmpString = "";
    addrToString(&tmpString, renderPass);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRenderAreaGranularity(
    format::HandleId                            device,
    format::HandleId                            renderPass,
    const StructPointerDecoder<Decoded_VkExtent2D>& pGranularity)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetRenderAreaGranularity(device, renderPass, pGranularity)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass renderPass // ARG
    fprintf(GetFile(), "%s%-32sVkRenderPass = ", indentString.c_str(), "renderPass:"); // TRP
    tmpString = "";
    addrToString(&tmpString, renderPass);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExtent2D* pGranularity // ARG
    if (pGranularity.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExtent2D* = NULL", indentString.c_str(), "pGranularity:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExtent2D* = ", indentString.c_str(), "pGranularity:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pGranularity.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExtent2D>(&tmpString, *pGranularity.GetMetaStructPointer(), 2, pGranularity.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateCommandPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkCommandPoolCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkCommandPool>&  pCommandPool)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandPoolCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandPoolCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandPoolCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkCommandPoolCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool* pCommandPool // ARG
    if (pCommandPool.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCommandPool* = NULL", indentString.c_str(), "pCommandPool:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCommandPool* = ", indentString.c_str(), "pCommandPool:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pCommandPool.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyCommandPool(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyCommandPool(device, commandPool, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indentString.c_str(), "commandPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetCommandPool(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolResetFlags                     flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkResetCommandPool(device, commandPool, flags)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indentString.c_str(), "commandPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPoolResetFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkCommandPoolResetFlagBits);
    fprintf(GetFile(), "%s%-32sVkCommandPoolResetFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkAllocateCommandBuffers(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkCommandBufferAllocateInfo>& pAllocateInfo,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBufferAllocateInfo* pAllocateInfo // ARG
    if (pAllocateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferAllocateInfo* = NULL", indentString.c_str(), "pAllocateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferAllocateInfo* = ", indentString.c_str(), "pAllocateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkCommandBufferAllocateInfo>(&tmpString, *pAllocateInfo.GetMetaStructPointer(), 2, pAllocateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandBuffer* pCommandBuffers // ARG
    if (pCommandBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCommandBuffer* = NULL", indentString.c_str(), "pCommandBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCommandBuffer* = ", indentString.c_str(), "pCommandBuffers:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pCommandBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        arrayToString<VkCommandBuffer*>(&tmpString, 1, 1, "VkCommandBuffer*", reinterpret_cast<VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", pAllocateInfo.GetPointer()->commandBufferCount, vinfo_pCommandBuffers); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkFreeCommandBuffers(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    uint32_t                                    commandBufferCount,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indentString.c_str(), "commandPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t commandBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "commandBufferCount:", commandBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBuffer* pCommandBuffers // ARG
    if (pCommandBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = NULL", indentString.c_str(), "pCommandBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = ", indentString.c_str(), "pCommandBuffers:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pCommandBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        arrayToString<const VkCommandBuffer*>(&tmpString, 1, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", commandBufferCount, vinfo_pCommandBuffers); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkBeginCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCommandBufferBeginInfo>& pBeginInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBeginCommandBuffer(commandBuffer, pBeginInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBufferBeginInfo* pBeginInfo // ARG
    if (pBeginInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferBeginInfo* = NULL", indentString.c_str(), "pBeginInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBufferBeginInfo* = ", indentString.c_str(), "pBeginInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pBeginInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkCommandBufferBeginInfo>(&tmpString, *pBeginInfo.GetMetaStructPointer(), 2, pBeginInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkEndCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkEndCommandBuffer(commandBuffer)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkResetCommandBuffer(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    VkCommandBufferResetFlags                   flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkResetCommandBuffer(commandBuffer, flags)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandBufferResetFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkCommandBufferResetFlagBits);
    fprintf(GetFile(), "%s%-32sVkCommandBufferResetFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindPipeline(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            pipeline)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineBindPoint pipelineBindPoint // ARG
    tmpString = "";
    enumToString_VkPipelineBindPoint(&tmpString,pipelineBindPoint); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineBindPoint = %s", indentString.c_str(), "pipelineBindPoint:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indentString.c_str(), "pipeline:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipeline);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetViewport(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkViewport>& pViewports)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstViewport // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstViewport:", firstViewport); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t viewportCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "viewportCount:", viewportCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkViewport* pViewports // ARG
    if (pViewports.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkViewport* = NULL", indentString.c_str(), "pViewports:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkViewport* = ", indentString.c_str(), "pViewports:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pViewports.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkViewport>(&tmpString, 2, 1, "VkViewport",
            pViewports.GetMetaStructPointer(), "pViewports", viewportCount, false, pViewports.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetScissor(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pScissors)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstScissor // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstScissor:", firstScissor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t scissorCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "scissorCount:", scissorCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRect2D* pScissors // ARG
    if (pScissors.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = NULL", indentString.c_str(), "pScissors:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = ", indentString.c_str(), "pScissors:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pScissors.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkRect2D>(&tmpString, 2, 1, "VkRect2D",
            pScissors.GetMetaStructPointer(), "pScissors", scissorCount, false, pScissors.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetLineWidth(
    format::HandleId                            commandBuffer,
    float                                       lineWidth)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetLineWidth(commandBuffer, lineWidth)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // float lineWidth // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indentString.c_str(), "lineWidth:", lineWidth); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDepthBias(
    format::HandleId                            commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // float depthBiasConstantFactor // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indentString.c_str(), "depthBiasConstantFactor:", depthBiasConstantFactor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // float depthBiasClamp // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indentString.c_str(), "depthBiasClamp:", depthBiasClamp); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // float depthBiasSlopeFactor // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indentString.c_str(), "depthBiasSlopeFactor:", depthBiasSlopeFactor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetBlendConstants(
    format::HandleId                            commandBuffer,
    const PointerDecoder<float>&                blendConstants)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetBlendConstants(commandBuffer, blendConstants)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const float blendConstants // ARG
    tmpString = "";
    ValueToStringStruct vinfo_blendConstants = {false, false, false, nullptr};
    arrayToString<const float*>(&tmpString, 2, 0, "const float", blendConstants.GetPointer(), "blendConstants", 4, vinfo_blendConstants); // SFP
    fprintf(GetFile(), "%s", tmpString.c_str());
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDepthBounds(
    format::HandleId                            commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // float minDepthBounds // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indentString.c_str(), "minDepthBounds:", minDepthBounds); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // float maxDepthBounds // ARG
    fprintf(GetFile(), "%s%-32sfloat = %g", indentString.c_str(), "maxDepthBounds:", maxDepthBounds); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilCompareMask(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkStencilFaceFlags faceMask // ARG
    tmpString = "";
    flagsToString(&tmpString, faceMask, enumToString_VkStencilFaceFlagBits);
    fprintf(GetFile(), "%s%-32sVkStencilFaceFlags = %s", indentString.c_str(), "faceMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t compareMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "compareMask:", compareMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilWriteMask(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkStencilFaceFlags faceMask // ARG
    tmpString = "";
    flagsToString(&tmpString, faceMask, enumToString_VkStencilFaceFlagBits);
    fprintf(GetFile(), "%s%-32sVkStencilFaceFlags = %s", indentString.c_str(), "faceMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t writeMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "writeMask:", writeMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetStencilReference(
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetStencilReference(commandBuffer, faceMask, reference)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkStencilFaceFlags faceMask // ARG
    tmpString = "";
    flagsToString(&tmpString, faceMask, enumToString_VkStencilFaceFlagBits);
    fprintf(GetFile(), "%s%-32sVkStencilFaceFlags = %s", indentString.c_str(), "faceMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t reference // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "reference:", reference); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindDescriptorSets(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const HandlePointerDecoder<VkDescriptorSet>& pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const PointerDecoder<uint32_t>&             pDynamicOffsets)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineBindPoint pipelineBindPoint // ARG
    tmpString = "";
    enumToString_VkPipelineBindPoint(&tmpString,pipelineBindPoint); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineBindPoint = %s", indentString.c_str(), "pipelineBindPoint:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout layout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indentString.c_str(), "layout:"); // TRP
    tmpString = "";
    addrToString(&tmpString, layout);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstSet // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstSet:", firstSet); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorSetCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "descriptorSetCount:", descriptorSetCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSet* pDescriptorSets // ARG
    if (pDescriptorSets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = NULL", indentString.c_str(), "pDescriptorSets:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSet* = ", indentString.c_str(), "pDescriptorSets:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pDescriptorSets.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pDescriptorSets = {true, false, false, nullptr};
        arrayToString<const VkDescriptorSet*>(&tmpString, 1, 1, "const VkDescriptorSet*", reinterpret_cast<const VkDescriptorSet*>(pDescriptorSets.GetPointer()), "pDescriptorSets", descriptorSetCount, vinfo_pDescriptorSets); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t dynamicOffsetCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "dynamicOffsetCount:", dynamicOffsetCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const uint32_t* pDynamicOffsets // ARG
    if (pDynamicOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = NULL", indentString.c_str(), "pDynamicOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = %" PRId64 "", indentString.c_str(), "pDynamicOffsets:", static_cast<uint64_t>(*pDynamicOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindIndexBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkIndexType indexType // ARG
    tmpString = "";
    enumToString_VkIndexType(&tmpString,indexType); // EPW
    fprintf(GetFile(), "%s%-32sVkIndexType = %s", indentString.c_str(), "indexType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBindVertexBuffers(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const HandlePointerDecoder<VkBuffer>&       pBuffers,
    const PointerDecoder<VkDeviceSize>&         pOffsets)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstBinding // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstBinding:", firstBinding); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindingCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindingCount:", bindingCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pBuffers // ARG
    if (pBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indentString.c_str(), "pBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indentString.c_str(), "pBuffers:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pBuffers = {true, false, false, nullptr};
        arrayToString<const VkBuffer*>(&tmpString, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pBuffers.GetPointer()), "pBuffers", bindingCount, vinfo_pBuffers); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pOffsets // ARG
    if (pOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indentString.c_str(), "pOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indentString.c_str(), "pOffsets:", static_cast<uint64_t>(*pOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDraw(
    format::HandleId                            commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t vertexCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "vertexCount:", vertexCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t instanceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "instanceCount:", instanceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstVertex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstVertex:", firstVertex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstInstance // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstInstance:", firstInstance); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexed(
    format::HandleId                            commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t indexCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "indexCount:", indexCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t instanceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "instanceCount:", instanceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstIndex:", firstIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // int32_t vertexOffset // ARG
    fprintf(GetFile(), "%s%-32sint32_t = %d", indentString.c_str(), "vertexOffset:", vertexOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstInstance // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstInstance:", firstInstance); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t drawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "drawCount:", drawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t drawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "drawCount:", drawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatch(
    format::HandleId                            commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountX:", groupCountX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountY:", groupCountY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountZ:", groupCountZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchIndirect(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDispatchIndirect(commandBuffer, buffer, offset)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferCopy>& pRegions)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer srcBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "srcBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, srcBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "dstBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCopy* = NULL", indentString.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferCopy* = ", indentString.c_str(), "pRegions:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBufferCopy>(&tmpString, 2, 1, "VkBufferCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageCopy>& pRegions)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "srcImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, srcImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "srcImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "dstImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "dstImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCopy* = NULL", indentString.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageCopy* = ", indentString.c_str(), "pRegions:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkImageCopy>(&tmpString, 2, 1, "VkImageCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBlitImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageBlit>& pRegions,
    VkFilter                                    filter)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "srcImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, srcImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "srcImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "dstImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "dstImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageBlit* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageBlit* = NULL", indentString.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageBlit* = ", indentString.c_str(), "pRegions:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkImageBlit>(&tmpString, 2, 1, "VkImageBlit",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFilter filter // ARG
    tmpString = "";
    enumToString_VkFilter(&tmpString,filter); // EPW
    fprintf(GetFile(), "%s%-32sVkFilter = %s", indentString.c_str(), "filter:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyBufferToImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferImageCopy>& pRegions)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer srcBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "srcBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, srcBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "dstImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "dstImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferImageCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = NULL", indentString.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = ", indentString.c_str(), "pRegions:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBufferImageCopy>(&tmpString, 2, 1, "VkBufferImageCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyImageToBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkBufferImageCopy>& pRegions)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "srcImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, srcImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "srcImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "dstBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferImageCopy* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = NULL", indentString.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferImageCopy* = ", indentString.c_str(), "pRegions:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBufferImageCopy>(&tmpString, 2, 1, "VkBufferImageCopy",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdUpdateBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "dstBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dataSize // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst void* = NULL", indentString.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst void* = ", indentString.c_str(), "pData:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdFillBuffer(
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "dstBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize size // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "size:", size); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t data // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "data:", data); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearColorImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    const StructPointerDecoder<Decoded_VkClearColorValue>& pColor,
    uint32_t                                    rangeCount,
    const StructPointerDecoder<Decoded_VkImageSubresourceRange>& pRanges)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout imageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,imageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "imageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearColorValue* pColor // ARG
    if (pColor.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearColorValue* = NULL", indentString.c_str(), "pColor:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearColorValue* = ", indentString.c_str(), "pColor:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pColor.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkClearColorValue>(&tmpString, *pColor.GetMetaStructPointer(), 2, pColor.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t rangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "rangeCount:", rangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSubresourceRange* pRanges // ARG
    if (pRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = NULL", indentString.c_str(), "pRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = ", indentString.c_str(), "pRanges:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRanges.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkImageSubresourceRange>(&tmpString, 2, 1, "VkImageSubresourceRange",
            pRanges.GetMetaStructPointer(), "pRanges", rangeCount, false, pRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearDepthStencilImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    const StructPointerDecoder<Decoded_VkClearDepthStencilValue>& pDepthStencil,
    uint32_t                                    rangeCount,
    const StructPointerDecoder<Decoded_VkImageSubresourceRange>& pRanges)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout imageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,imageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "imageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearDepthStencilValue* pDepthStencil // ARG
    if (pDepthStencil.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearDepthStencilValue* = NULL", indentString.c_str(), "pDepthStencil:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearDepthStencilValue* = ", indentString.c_str(), "pDepthStencil:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pDepthStencil.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkClearDepthStencilValue>(&tmpString, *pDepthStencil.GetMetaStructPointer(), 2, pDepthStencil.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t rangeCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "rangeCount:", rangeCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSubresourceRange* pRanges // ARG
    if (pRanges.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = NULL", indentString.c_str(), "pRanges:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSubresourceRange* = ", indentString.c_str(), "pRanges:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRanges.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkImageSubresourceRange>(&tmpString, 2, 1, "VkImageSubresourceRange",
            pRanges.GetMetaStructPointer(), "pRanges", rangeCount, false, pRanges.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdClearAttachments(
    format::HandleId                            commandBuffer,
    uint32_t                                    attachmentCount,
    const StructPointerDecoder<Decoded_VkClearAttachment>& pAttachments,
    uint32_t                                    rectCount,
    const StructPointerDecoder<Decoded_VkClearRect>& pRects)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t attachmentCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "attachmentCount:", attachmentCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearAttachment* pAttachments // ARG
    if (pAttachments.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearAttachment* = NULL", indentString.c_str(), "pAttachments:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearAttachment* = ", indentString.c_str(), "pAttachments:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pAttachments.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkClearAttachment>(&tmpString, 2, 1, "VkClearAttachment",
            pAttachments.GetMetaStructPointer(), "pAttachments", attachmentCount, false, pAttachments.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t rectCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "rectCount:", rectCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkClearRect* pRects // ARG
    if (pRects.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkClearRect* = NULL", indentString.c_str(), "pRects:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkClearRect* = ", indentString.c_str(), "pRects:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRects.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkClearRect>(&tmpString, 2, 1, "VkClearRect",
            pRects.GetMetaStructPointer(), "pRects", rectCount, false, pRects.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResolveImage(
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const StructPointerDecoder<Decoded_VkImageResolve>& pRegions)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage srcImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "srcImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, srcImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout srcImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,srcImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "srcImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImage dstImage // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "dstImage:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstImage);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout dstImageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,dstImageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "dstImageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t regionCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "regionCount:", regionCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageResolve* pRegions // ARG
    if (pRegions.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageResolve* = NULL", indentString.c_str(), "pRegions:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageResolve* = ", indentString.c_str(), "pRegions:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRegions.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkImageResolve>(&tmpString, 2, 1, "VkImageResolve",
            pRegions.GetMetaStructPointer(), "pRegions", regionCount, false, pRegions.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetEvent(
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetEvent(commandBuffer, event, stageMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indentString.c_str(), "event:"); // TRP
    tmpString = "";
    addrToString(&tmpString, event);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags stageMask // ARG
    tmpString = "";
    flagsToString(&tmpString, stageMask, enumToString_VkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indentString.c_str(), "stageMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResetEvent(
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdResetEvent(commandBuffer, event, stageMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkEvent event // ARG
    fprintf(GetFile(), "%s%-32sVkEvent = ", indentString.c_str(), "event:"); // TRP
    tmpString = "";
    addrToString(&tmpString, event);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags stageMask // ARG
    tmpString = "";
    flagsToString(&tmpString, stageMask, enumToString_VkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indentString.c_str(), "stageMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWaitEvents(
    format::HandleId                            commandBuffer,
    uint32_t                                    eventCount,
    const HandlePointerDecoder<VkEvent>&        pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const StructPointerDecoder<Decoded_VkMemoryBarrier>& pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkBufferMemoryBarrier>& pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkImageMemoryBarrier>& pImageMemoryBarriers)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t eventCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "eventCount:", eventCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkEvent* pEvents // ARG
    if (pEvents.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkEvent* = NULL", indentString.c_str(), "pEvents:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkEvent* = ", indentString.c_str(), "pEvents:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pEvents.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pEvents = {true, false, false, nullptr};
        arrayToString<const VkEvent*>(&tmpString, 1, 1, "const VkEvent*", reinterpret_cast<const VkEvent*>(pEvents.GetPointer()), "pEvents", eventCount, vinfo_pEvents); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags srcStageMask // ARG
    tmpString = "";
    flagsToString(&tmpString, srcStageMask, enumToString_VkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indentString.c_str(), "srcStageMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags dstStageMask // ARG
    tmpString = "";
    flagsToString(&tmpString, dstStageMask, enumToString_VkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indentString.c_str(), "dstStageMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "memoryBarrierCount:", memoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryBarrier* pMemoryBarriers // ARG
    if (pMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = NULL", indentString.c_str(), "pMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = ", indentString.c_str(), "pMemoryBarriers:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkMemoryBarrier>(&tmpString, 2, 1, "VkMemoryBarrier",
            pMemoryBarriers.GetMetaStructPointer(), "pMemoryBarriers", memoryBarrierCount, false, pMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bufferMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bufferMemoryBarrierCount:", bufferMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryBarrier* pBufferMemoryBarriers // ARG
    if (pBufferMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = NULL", indentString.c_str(), "pBufferMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = ", indentString.c_str(), "pBufferMemoryBarriers:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBufferMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBufferMemoryBarrier>(&tmpString, 2, 1, "VkBufferMemoryBarrier",
            pBufferMemoryBarriers.GetMetaStructPointer(), "pBufferMemoryBarriers", bufferMemoryBarrierCount, false, pBufferMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t imageMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "imageMemoryBarrierCount:", imageMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryBarrier* pImageMemoryBarriers // ARG
    if (pImageMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = NULL", indentString.c_str(), "pImageMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = ", indentString.c_str(), "pImageMemoryBarriers:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pImageMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkImageMemoryBarrier>(&tmpString, 2, 1, "VkImageMemoryBarrier",
            pImageMemoryBarriers.GetMetaStructPointer(), "pImageMemoryBarriers", imageMemoryBarrierCount, false, pImageMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdPipelineBarrier(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const StructPointerDecoder<Decoded_VkMemoryBarrier>& pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkBufferMemoryBarrier>& pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const StructPointerDecoder<Decoded_VkImageMemoryBarrier>& pImageMemoryBarriers)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags srcStageMask // ARG
    tmpString = "";
    flagsToString(&tmpString, srcStageMask, enumToString_VkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indentString.c_str(), "srcStageMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlags dstStageMask // ARG
    tmpString = "";
    flagsToString(&tmpString, dstStageMask, enumToString_VkPipelineStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlags = %s", indentString.c_str(), "dstStageMask:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDependencyFlags dependencyFlags // ARG
    tmpString = "";
    flagsToString(&tmpString, dependencyFlags, enumToString_VkDependencyFlagBits);
    fprintf(GetFile(), "%s%-32sVkDependencyFlags = %s", indentString.c_str(), "dependencyFlags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t memoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "memoryBarrierCount:", memoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryBarrier* pMemoryBarriers // ARG
    if (pMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = NULL", indentString.c_str(), "pMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryBarrier* = ", indentString.c_str(), "pMemoryBarriers:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkMemoryBarrier>(&tmpString, 2, 1, "VkMemoryBarrier",
            pMemoryBarriers.GetMetaStructPointer(), "pMemoryBarriers", memoryBarrierCount, false, pMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bufferMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bufferMemoryBarrierCount:", bufferMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryBarrier* pBufferMemoryBarriers // ARG
    if (pBufferMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = NULL", indentString.c_str(), "pBufferMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryBarrier* = ", indentString.c_str(), "pBufferMemoryBarriers:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBufferMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBufferMemoryBarrier>(&tmpString, 2, 1, "VkBufferMemoryBarrier",
            pBufferMemoryBarriers.GetMetaStructPointer(), "pBufferMemoryBarriers", bufferMemoryBarrierCount, false, pBufferMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t imageMemoryBarrierCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "imageMemoryBarrierCount:", imageMemoryBarrierCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryBarrier* pImageMemoryBarriers // ARG
    if (pImageMemoryBarriers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = NULL", indentString.c_str(), "pImageMemoryBarriers:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryBarrier* = ", indentString.c_str(), "pImageMemoryBarriers:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pImageMemoryBarriers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkImageMemoryBarrier>(&tmpString, 2, 1, "VkImageMemoryBarrier",
            pImageMemoryBarriers.GetMetaStructPointer(), "pImageMemoryBarriers", imageMemoryBarrierCount, false, pImageMemoryBarriers.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginQuery(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBeginQuery(commandBuffer, queryPool, query, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryControlFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkQueryControlFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryControlFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndQuery(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdEndQuery(commandBuffer, queryPool, query)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdResetQueryPool(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWriteTimestamp(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlagBits pipelineStage // ARG
    tmpString = "";
    enumToString_VkPipelineStageFlagBits(&tmpString,pipelineStage); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlagBits = %s", indentString.c_str(), "pipelineStage:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyQueryPoolResults(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "dstBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize stride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryResultFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkQueryResultFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryResultFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdPushConstants(
    format::HandleId                            commandBuffer,
    format::HandleId                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const PointerDecoder<uint8_t>&              pValues)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout layout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indentString.c_str(), "layout:"); // TRP
    tmpString = "";
    addrToString(&tmpString, layout);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderStageFlags stageFlags // ARG
    tmpString = "";
    flagsToString(&tmpString, stageFlags, enumToString_VkShaderStageFlagBits);
    fprintf(GetFile(), "%s%-32sVkShaderStageFlags = %s", indentString.c_str(), "stageFlags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t offset // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t size // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "size:", size); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const void* pValues // ARG
    if (pValues.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst void* = NULL", indentString.c_str(), "pValues:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst void* = ", indentString.c_str(), "pValues:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pValues.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginRenderPass(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkRenderPassBeginInfo>& pRenderPassBegin,
    VkSubpassContents                           contents)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassBeginInfo* pRenderPassBegin // ARG
    if (pRenderPassBegin.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = NULL", indentString.c_str(), "pRenderPassBegin:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = ", indentString.c_str(), "pRenderPassBegin:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pRenderPassBegin.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkRenderPassBeginInfo>(&tmpString, *pRenderPassBegin.GetMetaStructPointer(), 2, pRenderPassBegin.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSubpassContents contents // ARG
    tmpString = "";
    enumToString_VkSubpassContents(&tmpString,contents); // EPW
    fprintf(GetFile(), "%s%-32sVkSubpassContents = %s", indentString.c_str(), "contents:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdNextSubpass(
    format::HandleId                            commandBuffer,
    VkSubpassContents                           contents)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdNextSubpass(commandBuffer, contents)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSubpassContents contents // ARG
    tmpString = "";
    enumToString_VkSubpassContents(&tmpString,contents); // EPW
    fprintf(GetFile(), "%s%-32sVkSubpassContents = %s", indentString.c_str(), "contents:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndRenderPass(
    format::HandleId                            commandBuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdEndRenderPass(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdExecuteCommands(
    format::HandleId                            commandBuffer,
    uint32_t                                    commandBufferCount,
    const HandlePointerDecoder<VkCommandBuffer>& pCommandBuffers)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t commandBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "commandBufferCount:", commandBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCommandBuffer* pCommandBuffers // ARG
    if (pCommandBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = NULL", indentString.c_str(), "pCommandBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCommandBuffer* = ", indentString.c_str(), "pCommandBuffers:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pCommandBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pCommandBuffers = {true, false, false, nullptr};
        arrayToString<const VkCommandBuffer*>(&tmpString, 1, 1, "const VkCommandBuffer*", reinterpret_cast<const VkCommandBuffer*>(pCommandBuffers.GetPointer()), "pCommandBuffers", commandBufferCount, vinfo_pCommandBuffers); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkSamplerYcbcrRange(std::string* rString, uint32_t enumValueInt32)
{
    VkSamplerYcbcrRange enumValue = static_cast<VkSamplerYcbcrRange>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SAMPLER_YCBCR_RANGE_ITU_NARROW:
            *rString += std::string("VK_SAMPLER_YCBCR_RANGE_ITU_NARROW");
            return;
        case VK_SAMPLER_YCBCR_RANGE_ITU_FULL:
            *rString += std::string("VK_SAMPLER_YCBCR_RANGE_ITU_FULL");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkTessellationDomainOrigin(std::string* rString, uint32_t enumValueInt32)
{
    VkTessellationDomainOrigin enumValue = static_cast<VkTessellationDomainOrigin>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT:
            *rString += std::string("VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT");
            return;
        case VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT:
            *rString += std::string("VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPeerMemoryFeatureFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkPeerMemoryFeatureFlagBits enumValue = static_cast<VkPeerMemoryFeatureFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PEER_MEMORY_FEATURE_COPY_DST_BIT:
            *rString += std::string("VK_PEER_MEMORY_FEATURE_COPY_DST_BIT");
            return;
        case VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT:
            *rString += std::string("VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT");
            return;
        case VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT:
            *rString += std::string("VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT");
            return;
        case VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT:
            *rString += std::string("VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSamplerYcbcrModelConversion(std::string* rString, uint32_t enumValueInt32)
{
    VkSamplerYcbcrModelConversion enumValue = static_cast<VkSamplerYcbcrModelConversion>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020:
            *rString += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY:
            *rString += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601:
            *rString += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY:
            *rString += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY");
            return;
        case VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709:
            *rString += std::string("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkChromaLocation(std::string* rString, uint32_t enumValueInt32)
{
    VkChromaLocation enumValue = static_cast<VkChromaLocation>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_CHROMA_LOCATION_MIDPOINT:
            *rString += std::string("VK_CHROMA_LOCATION_MIDPOINT");
            return;
        case VK_CHROMA_LOCATION_COSITED_EVEN:
            *rString += std::string("VK_CHROMA_LOCATION_COSITED_EVEN");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkFenceImportFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkFenceImportFlagBits enumValue = static_cast<VkFenceImportFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FENCE_IMPORT_TEMPORARY_BIT:
            *rString += std::string("VK_FENCE_IMPORT_TEMPORARY_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkExternalMemoryFeatureFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalMemoryFeatureFlagBits enumValue = static_cast<VkExternalMemoryFeatureFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSubgroupFeatureFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkSubgroupFeatureFlagBits enumValue = static_cast<VkSubgroupFeatureFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT");
            return;
        case VK_SUBGROUP_FEATURE_CLUSTERED_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_CLUSTERED_BIT");
            return;
        case VK_SUBGROUP_FEATURE_QUAD_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_QUAD_BIT");
            return;
        case VK_SUBGROUP_FEATURE_ARITHMETIC_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_ARITHMETIC_BIT");
            return;
        case VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV:
            *rString += std::string("VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV");
            return;
        case VK_SUBGROUP_FEATURE_SHUFFLE_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_SHUFFLE_BIT");
            return;
        case VK_SUBGROUP_FEATURE_BALLOT_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_BALLOT_BIT");
            return;
        case VK_SUBGROUP_FEATURE_VOTE_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_VOTE_BIT");
            return;
        case VK_SUBGROUP_FEATURE_BASIC_BIT:
            *rString += std::string("VK_SUBGROUP_FEATURE_BASIC_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPointClippingBehavior(std::string* rString, uint32_t enumValueInt32)
{
    VkPointClippingBehavior enumValue = static_cast<VkPointClippingBehavior>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY:
            *rString += std::string("VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY");
            return;
        case VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:
            *rString += std::string("VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkExternalFenceHandleTypeFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalFenceHandleTypeFlagBits enumValue = static_cast<VkExternalFenceHandleTypeFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
            *rString += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT");
            return;
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
            *rString += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT");
            return;
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
            *rString += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
            return;
        case VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:
            *rString += std::string("VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkExternalFenceFeatureFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalFenceFeatureFlagBits enumValue = static_cast<VkExternalFenceFeatureFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT:
            *rString += std::string("VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT");
            return;
        case VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT:
            *rString += std::string("VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkExternalSemaphoreFeatureFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalSemaphoreFeatureFlagBits enumValue = static_cast<VkExternalSemaphoreFeatureFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT:
            *rString += std::string("VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT:
            *rString += std::string("VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkExternalMemoryHandleTypeFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalMemoryHandleTypeFlagBits enumValue = static_cast<VkExternalMemoryHandleTypeFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDescriptorUpdateTemplateType(std::string* rString, uint32_t enumValueInt32)
{
    VkDescriptorUpdateTemplateType enumValue = static_cast<VkDescriptorUpdateTemplateType>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET:
            *rString += std::string("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET");
            return;
        case VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR:
            *rString += std::string("VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSemaphoreImportFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkSemaphoreImportFlagBits enumValue = static_cast<VkSemaphoreImportFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SEMAPHORE_IMPORT_TEMPORARY_BIT:
            *rString += std::string("VK_SEMAPHORE_IMPORT_TEMPORARY_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkExternalSemaphoreHandleTypeFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalSemaphoreHandleTypeFlagBits enumValue = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
            *rString += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
            *rString += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
            *rString += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:
            *rString += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT");
            return;
        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT:
            *rString += std::string("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkMemoryAllocateFlagBits(std::string* rString, uint32_t enumValueInt32)
{
    VkMemoryAllocateFlagBits enumValue = static_cast<VkMemoryAllocateFlagBits>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT:
            *rString += std::string("VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPhysicalDeviceSubgroupProperties>(std::string* rString, const Decoded_VkPhysicalDeviceSubgroupProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindBufferMemoryInfo>(std::string* rString, const Decoded_VkBindBufferMemoryInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindImageMemoryInfo>(std::string* rString, const Decoded_VkBindImageMemoryInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDevice16BitStorageFeatures>(std::string* rString, const Decoded_VkPhysicalDevice16BitStorageFeatures &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryDedicatedRequirements>(std::string* rString, const Decoded_VkMemoryDedicatedRequirements &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryDedicatedAllocateInfo>(std::string* rString, const Decoded_VkMemoryDedicatedAllocateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryAllocateFlagsInfo>(std::string* rString, const Decoded_VkMemoryAllocateFlagsInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupRenderPassBeginInfo>(std::string* rString, const Decoded_VkDeviceGroupRenderPassBeginInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupCommandBufferBeginInfo>(std::string* rString, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupSubmitInfo>(std::string* rString, const Decoded_VkDeviceGroupSubmitInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupBindSparseInfo>(std::string* rString, const Decoded_VkDeviceGroupBindSparseInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindBufferMemoryDeviceGroupInfo>(std::string* rString, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindImageMemoryDeviceGroupInfo>(std::string* rString, const Decoded_VkBindImageMemoryDeviceGroupInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceGroupProperties>(std::string* rString, const Decoded_VkPhysicalDeviceGroupProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupDeviceCreateInfo>(std::string* rString, const Decoded_VkDeviceGroupDeviceCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferMemoryRequirementsInfo2>(std::string* rString, const Decoded_VkBufferMemoryRequirementsInfo2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageMemoryRequirementsInfo2>(std::string* rString, const Decoded_VkImageMemoryRequirementsInfo2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(std::string* rString, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryRequirements2>(std::string* rString, const Decoded_VkMemoryRequirements2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseImageMemoryRequirements2>(std::string* rString, const Decoded_VkSparseImageMemoryRequirements2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceFeatures2>(std::string* rString, const Decoded_VkPhysicalDeviceFeatures2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceProperties2>(std::string* rString, const Decoded_VkPhysicalDeviceProperties2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkFormatProperties2>(std::string* rString, const Decoded_VkFormatProperties2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageFormatProperties2>(std::string* rString, const Decoded_VkImageFormatProperties2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(std::string* rString, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkQueueFamilyProperties2>(std::string* rString, const Decoded_VkQueueFamilyProperties2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(std::string* rString, const Decoded_VkPhysicalDeviceMemoryProperties2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSparseImageFormatProperties2>(std::string* rString, const Decoded_VkSparseImageFormatProperties2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(std::string* rString, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDevicePointClippingProperties>(std::string* rString, const Decoded_VkPhysicalDevicePointClippingProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkInputAttachmentAspectReference>(std::string* rString, const Decoded_VkInputAttachmentAspectReference &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>(std::string* rString, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageViewUsageCreateInfo>(std::string* rString, const Decoded_VkImageViewUsageCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>(std::string* rString, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRenderPassMultiviewCreateInfo>(std::string* rString, const Decoded_VkRenderPassMultiviewCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceMultiviewFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceMultiviewFeatures &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceMultiviewProperties>(std::string* rString, const Decoded_VkPhysicalDeviceMultiviewProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceVariablePointersFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceProtectedMemoryProperties>(std::string* rString, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceQueueInfo2>(std::string* rString, const Decoded_VkDeviceQueueInfo2 &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkProtectedSubmitInfo>(std::string* rString, const Decoded_VkProtectedSubmitInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(std::string* rString, const Decoded_VkSamplerYcbcrConversionCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSamplerYcbcrConversionInfo>(std::string* rString, const Decoded_VkSamplerYcbcrConversionInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindImagePlaneMemoryInfo>(std::string* rString, const Decoded_VkBindImagePlaneMemoryInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImagePlaneMemoryRequirementsInfo>(std::string* rString, const Decoded_VkImagePlaneMemoryRequirementsInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSamplerYcbcrConversionImageFormatProperties>(std::string* rString, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorUpdateTemplateEntry>(std::string* rString, const Decoded_VkDescriptorUpdateTemplateEntry &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(std::string* rString, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalMemoryProperties>(std::string* rString, const Decoded_VkExternalMemoryProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceExternalImageFormatInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalImageFormatProperties>(std::string* rString, const Decoded_VkExternalImageFormatProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalBufferInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalBufferProperties>(std::string* rString, const Decoded_VkExternalBufferProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceIDProperties>(std::string* rString, const Decoded_VkPhysicalDeviceIDProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalMemoryImageCreateInfo>(std::string* rString, const Decoded_VkExternalMemoryImageCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalMemoryBufferCreateInfo>(std::string* rString, const Decoded_VkExternalMemoryBufferCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExportMemoryAllocateInfo>(std::string* rString, const Decoded_VkExportMemoryAllocateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalFenceInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalFenceProperties>(std::string* rString, const Decoded_VkExternalFenceProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExportFenceCreateInfo>(std::string* rString, const Decoded_VkExportFenceCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExportSemaphoreCreateInfo>(std::string* rString, const Decoded_VkExportSemaphoreCreateInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalSemaphoreProperties>(std::string* rString, const Decoded_VkExternalSemaphoreProperties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceMaintenance3Properties>(std::string* rString, const Decoded_VkPhysicalDeviceMaintenance3Properties &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDescriptorSetLayoutSupport>(std::string* rString, const Decoded_VkDescriptorSetLayoutSupport &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceSubgroupProperties>(std::string* rString, const Decoded_VkPhysicalDeviceSubgroupProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceSubgroupProperties *pStruct = (const VkPhysicalDeviceSubgroupProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t subgroupSize // SMB
    indentSpaces(rString, indent);
    *rString += "subgroupSize:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subgroupSize);
    *rString += "\n"; // GDS

    // VkShaderStageFlags supportedStages // SMB
    indentSpaces(rString, indent);
    *rString += "supportedStages:                ";
    *rString += "VkShaderStageFlags = "; // TEQ
    flagsToString(rString, pStruct->supportedStages, enumToString_VkShaderStageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSubgroupFeatureFlags supportedOperations // SMB
    indentSpaces(rString, indent);
    *rString += "supportedOperations:            ";
    *rString += "VkSubgroupFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->supportedOperations, enumToString_VkSubgroupFeatureFlagBits); // URW
    *rString += "\n"; // GDS

    // VkBool32 quadOperationsInAllStages // SMB
    indentSpaces(rString, indent);
    *rString += "quadOperationsInAllStages:      ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->quadOperationsInAllStages);
}

template <>
void structureToString<Decoded_VkBindBufferMemoryInfo>(std::string* rString, const Decoded_VkBindBufferMemoryInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindBufferMemoryInfo *pStruct = (const VkBindBufferMemoryInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    indentSpaces(rString, indent);
    *rString += "memoryOffset:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->memoryOffset);
}

template <>
void structureToString<Decoded_VkBindImageMemoryInfo>(std::string* rString, const Decoded_VkBindImageMemoryInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindImageMemoryInfo *pStruct = (const VkBindImageMemoryInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    indentSpaces(rString, indent);
    *rString += "memoryOffset:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->memoryOffset);
}

template <>
void structureToString<Decoded_VkPhysicalDevice16BitStorageFeatures>(std::string* rString, const Decoded_VkPhysicalDevice16BitStorageFeatures &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDevice16BitStorageFeatures *pStruct = (const VkPhysicalDevice16BitStorageFeatures *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 storageBuffer16BitAccess // SMB
    indentSpaces(rString, indent);
    *rString += "storageBuffer16BitAccess:       ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->storageBuffer16BitAccess);
    *rString += "\n"; // GDS

    // VkBool32 uniformAndStorageBuffer16BitAccess // SMB
    indentSpaces(rString, indent);
    *rString += "uniformAndStorageBuffer16BitAccess: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->uniformAndStorageBuffer16BitAccess);
    *rString += "\n"; // GDS

    // VkBool32 storagePushConstant16 // SMB
    indentSpaces(rString, indent);
    *rString += "storagePushConstant16:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->storagePushConstant16);
    *rString += "\n"; // GDS

    // VkBool32 storageInputOutput16 // SMB
    indentSpaces(rString, indent);
    *rString += "storageInputOutput16:           ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->storageInputOutput16);
}

template <>
void structureToString<Decoded_VkMemoryDedicatedRequirements>(std::string* rString, const Decoded_VkMemoryDedicatedRequirements &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryDedicatedRequirements *pStruct = (const VkMemoryDedicatedRequirements *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 prefersDedicatedAllocation // SMB
    indentSpaces(rString, indent);
    *rString += "prefersDedicatedAllocation:     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->prefersDedicatedAllocation);
    *rString += "\n"; // GDS

    // VkBool32 requiresDedicatedAllocation // SMB
    indentSpaces(rString, indent);
    *rString += "requiresDedicatedAllocation:    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->requiresDedicatedAllocation);
}

template <>
void structureToString<Decoded_VkMemoryDedicatedAllocateInfo>(std::string* rString, const Decoded_VkMemoryDedicatedAllocateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryDedicatedAllocateInfo *pStruct = (const VkMemoryDedicatedAllocateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
}

template <>
void structureToString<Decoded_VkMemoryAllocateFlagsInfo>(std::string* rString, const Decoded_VkMemoryAllocateFlagsInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryAllocateFlagsInfo *pStruct = (const VkMemoryAllocateFlagsInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkMemoryAllocateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkMemoryAllocateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkMemoryAllocateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t deviceMask // SMB
    indentSpaces(rString, indent);
    *rString += "deviceMask:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceMask);
}

template <>
void structureToString<Decoded_VkDeviceGroupRenderPassBeginInfo>(std::string* rString, const Decoded_VkDeviceGroupRenderPassBeginInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupRenderPassBeginInfo *pStruct = (const VkDeviceGroupRenderPassBeginInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t deviceMask // SMB
    indentSpaces(rString, indent);
    *rString += "deviceMask:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceMask);
    *rString += "\n"; // GDS

    // uint32_t deviceRenderAreaCount // SMB
    indentSpaces(rString, indent);
    *rString += "deviceRenderAreaCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceRenderAreaCount);
    *rString += "\n"; // GDS

    // const VkRect2D* pDeviceRenderAreas // SMB
    indentSpaces(rString, indent);
    *rString += "pDeviceRenderAreas:             ";
    *rString += "const VkRect2D* = "; // TEQ
    if (pStruct->pDeviceRenderAreas == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDeviceRenderAreas->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkRect2D>(rString, indent+1, 1, "VkRect2D", pStructIn.pDeviceRenderAreas->GetMetaStructPointer(), "pDeviceRenderAreas", pStruct->deviceRenderAreaCount, false, pStructIn.pDeviceRenderAreas->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkDeviceGroupCommandBufferBeginInfo>(std::string* rString, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupCommandBufferBeginInfo *pStruct = (const VkDeviceGroupCommandBufferBeginInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t deviceMask // SMB
    indentSpaces(rString, indent);
    *rString += "deviceMask:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceMask);
}

template <>
void structureToString<Decoded_VkDeviceGroupSubmitInfo>(std::string* rString, const Decoded_VkDeviceGroupSubmitInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupSubmitInfo *pStruct = (const VkDeviceGroupSubmitInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "waitSemaphoreCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->waitSemaphoreCount);
    *rString += "\n"; // GDS

    // const uint32_t* pWaitSemaphoreDeviceIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pWaitSemaphoreDeviceIndices:    ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pWaitSemaphoreDeviceIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pWaitSemaphoreDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphoreDeviceIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pWaitSemaphoreDeviceIndices.GetPointer()), "pWaitSemaphoreDeviceIndices", pStruct->waitSemaphoreCount,  vinfo_pWaitSemaphoreDeviceIndices);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t commandBufferCount // SMB
    indentSpaces(rString, indent);
    *rString += "commandBufferCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->commandBufferCount);
    *rString += "\n"; // GDS

    // const uint32_t* pCommandBufferDeviceMasks // SMB
    indentSpaces(rString, indent);
    *rString += "pCommandBufferDeviceMasks:      ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pCommandBufferDeviceMasks == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCommandBufferDeviceMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCommandBufferDeviceMasks = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pCommandBufferDeviceMasks.GetPointer()), "pCommandBufferDeviceMasks", pStruct->commandBufferCount,  vinfo_pCommandBufferDeviceMasks);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t signalSemaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "signalSemaphoreCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->signalSemaphoreCount);
    *rString += "\n"; // GDS

    // const uint32_t* pSignalSemaphoreDeviceIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pSignalSemaphoreDeviceIndices:  ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pSignalSemaphoreDeviceIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSignalSemaphoreDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphoreDeviceIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pSignalSemaphoreDeviceIndices.GetPointer()), "pSignalSemaphoreDeviceIndices", pStruct->signalSemaphoreCount,  vinfo_pSignalSemaphoreDeviceIndices);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkDeviceGroupBindSparseInfo>(std::string* rString, const Decoded_VkDeviceGroupBindSparseInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupBindSparseInfo *pStruct = (const VkDeviceGroupBindSparseInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t resourceDeviceIndex // SMB
    indentSpaces(rString, indent);
    *rString += "resourceDeviceIndex:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->resourceDeviceIndex);
    *rString += "\n"; // GDS

    // uint32_t memoryDeviceIndex // SMB
    indentSpaces(rString, indent);
    *rString += "memoryDeviceIndex:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryDeviceIndex);
}

template <>
void structureToString<Decoded_VkBindBufferMemoryDeviceGroupInfo>(std::string* rString, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindBufferMemoryDeviceGroupInfo *pStruct = (const VkBindBufferMemoryDeviceGroupInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t deviceIndexCount // SMB
    indentSpaces(rString, indent);
    *rString += "deviceIndexCount:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceIndexCount);
    *rString += "\n"; // GDS

    // const uint32_t* pDeviceIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pDeviceIndices:                 ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pDeviceIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pDeviceIndices.GetPointer()), "pDeviceIndices", pStruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkBindImageMemoryDeviceGroupInfo>(std::string* rString, const Decoded_VkBindImageMemoryDeviceGroupInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindImageMemoryDeviceGroupInfo *pStruct = (const VkBindImageMemoryDeviceGroupInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t deviceIndexCount // SMB
    indentSpaces(rString, indent);
    *rString += "deviceIndexCount:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceIndexCount);
    *rString += "\n"; // GDS

    // const uint32_t* pDeviceIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pDeviceIndices:                 ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pDeviceIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pDeviceIndices.GetPointer()), "pDeviceIndices", pStruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t splitInstanceBindRegionCount // SMB
    indentSpaces(rString, indent);
    *rString += "splitInstanceBindRegionCount:   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->splitInstanceBindRegionCount);
    *rString += "\n"; // GDS

    // const VkRect2D* pSplitInstanceBindRegions // SMB
    indentSpaces(rString, indent);
    *rString += "pSplitInstanceBindRegions:      ";
    *rString += "const VkRect2D* = "; // TEQ
    if (pStruct->pSplitInstanceBindRegions == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSplitInstanceBindRegions->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkRect2D>(rString, indent+1, 1, "VkRect2D", pStructIn.pSplitInstanceBindRegions->GetMetaStructPointer(), "pSplitInstanceBindRegions", pStruct->splitInstanceBindRegionCount, false, pStructIn.pSplitInstanceBindRegions->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPhysicalDeviceGroupProperties>(std::string* rString, const Decoded_VkPhysicalDeviceGroupProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceGroupProperties *pStruct = (const VkPhysicalDeviceGroupProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t physicalDeviceCount // SMB
    indentSpaces(rString, indent);
    *rString += "physicalDeviceCount:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->physicalDeviceCount);
    *rString += "\n"; // GDS

    // VkPhysicalDevice physicalDevices // SMB
    indentSpaces(rString, indent);
    *rString += "physicalDevices:                ";
    *rString += "VkPhysicalDevice[";
    unsignedDecimalToString(rString, pStruct->physicalDeviceCount);
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceGroupProperties, physicalDevices)); // IYY
    ValueToStringStruct vinfo_physicalDevices = {true, false, false, nullptr};
    arrayToString<VkPhysicalDevice*>(rString, indent, 0, "VkPhysicalDevice", const_cast<VkPhysicalDevice*>(pStruct->physicalDevices), "physicalDevices", pStruct->physicalDeviceCount, vinfo_physicalDevices); // JPA
    *rString += "\n"; // GDS

    // VkBool32 subsetAllocation // SMB
    indentSpaces(rString, indent);
    *rString += "subsetAllocation:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->subsetAllocation);
}

template <>
void structureToString<Decoded_VkDeviceGroupDeviceCreateInfo>(std::string* rString, const Decoded_VkDeviceGroupDeviceCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupDeviceCreateInfo *pStruct = (const VkDeviceGroupDeviceCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t physicalDeviceCount // SMB
    indentSpaces(rString, indent);
    *rString += "physicalDeviceCount:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->physicalDeviceCount);
    *rString += "\n"; // GDS

    // const VkPhysicalDevice* pPhysicalDevices // SMB
    indentSpaces(rString, indent);
    *rString += "pPhysicalDevices:               ";
    *rString += "const VkPhysicalDevice* = "; // TEQ
    if (pStruct->pPhysicalDevices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pPhysicalDevices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pPhysicalDevices = {true, false, false, nullptr};
        arrayToString<const VkPhysicalDevice*>(rString, indent, 1, "const VkPhysicalDevice*", reinterpret_cast<const VkPhysicalDevice*>(pStructIn.pPhysicalDevices.GetPointer()), "pPhysicalDevices", pStruct->physicalDeviceCount,  vinfo_pPhysicalDevices);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkBufferMemoryRequirementsInfo2>(std::string* rString, const Decoded_VkBufferMemoryRequirementsInfo2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferMemoryRequirementsInfo2 *pStruct = (const VkBufferMemoryRequirementsInfo2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
}

template <>
void structureToString<Decoded_VkImageMemoryRequirementsInfo2>(std::string* rString, const Decoded_VkImageMemoryRequirementsInfo2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageMemoryRequirementsInfo2 *pStruct = (const VkImageMemoryRequirementsInfo2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
}

template <>
void structureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(std::string* rString, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageSparseMemoryRequirementsInfo2 *pStruct = (const VkImageSparseMemoryRequirementsInfo2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImage image // SMB
    indentSpaces(rString, indent);
    *rString += "image:                          ";
    *rString += "VkImage = "; // TEQ
    addrToString(rString, pStructIn.image); // PAQ  
}

template <>
void structureToString<Decoded_VkMemoryRequirements2>(std::string* rString, const Decoded_VkMemoryRequirements2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryRequirements2 *pStruct = (const VkMemoryRequirements2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkMemoryRequirements memoryRequirements // SMB
    indentSpaces(rString, indent);
    *rString += "memoryRequirements:             ";
    *rString += "VkMemoryRequirements = "; // TEQ
    structureToString<Decoded_VkMemoryRequirements>(rString, *pStructIn.memoryRequirements, indent+1,  baseAddr + offsetof(VkMemoryRequirements2, memoryRequirements)); // AZJ
}

template <>
void structureToString<Decoded_VkSparseImageMemoryRequirements2>(std::string* rString, const Decoded_VkSparseImageMemoryRequirements2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseImageMemoryRequirements2 *pStruct = (const VkSparseImageMemoryRequirements2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSparseImageMemoryRequirements memoryRequirements // SMB
    indentSpaces(rString, indent);
    *rString += "memoryRequirements:             ";
    *rString += "VkSparseImageMemoryRequirements = "; // TEQ
    structureToString<Decoded_VkSparseImageMemoryRequirements>(rString, *pStructIn.memoryRequirements, indent+1,  baseAddr + offsetof(VkSparseImageMemoryRequirements2, memoryRequirements)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceFeatures2>(std::string* rString, const Decoded_VkPhysicalDeviceFeatures2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceFeatures2 *pStruct = (const VkPhysicalDeviceFeatures2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPhysicalDeviceFeatures features // SMB
    indentSpaces(rString, indent);
    *rString += "features:                       ";
    *rString += "VkPhysicalDeviceFeatures = "; // TEQ
    structureToString<Decoded_VkPhysicalDeviceFeatures>(rString, *pStructIn.features, indent+1,  baseAddr + offsetof(VkPhysicalDeviceFeatures2, features)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceProperties2>(std::string* rString, const Decoded_VkPhysicalDeviceProperties2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceProperties2 *pStruct = (const VkPhysicalDeviceProperties2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPhysicalDeviceProperties properties // SMB
    indentSpaces(rString, indent);
    *rString += "properties:                     ";
    *rString += "VkPhysicalDeviceProperties = "; // TEQ
    structureToString<Decoded_VkPhysicalDeviceProperties>(rString, *pStructIn.properties, indent+1,  baseAddr + offsetof(VkPhysicalDeviceProperties2, properties)); // AZJ
}

template <>
void structureToString<Decoded_VkFormatProperties2>(std::string* rString, const Decoded_VkFormatProperties2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkFormatProperties2 *pStruct = (const VkFormatProperties2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFormatProperties formatProperties // SMB
    indentSpaces(rString, indent);
    *rString += "formatProperties:               ";
    *rString += "VkFormatProperties = "; // TEQ
    structureToString<Decoded_VkFormatProperties>(rString, *pStructIn.formatProperties, indent+1,  baseAddr + offsetof(VkFormatProperties2, formatProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkImageFormatProperties2>(std::string* rString, const Decoded_VkImageFormatProperties2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageFormatProperties2 *pStruct = (const VkImageFormatProperties2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageFormatProperties imageFormatProperties // SMB
    indentSpaces(rString, indent);
    *rString += "imageFormatProperties:          ";
    *rString += "VkImageFormatProperties = "; // TEQ
    structureToString<Decoded_VkImageFormatProperties>(rString, *pStructIn.imageFormatProperties, indent+1,  baseAddr + offsetof(VkImageFormatProperties2, imageFormatProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(std::string* rString, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceImageFormatInfo2 *pStruct = (const VkPhysicalDeviceImageFormatInfo2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageType type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkImageType = "; // TEQ
    enumToString_VkImageType(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageTiling tiling // SMB
    indentSpaces(rString, indent);
    *rString += "tiling:                         ";
    *rString += "VkImageTiling = "; // TEQ
    enumToString_VkImageTiling(rString, pStruct->tiling);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->tiling);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    indentSpaces(rString, indent);
    *rString += "usage:                          ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->usage, enumToString_VkImageUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkImageCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkImageCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkImageCreateFlagBits); // URW
}

template <>
void structureToString<Decoded_VkQueueFamilyProperties2>(std::string* rString, const Decoded_VkQueueFamilyProperties2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkQueueFamilyProperties2 *pStruct = (const VkQueueFamilyProperties2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkQueueFamilyProperties queueFamilyProperties // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyProperties:          ";
    *rString += "VkQueueFamilyProperties = "; // TEQ
    structureToString<Decoded_VkQueueFamilyProperties>(rString, *pStructIn.queueFamilyProperties, indent+1,  baseAddr + offsetof(VkQueueFamilyProperties2, queueFamilyProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(std::string* rString, const Decoded_VkPhysicalDeviceMemoryProperties2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceMemoryProperties2 *pStruct = (const VkPhysicalDeviceMemoryProperties2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPhysicalDeviceMemoryProperties memoryProperties // SMB
    indentSpaces(rString, indent);
    *rString += "memoryProperties:               ";
    *rString += "VkPhysicalDeviceMemoryProperties = "; // TEQ
    structureToString<Decoded_VkPhysicalDeviceMemoryProperties>(rString, *pStructIn.memoryProperties, indent+1,  baseAddr + offsetof(VkPhysicalDeviceMemoryProperties2, memoryProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkSparseImageFormatProperties2>(std::string* rString, const Decoded_VkSparseImageFormatProperties2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSparseImageFormatProperties2 *pStruct = (const VkSparseImageFormatProperties2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSparseImageFormatProperties properties // SMB
    indentSpaces(rString, indent);
    *rString += "properties:                     ";
    *rString += "VkSparseImageFormatProperties = "; // TEQ
    structureToString<Decoded_VkSparseImageFormatProperties>(rString, *pStructIn.properties, indent+1,  baseAddr + offsetof(VkSparseImageFormatProperties2, properties)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(std::string* rString, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceSparseImageFormatInfo2 *pStruct = (const VkPhysicalDeviceSparseImageFormatInfo2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageType type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkImageType = "; // TEQ
    enumToString_VkImageType(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    indentSpaces(rString, indent);
    *rString += "samples:                        ";
    *rString += "VkSampleCountFlagBits = "; // TEQ
    enumToString_VkSampleCountFlagBits(rString, pStruct->samples);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->samples);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    indentSpaces(rString, indent);
    *rString += "usage:                          ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->usage, enumToString_VkImageUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkImageTiling tiling // SMB
    indentSpaces(rString, indent);
    *rString += "tiling:                         ";
    *rString += "VkImageTiling = "; // TEQ
    enumToString_VkImageTiling(rString, pStruct->tiling);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->tiling);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkPhysicalDevicePointClippingProperties>(std::string* rString, const Decoded_VkPhysicalDevicePointClippingProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDevicePointClippingProperties *pStruct = (const VkPhysicalDevicePointClippingProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPointClippingBehavior pointClippingBehavior // SMB
    indentSpaces(rString, indent);
    *rString += "pointClippingBehavior:          ";
    *rString += "VkPointClippingBehavior = "; // TEQ
    enumToString_VkPointClippingBehavior(rString, pStruct->pointClippingBehavior);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->pointClippingBehavior);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkInputAttachmentAspectReference>(std::string* rString, const Decoded_VkInputAttachmentAspectReference &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkInputAttachmentAspectReference *pStruct = (const VkInputAttachmentAspectReference *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t subpass // SMB
    indentSpaces(rString, indent);
    *rString += "subpass:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subpass);
    *rString += "\n"; // GDS

    // uint32_t inputAttachmentIndex // SMB
    indentSpaces(rString, indent);
    *rString += "inputAttachmentIndex:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->inputAttachmentIndex);
    *rString += "\n"; // GDS

    // VkImageAspectFlags aspectMask // SMB
    indentSpaces(rString, indent);
    *rString += "aspectMask:                     ";
    *rString += "VkImageAspectFlags = "; // TEQ
    flagsToString(rString, pStruct->aspectMask, enumToString_VkImageAspectFlagBits); // URW
}

template <>
void structureToString<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>(std::string* rString, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRenderPassInputAttachmentAspectCreateInfo *pStruct = (const VkRenderPassInputAttachmentAspectCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t aspectReferenceCount // SMB
    indentSpaces(rString, indent);
    *rString += "aspectReferenceCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->aspectReferenceCount);
    *rString += "\n"; // GDS

    // const VkInputAttachmentAspectReference* pAspectReferences // SMB
    indentSpaces(rString, indent);
    *rString += "pAspectReferences:              ";
    *rString += "const VkInputAttachmentAspectReference* = "; // TEQ
    if (pStruct->pAspectReferences == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAspectReferences->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkInputAttachmentAspectReference>(rString, indent+1, 1, "VkInputAttachmentAspectReference", pStructIn.pAspectReferences->GetMetaStructPointer(), "pAspectReferences", pStruct->aspectReferenceCount, false, pStructIn.pAspectReferences->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkImageViewUsageCreateInfo>(std::string* rString, const Decoded_VkImageViewUsageCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageViewUsageCreateInfo *pStruct = (const VkImageViewUsageCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageUsageFlags usage // SMB
    indentSpaces(rString, indent);
    *rString += "usage:                          ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->usage, enumToString_VkImageUsageFlagBits); // URW
}

template <>
void structureToString<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>(std::string* rString, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineTessellationDomainOriginStateCreateInfo *pStruct = (const VkPipelineTessellationDomainOriginStateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkTessellationDomainOrigin domainOrigin // SMB
    indentSpaces(rString, indent);
    *rString += "domainOrigin:                   ";
    *rString += "VkTessellationDomainOrigin = "; // TEQ
    enumToString_VkTessellationDomainOrigin(rString, pStruct->domainOrigin);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->domainOrigin);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkRenderPassMultiviewCreateInfo>(std::string* rString, const Decoded_VkRenderPassMultiviewCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRenderPassMultiviewCreateInfo *pStruct = (const VkRenderPassMultiviewCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t subpassCount // SMB
    indentSpaces(rString, indent);
    *rString += "subpassCount:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subpassCount);
    *rString += "\n"; // GDS

    // const uint32_t* pViewMasks // SMB
    indentSpaces(rString, indent);
    *rString += "pViewMasks:                     ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pViewMasks == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pViewMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pViewMasks = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pViewMasks.GetPointer()), "pViewMasks", pStruct->subpassCount,  vinfo_pViewMasks);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t dependencyCount // SMB
    indentSpaces(rString, indent);
    *rString += "dependencyCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dependencyCount);
    *rString += "\n"; // GDS

    // const int32_t* pViewOffsets // SMB
    indentSpaces(rString, indent);
    *rString += "pViewOffsets:                   ";
    *rString += "const int32_t* = "; // TEQ
    if (pStruct->pViewOffsets == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pViewOffsets.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pViewOffsets = {false, false, false, nullptr};
        arrayToString<const int32_t*>(rString, indent, 1, "const int32_t*", reinterpret_cast<const int32_t*>(pStructIn.pViewOffsets.GetPointer()), "pViewOffsets", pStruct->dependencyCount,  vinfo_pViewOffsets);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t correlationMaskCount // SMB
    indentSpaces(rString, indent);
    *rString += "correlationMaskCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->correlationMaskCount);
    *rString += "\n"; // GDS

    // const uint32_t* pCorrelationMasks // SMB
    indentSpaces(rString, indent);
    *rString += "pCorrelationMasks:              ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pCorrelationMasks == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCorrelationMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCorrelationMasks = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pCorrelationMasks.GetPointer()), "pCorrelationMasks", pStruct->correlationMaskCount,  vinfo_pCorrelationMasks);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkPhysicalDeviceMultiviewFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceMultiviewFeatures &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceMultiviewFeatures *pStruct = (const VkPhysicalDeviceMultiviewFeatures *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 multiview // SMB
    indentSpaces(rString, indent);
    *rString += "multiview:                      ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->multiview);
    *rString += "\n"; // GDS

    // VkBool32 multiviewGeometryShader // SMB
    indentSpaces(rString, indent);
    *rString += "multiviewGeometryShader:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->multiviewGeometryShader);
    *rString += "\n"; // GDS

    // VkBool32 multiviewTessellationShader // SMB
    indentSpaces(rString, indent);
    *rString += "multiviewTessellationShader:    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->multiviewTessellationShader);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceMultiviewProperties>(std::string* rString, const Decoded_VkPhysicalDeviceMultiviewProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceMultiviewProperties *pStruct = (const VkPhysicalDeviceMultiviewProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t maxMultiviewViewCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxMultiviewViewCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMultiviewViewCount);
    *rString += "\n"; // GDS

    // uint32_t maxMultiviewInstanceIndex // SMB
    indentSpaces(rString, indent);
    *rString += "maxMultiviewInstanceIndex:      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMultiviewInstanceIndex);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceVariablePointersFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceVariablePointersFeatures *pStruct = (const VkPhysicalDeviceVariablePointersFeatures *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 variablePointersStorageBuffer // SMB
    indentSpaces(rString, indent);
    *rString += "variablePointersStorageBuffer:  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->variablePointersStorageBuffer);
    *rString += "\n"; // GDS

    // VkBool32 variablePointers // SMB
    indentSpaces(rString, indent);
    *rString += "variablePointers:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->variablePointers);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceProtectedMemoryFeatures *pStruct = (const VkPhysicalDeviceProtectedMemoryFeatures *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 protectedMemory // SMB
    indentSpaces(rString, indent);
    *rString += "protectedMemory:                ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->protectedMemory);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceProtectedMemoryProperties>(std::string* rString, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceProtectedMemoryProperties *pStruct = (const VkPhysicalDeviceProtectedMemoryProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 protectedNoFault // SMB
    indentSpaces(rString, indent);
    *rString += "protectedNoFault:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->protectedNoFault);
}

template <>
void structureToString<Decoded_VkDeviceQueueInfo2>(std::string* rString, const Decoded_VkDeviceQueueInfo2 &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceQueueInfo2 *pStruct = (const VkDeviceQueueInfo2 *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceQueueCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDeviceQueueCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkDeviceQueueCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t queueFamilyIndex // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyIndex:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueFamilyIndex);
    *rString += "\n"; // GDS

    // uint32_t queueIndex // SMB
    indentSpaces(rString, indent);
    *rString += "queueIndex:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueIndex);
}

template <>
void structureToString<Decoded_VkProtectedSubmitInfo>(std::string* rString, const Decoded_VkProtectedSubmitInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkProtectedSubmitInfo *pStruct = (const VkProtectedSubmitInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 protectedSubmit // SMB
    indentSpaces(rString, indent);
    *rString += "protectedSubmit:                ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->protectedSubmit);
}

template <>
void structureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(std::string* rString, const Decoded_VkSamplerYcbcrConversionCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSamplerYcbcrConversionCreateInfo *pStruct = (const VkSamplerYcbcrConversionCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSamplerYcbcrModelConversion ycbcrModel // SMB
    indentSpaces(rString, indent);
    *rString += "ycbcrModel:                     ";
    *rString += "VkSamplerYcbcrModelConversion = "; // TEQ
    enumToString_VkSamplerYcbcrModelConversion(rString, pStruct->ycbcrModel);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->ycbcrModel);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSamplerYcbcrRange ycbcrRange // SMB
    indentSpaces(rString, indent);
    *rString += "ycbcrRange:                     ";
    *rString += "VkSamplerYcbcrRange = "; // TEQ
    enumToString_VkSamplerYcbcrRange(rString, pStruct->ycbcrRange);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->ycbcrRange);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentMapping components // SMB
    indentSpaces(rString, indent);
    *rString += "components:                     ";
    *rString += "VkComponentMapping = "; // TEQ
    structureToString<Decoded_VkComponentMapping>(rString, *pStructIn.components, indent+1,  baseAddr + offsetof(VkSamplerYcbcrConversionCreateInfo, components)); // AZJ
    *rString += "\n"; // GDS

    // VkChromaLocation xChromaOffset // SMB
    indentSpaces(rString, indent);
    *rString += "xChromaOffset:                  ";
    *rString += "VkChromaLocation = "; // TEQ
    enumToString_VkChromaLocation(rString, pStruct->xChromaOffset);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->xChromaOffset);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkChromaLocation yChromaOffset // SMB
    indentSpaces(rString, indent);
    *rString += "yChromaOffset:                  ";
    *rString += "VkChromaLocation = "; // TEQ
    enumToString_VkChromaLocation(rString, pStruct->yChromaOffset);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->yChromaOffset);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkFilter chromaFilter // SMB
    indentSpaces(rString, indent);
    *rString += "chromaFilter:                   ";
    *rString += "VkFilter = "; // TEQ
    enumToString_VkFilter(rString, pStruct->chromaFilter);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->chromaFilter);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 forceExplicitReconstruction // SMB
    indentSpaces(rString, indent);
    *rString += "forceExplicitReconstruction:    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->forceExplicitReconstruction);
}

template <>
void structureToString<Decoded_VkSamplerYcbcrConversionInfo>(std::string* rString, const Decoded_VkSamplerYcbcrConversionInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSamplerYcbcrConversionInfo *pStruct = (const VkSamplerYcbcrConversionInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSamplerYcbcrConversion conversion // SMB
    indentSpaces(rString, indent);
    *rString += "conversion:                     ";
    *rString += "VkSamplerYcbcrConversion = "; // TEQ
    addrToString(rString, pStructIn.conversion); // PAQ  
}

template <>
void structureToString<Decoded_VkBindImagePlaneMemoryInfo>(std::string* rString, const Decoded_VkBindImagePlaneMemoryInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindImagePlaneMemoryInfo *pStruct = (const VkBindImagePlaneMemoryInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageAspectFlagBits planeAspect // SMB
    indentSpaces(rString, indent);
    *rString += "planeAspect:                    ";
    *rString += "VkImageAspectFlagBits = "; // TEQ
    enumToString_VkImageAspectFlagBits(rString, pStruct->planeAspect);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->planeAspect);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkImagePlaneMemoryRequirementsInfo>(std::string* rString, const Decoded_VkImagePlaneMemoryRequirementsInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImagePlaneMemoryRequirementsInfo *pStruct = (const VkImagePlaneMemoryRequirementsInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageAspectFlagBits planeAspect // SMB
    indentSpaces(rString, indent);
    *rString += "planeAspect:                    ";
    *rString += "VkImageAspectFlagBits = "; // TEQ
    enumToString_VkImageAspectFlagBits(rString, pStruct->planeAspect);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->planeAspect);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures *pStruct = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 samplerYcbcrConversion // SMB
    indentSpaces(rString, indent);
    *rString += "samplerYcbcrConversion:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->samplerYcbcrConversion);
}

template <>
void structureToString<Decoded_VkSamplerYcbcrConversionImageFormatProperties>(std::string* rString, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSamplerYcbcrConversionImageFormatProperties *pStruct = (const VkSamplerYcbcrConversionImageFormatProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t combinedImageSamplerDescriptorCount // SMB
    indentSpaces(rString, indent);
    *rString += "combinedImageSamplerDescriptorCount: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->combinedImageSamplerDescriptorCount);
}

template <>
void structureToString<Decoded_VkDescriptorUpdateTemplateEntry>(std::string* rString, const Decoded_VkDescriptorUpdateTemplateEntry &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorUpdateTemplateEntry *pStruct = (const VkDescriptorUpdateTemplateEntry *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t dstBinding // SMB
    indentSpaces(rString, indent);
    *rString += "dstBinding:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstBinding);
    *rString += "\n"; // GDS

    // uint32_t dstArrayElement // SMB
    indentSpaces(rString, indent);
    *rString += "dstArrayElement:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstArrayElement);
    *rString += "\n"; // GDS

    // uint32_t descriptorCount // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->descriptorCount);
    *rString += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorType:                 ";
    *rString += "VkDescriptorType = "; // TEQ
    enumToString_VkDescriptorType(rString, pStruct->descriptorType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->descriptorType);
    *rString += ")";
    *rString += "\n"; // GDS

    // size_t offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // size_t stride // SMB
    indentSpaces(rString, indent);
    *rString += "stride:                         ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->stride);
}

template <>
void structureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(std::string* rString, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorUpdateTemplateCreateInfo *pStruct = (const VkDescriptorUpdateTemplateCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDescriptorUpdateTemplateCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDescriptorUpdateTemplateCreateFlags = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t descriptorUpdateEntryCount // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorUpdateEntryCount:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->descriptorUpdateEntryCount);
    *rString += "\n"; // GDS

    // const VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries // SMB
    indentSpaces(rString, indent);
    *rString += "pDescriptorUpdateEntries:       ";
    *rString += "const VkDescriptorUpdateTemplateEntry* = "; // TEQ
    if (pStruct->pDescriptorUpdateEntries == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDescriptorUpdateEntries->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDescriptorUpdateTemplateEntry>(rString, indent+1, 1, "VkDescriptorUpdateTemplateEntry", pStructIn.pDescriptorUpdateEntries->GetMetaStructPointer(), "pDescriptorUpdateEntries", pStruct->descriptorUpdateEntryCount, false, pStructIn.pDescriptorUpdateEntries->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // VkDescriptorUpdateTemplateType templateType // SMB
    indentSpaces(rString, indent);
    *rString += "templateType:                   ";
    *rString += "VkDescriptorUpdateTemplateType = "; // TEQ
    enumToString_VkDescriptorUpdateTemplateType(rString, pStruct->templateType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->templateType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkDescriptorSetLayout descriptorSetLayout // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorSetLayout:            ";
    *rString += "VkDescriptorSetLayout = "; // TEQ
    addrToString(rString, pStructIn.descriptorSetLayout); // PAQ  
    *rString += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineBindPoint:              ";
    *rString += "VkPipelineBindPoint = "; // TEQ
    enumToString_VkPipelineBindPoint(rString, pStruct->pipelineBindPoint);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->pipelineBindPoint);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkPipelineLayout pipelineLayout // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineLayout:                 ";
    *rString += "VkPipelineLayout = "; // TEQ
    addrToString(rString, pStructIn.pipelineLayout); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t set // SMB
    indentSpaces(rString, indent);
    *rString += "set:                            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->set);
}

template <>
void structureToString<Decoded_VkExternalMemoryProperties>(std::string* rString, const Decoded_VkExternalMemoryProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalMemoryProperties *pStruct = (const VkExternalMemoryProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkExternalMemoryFeatureFlags externalMemoryFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "externalMemoryFeatures:         ";
    *rString += "VkExternalMemoryFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->externalMemoryFeatures, enumToString_VkExternalMemoryFeatureFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "exportFromImportedHandleTypes:  ";
    *rString += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->exportFromImportedHandleTypes, enumToString_VkExternalMemoryHandleTypeFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags compatibleHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "compatibleHandleTypes:          ";
    *rString += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->compatibleHandleTypes, enumToString_VkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void structureToString<Decoded_VkPhysicalDeviceExternalImageFormatInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceExternalImageFormatInfo *pStruct = (const VkPhysicalDeviceExternalImageFormatInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkExternalImageFormatProperties>(std::string* rString, const Decoded_VkExternalImageFormatProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalImageFormatProperties *pStruct = (const VkExternalImageFormatProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryProperties externalMemoryProperties // SMB
    indentSpaces(rString, indent);
    *rString += "externalMemoryProperties:       ";
    *rString += "VkExternalMemoryProperties = "; // TEQ
    structureToString<Decoded_VkExternalMemoryProperties>(rString, *pStructIn.externalMemoryProperties, indent+1,  baseAddr + offsetof(VkExternalImageFormatProperties, externalMemoryProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalBufferInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceExternalBufferInfo *pStruct = (const VkPhysicalDeviceExternalBufferInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBufferCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkBufferCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkBufferCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // VkBufferUsageFlags usage // SMB
    indentSpaces(rString, indent);
    *rString += "usage:                          ";
    *rString += "VkBufferUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->usage, enumToString_VkBufferUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkExternalBufferProperties>(std::string* rString, const Decoded_VkExternalBufferProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalBufferProperties *pStruct = (const VkExternalBufferProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryProperties externalMemoryProperties // SMB
    indentSpaces(rString, indent);
    *rString += "externalMemoryProperties:       ";
    *rString += "VkExternalMemoryProperties = "; // TEQ
    structureToString<Decoded_VkExternalMemoryProperties>(rString, *pStructIn.externalMemoryProperties, indent+1,  baseAddr + offsetof(VkExternalBufferProperties, externalMemoryProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceIDProperties>(std::string* rString, const Decoded_VkPhysicalDeviceIDProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceIDProperties *pStruct = (const VkPhysicalDeviceIDProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint8_t deviceUUID // SMB
    indentSpaces(rString, indent);
    *rString += "deviceUUID:                     ";
    *rString += "uint8_t[";
    *rString += "VK_UUID_SIZE";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceIDProperties, deviceUUID)); // IYY
    ValueToStringStruct vinfo_deviceUUID = {false, false, false, nullptr};
    arrayToString<uint8_t*>(rString, indent, 0, "uint8_t", const_cast<uint8_t*>(pStruct->deviceUUID), "deviceUUID", VK_UUID_SIZE, vinfo_deviceUUID); // JPA
    *rString += "\n"; // GDS

    // uint8_t driverUUID // SMB
    indentSpaces(rString, indent);
    *rString += "driverUUID:                     ";
    *rString += "uint8_t[";
    *rString += "VK_UUID_SIZE";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceIDProperties, driverUUID)); // IYY
    ValueToStringStruct vinfo_driverUUID = {false, false, false, nullptr};
    arrayToString<uint8_t*>(rString, indent, 0, "uint8_t", const_cast<uint8_t*>(pStruct->driverUUID), "driverUUID", VK_UUID_SIZE, vinfo_driverUUID); // JPA
    *rString += "\n"; // GDS

    // uint8_t deviceLUID // SMB
    indentSpaces(rString, indent);
    *rString += "deviceLUID:                     ";
    *rString += "uint8_t[";
    *rString += "VK_LUID_SIZE";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceIDProperties, deviceLUID)); // IYY
    ValueToStringStruct vinfo_deviceLUID = {false, false, false, nullptr};
    arrayToString<uint8_t*>(rString, indent, 0, "uint8_t", const_cast<uint8_t*>(pStruct->deviceLUID), "deviceLUID", VK_LUID_SIZE, vinfo_deviceLUID); // JPA
    *rString += "\n"; // GDS

    // uint32_t deviceNodeMask // SMB
    indentSpaces(rString, indent);
    *rString += "deviceNodeMask:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceNodeMask);
    *rString += "\n"; // GDS

    // VkBool32 deviceLUIDValid // SMB
    indentSpaces(rString, indent);
    *rString += "deviceLUIDValid:                ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->deviceLUIDValid);
}

template <>
void structureToString<Decoded_VkExternalMemoryImageCreateInfo>(std::string* rString, const Decoded_VkExternalMemoryImageCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalMemoryImageCreateInfo *pStruct = (const VkExternalMemoryImageCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags handleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "handleTypes:                    ";
    *rString += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->handleTypes, enumToString_VkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void structureToString<Decoded_VkExternalMemoryBufferCreateInfo>(std::string* rString, const Decoded_VkExternalMemoryBufferCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalMemoryBufferCreateInfo *pStruct = (const VkExternalMemoryBufferCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags handleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "handleTypes:                    ";
    *rString += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->handleTypes, enumToString_VkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void structureToString<Decoded_VkExportMemoryAllocateInfo>(std::string* rString, const Decoded_VkExportMemoryAllocateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExportMemoryAllocateInfo *pStruct = (const VkExportMemoryAllocateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlags handleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "handleTypes:                    ";
    *rString += "VkExternalMemoryHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->handleTypes, enumToString_VkExternalMemoryHandleTypeFlagBits); // URW
}

template <>
void structureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalFenceInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceExternalFenceInfo *pStruct = (const VkPhysicalDeviceExternalFenceInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalFenceHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkExternalFenceProperties>(std::string* rString, const Decoded_VkExternalFenceProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalFenceProperties *pStruct = (const VkExternalFenceProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "exportFromImportedHandleTypes:  ";
    *rString += "VkExternalFenceHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->exportFromImportedHandleTypes, enumToString_VkExternalFenceHandleTypeFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlags compatibleHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "compatibleHandleTypes:          ";
    *rString += "VkExternalFenceHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->compatibleHandleTypes, enumToString_VkExternalFenceHandleTypeFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalFenceFeatureFlags externalFenceFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "externalFenceFeatures:          ";
    *rString += "VkExternalFenceFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->externalFenceFeatures, enumToString_VkExternalFenceFeatureFlagBits); // URW
}

template <>
void structureToString<Decoded_VkExportFenceCreateInfo>(std::string* rString, const Decoded_VkExportFenceCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExportFenceCreateInfo *pStruct = (const VkExportFenceCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlags handleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "handleTypes:                    ";
    *rString += "VkExternalFenceHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->handleTypes, enumToString_VkExternalFenceHandleTypeFlagBits); // URW
}

template <>
void structureToString<Decoded_VkExportSemaphoreCreateInfo>(std::string* rString, const Decoded_VkExportSemaphoreCreateInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExportSemaphoreCreateInfo *pStruct = (const VkExportSemaphoreCreateInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlags handleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "handleTypes:                    ";
    *rString += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->handleTypes, enumToString_VkExternalSemaphoreHandleTypeFlagBits); // URW
}

template <>
void structureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(std::string* rString, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceExternalSemaphoreInfo *pStruct = (const VkPhysicalDeviceExternalSemaphoreInfo *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalSemaphoreHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkExternalSemaphoreProperties>(std::string* rString, const Decoded_VkExternalSemaphoreProperties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalSemaphoreProperties *pStruct = (const VkExternalSemaphoreProperties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "exportFromImportedHandleTypes:  ";
    *rString += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->exportFromImportedHandleTypes, enumToString_VkExternalSemaphoreHandleTypeFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "compatibleHandleTypes:          ";
    *rString += "VkExternalSemaphoreHandleTypeFlags = "; // TEQ
    flagsToString(rString, pStruct->compatibleHandleTypes, enumToString_VkExternalSemaphoreHandleTypeFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "externalSemaphoreFeatures:      ";
    *rString += "VkExternalSemaphoreFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->externalSemaphoreFeatures, enumToString_VkExternalSemaphoreFeatureFlagBits); // URW
}

template <>
void structureToString<Decoded_VkPhysicalDeviceMaintenance3Properties>(std::string* rString, const Decoded_VkPhysicalDeviceMaintenance3Properties &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceMaintenance3Properties *pStruct = (const VkPhysicalDeviceMaintenance3Properties *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t maxPerSetDescriptors // SMB
    indentSpaces(rString, indent);
    *rString += "maxPerSetDescriptors:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPerSetDescriptors);
    *rString += "\n"; // GDS

    // VkDeviceSize maxMemoryAllocationSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxMemoryAllocationSize:        ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->maxMemoryAllocationSize);
}

template <>
void structureToString<Decoded_VkDescriptorSetLayoutSupport>(std::string* rString, const Decoded_VkDescriptorSetLayoutSupport &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDescriptorSetLayoutSupport *pStruct = (const VkDescriptorSetLayoutSupport *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 supported // SMB
    indentSpaces(rString, indent);
    *rString += "supported:                      ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->supported);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>(std::string* rString, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceShaderDrawParametersFeatures *pStruct = (const VkPhysicalDeviceShaderDrawParametersFeatures *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 shaderDrawParameters // SMB
    indentSpaces(rString, indent);
    *rString += "shaderDrawParameters:           ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shaderDrawParameters);
}

void VulkanAsciiConsumer::Process_vkBindBufferMemory2(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>& pBindInfos)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBindBufferMemory2(device, bindInfoCount, pBindInfos)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindBufferMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = NULL", indentString.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = ", indentString.c_str(), "pBindInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBindBufferMemoryInfo>(&tmpString, 2, 1, "VkBindBufferMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory2(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindImageMemoryInfo>& pBindInfos)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBindImageMemory2(device, bindInfoCount, pBindInfos)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindImageMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = NULL", indentString.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = ", indentString.c_str(), "pBindInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBindImageMemoryInfo>(&tmpString, 2, 1, "VkBindImageMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupPeerMemoryFeatures(
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    const PointerDecoder<VkPeerMemoryFeatureFlags>& pPeerMemoryFeatures)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t heapIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "heapIndex:", heapIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t localDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "localDeviceIndex:", localDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t remoteDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "remoteDeviceIndex:", remoteDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPeerMemoryFeatureFlags* pPeerMemoryFeatures // ARG
    tmpString = "";
    flagsToString(&tmpString, *pPeerMemoryFeatures.GetPointer(), enumToString_VkPeerMemoryFeatureFlagBits);
    fprintf(GetFile(), "%s%-32sVkPeerMemoryFeatureFlags* = %s", indentString.c_str(), "pPeerMemoryFeatures:", tmpString.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDeviceMask(
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetDeviceMask(commandBuffer, deviceMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t deviceMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "deviceMask:", deviceMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchBase(
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "baseGroupX:", baseGroupX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "baseGroupY:", baseGroupY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "baseGroupZ:", baseGroupZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountX:", groupCountX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountY:", groupCountY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountZ:", groupCountZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDeviceGroups(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceGroupCount,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>& pPhysicalDeviceGroupProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPhysicalDeviceGroupCount // ARG
    if (pPhysicalDeviceGroupCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPhysicalDeviceGroupCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPhysicalDeviceGroupCount:", static_cast<uint64_t>(*pPhysicalDeviceGroupCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties // ARG
    if (pPhysicalDeviceGroupProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = NULL", indentString.c_str(), "pPhysicalDeviceGroupProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = ", indentString.c_str(), "pPhysicalDeviceGroupProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pPhysicalDeviceGroupProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkPhysicalDeviceGroupProperties>(&tmpString, 2, 1, "VkPhysicalDeviceGroupProperties",
            pPhysicalDeviceGroupProperties.GetMetaStructPointer(), "pPhysicalDeviceGroupProperties", *pPhysicalDeviceGroupCount.GetPointer(), false, pPhysicalDeviceGroupProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageMemoryRequirementsInfo2>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indentString.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indentString.c_str(), "pMemoryRequirements:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryRequirements2>(&tmpString, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkBufferMemoryRequirementsInfo2>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indentString.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indentString.c_str(), "pMemoryRequirements:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryRequirements2>(&tmpString, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>& pInfo,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>& pSparseMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSparseMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSparseMemoryRequirementCount // ARG
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pSparseMemoryRequirementCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pSparseMemoryRequirementCount:", static_cast<uint64_t>(*pSparseMemoryRequirementCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageMemoryRequirements2* pSparseMemoryRequirements // ARG
    if (pSparseMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = NULL", indentString.c_str(), "pSparseMemoryRequirements:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = ", indentString.c_str(), "pSparseMemoryRequirements:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pSparseMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements2>(&tmpString, 2, 1, "VkSparseImageMemoryRequirements2",
            pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>& pFeatures)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceFeatures2* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = NULL", indentString.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = ", indentString.c_str(), "pFeatures:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceFeatures2>(&tmpString, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties2(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = NULL", indentString.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = ", indentString.c_str(), "pProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceProperties2>(&tmpString, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties2(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties2>& pFormatProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmpString = "";
    enumToString_VkFormat(&tmpString,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indentString.c_str(), "format:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkFormatProperties2* pFormatProperties // ARG
    if (pFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = NULL", indentString.c_str(), "pFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = ", indentString.c_str(), "pFormatProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkFormatProperties2>(&tmpString, *pFormatProperties.GetMetaStructPointer(), 2, pFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>& pImageFormatInfo,
    const StructPointerDecoder<Decoded_VkImageFormatProperties2>& pImageFormatProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo // ARG
    if (pImageFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = NULL", indentString.c_str(), "pImageFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = ", indentString.c_str(), "pImageFormatInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImageFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(&tmpString, *pImageFormatInfo.GetMetaStructPointer(), 2, pImageFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImageFormatProperties2* pImageFormatProperties // ARG
    if (pImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = NULL", indentString.c_str(), "pImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = ", indentString.c_str(), "pImageFormatProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageFormatProperties2>(&tmpString, *pImageFormatProperties.GetMetaStructPointer(), 2, pImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties2>& pQueueFamilyProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pQueueFamilyPropertyCount // ARG
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pQueueFamilyPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pQueueFamilyPropertyCount:", static_cast<uint64_t>(*pQueueFamilyPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueueFamilyProperties2* pQueueFamilyProperties // ARG
    if (pQueueFamilyProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = NULL", indentString.c_str(), "pQueueFamilyProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = ", indentString.c_str(), "pQueueFamilyProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pQueueFamilyProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkQueueFamilyProperties2>(&tmpString, 2, 1, "VkQueueFamilyProperties2",
            pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>& pMemoryProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceMemoryProperties2* pMemoryProperties // ARG
    if (pMemoryProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = NULL", indentString.c_str(), "pMemoryProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = ", indentString.c_str(), "pMemoryProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(&tmpString, *pMemoryProperties.GetMetaStructPointer(), 2, pMemoryProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>& pFormatInfo,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo // ARG
    if (pFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = NULL", indentString.c_str(), "pFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = ", indentString.c_str(), "pFormatInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(&tmpString, *pFormatInfo.GetMetaStructPointer(), 2, pFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageFormatProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSparseImageFormatProperties2>(&tmpString, 2, 1, "VkSparseImageFormatProperties2",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkTrimCommandPool(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkTrimCommandPool(device, commandPool, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indentString.c_str(), "commandPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPoolTrimFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPoolTrimFlags = %d", indentString.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceQueue2(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceQueueInfo2>& pQueueInfo,
    const HandlePointerDecoder<VkQueue>&        pQueue)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceQueue2(device, pQueueInfo, pQueue)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceQueueInfo2* pQueueInfo // ARG
    if (pQueueInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceQueueInfo2* = NULL", indentString.c_str(), "pQueueInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceQueueInfo2* = ", indentString.c_str(), "pQueueInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pQueueInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDeviceQueueInfo2>(&tmpString, *pQueueInfo.GetMetaStructPointer(), 2, pQueueInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueue* pQueue // ARG
    if (pQueue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = NULL", indentString.c_str(), "pQueue:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueue* = ", indentString.c_str(), "pQueue:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pQueue.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateSamplerYcbcrConversion(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSamplerYcbcrConversion>& pYcbcrConversion)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSamplerYcbcrConversionCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion* pYcbcrConversion // ARG
    if (pYcbcrConversion.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = NULL", indentString.c_str(), "pYcbcrConversion:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = ", indentString.c_str(), "pYcbcrConversion:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pYcbcrConversion.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySamplerYcbcrConversion(
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion ycbcrConversion // ARG
    fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion = ", indentString.c_str(), "ycbcrConversion:"); // TRP
    tmpString = "";
    addrToString(&tmpString, ycbcrConversion);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDescriptorUpdateTemplate(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorUpdateTemplate>& pDescriptorUpdateTemplate)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate // ARG
    if (pDescriptorUpdateTemplate.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = NULL", indentString.c_str(), "pDescriptorUpdateTemplate:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = ", indentString.c_str(), "pDescriptorUpdateTemplate:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pDescriptorUpdateTemplate.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorUpdateTemplate(
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate descriptorUpdateTemplate // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate = ", indentString.c_str(), "descriptorUpdateTemplate:"); // TRP
    tmpString = "";
    addrToString(&tmpString, descriptorUpdateTemplate);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalBufferProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>& pExternalBufferInfo,
    const StructPointerDecoder<Decoded_VkExternalBufferProperties>& pExternalBufferProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo // ARG
    if (pExternalBufferInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = NULL", indentString.c_str(), "pExternalBufferInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = ", indentString.c_str(), "pExternalBufferInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalBufferInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(&tmpString, *pExternalBufferInfo.GetMetaStructPointer(), 2, pExternalBufferInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalBufferProperties* pExternalBufferProperties // ARG
    if (pExternalBufferProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = NULL", indentString.c_str(), "pExternalBufferProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = ", indentString.c_str(), "pExternalBufferProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalBufferProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExternalBufferProperties>(&tmpString, *pExternalBufferProperties.GetMetaStructPointer(), 2, pExternalBufferProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalFenceProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>& pExternalFenceInfo,
    const StructPointerDecoder<Decoded_VkExternalFenceProperties>& pExternalFenceProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo // ARG
    if (pExternalFenceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = NULL", indentString.c_str(), "pExternalFenceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = ", indentString.c_str(), "pExternalFenceInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalFenceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(&tmpString, *pExternalFenceInfo.GetMetaStructPointer(), 2, pExternalFenceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalFenceProperties* pExternalFenceProperties // ARG
    if (pExternalFenceProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = NULL", indentString.c_str(), "pExternalFenceProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = ", indentString.c_str(), "pExternalFenceProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalFenceProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExternalFenceProperties>(&tmpString, *pExternalFenceProperties.GetMetaStructPointer(), 2, pExternalFenceProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalSemaphoreProperties(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>& pExternalSemaphoreInfo,
    const StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>& pExternalSemaphoreProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo // ARG
    if (pExternalSemaphoreInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = NULL", indentString.c_str(), "pExternalSemaphoreInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = ", indentString.c_str(), "pExternalSemaphoreInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalSemaphoreInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(&tmpString, *pExternalSemaphoreInfo.GetMetaStructPointer(), 2, pExternalSemaphoreInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalSemaphoreProperties* pExternalSemaphoreProperties // ARG
    if (pExternalSemaphoreProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = NULL", indentString.c_str(), "pExternalSemaphoreProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = ", indentString.c_str(), "pExternalSemaphoreProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalSemaphoreProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExternalSemaphoreProperties>(&tmpString, *pExternalSemaphoreProperties.GetMetaStructPointer(), 2, pExternalSemaphoreProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDescriptorSetLayoutSupport(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>& pSupport)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayoutSupport* pSupport // ARG
    if (pSupport.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = NULL", indentString.c_str(), "pSupport:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = ", indentString.c_str(), "pSupport:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSupport.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorSetLayoutSupport>(&tmpString, *pSupport.GetMetaStructPointer(), 2, pSupport.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkCompositeAlphaFlagBitsKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkCompositeAlphaFlagBitsKHR enumValue = static_cast<VkCompositeAlphaFlagBitsKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR:
            *rString += std::string("VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR");
            return;
        case VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR:
            *rString += std::string("VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR");
            return;
        case VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR:
            *rString += std::string("VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR");
            return;
        case VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR:
            *rString += std::string("VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSurfaceTransformFlagBitsKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkSurfaceTransformFlagBitsKHR enumValue = static_cast<VkSurfaceTransformFlagBitsKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR");
            return;
        case VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR:
            *rString += std::string("VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPresentModeKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkPresentModeKHR enumValue = static_cast<VkPresentModeKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PRESENT_MODE_MAILBOX_KHR:
            *rString += std::string("VK_PRESENT_MODE_MAILBOX_KHR");
            return;
        case VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR:
            *rString += std::string("VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR");
            return;
        case VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR:
            *rString += std::string("VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR");
            return;
        case VK_PRESENT_MODE_IMMEDIATE_KHR:
            *rString += std::string("VK_PRESENT_MODE_IMMEDIATE_KHR");
            return;
        case VK_PRESENT_MODE_FIFO_RELAXED_KHR:
            *rString += std::string("VK_PRESENT_MODE_FIFO_RELAXED_KHR");
            return;
        case VK_PRESENT_MODE_FIFO_KHR:
            *rString += std::string("VK_PRESENT_MODE_FIFO_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkColorSpaceKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkColorSpaceKHR enumValue = static_cast<VkColorSpaceKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_BT2020_LINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_BT2020_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_SRGB_NONLINEAR_KHR:
            *rString += std::string("VK_COLOR_SPACE_SRGB_NONLINEAR_KHR");
            return;
        case VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_BT709_LINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_BT709_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_HDR10_HLG_EXT:
            *rString += std::string("VK_COLOR_SPACE_HDR10_HLG_EXT");
            return;
        case VK_COLOR_SPACE_HDR10_ST2084_EXT:
            *rString += std::string("VK_COLOR_SPACE_HDR10_ST2084_EXT");
            return;
        case VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_DOLBYVISION_EXT:
            *rString += std::string("VK_COLOR_SPACE_DOLBYVISION_EXT");
            return;
        case VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_PASS_THROUGH_EXT:
            *rString += std::string("VK_COLOR_SPACE_PASS_THROUGH_EXT");
            return;
        case VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT");
            return;
        case VK_COLOR_SPACE_BT709_NONLINEAR_EXT:
            *rString += std::string("VK_COLOR_SPACE_BT709_NONLINEAR_EXT");
            return;
        case VK_COLOR_SPACE_DISPLAY_NATIVE_AMD:
            *rString += std::string("VK_COLOR_SPACE_DISPLAY_NATIVE_AMD");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkSurfaceCapabilitiesKHR>(std::string* rString, const Decoded_VkSurfaceCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSurfaceFormatKHR>(std::string* rString, const Decoded_VkSurfaceFormatKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkSurfaceCapabilitiesKHR>(std::string* rString, const Decoded_VkSurfaceCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceCapabilitiesKHR *pStruct = (const VkSurfaceCapabilitiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t minImageCount // SMB
    indentSpaces(rString, indent);
    *rString += "minImageCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->minImageCount);
    *rString += "\n"; // GDS

    // uint32_t maxImageCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageCount);
    *rString += "\n"; // GDS

    // VkExtent2D currentExtent // SMB
    indentSpaces(rString, indent);
    *rString += "currentExtent:                  ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.currentExtent, indent+1,  baseAddr + offsetof(VkSurfaceCapabilitiesKHR, currentExtent)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D minImageExtent // SMB
    indentSpaces(rString, indent);
    *rString += "minImageExtent:                 ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.minImageExtent, indent+1,  baseAddr + offsetof(VkSurfaceCapabilitiesKHR, minImageExtent)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D maxImageExtent // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageExtent:                 ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.maxImageExtent, indent+1,  baseAddr + offsetof(VkSurfaceCapabilitiesKHR, maxImageExtent)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t maxImageArrayLayers // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageArrayLayers:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageArrayLayers);
    *rString += "\n"; // GDS

    // VkSurfaceTransformFlagsKHR supportedTransforms // SMB
    indentSpaces(rString, indent);
    *rString += "supportedTransforms:            ";
    *rString += "VkSurfaceTransformFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->supportedTransforms, enumToString_VkSurfaceTransformFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR currentTransform // SMB
    indentSpaces(rString, indent);
    *rString += "currentTransform:               ";
    *rString += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    enumToString_VkSurfaceTransformFlagBitsKHR(rString, pStruct->currentTransform);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->currentTransform);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkCompositeAlphaFlagsKHR supportedCompositeAlpha // SMB
    indentSpaces(rString, indent);
    *rString += "supportedCompositeAlpha:        ";
    *rString += "VkCompositeAlphaFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->supportedCompositeAlpha, enumToString_VkCompositeAlphaFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // VkImageUsageFlags supportedUsageFlags // SMB
    indentSpaces(rString, indent);
    *rString += "supportedUsageFlags:            ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->supportedUsageFlags, enumToString_VkImageUsageFlagBits); // URW
}

template <>
void structureToString<Decoded_VkSurfaceFormatKHR>(std::string* rString, const Decoded_VkSurfaceFormatKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceFormatKHR *pStruct = (const VkSurfaceFormatKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkColorSpaceKHR colorSpace // SMB
    indentSpaces(rString, indent);
    *rString += "colorSpace:                     ";
    *rString += "VkColorSpaceKHR = "; // TEQ
    enumToString_VkColorSpaceKHR(rString, pStruct->colorSpace);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->colorSpace);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkDestroySurfaceKHR(
    format::HandleId                            instance,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroySurfaceKHR(instance, surface, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceSupportKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    format::HandleId                            surface,
    const PointerDecoder<VkBool32>&             pSupported)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32* pSupported // ARG
    if (pSupported.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkBool32* = NULL", indentString.c_str(), "pSupported:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkBool32* = %" PRId64 "", indentString.c_str(), "pSupported:", static_cast<uint64_t>(*pSupported.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilitiesKHR>& pSurfaceCapabilities)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCapabilitiesKHR* pSurfaceCapabilities // ARG
    if (pSurfaceCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilitiesKHR* = NULL", indentString.c_str(), "pSurfaceCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilitiesKHR* = ", indentString.c_str(), "pSurfaceCapabilities:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSurfaceCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSurfaceCapabilitiesKHR>(&tmpString, *pSurfaceCapabilities.GetMetaStructPointer(), 2, pSurfaceCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pSurfaceFormatCount,
    const StructPointerDecoder<Decoded_VkSurfaceFormatKHR>& pSurfaceFormats)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSurfaceFormatCount // ARG
    if (pSurfaceFormatCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pSurfaceFormatCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pSurfaceFormatCount:", static_cast<uint64_t>(*pSurfaceFormatCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceFormatKHR* pSurfaceFormats // ARG
    if (pSurfaceFormats.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormatKHR* = NULL", indentString.c_str(), "pSurfaceFormats:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormatKHR* = ", indentString.c_str(), "pSurfaceFormats:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pSurfaceFormats.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSurfaceFormatKHR>(&tmpString, 2, 1, "VkSurfaceFormatKHR",
            pSurfaceFormats.GetMetaStructPointer(), "pSurfaceFormats", *pSurfaceFormatCount.GetPointer(), false, pSurfaceFormats.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pPresentModeCount,
    const PointerDecoder<VkPresentModeKHR>&     pPresentModes)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPresentModeCount // ARG
    if (pPresentModeCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPresentModeCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPresentModeCount:", static_cast<uint64_t>(*pPresentModeCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPresentModeKHR* pPresentModes // ARG
    if (pPresentModes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = NULL", indentString.c_str(), "pPresentModes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = %" PRId64 "", indentString.c_str(), "pPresentModes:", static_cast<uint64_t>(*pPresentModes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDeviceGroupPresentModeFlagBitsKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkDeviceGroupPresentModeFlagBitsKHR enumValue = static_cast<VkDeviceGroupPresentModeFlagBitsKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR:
            *rString += std::string("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR");
            return;
        case VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR:
            *rString += std::string("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR");
            return;
        case VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR:
            *rString += std::string("VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR");
            return;
        case VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR:
            *rString += std::string("VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSwapchainCreateFlagBitsKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkSwapchainCreateFlagBitsKHR enumValue = static_cast<VkSwapchainCreateFlagBitsKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR:
            *rString += std::string("VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR");
            return;
        case VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR:
            *rString += std::string("VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR");
            return;
        case VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR:
            *rString += std::string("VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkSwapchainCreateInfoKHR>(std::string* rString, const Decoded_VkSwapchainCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPresentInfoKHR>(std::string* rString, const Decoded_VkPresentInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageSwapchainCreateInfoKHR>(std::string* rString, const Decoded_VkImageSwapchainCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindImageMemorySwapchainInfoKHR>(std::string* rString, const Decoded_VkBindImageMemorySwapchainInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAcquireNextImageInfoKHR>(std::string* rString, const Decoded_VkAcquireNextImageInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(std::string* rString, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupPresentInfoKHR>(std::string* rString, const Decoded_VkDeviceGroupPresentInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>(std::string* rString, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkSwapchainCreateInfoKHR>(std::string* rString, const Decoded_VkSwapchainCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSwapchainCreateInfoKHR *pStruct = (const VkSwapchainCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSwapchainCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSwapchainCreateFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSwapchainCreateFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // VkSurfaceKHR surface // SMB
    indentSpaces(rString, indent);
    *rString += "surface:                        ";
    *rString += "VkSurfaceKHR = "; // TEQ
    addrToString(rString, pStructIn.surface); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t minImageCount // SMB
    indentSpaces(rString, indent);
    *rString += "minImageCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->minImageCount);
    *rString += "\n"; // GDS

    // VkFormat imageFormat // SMB
    indentSpaces(rString, indent);
    *rString += "imageFormat:                    ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->imageFormat);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->imageFormat);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkColorSpaceKHR imageColorSpace // SMB
    indentSpaces(rString, indent);
    *rString += "imageColorSpace:                ";
    *rString += "VkColorSpaceKHR = "; // TEQ
    enumToString_VkColorSpaceKHR(rString, pStruct->imageColorSpace);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->imageColorSpace);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkExtent2D imageExtent // SMB
    indentSpaces(rString, indent);
    *rString += "imageExtent:                    ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.imageExtent, indent+1,  baseAddr + offsetof(VkSwapchainCreateInfoKHR, imageExtent)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t imageArrayLayers // SMB
    indentSpaces(rString, indent);
    *rString += "imageArrayLayers:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->imageArrayLayers);
    *rString += "\n"; // GDS

    // VkImageUsageFlags imageUsage // SMB
    indentSpaces(rString, indent);
    *rString += "imageUsage:                     ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->imageUsage, enumToString_VkImageUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSharingMode imageSharingMode // SMB
    indentSpaces(rString, indent);
    *rString += "imageSharingMode:               ";
    *rString += "VkSharingMode = "; // TEQ
    enumToString_VkSharingMode(rString, pStruct->imageSharingMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->imageSharingMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyIndexCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueFamilyIndexCount);
    *rString += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pQueueFamilyIndices:            ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pStruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
    *rString += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR preTransform // SMB
    indentSpaces(rString, indent);
    *rString += "preTransform:                   ";
    *rString += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    enumToString_VkSurfaceTransformFlagBitsKHR(rString, pStruct->preTransform);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->preTransform);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkCompositeAlphaFlagBitsKHR compositeAlpha // SMB
    indentSpaces(rString, indent);
    *rString += "compositeAlpha:                 ";
    *rString += "VkCompositeAlphaFlagBitsKHR = "; // TEQ
    enumToString_VkCompositeAlphaFlagBitsKHR(rString, pStruct->compositeAlpha);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->compositeAlpha);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkPresentModeKHR presentMode // SMB
    indentSpaces(rString, indent);
    *rString += "presentMode:                    ";
    *rString += "VkPresentModeKHR = "; // TEQ
    enumToString_VkPresentModeKHR(rString, pStruct->presentMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->presentMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 clipped // SMB
    indentSpaces(rString, indent);
    *rString += "clipped:                        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->clipped);
    *rString += "\n"; // GDS

    // VkSwapchainKHR oldSwapchain // SMB
    indentSpaces(rString, indent);
    *rString += "oldSwapchain:                   ";
    *rString += "VkSwapchainKHR = "; // TEQ
    addrToString(rString, pStructIn.oldSwapchain); // PAQ  
}

template <>
void structureToString<Decoded_VkPresentInfoKHR>(std::string* rString, const Decoded_VkPresentInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPresentInfoKHR *pStruct = (const VkPresentInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t waitSemaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "waitSemaphoreCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->waitSemaphoreCount);
    *rString += "\n"; // GDS

    // const VkSemaphore* pWaitSemaphores // SMB
    indentSpaces(rString, indent);
    *rString += "pWaitSemaphores:                ";
    *rString += "const VkSemaphore* = "; // TEQ
    if (pStruct->pWaitSemaphores == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pWaitSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphores = {true, false, false, nullptr};
        arrayToString<const VkSemaphore*>(rString, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pStructIn.pWaitSemaphores.GetPointer()), "pWaitSemaphores", pStruct->waitSemaphoreCount,  vinfo_pWaitSemaphores);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t swapchainCount // SMB
    indentSpaces(rString, indent);
    *rString += "swapchainCount:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->swapchainCount);
    *rString += "\n"; // GDS

    // const VkSwapchainKHR* pSwapchains // SMB
    indentSpaces(rString, indent);
    *rString += "pSwapchains:                    ";
    *rString += "const VkSwapchainKHR* = "; // TEQ
    if (pStruct->pSwapchains == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSwapchains.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        arrayToString<const VkSwapchainKHR*>(rString, indent, 1, "const VkSwapchainKHR*", reinterpret_cast<const VkSwapchainKHR*>(pStructIn.pSwapchains.GetPointer()), "pSwapchains", pStruct->swapchainCount,  vinfo_pSwapchains);  // CCQ
    }
    *rString += "\n"; // GDS

    // const uint32_t* pImageIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pImageIndices:                  ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pImageIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pImageIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pImageIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pImageIndices.GetPointer()), "pImageIndices", pStruct->swapchainCount,  vinfo_pImageIndices);  // CCQ
    }
    *rString += "\n"; // GDS

    // VkResult* pResults // SMB
    indentSpaces(rString, indent);
    *rString += "pResults:                       ";
    *rString += "VkResult* = "; // TEQ
    if (pStruct->pResults == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pResults.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pResults = {false, true, false, enumToString_VkResult};
        arrayToString<VkResult*>(rString, indent, 1, "VkResult*", reinterpret_cast<VkResult*>(pStructIn.pResults.GetPointer()), "pResults", pStruct->swapchainCount,  vinfo_pResults);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkImageSwapchainCreateInfoKHR>(std::string* rString, const Decoded_VkImageSwapchainCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageSwapchainCreateInfoKHR *pStruct = (const VkImageSwapchainCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSwapchainKHR swapchain // SMB
    indentSpaces(rString, indent);
    *rString += "swapchain:                      ";
    *rString += "VkSwapchainKHR = "; // TEQ
    addrToString(rString, pStructIn.swapchain); // PAQ  
}

template <>
void structureToString<Decoded_VkBindImageMemorySwapchainInfoKHR>(std::string* rString, const Decoded_VkBindImageMemorySwapchainInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindImageMemorySwapchainInfoKHR *pStruct = (const VkBindImageMemorySwapchainInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSwapchainKHR swapchain // SMB
    indentSpaces(rString, indent);
    *rString += "swapchain:                      ";
    *rString += "VkSwapchainKHR = "; // TEQ
    addrToString(rString, pStructIn.swapchain); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t imageIndex // SMB
    indentSpaces(rString, indent);
    *rString += "imageIndex:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->imageIndex);
}

template <>
void structureToString<Decoded_VkAcquireNextImageInfoKHR>(std::string* rString, const Decoded_VkAcquireNextImageInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAcquireNextImageInfoKHR *pStruct = (const VkAcquireNextImageInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSwapchainKHR swapchain // SMB
    indentSpaces(rString, indent);
    *rString += "swapchain:                      ";
    *rString += "VkSwapchainKHR = "; // TEQ
    addrToString(rString, pStructIn.swapchain); // PAQ  
    *rString += "\n"; // GDS

    // uint64_t timeout // SMB
    indentSpaces(rString, indent);
    *rString += "timeout:                        ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->timeout);
    *rString += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    indentSpaces(rString, indent);
    *rString += "semaphore:                      ";
    *rString += "VkSemaphore = "; // TEQ
    addrToString(rString, pStructIn.semaphore); // PAQ  
    *rString += "\n"; // GDS

    // VkFence fence // SMB
    indentSpaces(rString, indent);
    *rString += "fence:                          ";
    *rString += "VkFence = "; // TEQ
    addrToString(rString, pStructIn.fence); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t deviceMask // SMB
    indentSpaces(rString, indent);
    *rString += "deviceMask:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceMask);
}

template <>
void structureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(std::string* rString, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupPresentCapabilitiesKHR *pStruct = (const VkDeviceGroupPresentCapabilitiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t presentMask // SMB
    indentSpaces(rString, indent);
    *rString += "presentMask:                    ";
    *rString += "uint32_t[";
    *rString += "VK_MAX_DEVICE_GROUP_SIZE";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkDeviceGroupPresentCapabilitiesKHR, presentMask)); // IYY
    ValueToStringStruct vinfo_presentMask = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->presentMask), "presentMask", VK_MAX_DEVICE_GROUP_SIZE, vinfo_presentMask); // JPA
    *rString += "\n"; // GDS

    // VkDeviceGroupPresentModeFlagsKHR modes // SMB
    indentSpaces(rString, indent);
    *rString += "modes:                          ";
    *rString += "VkDeviceGroupPresentModeFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->modes, enumToString_VkDeviceGroupPresentModeFlagBitsKHR); // URW
}

template <>
void structureToString<Decoded_VkDeviceGroupPresentInfoKHR>(std::string* rString, const Decoded_VkDeviceGroupPresentInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupPresentInfoKHR *pStruct = (const VkDeviceGroupPresentInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t swapchainCount // SMB
    indentSpaces(rString, indent);
    *rString += "swapchainCount:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->swapchainCount);
    *rString += "\n"; // GDS

    // const uint32_t* pDeviceMasks // SMB
    indentSpaces(rString, indent);
    *rString += "pDeviceMasks:                   ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pDeviceMasks == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDeviceMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceMasks = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pDeviceMasks.GetPointer()), "pDeviceMasks", pStruct->swapchainCount,  vinfo_pDeviceMasks);  // CCQ
    }
    *rString += "\n"; // GDS

    // VkDeviceGroupPresentModeFlagBitsKHR mode // SMB
    indentSpaces(rString, indent);
    *rString += "mode:                           ";
    *rString += "VkDeviceGroupPresentModeFlagBitsKHR = "; // TEQ
    enumToString_VkDeviceGroupPresentModeFlagBitsKHR(rString, pStruct->mode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->mode);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>(std::string* rString, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGroupSwapchainCreateInfoKHR *pStruct = (const VkDeviceGroupSwapchainCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceGroupPresentModeFlagsKHR modes // SMB
    indentSpaces(rString, indent);
    *rString += "modes:                          ";
    *rString += "VkDeviceGroupPresentModeFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->modes, enumToString_VkDeviceGroupPresentModeFlagBitsKHR); // URW
}

void VulkanAsciiConsumer::Process_vkCreateSwapchainKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchain)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSwapchainCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSwapchainCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR* pSwapchain // ARG
    if (pSwapchain.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = NULL", indentString.c_str(), "pSwapchain:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = ", indentString.c_str(), "pSwapchain:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSwapchain.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySwapchainKHR(
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroySwapchainKHR(device, swapchain, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSwapchainImagesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const PointerDecoder<uint32_t>&             pSwapchainImageCount,
    const HandlePointerDecoder<VkImage>&        pSwapchainImages)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSwapchainImageCount // ARG
    if (pSwapchainImageCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pSwapchainImageCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pSwapchainImageCount:", static_cast<uint64_t>(*pSwapchainImageCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImage* pSwapchainImages // ARG
    if (pSwapchainImages.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImage* = NULL", indentString.c_str(), "pSwapchainImages:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImage* = ", indentString.c_str(), "pSwapchainImages:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pSwapchainImages.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pSwapchainImages = {true, false, false, nullptr};
        arrayToString<VkImage*>(&tmpString, 1, 1, "VkImage*", reinterpret_cast<VkImage*>(pSwapchainImages.GetPointer()), "pSwapchainImages", *pSwapchainImageCount.GetPointer(), vinfo_pSwapchainImages); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireNextImageKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    uint64_t                                    timeout,
    format::HandleId                            semaphore,
    format::HandleId                            fence,
    const PointerDecoder<uint32_t>&             pImageIndex)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t timeout // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indentString.c_str(), "timeout:", timeout); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore semaphore // ARG
    fprintf(GetFile(), "%s%-32sVkSemaphore = ", indentString.c_str(), "semaphore:"); // TRP
    tmpString = "";
    addrToString(&tmpString, semaphore);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFence fence // ARG
    fprintf(GetFile(), "%s%-32sVkFence = ", indentString.c_str(), "fence:"); // TRP
    tmpString = "";
    addrToString(&tmpString, fence);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pImageIndex // ARG
    if (pImageIndex.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pImageIndex:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pImageIndex:", static_cast<uint64_t>(*pImageIndex.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueuePresentKHR(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkPresentInfoKHR>& pPresentInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueuePresentKHR(queue, pPresentInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPresentInfoKHR* pPresentInfo // ARG
    if (pPresentInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPresentInfoKHR* = NULL", indentString.c_str(), "pPresentInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPresentInfoKHR* = ", indentString.c_str(), "pPresentInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pPresentInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPresentInfoKHR>(&tmpString, *pPresentInfo.GetMetaStructPointer(), 2, pPresentInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupPresentCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceGroupPresentCapabilitiesKHR>& pDeviceGroupPresentCapabilities)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities // ARG
    if (pDeviceGroupPresentCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentCapabilitiesKHR* = NULL", indentString.c_str(), "pDeviceGroupPresentCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentCapabilitiesKHR* = ", indentString.c_str(), "pDeviceGroupPresentCapabilities:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pDeviceGroupPresentCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDeviceGroupPresentCapabilitiesKHR>(&tmpString, *pDeviceGroupPresentCapabilities.GetMetaStructPointer(), 2, pDeviceGroupPresentCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupSurfacePresentModesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            surface,
    const PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>& pModes)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGroupPresentModeFlagsKHR* pModes // ARG
    tmpString = "";
    flagsToString(&tmpString, *pModes.GetPointer(), enumToString_VkDeviceGroupPresentModeFlagBitsKHR);
    fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentModeFlagsKHR* = %s", indentString.c_str(), "pModes:", tmpString.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDevicePresentRectanglesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const PointerDecoder<uint32_t>&             pRectCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pRects)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pRectCount // ARG
    if (pRectCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pRectCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pRectCount:", static_cast<uint64_t>(*pRectCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkRect2D* pRects // ARG
    if (pRects.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRect2D* = NULL", indentString.c_str(), "pRects:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRect2D* = ", indentString.c_str(), "pRects:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pRects.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkRect2D>(&tmpString, 2, 1, "VkRect2D",
            pRects.GetMetaStructPointer(), "pRects", *pRectCount.GetPointer(), false, pRects.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireNextImage2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAcquireNextImageInfoKHR>& pAcquireInfo,
    const PointerDecoder<uint32_t>&             pImageIndex)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAcquireNextImageInfoKHR* pAcquireInfo // ARG
    if (pAcquireInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAcquireNextImageInfoKHR* = NULL", indentString.c_str(), "pAcquireInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAcquireNextImageInfoKHR* = ", indentString.c_str(), "pAcquireInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAcquireInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAcquireNextImageInfoKHR>(&tmpString, *pAcquireInfo.GetMetaStructPointer(), 2, pAcquireInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pImageIndex // ARG
    if (pImageIndex.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pImageIndex:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pImageIndex:", static_cast<uint64_t>(*pImageIndex.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDisplayPlaneAlphaFlagBitsKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkDisplayPlaneAlphaFlagBitsKHR enumValue = static_cast<VkDisplayPlaneAlphaFlagBitsKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR:
            *rString += std::string("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR");
            return;
        case VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR:
            *rString += std::string("VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR");
            return;
        case VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR:
            *rString += std::string("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR");
            return;
        case VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR:
            *rString += std::string("VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkDisplayPropertiesKHR>(std::string* rString, const Decoded_VkDisplayPropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayModeParametersKHR>(std::string* rString, const Decoded_VkDisplayModeParametersKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayModePropertiesKHR>(std::string* rString, const Decoded_VkDisplayModePropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayModeCreateInfoKHR>(std::string* rString, const Decoded_VkDisplayModeCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(std::string* rString, const Decoded_VkDisplayPlaneCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayPlanePropertiesKHR>(std::string* rString, const Decoded_VkDisplayPlanePropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkDisplaySurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDisplayPropertiesKHR>(std::string* rString, const Decoded_VkDisplayPropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPropertiesKHR *pStruct = (const VkDisplayPropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDisplayKHR display // SMB
    indentSpaces(rString, indent);
    *rString += "display:                        ";
    *rString += "VkDisplayKHR = "; // TEQ
    addrToString(rString, pStructIn.display); // PAQ  
    *rString += "\n"; // GDS

    // const char* displayName // SMB
    indentSpaces(rString, indent);
    *rString += "displayName:                    ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->displayName); // TGH
    *rString += "\n"; // GDS

    // VkExtent2D physicalDimensions // SMB
    indentSpaces(rString, indent);
    *rString += "physicalDimensions:             ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.physicalDimensions, indent+1,  baseAddr + offsetof(VkDisplayPropertiesKHR, physicalDimensions)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D physicalResolution // SMB
    indentSpaces(rString, indent);
    *rString += "physicalResolution:             ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.physicalResolution, indent+1,  baseAddr + offsetof(VkDisplayPropertiesKHR, physicalResolution)); // AZJ
    *rString += "\n"; // GDS

    // VkSurfaceTransformFlagsKHR supportedTransforms // SMB
    indentSpaces(rString, indent);
    *rString += "supportedTransforms:            ";
    *rString += "VkSurfaceTransformFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->supportedTransforms, enumToString_VkSurfaceTransformFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // VkBool32 planeReorderPossible // SMB
    indentSpaces(rString, indent);
    *rString += "planeReorderPossible:           ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->planeReorderPossible);
    *rString += "\n"; // GDS

    // VkBool32 persistentContent // SMB
    indentSpaces(rString, indent);
    *rString += "persistentContent:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->persistentContent);
}

template <>
void structureToString<Decoded_VkDisplayModeParametersKHR>(std::string* rString, const Decoded_VkDisplayModeParametersKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayModeParametersKHR *pStruct = (const VkDisplayModeParametersKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkExtent2D visibleRegion // SMB
    indentSpaces(rString, indent);
    *rString += "visibleRegion:                  ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.visibleRegion, indent+1,  baseAddr + offsetof(VkDisplayModeParametersKHR, visibleRegion)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t refreshRate // SMB
    indentSpaces(rString, indent);
    *rString += "refreshRate:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->refreshRate);
}

template <>
void structureToString<Decoded_VkDisplayModePropertiesKHR>(std::string* rString, const Decoded_VkDisplayModePropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayModePropertiesKHR *pStruct = (const VkDisplayModePropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDisplayModeKHR displayMode // SMB
    indentSpaces(rString, indent);
    *rString += "displayMode:                    ";
    *rString += "VkDisplayModeKHR = "; // TEQ
    addrToString(rString, pStructIn.displayMode); // PAQ  
    *rString += "\n"; // GDS

    // VkDisplayModeParametersKHR parameters // SMB
    indentSpaces(rString, indent);
    *rString += "parameters:                     ";
    *rString += "VkDisplayModeParametersKHR = "; // TEQ
    structureToString<Decoded_VkDisplayModeParametersKHR>(rString, *pStructIn.parameters, indent+1,  baseAddr + offsetof(VkDisplayModePropertiesKHR, parameters)); // AZJ
}

template <>
void structureToString<Decoded_VkDisplayModeCreateInfoKHR>(std::string* rString, const Decoded_VkDisplayModeCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayModeCreateInfoKHR *pStruct = (const VkDisplayModeCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayModeCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDisplayModeCreateFlagsKHR = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkDisplayModeParametersKHR parameters // SMB
    indentSpaces(rString, indent);
    *rString += "parameters:                     ";
    *rString += "VkDisplayModeParametersKHR = "; // TEQ
    structureToString<Decoded_VkDisplayModeParametersKHR>(rString, *pStructIn.parameters, indent+1,  baseAddr + offsetof(VkDisplayModeCreateInfoKHR, parameters)); // AZJ
}

template <>
void structureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(std::string* rString, const Decoded_VkDisplayPlaneCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPlaneCapabilitiesKHR *pStruct = (const VkDisplayPlaneCapabilitiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDisplayPlaneAlphaFlagsKHR supportedAlpha // SMB
    indentSpaces(rString, indent);
    *rString += "supportedAlpha:                 ";
    *rString += "VkDisplayPlaneAlphaFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->supportedAlpha, enumToString_VkDisplayPlaneAlphaFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // VkOffset2D minSrcPosition // SMB
    indentSpaces(rString, indent);
    *rString += "minSrcPosition:                 ";
    *rString += "VkOffset2D = "; // TEQ
    structureToString<Decoded_VkOffset2D>(rString, *pStructIn.minSrcPosition, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcPosition)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset2D maxSrcPosition // SMB
    indentSpaces(rString, indent);
    *rString += "maxSrcPosition:                 ";
    *rString += "VkOffset2D = "; // TEQ
    structureToString<Decoded_VkOffset2D>(rString, *pStructIn.maxSrcPosition, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcPosition)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D minSrcExtent // SMB
    indentSpaces(rString, indent);
    *rString += "minSrcExtent:                   ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.minSrcExtent, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcExtent)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D maxSrcExtent // SMB
    indentSpaces(rString, indent);
    *rString += "maxSrcExtent:                   ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.maxSrcExtent, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcExtent)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset2D minDstPosition // SMB
    indentSpaces(rString, indent);
    *rString += "minDstPosition:                 ";
    *rString += "VkOffset2D = "; // TEQ
    structureToString<Decoded_VkOffset2D>(rString, *pStructIn.minDstPosition, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstPosition)); // AZJ
    *rString += "\n"; // GDS

    // VkOffset2D maxDstPosition // SMB
    indentSpaces(rString, indent);
    *rString += "maxDstPosition:                 ";
    *rString += "VkOffset2D = "; // TEQ
    structureToString<Decoded_VkOffset2D>(rString, *pStructIn.maxDstPosition, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstPosition)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D minDstExtent // SMB
    indentSpaces(rString, indent);
    *rString += "minDstExtent:                   ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.minDstExtent, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstExtent)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D maxDstExtent // SMB
    indentSpaces(rString, indent);
    *rString += "maxDstExtent:                   ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.maxDstExtent, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstExtent)); // AZJ
}

template <>
void structureToString<Decoded_VkDisplayPlanePropertiesKHR>(std::string* rString, const Decoded_VkDisplayPlanePropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPlanePropertiesKHR *pStruct = (const VkDisplayPlanePropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkDisplayKHR currentDisplay // SMB
    indentSpaces(rString, indent);
    *rString += "currentDisplay:                 ";
    *rString += "VkDisplayKHR = "; // TEQ
    addrToString(rString, pStructIn.currentDisplay); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t currentStackIndex // SMB
    indentSpaces(rString, indent);
    *rString += "currentStackIndex:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->currentStackIndex);
}

template <>
void structureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkDisplaySurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplaySurfaceCreateInfoKHR *pStruct = (const VkDisplaySurfaceCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplaySurfaceCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDisplaySurfaceCreateFlagsKHR = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkDisplayModeKHR displayMode // SMB
    indentSpaces(rString, indent);
    *rString += "displayMode:                    ";
    *rString += "VkDisplayModeKHR = "; // TEQ
    addrToString(rString, pStructIn.displayMode); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t planeIndex // SMB
    indentSpaces(rString, indent);
    *rString += "planeIndex:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->planeIndex);
    *rString += "\n"; // GDS

    // uint32_t planeStackIndex // SMB
    indentSpaces(rString, indent);
    *rString += "planeStackIndex:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->planeStackIndex);
    *rString += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR transform // SMB
    indentSpaces(rString, indent);
    *rString += "transform:                      ";
    *rString += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    enumToString_VkSurfaceTransformFlagBitsKHR(rString, pStruct->transform);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->transform);
    *rString += ")";
    *rString += "\n"; // GDS

    // float globalAlpha // SMB
    indentSpaces(rString, indent);
    *rString += "globalAlpha:                    ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->globalAlpha);
    *rString += "\n"; // GDS

    // VkDisplayPlaneAlphaFlagBitsKHR alphaMode // SMB
    indentSpaces(rString, indent);
    *rString += "alphaMode:                      ";
    *rString += "VkDisplayPlaneAlphaFlagBitsKHR = "; // TEQ
    enumToString_VkDisplayPlaneAlphaFlagBitsKHR(rString, pStruct->alphaMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->alphaMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkExtent2D imageExtent // SMB
    indentSpaces(rString, indent);
    *rString += "imageExtent:                    ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.imageExtent, indent+1,  baseAddr + offsetof(VkDisplaySurfaceCreateInfoKHR, imageExtent)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPropertiesKHR>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPropertiesKHR* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPropertiesKHR* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkDisplayPropertiesKHR>(&tmpString, 2, 1, "VkDisplayPropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPlanePropertiesKHR>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlanePropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlanePropertiesKHR* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlanePropertiesKHR* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkDisplayPlanePropertiesKHR>(&tmpString, 2, 1, "VkDisplayPlanePropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneSupportedDisplaysKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    planeIndex,
    const PointerDecoder<uint32_t>&             pDisplayCount,
    const HandlePointerDecoder<VkDisplayKHR>&   pDisplays)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t planeIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "planeIndex:", planeIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pDisplayCount // ARG
    if (pDisplayCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pDisplayCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pDisplayCount:", static_cast<uint64_t>(*pDisplayCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR* pDisplays // ARG
    if (pDisplays.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = NULL", indentString.c_str(), "pDisplays:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = ", indentString.c_str(), "pDisplays:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pDisplays.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pDisplays = {true, false, false, nullptr};
        arrayToString<VkDisplayKHR*>(&tmpString, 1, 1, "VkDisplayKHR*", reinterpret_cast<VkDisplayKHR*>(pDisplays.GetPointer()), "pDisplays", *pDisplayCount.GetPointer(), vinfo_pDisplays); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayModePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayModePropertiesKHR>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indentString.c_str(), "display:"); // TRP
    tmpString = "";
    addrToString(&tmpString, display);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModePropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModePropertiesKHR* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModePropertiesKHR* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkDisplayModePropertiesKHR>(&tmpString, 2, 1, "VkDisplayModePropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDisplayModeKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayModeCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDisplayModeKHR>& pMode)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indentString.c_str(), "display:"); // TRP
    tmpString = "";
    addrToString(&tmpString, display);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayModeCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayModeCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayModeCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDisplayModeCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModeKHR* pMode // ARG
    if (pMode.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeKHR* = NULL", indentString.c_str(), "pMode:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeKHR* = ", indentString.c_str(), "pMode:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pMode.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneCapabilitiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            mode,
    uint32_t                                    planeIndex,
    const StructPointerDecoder<Decoded_VkDisplayPlaneCapabilitiesKHR>& pCapabilities)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModeKHR mode // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayModeKHR = ", indentString.c_str(), "mode:"); // TRP
    tmpString = "";
    addrToString(&tmpString, mode);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t planeIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "planeIndex:", planeIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlaneCapabilitiesKHR* pCapabilities // ARG
    if (pCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilitiesKHR* = NULL", indentString.c_str(), "pCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilitiesKHR* = ", indentString.c_str(), "pCapabilities:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(&tmpString, *pCapabilities.GetMetaStructPointer(), 2, pCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDisplayPlaneSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDisplaySurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplaySurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplaySurfaceCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplaySurfaceCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDisplaySurfaceCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkDisplayPresentInfoKHR>(std::string* rString, const Decoded_VkDisplayPresentInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDisplayPresentInfoKHR>(std::string* rString, const Decoded_VkDisplayPresentInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPresentInfoKHR *pStruct = (const VkDisplayPresentInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkRect2D srcRect // SMB
    indentSpaces(rString, indent);
    *rString += "srcRect:                        ";
    *rString += "VkRect2D = "; // TEQ
    structureToString<Decoded_VkRect2D>(rString, *pStructIn.srcRect, indent+1,  baseAddr + offsetof(VkDisplayPresentInfoKHR, srcRect)); // AZJ
    *rString += "\n"; // GDS

    // VkRect2D dstRect // SMB
    indentSpaces(rString, indent);
    *rString += "dstRect:                        ";
    *rString += "VkRect2D = "; // TEQ
    structureToString<Decoded_VkRect2D>(rString, *pStructIn.dstRect, indent+1,  baseAddr + offsetof(VkDisplayPresentInfoKHR, dstRect)); // AZJ
    *rString += "\n"; // GDS

    // VkBool32 persistent // SMB
    indentSpaces(rString, indent);
    *rString += "persistent:                     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->persistent);
}

void VulkanAsciiConsumer::Process_vkCreateSharedSwapchainsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    const StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchains)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t swapchainCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "swapchainCount:", swapchainCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkSwapchainCreateInfoKHR* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainCreateInfoKHR* = ", indentString.c_str(), "pCreateInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSwapchainCreateInfoKHR>(&tmpString, 2, 1, "VkSwapchainCreateInfoKHR",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", swapchainCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR* pSwapchains // ARG
    if (pSwapchains.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = NULL", indentString.c_str(), "pSwapchains:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSwapchainKHR* = ", indentString.c_str(), "pSwapchains:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pSwapchains.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        arrayToString<VkSwapchainKHR*>(&tmpString, 1, 1, "VkSwapchainKHR*", reinterpret_cast<VkSwapchainKHR*>(pSwapchains.GetPointer()), "pSwapchains", swapchainCount, vinfo_pSwapchains); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkXlibSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkXlibSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkXlibSurfaceCreateInfoKHR *pStruct = (const VkXlibSurfaceCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkXlibSurfaceCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkXlibSurfaceCreateFlagsKHR = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // void* dpy // SMB
    indentSpaces(rString, indent);
    *rString += "dpy:                            ";
    *rString += "void* = "; // TEQ
    if (pStruct->dpy == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.dpy); // PWR
    }
    *rString += "\n"; // GDS

    // size_t window // SMB
    indentSpaces(rString, indent);
    *rString += "window:                         ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->window);
}

void VulkanAsciiConsumer::Process_vkCreateXlibSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkXlibSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkXlibSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkXlibSurfaceCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkXlibSurfaceCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkXlibSurfaceCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    dpy,
    size_t                                      visualID)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* dpy // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indentString.c_str(), "dpy:", dpy); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // size_t visualID // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indentString.c_str(), "visualID:", visualID); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkXcbSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkXcbSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkXcbSurfaceCreateInfoKHR *pStruct = (const VkXcbSurfaceCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkXcbSurfaceCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkXcbSurfaceCreateFlagsKHR = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // void* connection // SMB
    indentSpaces(rString, indent);
    *rString += "connection:                     ";
    *rString += "void* = "; // TEQ
    if (pStruct->connection == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.connection); // PWR
    }
    *rString += "\n"; // GDS

    // uint32_t window // SMB
    indentSpaces(rString, indent);
    *rString += "window:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->window);
}

void VulkanAsciiConsumer::Process_vkCreateXcbSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkXcbSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkXcbSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkXcbSurfaceCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkXcbSurfaceCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkXcbSurfaceCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    connection,
    uint32_t                                    visual_id)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* connection // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indentString.c_str(), "connection:", connection); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t visual_id // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "visual_id:", visual_id); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkWaylandSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkWaylandSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkWaylandSurfaceCreateInfoKHR *pStruct = (const VkWaylandSurfaceCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkWaylandSurfaceCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkWaylandSurfaceCreateFlagsKHR = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // struct void* display // SMB
    indentSpaces(rString, indent);
    *rString += "display:                        ";
    *rString += "struct void* = "; // TEQ
    if (pStruct->display == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.display); // PWR
    }
    *rString += "\n"; // GDS

    // struct void* surface // SMB
    indentSpaces(rString, indent);
    *rString += "surface:                        ";
    *rString += "struct void* = "; // TEQ
    if (pStruct->surface == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.surface); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateWaylandSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkWaylandSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkWaylandSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWaylandSurfaceCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWaylandSurfaceCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkWaylandSurfaceCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    display)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // struct void* display // ARG
    fprintf(GetFile(), "%s%-32sstruct void* = 0x%" PRIx64 "", indentString.c_str(), "display:", display); // YQA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkAndroidSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkAndroidSurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAndroidSurfaceCreateInfoKHR *pStruct = (const VkAndroidSurfaceCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAndroidSurfaceCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkAndroidSurfaceCreateFlagsKHR = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // struct void* window // SMB
    indentSpaces(rString, indent);
    *rString += "window:                         ";
    *rString += "struct void* = "; // TEQ
    if (pStruct->window == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.window); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateAndroidSurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkAndroidSurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAndroidSurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAndroidSurfaceCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAndroidSurfaceCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAndroidSurfaceCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkWin32SurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(std::string* rString, const Decoded_VkWin32SurfaceCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkWin32SurfaceCreateInfoKHR *pStruct = (const VkWin32SurfaceCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkWin32SurfaceCreateFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkWin32SurfaceCreateFlagsKHR = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // void* hinstance // SMB
    indentSpaces(rString, indent);
    *rString += "hinstance:                      ";
    *rString += "void* = "; // TEQ
    if (pStruct->hinstance == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.hinstance); // PWR
    }
    *rString += "\n"; // GDS

    // void* hwnd // SMB
    indentSpaces(rString, indent);
    *rString += "hwnd:                           ";
    *rString += "void* = "; // TEQ
    if (pStruct->hwnd == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.hwnd); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateWin32SurfaceKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkWin32SurfaceCreateInfoKHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkWin32SurfaceCreateInfoKHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWin32SurfaceCreateInfoKHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWin32SurfaceCreateInfoKHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkWin32SurfaceCreateInfoKHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queueFamilyIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queueFamilyIndex:", queueFamilyIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFeatures2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>& pFeatures)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceFeatures2* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = NULL", indentString.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceFeatures2* = ", indentString.c_str(), "pFeatures:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceFeatures2>(&tmpString, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = NULL", indentString.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceProperties2* = ", indentString.c_str(), "pProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceProperties2>(&tmpString, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceFormatProperties2KHR(
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    const StructPointerDecoder<Decoded_VkFormatProperties2>& pFormatProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmpString = "";
    enumToString_VkFormat(&tmpString,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indentString.c_str(), "format:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkFormatProperties2* pFormatProperties // ARG
    if (pFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = NULL", indentString.c_str(), "pFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFormatProperties2* = ", indentString.c_str(), "pFormatProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkFormatProperties2>(&tmpString, *pFormatProperties.GetMetaStructPointer(), 2, pFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>& pImageFormatInfo,
    const StructPointerDecoder<Decoded_VkImageFormatProperties2>& pImageFormatProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo // ARG
    if (pImageFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = NULL", indentString.c_str(), "pImageFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceImageFormatInfo2* = ", indentString.c_str(), "pImageFormatInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImageFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceImageFormatInfo2>(&tmpString, *pImageFormatInfo.GetMetaStructPointer(), 2, pImageFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkImageFormatProperties2* pImageFormatProperties // ARG
    if (pImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = NULL", indentString.c_str(), "pImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageFormatProperties2* = ", indentString.c_str(), "pImageFormatProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageFormatProperties2>(&tmpString, *pImageFormatProperties.GetMetaStructPointer(), 2, pImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pQueueFamilyPropertyCount,
    const StructPointerDecoder<Decoded_VkQueueFamilyProperties2>& pQueueFamilyProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pQueueFamilyPropertyCount // ARG
    if (pQueueFamilyPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pQueueFamilyPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pQueueFamilyPropertyCount:", static_cast<uint64_t>(*pQueueFamilyPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueueFamilyProperties2* pQueueFamilyProperties // ARG
    if (pQueueFamilyProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = NULL", indentString.c_str(), "pQueueFamilyProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkQueueFamilyProperties2* = ", indentString.c_str(), "pQueueFamilyProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pQueueFamilyProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkQueueFamilyProperties2>(&tmpString, 2, 1, "VkQueueFamilyProperties2",
            pQueueFamilyProperties.GetMetaStructPointer(), "pQueueFamilyProperties", *pQueueFamilyPropertyCount.GetPointer(), false, pQueueFamilyProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMemoryProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>& pMemoryProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceMemoryProperties2* pMemoryProperties // ARG
    if (pMemoryProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = NULL", indentString.c_str(), "pMemoryProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceMemoryProperties2* = ", indentString.c_str(), "pMemoryProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceMemoryProperties2>(&tmpString, *pMemoryProperties.GetMetaStructPointer(), 2, pMemoryProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>& pFormatInfo,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo // ARG
    if (pFormatInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = NULL", indentString.c_str(), "pFormatInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSparseImageFormatInfo2* = ", indentString.c_str(), "pFormatInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFormatInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>(&tmpString, *pFormatInfo.GetMetaStructPointer(), 2, pFormatInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageFormatProperties2* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageFormatProperties2* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSparseImageFormatProperties2>(&tmpString, 2, 1, "VkSparseImageFormatProperties2",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkPeerMemoryFeatureFlagBitsKHR(std::string* rString, VkPeerMemoryFeatureFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkPeerMemoryFeatureFlagBits(rString, enumValue);
}


void enumToString_VkMemoryAllocateFlagBitsKHR(std::string* rString, VkMemoryAllocateFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkMemoryAllocateFlagBits(rString, enumValue);
}


void VulkanAsciiConsumer::Process_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    const PointerDecoder<VkPeerMemoryFeatureFlags>& pPeerMemoryFeatures)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t heapIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "heapIndex:", heapIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t localDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "localDeviceIndex:", localDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t remoteDeviceIndex // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "remoteDeviceIndex:", remoteDeviceIndex); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkPeerMemoryFeatureFlags* pPeerMemoryFeatures // ARG
    tmpString = "";
    flagsToString(&tmpString, *pPeerMemoryFeatures.GetPointer(), enumToString_VkPeerMemoryFeatureFlagBits);
    fprintf(GetFile(), "%s%-32sVkPeerMemoryFeatureFlags* = %s", indentString.c_str(), "pPeerMemoryFeatures:", tmpString.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetDeviceMaskKHR(
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t deviceMask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "deviceMask:", deviceMask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDispatchBaseKHR(
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "baseGroupX:", baseGroupX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "baseGroupY:", baseGroupY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t baseGroupZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "baseGroupZ:", baseGroupZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountX // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountX:", groupCountX); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountY // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountY:", groupCountY); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCountZ // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCountZ:", groupCountZ); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkTrimCommandPoolKHR(
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkTrimCommandPoolKHR(device, commandPool, flags)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPool commandPool // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPool = ", indentString.c_str(), "commandPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCommandPoolTrimFlags flags // ARG
    fprintf(GetFile(), "%s%-32sVkCommandPoolTrimFlags = %d", indentString.c_str(), "flags:", flags); // ZSQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkEnumeratePhysicalDeviceGroupsKHR(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const PointerDecoder<uint32_t>&             pPhysicalDeviceGroupCount,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>& pPhysicalDeviceGroupProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPhysicalDeviceGroupCount // ARG
    if (pPhysicalDeviceGroupCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPhysicalDeviceGroupCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPhysicalDeviceGroupCount:", static_cast<uint64_t>(*pPhysicalDeviceGroupCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties // ARG
    if (pPhysicalDeviceGroupProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = NULL", indentString.c_str(), "pPhysicalDeviceGroupProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPhysicalDeviceGroupProperties* = ", indentString.c_str(), "pPhysicalDeviceGroupProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pPhysicalDeviceGroupProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkPhysicalDeviceGroupProperties>(&tmpString, 2, 1, "VkPhysicalDeviceGroupProperties",
            pPhysicalDeviceGroupProperties.GetMetaStructPointer(), "pPhysicalDeviceGroupProperties", *pPhysicalDeviceGroupCount.GetPointer(), false, pPhysicalDeviceGroupProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkExternalMemoryHandleTypeFlagBitsKHR(std::string* rString, VkExternalMemoryHandleTypeFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, enumValue);
}


void enumToString_VkExternalMemoryFeatureFlagBitsKHR(std::string* rString, VkExternalMemoryFeatureFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkExternalMemoryFeatureFlagBits(rString, enumValue);
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>& pExternalBufferInfo,
    const StructPointerDecoder<Decoded_VkExternalBufferProperties>& pExternalBufferProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo // ARG
    if (pExternalBufferInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = NULL", indentString.c_str(), "pExternalBufferInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalBufferInfo* = ", indentString.c_str(), "pExternalBufferInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalBufferInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceExternalBufferInfo>(&tmpString, *pExternalBufferInfo.GetMetaStructPointer(), 2, pExternalBufferInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalBufferProperties* pExternalBufferProperties // ARG
    if (pExternalBufferProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = NULL", indentString.c_str(), "pExternalBufferProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalBufferProperties* = ", indentString.c_str(), "pExternalBufferProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalBufferProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExternalBufferProperties>(&tmpString, *pExternalBufferProperties.GetMetaStructPointer(), 2, pExternalBufferProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkImportMemoryWin32HandleInfoKHR>(std::string* rString, const Decoded_VkImportMemoryWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExportMemoryWin32HandleInfoKHR>(std::string* rString, const Decoded_VkExportMemoryWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(std::string* rString, const Decoded_VkMemoryWin32HandlePropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(std::string* rString, const Decoded_VkMemoryGetWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportMemoryWin32HandleInfoKHR>(std::string* rString, const Decoded_VkImportMemoryWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportMemoryWin32HandleInfoKHR *pStruct = (const VkImportMemoryWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* handle // SMB
    indentSpaces(rString, indent);
    *rString += "handle:                         ";
    *rString += "void* = "; // TEQ
    if (pStruct->handle == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.handle); // PWR
    }
    *rString += "\n"; // GDS

    // const wchar_t* name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "const wchar_t* = "; // TEQ
    if (pStruct->name == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.name.GetAddress()); // PWQ
    }
}

template <>
void structureToString<Decoded_VkExportMemoryWin32HandleInfoKHR>(std::string* rString, const Decoded_VkExportMemoryWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExportMemoryWin32HandleInfoKHR *pStruct = (const VkExportMemoryWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    indentSpaces(rString, indent);
    *rString += "pAttributes:                    ";
    *rString += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pStruct->pAttributes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttributes->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t dwAccess // SMB
    indentSpaces(rString, indent);
    *rString += "dwAccess:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dwAccess);
    *rString += "\n"; // GDS

    // const wchar_t* name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "const wchar_t* = "; // TEQ
    if (pStruct->name == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.name.GetAddress()); // PWQ
    }
}

template <>
void structureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(std::string* rString, const Decoded_VkMemoryWin32HandlePropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryWin32HandlePropertiesKHR *pStruct = (const VkMemoryWin32HandlePropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypeBits:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryTypeBits);
}

template <>
void structureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(std::string* rString, const Decoded_VkMemoryGetWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryGetWin32HandleInfoKHR *pStruct = (const VkMemoryGetWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo // ARG
    if (pGetWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetWin32HandleInfoKHR* = NULL", indentString.c_str(), "pGetWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetWin32HandleInfoKHR* = ", indentString.c_str(), "pGetWin32HandleInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pGetWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryGetWin32HandleInfoKHR>(&tmpString, *pGetWin32HandleInfo.GetMetaStructPointer(), 2, pGetWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indentString.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indentString.c_str(), "pHandle:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandlePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    handle,
    const StructPointerDecoder<Decoded_VkMemoryWin32HandlePropertiesKHR>& pMemoryWin32HandleProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagBits handleType // ARG
    tmpString = "";
    enumToString_VkExternalMemoryHandleTypeFlagBits(&tmpString,handleType); // EPW
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagBits = %s", indentString.c_str(), "handleType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // void* handle // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indentString.c_str(), "handle:", handle); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties // ARG
    if (pMemoryWin32HandleProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryWin32HandlePropertiesKHR* = NULL", indentString.c_str(), "pMemoryWin32HandleProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryWin32HandlePropertiesKHR* = ", indentString.c_str(), "pMemoryWin32HandleProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryWin32HandleProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryWin32HandlePropertiesKHR>(&tmpString, *pMemoryWin32HandleProperties.GetMetaStructPointer(), 2, pMemoryWin32HandleProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkImportMemoryFdInfoKHR>(std::string* rString, const Decoded_VkImportMemoryFdInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryFdPropertiesKHR>(std::string* rString, const Decoded_VkMemoryFdPropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryGetFdInfoKHR>(std::string* rString, const Decoded_VkMemoryGetFdInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportMemoryFdInfoKHR>(std::string* rString, const Decoded_VkImportMemoryFdInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportMemoryFdInfoKHR *pStruct = (const VkImportMemoryFdInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
    *rString += "\n"; // GDS

    // int fd // SMB
    indentSpaces(rString, indent);
    *rString += "fd:                             ";
    *rString += "int = "; // TEQ
    signedDecimalToString(rString, pStruct->fd);
}

template <>
void structureToString<Decoded_VkMemoryFdPropertiesKHR>(std::string* rString, const Decoded_VkMemoryFdPropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryFdPropertiesKHR *pStruct = (const VkMemoryFdPropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypeBits:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryTypeBits);
}

template <>
void structureToString<Decoded_VkMemoryGetFdInfoKHR>(std::string* rString, const Decoded_VkMemoryGetFdInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryGetFdInfoKHR *pStruct = (const VkMemoryGetFdInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkGetMemoryFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetMemoryFdKHR(device, pGetFdInfo, pFd)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryGetFdInfoKHR* pGetFdInfo // ARG
    if (pGetFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetFdInfoKHR* = NULL", indentString.c_str(), "pGetFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetFdInfoKHR* = ", indentString.c_str(), "pGetFdInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pGetFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryGetFdInfoKHR>(&tmpString, *pGetFdInfo.GetMetaStructPointer(), 2, pGetFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // int* pFd // ARG
    if (pFd.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sint* = NULL", indentString.c_str(), "pFd:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sint* = %" PRId64 "", indentString.c_str(), "pFd:", static_cast<uint64_t>(*pFd.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryFdPropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd,
    const StructPointerDecoder<Decoded_VkMemoryFdPropertiesKHR>& pMemoryFdProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagBits handleType // ARG
    tmpString = "";
    enumToString_VkExternalMemoryHandleTypeFlagBits(&tmpString,handleType); // EPW
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagBits = %s", indentString.c_str(), "handleType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // int fd // ARG
    fprintf(GetFile(), "%s%-32sint = %d", indentString.c_str(), "fd:", fd); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryFdPropertiesKHR* pMemoryFdProperties // ARG
    if (pMemoryFdProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryFdPropertiesKHR* = NULL", indentString.c_str(), "pMemoryFdProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryFdPropertiesKHR* = ", indentString.c_str(), "pMemoryFdProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryFdProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryFdPropertiesKHR>(&tmpString, *pMemoryFdProperties.GetMetaStructPointer(), 2, pMemoryFdProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkExternalSemaphoreHandleTypeFlagBitsKHR(std::string* rString, VkExternalSemaphoreHandleTypeFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkExternalSemaphoreHandleTypeFlagBits(rString, enumValue);
}


void enumToString_VkExternalSemaphoreFeatureFlagBitsKHR(std::string* rString, VkExternalSemaphoreFeatureFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkExternalSemaphoreFeatureFlagBits(rString, enumValue);
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>& pExternalSemaphoreInfo,
    const StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>& pExternalSemaphoreProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo // ARG
    if (pExternalSemaphoreInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = NULL", indentString.c_str(), "pExternalSemaphoreInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalSemaphoreInfo* = ", indentString.c_str(), "pExternalSemaphoreInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalSemaphoreInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>(&tmpString, *pExternalSemaphoreInfo.GetMetaStructPointer(), 2, pExternalSemaphoreInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalSemaphoreProperties* pExternalSemaphoreProperties // ARG
    if (pExternalSemaphoreProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = NULL", indentString.c_str(), "pExternalSemaphoreProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalSemaphoreProperties* = ", indentString.c_str(), "pExternalSemaphoreProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalSemaphoreProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExternalSemaphoreProperties>(&tmpString, *pExternalSemaphoreProperties.GetMetaStructPointer(), 2, pExternalSemaphoreProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkSemaphoreImportFlagBitsKHR(std::string* rString, VkSemaphoreImportFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkSemaphoreImportFlagBits(rString, enumValue);
}

template <> void structureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(std::string* rString, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExportSemaphoreWin32HandleInfoKHR>(std::string* rString, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkD3D12FenceSubmitInfoKHR>(std::string* rString, const Decoded_VkD3D12FenceSubmitInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(std::string* rString, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(std::string* rString, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportSemaphoreWin32HandleInfoKHR *pStruct = (const VkImportSemaphoreWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    indentSpaces(rString, indent);
    *rString += "semaphore:                      ";
    *rString += "VkSemaphore = "; // TEQ
    addrToString(rString, pStructIn.semaphore); // PAQ  
    *rString += "\n"; // GDS

    // VkSemaphoreImportFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSemaphoreImportFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSemaphoreImportFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalSemaphoreHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* handle // SMB
    indentSpaces(rString, indent);
    *rString += "handle:                         ";
    *rString += "void* = "; // TEQ
    if (pStruct->handle == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.handle); // PWR
    }
    *rString += "\n"; // GDS

    // const wchar_t* name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "const wchar_t* = "; // TEQ
    if (pStruct->name == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.name.GetAddress()); // PWQ
    }
}

template <>
void structureToString<Decoded_VkExportSemaphoreWin32HandleInfoKHR>(std::string* rString, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExportSemaphoreWin32HandleInfoKHR *pStruct = (const VkExportSemaphoreWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    indentSpaces(rString, indent);
    *rString += "pAttributes:                    ";
    *rString += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pStruct->pAttributes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttributes->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t dwAccess // SMB
    indentSpaces(rString, indent);
    *rString += "dwAccess:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dwAccess);
    *rString += "\n"; // GDS

    // const wchar_t* name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "const wchar_t* = "; // TEQ
    if (pStruct->name == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.name.GetAddress()); // PWQ
    }
}

template <>
void structureToString<Decoded_VkD3D12FenceSubmitInfoKHR>(std::string* rString, const Decoded_VkD3D12FenceSubmitInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkD3D12FenceSubmitInfoKHR *pStruct = (const VkD3D12FenceSubmitInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t waitSemaphoreValuesCount // SMB
    indentSpaces(rString, indent);
    *rString += "waitSemaphoreValuesCount:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->waitSemaphoreValuesCount);
    *rString += "\n"; // GDS

    // const uint64_t* pWaitSemaphoreValues // SMB
    indentSpaces(rString, indent);
    *rString += "pWaitSemaphoreValues:           ";
    *rString += "const uint64_t* = "; // TEQ
    if (pStruct->pWaitSemaphoreValues == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pWaitSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        arrayToString<const uint64_t*>(rString, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pStructIn.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pStruct->waitSemaphoreValuesCount,  vinfo_pWaitSemaphoreValues);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t signalSemaphoreValuesCount // SMB
    indentSpaces(rString, indent);
    *rString += "signalSemaphoreValuesCount:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->signalSemaphoreValuesCount);
    *rString += "\n"; // GDS

    // const uint64_t* pSignalSemaphoreValues // SMB
    indentSpaces(rString, indent);
    *rString += "pSignalSemaphoreValues:         ";
    *rString += "const uint64_t* = "; // TEQ
    if (pStruct->pSignalSemaphoreValues == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSignalSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        arrayToString<const uint64_t*>(rString, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pStructIn.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pStruct->signalSemaphoreValuesCount,  vinfo_pSignalSemaphoreValues);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(std::string* rString, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSemaphoreGetWin32HandleInfoKHR *pStruct = (const VkSemaphoreGetWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    indentSpaces(rString, indent);
    *rString += "semaphore:                      ";
    *rString += "VkSemaphore = "; // TEQ
    addrToString(rString, pStructIn.semaphore); // PAQ  
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalSemaphoreHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkImportSemaphoreWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportSemaphoreWin32HandleInfoKHR>& pImportSemaphoreWin32HandleInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo // ARG
    if (pImportSemaphoreWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreWin32HandleInfoKHR* = NULL", indentString.c_str(), "pImportSemaphoreWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreWin32HandleInfoKHR* = ", indentString.c_str(), "pImportSemaphoreWin32HandleInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImportSemaphoreWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImportSemaphoreWin32HandleInfoKHR>(&tmpString, *pImportSemaphoreWin32HandleInfo.GetMetaStructPointer(), 2, pImportSemaphoreWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSemaphoreWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo // ARG
    if (pGetWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetWin32HandleInfoKHR* = NULL", indentString.c_str(), "pGetWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetWin32HandleInfoKHR* = ", indentString.c_str(), "pGetWin32HandleInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pGetWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSemaphoreGetWin32HandleInfoKHR>(&tmpString, *pGetWin32HandleInfo.GetMetaStructPointer(), 2, pGetWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indentString.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indentString.c_str(), "pHandle:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkImportSemaphoreFdInfoKHR>(std::string* rString, const Decoded_VkImportSemaphoreFdInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSemaphoreGetFdInfoKHR>(std::string* rString, const Decoded_VkSemaphoreGetFdInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportSemaphoreFdInfoKHR>(std::string* rString, const Decoded_VkImportSemaphoreFdInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportSemaphoreFdInfoKHR *pStruct = (const VkImportSemaphoreFdInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    indentSpaces(rString, indent);
    *rString += "semaphore:                      ";
    *rString += "VkSemaphore = "; // TEQ
    addrToString(rString, pStructIn.semaphore); // PAQ  
    *rString += "\n"; // GDS

    // VkSemaphoreImportFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSemaphoreImportFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSemaphoreImportFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalSemaphoreHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
    *rString += "\n"; // GDS

    // int fd // SMB
    indentSpaces(rString, indent);
    *rString += "fd:                             ";
    *rString += "int = "; // TEQ
    signedDecimalToString(rString, pStruct->fd);
}

template <>
void structureToString<Decoded_VkSemaphoreGetFdInfoKHR>(std::string* rString, const Decoded_VkSemaphoreGetFdInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSemaphoreGetFdInfoKHR *pStruct = (const VkSemaphoreGetFdInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    indentSpaces(rString, indent);
    *rString += "semaphore:                      ";
    *rString += "VkSemaphore = "; // TEQ
    addrToString(rString, pStructIn.semaphore); // PAQ  
    *rString += "\n"; // GDS

    // VkExternalSemaphoreHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalSemaphoreHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalSemaphoreHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkImportSemaphoreFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportSemaphoreFdInfoKHR>& pImportSemaphoreFdInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo // ARG
    if (pImportSemaphoreFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreFdInfoKHR* = NULL", indentString.c_str(), "pImportSemaphoreFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportSemaphoreFdInfoKHR* = ", indentString.c_str(), "pImportSemaphoreFdInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImportSemaphoreFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImportSemaphoreFdInfoKHR>(&tmpString, *pImportSemaphoreFdInfo.GetMetaStructPointer(), 2, pImportSemaphoreFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSemaphoreFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreGetFdInfoKHR* pGetFdInfo // ARG
    if (pGetFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetFdInfoKHR* = NULL", indentString.c_str(), "pGetFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreGetFdInfoKHR* = ", indentString.c_str(), "pGetFdInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pGetFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSemaphoreGetFdInfoKHR>(&tmpString, *pGetFdInfo.GetMetaStructPointer(), 2, pGetFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // int* pFd // ARG
    if (pFd.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sint* = NULL", indentString.c_str(), "pFd:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sint* = %" PRId64 "", indentString.c_str(), "pFd:", static_cast<uint64_t>(*pFd.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR>(std::string* rString, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR>(std::string* rString, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDevicePushDescriptorPropertiesKHR *pStruct = (const VkPhysicalDevicePushDescriptorPropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t maxPushDescriptors // SMB
    indentSpaces(rString, indent);
    *rString += "maxPushDescriptors:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPushDescriptors);
}

void VulkanAsciiConsumer::Process_vkCmdPushDescriptorSetKHR(
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const StructPointerDecoder<Decoded_VkWriteDescriptorSet>& pDescriptorWrites)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineBindPoint pipelineBindPoint // ARG
    tmpString = "";
    enumToString_VkPipelineBindPoint(&tmpString,pipelineBindPoint); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineBindPoint = %s", indentString.c_str(), "pipelineBindPoint:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineLayout layout // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineLayout = ", indentString.c_str(), "layout:"); // TRP
    tmpString = "";
    addrToString(&tmpString, layout);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t set // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "set:", set); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t descriptorWriteCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "descriptorWriteCount:", descriptorWriteCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkWriteDescriptorSet* pDescriptorWrites // ARG
    if (pDescriptorWrites.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = NULL", indentString.c_str(), "pDescriptorWrites:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkWriteDescriptorSet* = ", indentString.c_str(), "pDescriptorWrites:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pDescriptorWrites.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkWriteDescriptorSet>(&tmpString, 2, 1, "VkWriteDescriptorSet",
            pDescriptorWrites.GetMetaStructPointer(), "pDescriptorWrites", descriptorWriteCount, false, pDescriptorWrites.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDescriptorUpdateTemplateTypeKHR(std::string* rString, VkDescriptorUpdateTemplateTypeKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkDescriptorUpdateTemplateType(rString, enumValue);
}


void VulkanAsciiConsumer::Process_vkCreateDescriptorUpdateTemplateKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDescriptorUpdateTemplate>& pDescriptorUpdateTemplate)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorUpdateTemplateCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorUpdateTemplateCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate // ARG
    if (pDescriptorUpdateTemplate.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = NULL", indentString.c_str(), "pDescriptorUpdateTemplate:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate* = ", indentString.c_str(), "pDescriptorUpdateTemplate:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pDescriptorUpdateTemplate.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDescriptorUpdateTemplateKHR(
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorUpdateTemplate descriptorUpdateTemplate // ARG
    fprintf(GetFile(), "%s%-32sVkDescriptorUpdateTemplate = ", indentString.c_str(), "descriptorUpdateTemplate:"); // TRP
    tmpString = "";
    addrToString(&tmpString, descriptorUpdateTemplate);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkAttachmentDescription2KHR>(std::string* rString, const Decoded_VkAttachmentDescription2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAttachmentReference2KHR>(std::string* rString, const Decoded_VkAttachmentReference2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubpassDescription2KHR>(std::string* rString, const Decoded_VkSubpassDescription2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubpassDependency2KHR>(std::string* rString, const Decoded_VkSubpassDependency2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRenderPassCreateInfo2KHR>(std::string* rString, const Decoded_VkRenderPassCreateInfo2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubpassBeginInfoKHR>(std::string* rString, const Decoded_VkSubpassBeginInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubpassEndInfoKHR>(std::string* rString, const Decoded_VkSubpassEndInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkAttachmentDescription2KHR>(std::string* rString, const Decoded_VkAttachmentDescription2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAttachmentDescription2KHR *pStruct = (const VkAttachmentDescription2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAttachmentDescriptionFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkAttachmentDescriptionFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkAttachmentDescriptionFlagBits); // URW
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSampleCountFlagBits samples // SMB
    indentSpaces(rString, indent);
    *rString += "samples:                        ";
    *rString += "VkSampleCountFlagBits = "; // TEQ
    enumToString_VkSampleCountFlagBits(rString, pStruct->samples);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->samples);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentLoadOp loadOp // SMB
    indentSpaces(rString, indent);
    *rString += "loadOp:                         ";
    *rString += "VkAttachmentLoadOp = "; // TEQ
    enumToString_VkAttachmentLoadOp(rString, pStruct->loadOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->loadOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentStoreOp storeOp // SMB
    indentSpaces(rString, indent);
    *rString += "storeOp:                        ";
    *rString += "VkAttachmentStoreOp = "; // TEQ
    enumToString_VkAttachmentStoreOp(rString, pStruct->storeOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->storeOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentLoadOp stencilLoadOp // SMB
    indentSpaces(rString, indent);
    *rString += "stencilLoadOp:                  ";
    *rString += "VkAttachmentLoadOp = "; // TEQ
    enumToString_VkAttachmentLoadOp(rString, pStruct->stencilLoadOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->stencilLoadOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAttachmentStoreOp stencilStoreOp // SMB
    indentSpaces(rString, indent);
    *rString += "stencilStoreOp:                 ";
    *rString += "VkAttachmentStoreOp = "; // TEQ
    enumToString_VkAttachmentStoreOp(rString, pStruct->stencilStoreOp);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->stencilStoreOp);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageLayout initialLayout // SMB
    indentSpaces(rString, indent);
    *rString += "initialLayout:                  ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->initialLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->initialLayout);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageLayout finalLayout // SMB
    indentSpaces(rString, indent);
    *rString += "finalLayout:                    ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->finalLayout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->finalLayout);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkAttachmentReference2KHR>(std::string* rString, const Decoded_VkAttachmentReference2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAttachmentReference2KHR *pStruct = (const VkAttachmentReference2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t attachment // SMB
    indentSpaces(rString, indent);
    *rString += "attachment:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachment);
    *rString += "\n"; // GDS

    // VkImageLayout layout // SMB
    indentSpaces(rString, indent);
    *rString += "layout:                         ";
    *rString += "VkImageLayout = "; // TEQ
    enumToString_VkImageLayout(rString, pStruct->layout);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->layout);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkImageAspectFlags aspectMask // SMB
    indentSpaces(rString, indent);
    *rString += "aspectMask:                     ";
    *rString += "VkImageAspectFlags = "; // TEQ
    flagsToString(rString, pStruct->aspectMask, enumToString_VkImageAspectFlagBits); // URW
}

template <>
void structureToString<Decoded_VkSubpassDescription2KHR>(std::string* rString, const Decoded_VkSubpassDescription2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubpassDescription2KHR *pStruct = (const VkSubpassDescription2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSubpassDescriptionFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSubpassDescriptionFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSubpassDescriptionFlagBits); // URW
    *rString += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineBindPoint:              ";
    *rString += "VkPipelineBindPoint = "; // TEQ
    enumToString_VkPipelineBindPoint(rString, pStruct->pipelineBindPoint);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->pipelineBindPoint);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t viewMask // SMB
    indentSpaces(rString, indent);
    *rString += "viewMask:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->viewMask);
    *rString += "\n"; // GDS

    // uint32_t inputAttachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "inputAttachmentCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->inputAttachmentCount);
    *rString += "\n"; // GDS

    // const VkAttachmentReference2KHR* pInputAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pInputAttachments:              ";
    *rString += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pStruct->pInputAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pInputAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(rString, indent+1, 1, "VkAttachmentReference2KHR", pStructIn.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pStruct->inputAttachmentCount, false, pStructIn.pInputAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t colorAttachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "colorAttachmentCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->colorAttachmentCount);
    *rString += "\n"; // GDS

    // const VkAttachmentReference2KHR* pColorAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pColorAttachments:              ";
    *rString += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pStruct->pColorAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pColorAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(rString, indent+1, 1, "VkAttachmentReference2KHR", pStructIn.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pStruct->colorAttachmentCount, false, pStructIn.pColorAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // const VkAttachmentReference2KHR* pResolveAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pResolveAttachments:            ";
    *rString += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pStruct->pResolveAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pResolveAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentReference2KHR>(rString, indent+1, 1, "VkAttachmentReference2KHR", pStructIn.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pStruct->colorAttachmentCount, false, pStructIn.pResolveAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // const VkAttachmentReference2KHR* pDepthStencilAttachment // SMB
    indentSpaces(rString, indent);
    *rString += "pDepthStencilAttachment:        ";
    *rString += "const VkAttachmentReference2KHR* = "; // TEQ
    if (pStruct->pDepthStencilAttachment == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDepthStencilAttachment->GetAddress()); // JHI
        structureToString<Decoded_VkAttachmentReference2KHR>(rString, *pStructIn.pDepthStencilAttachment->GetMetaStructPointer(), indent+1, baseAddr + offsetof(VkSubpassDescription2KHR, pDepthStencilAttachment)); // GLM
    }
    *rString += "\n"; // GDS

    // uint32_t preserveAttachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "preserveAttachmentCount:        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->preserveAttachmentCount);
    *rString += "\n"; // GDS

    // const uint32_t* pPreserveAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pPreserveAttachments:           ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pPreserveAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pPreserveAttachments.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pPreserveAttachments = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pPreserveAttachments.GetPointer()), "pPreserveAttachments", pStruct->preserveAttachmentCount,  vinfo_pPreserveAttachments);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkSubpassDependency2KHR>(std::string* rString, const Decoded_VkSubpassDependency2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubpassDependency2KHR *pStruct = (const VkSubpassDependency2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t srcSubpass // SMB
    indentSpaces(rString, indent);
    *rString += "srcSubpass:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->srcSubpass);
    *rString += "\n"; // GDS

    // uint32_t dstSubpass // SMB
    indentSpaces(rString, indent);
    *rString += "dstSubpass:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dstSubpass);
    *rString += "\n"; // GDS

    // VkPipelineStageFlags srcStageMask // SMB
    indentSpaces(rString, indent);
    *rString += "srcStageMask:                   ";
    *rString += "VkPipelineStageFlags = "; // TEQ
    flagsToString(rString, pStruct->srcStageMask, enumToString_VkPipelineStageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkPipelineStageFlags dstStageMask // SMB
    indentSpaces(rString, indent);
    *rString += "dstStageMask:                   ";
    *rString += "VkPipelineStageFlags = "; // TEQ
    flagsToString(rString, pStruct->dstStageMask, enumToString_VkPipelineStageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkAccessFlags srcAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "srcAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->srcAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkAccessFlags dstAccessMask // SMB
    indentSpaces(rString, indent);
    *rString += "dstAccessMask:                  ";
    *rString += "VkAccessFlags = "; // TEQ
    flagsToString(rString, pStruct->dstAccessMask, enumToString_VkAccessFlagBits); // URW
    *rString += "\n"; // GDS

    // VkDependencyFlags dependencyFlags // SMB
    indentSpaces(rString, indent);
    *rString += "dependencyFlags:                ";
    *rString += "VkDependencyFlags = "; // TEQ
    flagsToString(rString, pStruct->dependencyFlags, enumToString_VkDependencyFlagBits); // URW
    *rString += "\n"; // GDS

    // int32_t viewOffset // SMB
    indentSpaces(rString, indent);
    *rString += "viewOffset:                     ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->viewOffset);
}

template <>
void structureToString<Decoded_VkRenderPassCreateInfo2KHR>(std::string* rString, const Decoded_VkRenderPassCreateInfo2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRenderPassCreateInfo2KHR *pStruct = (const VkRenderPassCreateInfo2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkRenderPassCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkRenderPassCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkRenderPassCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t attachmentCount // SMB
    indentSpaces(rString, indent);
    *rString += "attachmentCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachmentCount);
    *rString += "\n"; // GDS

    // const VkAttachmentDescription2KHR* pAttachments // SMB
    indentSpaces(rString, indent);
    *rString += "pAttachments:                   ";
    *rString += "const VkAttachmentDescription2KHR* = "; // TEQ
    if (pStruct->pAttachments == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttachments->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentDescription2KHR>(rString, indent+1, 1, "VkAttachmentDescription2KHR", pStructIn.pAttachments->GetMetaStructPointer(), "pAttachments", pStruct->attachmentCount, false, pStructIn.pAttachments->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t subpassCount // SMB
    indentSpaces(rString, indent);
    *rString += "subpassCount:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subpassCount);
    *rString += "\n"; // GDS

    // const VkSubpassDescription2KHR* pSubpasses // SMB
    indentSpaces(rString, indent);
    *rString += "pSubpasses:                     ";
    *rString += "const VkSubpassDescription2KHR* = "; // TEQ
    if (pStruct->pSubpasses == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSubpasses->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSubpassDescription2KHR>(rString, indent+1, 1, "VkSubpassDescription2KHR", pStructIn.pSubpasses->GetMetaStructPointer(), "pSubpasses", pStruct->subpassCount, false, pStructIn.pSubpasses->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t dependencyCount // SMB
    indentSpaces(rString, indent);
    *rString += "dependencyCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dependencyCount);
    *rString += "\n"; // GDS

    // const VkSubpassDependency2KHR* pDependencies // SMB
    indentSpaces(rString, indent);
    *rString += "pDependencies:                  ";
    *rString += "const VkSubpassDependency2KHR* = "; // TEQ
    if (pStruct->pDependencies == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDependencies->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSubpassDependency2KHR>(rString, indent+1, 1, "VkSubpassDependency2KHR", pStructIn.pDependencies->GetMetaStructPointer(), "pDependencies", pStruct->dependencyCount, false, pStructIn.pDependencies->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t correlatedViewMaskCount // SMB
    indentSpaces(rString, indent);
    *rString += "correlatedViewMaskCount:        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->correlatedViewMaskCount);
    *rString += "\n"; // GDS

    // const uint32_t* pCorrelatedViewMasks // SMB
    indentSpaces(rString, indent);
    *rString += "pCorrelatedViewMasks:           ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pCorrelatedViewMasks == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCorrelatedViewMasks.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pCorrelatedViewMasks = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pCorrelatedViewMasks.GetPointer()), "pCorrelatedViewMasks", pStruct->correlatedViewMaskCount,  vinfo_pCorrelatedViewMasks);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkSubpassBeginInfoKHR>(std::string* rString, const Decoded_VkSubpassBeginInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubpassBeginInfoKHR *pStruct = (const VkSubpassBeginInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSubpassContents contents // SMB
    indentSpaces(rString, indent);
    *rString += "contents:                       ";
    *rString += "VkSubpassContents = "; // TEQ
    enumToString_VkSubpassContents(rString, pStruct->contents);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->contents);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkSubpassEndInfoKHR>(std::string* rString, const Decoded_VkSubpassEndInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubpassEndInfoKHR *pStruct = (const VkSubpassEndInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
}

void VulkanAsciiConsumer::Process_vkCreateRenderPass2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkRenderPassCreateInfo2KHR>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkRenderPass>&   pRenderPass)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassCreateInfo2KHR* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo2KHR* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassCreateInfo2KHR* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkRenderPassCreateInfo2KHR>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkRenderPass* pRenderPass // ARG
    if (pRenderPass.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = NULL", indentString.c_str(), "pRenderPass:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRenderPass* = ", indentString.c_str(), "pRenderPass:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pRenderPass.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginRenderPass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkRenderPassBeginInfo>& pRenderPassBegin,
    const StructPointerDecoder<Decoded_VkSubpassBeginInfoKHR>& pSubpassBeginInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkRenderPassBeginInfo* pRenderPassBegin // ARG
    if (pRenderPassBegin.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = NULL", indentString.c_str(), "pRenderPassBegin:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRenderPassBeginInfo* = ", indentString.c_str(), "pRenderPassBegin:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pRenderPassBegin.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkRenderPassBeginInfo>(&tmpString, *pRenderPassBegin.GetMetaStructPointer(), 2, pRenderPassBegin.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassBeginInfoKHR* pSubpassBeginInfo // ARG
    if (pSubpassBeginInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = NULL", indentString.c_str(), "pSubpassBeginInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = ", indentString.c_str(), "pSubpassBeginInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSubpassBeginInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSubpassBeginInfoKHR>(&tmpString, *pSubpassBeginInfo.GetMetaStructPointer(), 2, pSubpassBeginInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdNextSubpass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSubpassBeginInfoKHR>& pSubpassBeginInfo,
    const StructPointerDecoder<Decoded_VkSubpassEndInfoKHR>& pSubpassEndInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassBeginInfoKHR* pSubpassBeginInfo // ARG
    if (pSubpassBeginInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = NULL", indentString.c_str(), "pSubpassBeginInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassBeginInfoKHR* = ", indentString.c_str(), "pSubpassBeginInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSubpassBeginInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSubpassBeginInfoKHR>(&tmpString, *pSubpassBeginInfo.GetMetaStructPointer(), 2, pSubpassBeginInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassEndInfoKHR* pSubpassEndInfo // ARG
    if (pSubpassEndInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = NULL", indentString.c_str(), "pSubpassEndInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = ", indentString.c_str(), "pSubpassEndInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSubpassEndInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSubpassEndInfoKHR>(&tmpString, *pSubpassEndInfo.GetMetaStructPointer(), 2, pSubpassEndInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndRenderPass2KHR(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSubpassEndInfoKHR>& pSubpassEndInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSubpassEndInfoKHR* pSubpassEndInfo // ARG
    if (pSubpassEndInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = NULL", indentString.c_str(), "pSubpassEndInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSubpassEndInfoKHR* = ", indentString.c_str(), "pSubpassEndInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSubpassEndInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSubpassEndInfoKHR>(&tmpString, *pSubpassEndInfo.GetMetaStructPointer(), 2, pSubpassEndInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>(std::string* rString, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>(std::string* rString, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSharedPresentSurfaceCapabilitiesKHR *pStruct = (const VkSharedPresentSurfaceCapabilitiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageUsageFlags sharedPresentSupportedUsageFlags // SMB
    indentSpaces(rString, indent);
    *rString += "sharedPresentSupportedUsageFlags: ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->sharedPresentSupportedUsageFlags, enumToString_VkImageUsageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetSwapchainStatusKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetSwapchainStatusKHR(device, swapchain)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkExternalFenceHandleTypeFlagBitsKHR(std::string* rString, VkExternalFenceHandleTypeFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkExternalFenceHandleTypeFlagBits(rString, enumValue);
}


void enumToString_VkExternalFenceFeatureFlagBitsKHR(std::string* rString, VkExternalFenceFeatureFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkExternalFenceFeatureFlagBits(rString, enumValue);
}


void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>& pExternalFenceInfo,
    const StructPointerDecoder<Decoded_VkExternalFenceProperties>& pExternalFenceProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo // ARG
    if (pExternalFenceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = NULL", indentString.c_str(), "pExternalFenceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceExternalFenceInfo* = ", indentString.c_str(), "pExternalFenceInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalFenceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceExternalFenceInfo>(&tmpString, *pExternalFenceInfo.GetMetaStructPointer(), 2, pExternalFenceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalFenceProperties* pExternalFenceProperties // ARG
    if (pExternalFenceProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = NULL", indentString.c_str(), "pExternalFenceProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalFenceProperties* = ", indentString.c_str(), "pExternalFenceProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalFenceProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExternalFenceProperties>(&tmpString, *pExternalFenceProperties.GetMetaStructPointer(), 2, pExternalFenceProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkFenceImportFlagBitsKHR(std::string* rString, VkFenceImportFlagBitsKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkFenceImportFlagBits(rString, enumValue);
}

template <> void structureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(std::string* rString, const Decoded_VkImportFenceWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExportFenceWin32HandleInfoKHR>(std::string* rString, const Decoded_VkExportFenceWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(std::string* rString, const Decoded_VkFenceGetWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(std::string* rString, const Decoded_VkImportFenceWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportFenceWin32HandleInfoKHR *pStruct = (const VkImportFenceWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFence fence // SMB
    indentSpaces(rString, indent);
    *rString += "fence:                          ";
    *rString += "VkFence = "; // TEQ
    addrToString(rString, pStructIn.fence); // PAQ  
    *rString += "\n"; // GDS

    // VkFenceImportFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkFenceImportFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkFenceImportFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalFenceHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* handle // SMB
    indentSpaces(rString, indent);
    *rString += "handle:                         ";
    *rString += "void* = "; // TEQ
    if (pStruct->handle == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.handle); // PWR
    }
    *rString += "\n"; // GDS

    // const wchar_t* name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "const wchar_t* = "; // TEQ
    if (pStruct->name == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.name.GetAddress()); // PWQ
    }
}

template <>
void structureToString<Decoded_VkExportFenceWin32HandleInfoKHR>(std::string* rString, const Decoded_VkExportFenceWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExportFenceWin32HandleInfoKHR *pStruct = (const VkExportFenceWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    indentSpaces(rString, indent);
    *rString += "pAttributes:                    ";
    *rString += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pStruct->pAttributes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttributes->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t dwAccess // SMB
    indentSpaces(rString, indent);
    *rString += "dwAccess:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dwAccess);
    *rString += "\n"; // GDS

    // const wchar_t* name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "const wchar_t* = "; // TEQ
    if (pStruct->name == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.name.GetAddress()); // PWQ
    }
}

template <>
void structureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(std::string* rString, const Decoded_VkFenceGetWin32HandleInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkFenceGetWin32HandleInfoKHR *pStruct = (const VkFenceGetWin32HandleInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFence fence // SMB
    indentSpaces(rString, indent);
    *rString += "fence:                          ";
    *rString += "VkFence = "; // TEQ
    addrToString(rString, pStructIn.fence); // PAQ  
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalFenceHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkImportFenceWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportFenceWin32HandleInfoKHR>& pImportFenceWin32HandleInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo // ARG
    if (pImportFenceWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceWin32HandleInfoKHR* = NULL", indentString.c_str(), "pImportFenceWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceWin32HandleInfoKHR* = ", indentString.c_str(), "pImportFenceWin32HandleInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImportFenceWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImportFenceWin32HandleInfoKHR>(&tmpString, *pImportFenceWin32HandleInfo.GetMetaStructPointer(), 2, pImportFenceWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetFenceWin32HandleKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceGetWin32HandleInfoKHR>& pGetWin32HandleInfo,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo // ARG
    if (pGetWin32HandleInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetWin32HandleInfoKHR* = NULL", indentString.c_str(), "pGetWin32HandleInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetWin32HandleInfoKHR* = ", indentString.c_str(), "pGetWin32HandleInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pGetWin32HandleInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkFenceGetWin32HandleInfoKHR>(&tmpString, *pGetWin32HandleInfo.GetMetaStructPointer(), 2, pGetWin32HandleInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indentString.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indentString.c_str(), "pHandle:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkImportFenceFdInfoKHR>(std::string* rString, const Decoded_VkImportFenceFdInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkFenceGetFdInfoKHR>(std::string* rString, const Decoded_VkFenceGetFdInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportFenceFdInfoKHR>(std::string* rString, const Decoded_VkImportFenceFdInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportFenceFdInfoKHR *pStruct = (const VkImportFenceFdInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFence fence // SMB
    indentSpaces(rString, indent);
    *rString += "fence:                          ";
    *rString += "VkFence = "; // TEQ
    addrToString(rString, pStructIn.fence); // PAQ  
    *rString += "\n"; // GDS

    // VkFenceImportFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkFenceImportFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkFenceImportFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalFenceHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
    *rString += "\n"; // GDS

    // int fd // SMB
    indentSpaces(rString, indent);
    *rString += "fd:                             ";
    *rString += "int = "; // TEQ
    signedDecimalToString(rString, pStruct->fd);
}

template <>
void structureToString<Decoded_VkFenceGetFdInfoKHR>(std::string* rString, const Decoded_VkFenceGetFdInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkFenceGetFdInfoKHR *pStruct = (const VkFenceGetFdInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFence fence // SMB
    indentSpaces(rString, indent);
    *rString += "fence:                          ";
    *rString += "VkFence = "; // TEQ
    addrToString(rString, pStructIn.fence); // PAQ  
    *rString += "\n"; // GDS

    // VkExternalFenceHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalFenceHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalFenceHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkImportFenceFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImportFenceFdInfoKHR>& pImportFenceFdInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkImportFenceFdKHR(device, pImportFenceFdInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImportFenceFdInfoKHR* pImportFenceFdInfo // ARG
    if (pImportFenceFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceFdInfoKHR* = NULL", indentString.c_str(), "pImportFenceFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImportFenceFdInfoKHR* = ", indentString.c_str(), "pImportFenceFdInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pImportFenceFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImportFenceFdInfoKHR>(&tmpString, *pImportFenceFdInfo.GetMetaStructPointer(), 2, pImportFenceFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetFenceFdKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkFenceGetFdInfoKHR>& pGetFdInfo,
    const PointerDecoder<int>&                  pFd)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetFenceFdKHR(device, pGetFdInfo, pFd)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkFenceGetFdInfoKHR* pGetFdInfo // ARG
    if (pGetFdInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetFdInfoKHR* = NULL", indentString.c_str(), "pGetFdInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkFenceGetFdInfoKHR* = ", indentString.c_str(), "pGetFdInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pGetFdInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkFenceGetFdInfoKHR>(&tmpString, *pGetFdInfo.GetMetaStructPointer(), 2, pGetFdInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // int* pFd // ARG
    if (pFd.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sint* = NULL", indentString.c_str(), "pFd:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sint* = %" PRId64 "", indentString.c_str(), "pFd:", static_cast<uint64_t>(*pFd.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkPointClippingBehaviorKHR(std::string* rString, VkPointClippingBehaviorKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkPointClippingBehavior(rString, enumValue);
}


void enumToString_VkTessellationDomainOriginKHR(std::string* rString, VkTessellationDomainOriginKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkTessellationDomainOrigin(rString, enumValue);
}

template <> void structureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(std::string* rString, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSurfaceCapabilities2KHR>(std::string* rString, const Decoded_VkSurfaceCapabilities2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSurfaceFormat2KHR>(std::string* rString, const Decoded_VkSurfaceFormat2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(std::string* rString, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceSurfaceInfo2KHR *pStruct = (const VkPhysicalDeviceSurfaceInfo2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSurfaceKHR surface // SMB
    indentSpaces(rString, indent);
    *rString += "surface:                        ";
    *rString += "VkSurfaceKHR = "; // TEQ
    addrToString(rString, pStructIn.surface); // PAQ  
}

template <>
void structureToString<Decoded_VkSurfaceCapabilities2KHR>(std::string* rString, const Decoded_VkSurfaceCapabilities2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceCapabilities2KHR *pStruct = (const VkSurfaceCapabilities2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSurfaceCapabilitiesKHR surfaceCapabilities // SMB
    indentSpaces(rString, indent);
    *rString += "surfaceCapabilities:            ";
    *rString += "VkSurfaceCapabilitiesKHR = "; // TEQ
    structureToString<Decoded_VkSurfaceCapabilitiesKHR>(rString, *pStructIn.surfaceCapabilities, indent+1,  baseAddr + offsetof(VkSurfaceCapabilities2KHR, surfaceCapabilities)); // AZJ
}

template <>
void structureToString<Decoded_VkSurfaceFormat2KHR>(std::string* rString, const Decoded_VkSurfaceFormat2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceFormat2KHR *pStruct = (const VkSurfaceFormat2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSurfaceFormatKHR surfaceFormat // SMB
    indentSpaces(rString, indent);
    *rString += "surfaceFormat:                  ";
    *rString += "VkSurfaceFormatKHR = "; // TEQ
    structureToString<Decoded_VkSurfaceFormatKHR>(rString, *pStructIn.surfaceFormat, indent+1,  baseAddr + offsetof(VkSurfaceFormat2KHR, surfaceFormat)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilities2KHR>& pSurfaceCapabilities)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indentString.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indentString.c_str(), "pSurfaceInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmpString, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCapabilities2KHR* pSurfaceCapabilities // ARG
    if (pSurfaceCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2KHR* = NULL", indentString.c_str(), "pSurfaceCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2KHR* = ", indentString.c_str(), "pSurfaceCapabilities:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSurfaceCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSurfaceCapabilities2KHR>(&tmpString, *pSurfaceCapabilities.GetMetaStructPointer(), 2, pSurfaceCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<uint32_t>&             pSurfaceFormatCount,
    const StructPointerDecoder<Decoded_VkSurfaceFormat2KHR>& pSurfaceFormats)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indentString.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indentString.c_str(), "pSurfaceInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmpString, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSurfaceFormatCount // ARG
    if (pSurfaceFormatCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pSurfaceFormatCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pSurfaceFormatCount:", static_cast<uint64_t>(*pSurfaceFormatCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceFormat2KHR* pSurfaceFormats // ARG
    if (pSurfaceFormats.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormat2KHR* = NULL", indentString.c_str(), "pSurfaceFormats:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceFormat2KHR* = ", indentString.c_str(), "pSurfaceFormats:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pSurfaceFormats.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSurfaceFormat2KHR>(&tmpString, 2, 1, "VkSurfaceFormat2KHR",
            pSurfaceFormats.GetMetaStructPointer(), "pSurfaceFormats", *pSurfaceFormatCount.GetPointer(), false, pSurfaceFormats.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkDisplayProperties2KHR>(std::string* rString, const Decoded_VkDisplayProperties2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayPlaneProperties2KHR>(std::string* rString, const Decoded_VkDisplayPlaneProperties2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayModeProperties2KHR>(std::string* rString, const Decoded_VkDisplayModeProperties2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayPlaneInfo2KHR>(std::string* rString, const Decoded_VkDisplayPlaneInfo2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(std::string* rString, const Decoded_VkDisplayPlaneCapabilities2KHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDisplayProperties2KHR>(std::string* rString, const Decoded_VkDisplayProperties2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayProperties2KHR *pStruct = (const VkDisplayProperties2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayPropertiesKHR displayProperties // SMB
    indentSpaces(rString, indent);
    *rString += "displayProperties:              ";
    *rString += "VkDisplayPropertiesKHR = "; // TEQ
    structureToString<Decoded_VkDisplayPropertiesKHR>(rString, *pStructIn.displayProperties, indent+1,  baseAddr + offsetof(VkDisplayProperties2KHR, displayProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkDisplayPlaneProperties2KHR>(std::string* rString, const Decoded_VkDisplayPlaneProperties2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPlaneProperties2KHR *pStruct = (const VkDisplayPlaneProperties2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayPlanePropertiesKHR displayPlaneProperties // SMB
    indentSpaces(rString, indent);
    *rString += "displayPlaneProperties:         ";
    *rString += "VkDisplayPlanePropertiesKHR = "; // TEQ
    structureToString<Decoded_VkDisplayPlanePropertiesKHR>(rString, *pStructIn.displayPlaneProperties, indent+1,  baseAddr + offsetof(VkDisplayPlaneProperties2KHR, displayPlaneProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkDisplayModeProperties2KHR>(std::string* rString, const Decoded_VkDisplayModeProperties2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayModeProperties2KHR *pStruct = (const VkDisplayModeProperties2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayModePropertiesKHR displayModeProperties // SMB
    indentSpaces(rString, indent);
    *rString += "displayModeProperties:          ";
    *rString += "VkDisplayModePropertiesKHR = "; // TEQ
    structureToString<Decoded_VkDisplayModePropertiesKHR>(rString, *pStructIn.displayModeProperties, indent+1,  baseAddr + offsetof(VkDisplayModeProperties2KHR, displayModeProperties)); // AZJ
}

template <>
void structureToString<Decoded_VkDisplayPlaneInfo2KHR>(std::string* rString, const Decoded_VkDisplayPlaneInfo2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPlaneInfo2KHR *pStruct = (const VkDisplayPlaneInfo2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayModeKHR mode // SMB
    indentSpaces(rString, indent);
    *rString += "mode:                           ";
    *rString += "VkDisplayModeKHR = "; // TEQ
    addrToString(rString, pStructIn.mode); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t planeIndex // SMB
    indentSpaces(rString, indent);
    *rString += "planeIndex:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->planeIndex);
}

template <>
void structureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(std::string* rString, const Decoded_VkDisplayPlaneCapabilities2KHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPlaneCapabilities2KHR *pStruct = (const VkDisplayPlaneCapabilities2KHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayPlaneCapabilitiesKHR capabilities // SMB
    indentSpaces(rString, indent);
    *rString += "capabilities:                   ";
    *rString += "VkDisplayPlaneCapabilitiesKHR = "; // TEQ
    structureToString<Decoded_VkDisplayPlaneCapabilitiesKHR>(rString, *pStructIn.capabilities, indent+1,  baseAddr + offsetof(VkDisplayPlaneCapabilities2KHR, capabilities)); // AZJ
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayProperties2KHR>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayProperties2KHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayProperties2KHR* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayProperties2KHR* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkDisplayProperties2KHR>(&tmpString, 2, 1, "VkDisplayProperties2KHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayPlaneProperties2KHR>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlaneProperties2KHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneProperties2KHR* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneProperties2KHR* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkDisplayPlaneProperties2KHR>(&tmpString, 2, 1, "VkDisplayPlaneProperties2KHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayModeProperties2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkDisplayModeProperties2KHR>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indentString.c_str(), "display:"); // TRP
    tmpString = "";
    addrToString(&tmpString, display);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayModeProperties2KHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeProperties2KHR* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayModeProperties2KHR* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkDisplayModeProperties2KHR>(&tmpString, 2, 1, "VkDisplayModeProperties2KHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDisplayPlaneCapabilities2KHR(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDisplayPlaneInfo2KHR>& pDisplayPlaneInfo,
    const StructPointerDecoder<Decoded_VkDisplayPlaneCapabilities2KHR>& pCapabilities)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo // ARG
    if (pDisplayPlaneInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPlaneInfo2KHR* = NULL", indentString.c_str(), "pDisplayPlaneInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPlaneInfo2KHR* = ", indentString.c_str(), "pDisplayPlaneInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pDisplayPlaneInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDisplayPlaneInfo2KHR>(&tmpString, *pDisplayPlaneInfo.GetMetaStructPointer(), 2, pDisplayPlaneInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayPlaneCapabilities2KHR* pCapabilities // ARG
    if (pCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilities2KHR* = NULL", indentString.c_str(), "pCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayPlaneCapabilities2KHR* = ", indentString.c_str(), "pCapabilities:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDisplayPlaneCapabilities2KHR>(&tmpString, *pCapabilities.GetMetaStructPointer(), 2, pCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetImageMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageMemoryRequirementsInfo2* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageMemoryRequirementsInfo2>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indentString.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indentString.c_str(), "pMemoryRequirements:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryRequirements2>(&tmpString, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetBufferMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2>& pMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferMemoryRequirementsInfo2* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkBufferMemoryRequirementsInfo2>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = NULL", indentString.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2* = ", indentString.c_str(), "pMemoryRequirements:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryRequirements2>(&tmpString, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetImageSparseMemoryRequirements2KHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>& pInfo,
    const PointerDecoder<uint32_t>&             pSparseMemoryRequirementCount,
    const StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>& pSparseMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageSparseMemoryRequirementsInfo2* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageSparseMemoryRequirementsInfo2* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageSparseMemoryRequirementsInfo2>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pSparseMemoryRequirementCount // ARG
    if (pSparseMemoryRequirementCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pSparseMemoryRequirementCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pSparseMemoryRequirementCount:", static_cast<uint64_t>(*pSparseMemoryRequirementCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSparseImageMemoryRequirements2* pSparseMemoryRequirements // ARG
    if (pSparseMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = NULL", indentString.c_str(), "pSparseMemoryRequirements:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSparseImageMemoryRequirements2* = ", indentString.c_str(), "pSparseMemoryRequirements:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pSparseMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkSparseImageMemoryRequirements2>(&tmpString, 2, 1, "VkSparseImageMemoryRequirements2",
            pSparseMemoryRequirements.GetMetaStructPointer(), "pSparseMemoryRequirements", *pSparseMemoryRequirementCount.GetPointer(), false, pSparseMemoryRequirements.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkSamplerYcbcrModelConversionKHR(std::string* rString, VkSamplerYcbcrModelConversionKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkSamplerYcbcrModelConversion(rString, enumValue);
}


void enumToString_VkSamplerYcbcrRangeKHR(std::string* rString, VkSamplerYcbcrRangeKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkSamplerYcbcrRange(rString, enumValue);
}


void enumToString_VkChromaLocationKHR(std::string* rString, VkChromaLocationKHR enumValue)
{
    assert(rString != nullptr);
    enumToString_VkChromaLocation(rString, enumValue);
}


void VulkanAsciiConsumer::Process_vkCreateSamplerYcbcrConversionKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSamplerYcbcrConversion>& pYcbcrConversion)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSamplerYcbcrConversionCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSamplerYcbcrConversionCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSamplerYcbcrConversionCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion* pYcbcrConversion // ARG
    if (pYcbcrConversion.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = NULL", indentString.c_str(), "pYcbcrConversion:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion* = ", indentString.c_str(), "pYcbcrConversion:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pYcbcrConversion.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroySamplerYcbcrConversionKHR(
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSamplerYcbcrConversion ycbcrConversion // ARG
    fprintf(GetFile(), "%s%-32sVkSamplerYcbcrConversion = ", indentString.c_str(), "ycbcrConversion:"); // TRP
    tmpString = "";
    addrToString(&tmpString, ycbcrConversion);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkBindBufferMemory2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>& pBindInfos)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindBufferMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = NULL", indentString.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindBufferMemoryInfo* = ", indentString.c_str(), "pBindInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBindBufferMemoryInfo>(&tmpString, 2, 1, "VkBindBufferMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindImageMemory2KHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindImageMemoryInfo>& pBindInfos)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindImageMemoryInfo* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = NULL", indentString.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindImageMemoryInfo* = ", indentString.c_str(), "pBindInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBindImageMemoryInfo>(&tmpString, 2, 1, "VkBindImageMemoryInfo",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkGetDescriptorSetLayoutSupportKHR(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>& pSupport)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDescriptorSetLayoutCreateInfo* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDescriptorSetLayoutCreateInfo* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorSetLayoutCreateInfo>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDescriptorSetLayoutSupport* pSupport // ARG
    if (pSupport.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = NULL", indentString.c_str(), "pSupport:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDescriptorSetLayoutSupport* = ", indentString.c_str(), "pSupport:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSupport.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDescriptorSetLayoutSupport>(&tmpString, *pSupport.GetMetaStructPointer(), 2, pSupport.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdDrawIndirectCountKHR(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "countBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, countBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirectCountKHR(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "countBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, countBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkResolveModeFlagBitsKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkResolveModeFlagBitsKHR enumValue = static_cast<VkResolveModeFlagBitsKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR:
            *rString += std::string("VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR");
            return;
        case VK_RESOLVE_MODE_NONE_KHR:
            *rString += std::string("VK_RESOLVE_MODE_NONE_KHR");
            return;
        case VK_RESOLVE_MODE_MIN_BIT_KHR:
            *rString += std::string("VK_RESOLVE_MODE_MIN_BIT_KHR");
            return;
        case VK_RESOLVE_MODE_AVERAGE_BIT_KHR:
            *rString += std::string("VK_RESOLVE_MODE_AVERAGE_BIT_KHR");
            return;
        case VK_RESOLVE_MODE_MAX_BIT_KHR:
            *rString += std::string("VK_RESOLVE_MODE_MAX_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSemaphoreTypeKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkSemaphoreTypeKHR enumValue = static_cast<VkSemaphoreTypeKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SEMAPHORE_TYPE_TIMELINE_KHR:
            *rString += std::string("VK_SEMAPHORE_TYPE_TIMELINE_KHR");
            return;
        case VK_SEMAPHORE_TYPE_BINARY_KHR:
            *rString += std::string("VK_SEMAPHORE_TYPE_BINARY_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkShaderFloatControlsIndependenceKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkShaderFloatControlsIndependenceKHR enumValue = static_cast<VkShaderFloatControlsIndependenceKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR:
            *rString += std::string("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR");
            return;
        case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR:
            *rString += std::string("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR");
            return;
        case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR:
            *rString += std::string("VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkSemaphoreWaitFlagBitsKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkSemaphoreWaitFlagBitsKHR enumValue = static_cast<VkSemaphoreWaitFlagBitsKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SEMAPHORE_WAIT_ANY_BIT_KHR:
            *rString += std::string("VK_SEMAPHORE_WAIT_ANY_BIT_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDriverIdKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkDriverIdKHR enumValue = static_cast<VkDriverIdKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR:
            *rString += std::string("VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR");
            return;
        case VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR:
            *rString += std::string("VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR:
            *rString += std::string("VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR:
            *rString += std::string("VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR");
            return;
        case VK_DRIVER_ID_MESA_RADV_KHR:
            *rString += std::string("VK_DRIVER_ID_MESA_RADV_KHR");
            return;
        case VK_DRIVER_ID_ARM_PROPRIETARY_KHR:
            *rString += std::string("VK_DRIVER_ID_ARM_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR:
            *rString += std::string("VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_AMD_PROPRIETARY_KHR:
            *rString += std::string("VK_DRIVER_ID_AMD_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR:
            *rString += std::string("VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR");
            return;
        case VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR:
            *rString += std::string("VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_GGP_PROPRIETARY_KHR:
            *rString += std::string("VK_DRIVER_ID_GGP_PROPRIETARY_KHR");
            return;
        case VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR:
            *rString += std::string("VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>(std::string* rString, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR>(std::string* rString, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSemaphoreTypeCreateInfoKHR>(std::string* rString, const Decoded_VkSemaphoreTypeCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkTimelineSemaphoreSubmitInfoKHR>(std::string* rString, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSemaphoreWaitInfoKHR>(std::string* rString, const Decoded_VkSemaphoreWaitInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSemaphoreSignalInfoKHR>(std::string* rString, const Decoded_VkSemaphoreSignalInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>(std::string* rString, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *pStruct = (const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 timelineSemaphore // SMB
    indentSpaces(rString, indent);
    *rString += "timelineSemaphore:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->timelineSemaphore);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR>(std::string* rString, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *pStruct = (const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint64_t maxTimelineSemaphoreValueDifference // SMB
    indentSpaces(rString, indent);
    *rString += "maxTimelineSemaphoreValueDifference: ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTimelineSemaphoreValueDifference);
}

template <>
void structureToString<Decoded_VkSemaphoreTypeCreateInfoKHR>(std::string* rString, const Decoded_VkSemaphoreTypeCreateInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSemaphoreTypeCreateInfoKHR *pStruct = (const VkSemaphoreTypeCreateInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphoreTypeKHR semaphoreType // SMB
    indentSpaces(rString, indent);
    *rString += "semaphoreType:                  ";
    *rString += "VkSemaphoreTypeKHR = "; // TEQ
    enumToString_VkSemaphoreTypeKHR(rString, pStruct->semaphoreType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->semaphoreType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint64_t initialValue // SMB
    indentSpaces(rString, indent);
    *rString += "initialValue:                   ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->initialValue);
}

template <>
void structureToString<Decoded_VkTimelineSemaphoreSubmitInfoKHR>(std::string* rString, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkTimelineSemaphoreSubmitInfoKHR *pStruct = (const VkTimelineSemaphoreSubmitInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t waitSemaphoreValueCount // SMB
    indentSpaces(rString, indent);
    *rString += "waitSemaphoreValueCount:        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->waitSemaphoreValueCount);
    *rString += "\n"; // GDS

    // const uint64_t* pWaitSemaphoreValues // SMB
    indentSpaces(rString, indent);
    *rString += "pWaitSemaphoreValues:           ";
    *rString += "const uint64_t* = "; // TEQ
    if (pStruct->pWaitSemaphoreValues == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pWaitSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        arrayToString<const uint64_t*>(rString, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pStructIn.pWaitSemaphoreValues.GetPointer()), "pWaitSemaphoreValues", pStruct->waitSemaphoreValueCount,  vinfo_pWaitSemaphoreValues);  // CCQ
    }
    *rString += "\n"; // GDS

    // uint32_t signalSemaphoreValueCount // SMB
    indentSpaces(rString, indent);
    *rString += "signalSemaphoreValueCount:      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->signalSemaphoreValueCount);
    *rString += "\n"; // GDS

    // const uint64_t* pSignalSemaphoreValues // SMB
    indentSpaces(rString, indent);
    *rString += "pSignalSemaphoreValues:         ";
    *rString += "const uint64_t* = "; // TEQ
    if (pStruct->pSignalSemaphoreValues == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSignalSemaphoreValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        arrayToString<const uint64_t*>(rString, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pStructIn.pSignalSemaphoreValues.GetPointer()), "pSignalSemaphoreValues", pStruct->signalSemaphoreValueCount,  vinfo_pSignalSemaphoreValues);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkSemaphoreWaitInfoKHR>(std::string* rString, const Decoded_VkSemaphoreWaitInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSemaphoreWaitInfoKHR *pStruct = (const VkSemaphoreWaitInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphoreWaitFlagsKHR flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkSemaphoreWaitFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkSemaphoreWaitFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // uint32_t semaphoreCount // SMB
    indentSpaces(rString, indent);
    *rString += "semaphoreCount:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->semaphoreCount);
    *rString += "\n"; // GDS

    // const VkSemaphore* pSemaphores // SMB
    indentSpaces(rString, indent);
    *rString += "pSemaphores:                    ";
    *rString += "const VkSemaphore* = "; // TEQ
    if (pStruct->pSemaphores == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSemaphores.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pSemaphores = {true, false, false, nullptr};
        arrayToString<const VkSemaphore*>(rString, indent, 1, "const VkSemaphore*", reinterpret_cast<const VkSemaphore*>(pStructIn.pSemaphores.GetPointer()), "pSemaphores", pStruct->semaphoreCount,  vinfo_pSemaphores);  // CCQ
    }
    *rString += "\n"; // GDS

    // const uint64_t* pValues // SMB
    indentSpaces(rString, indent);
    *rString += "pValues:                        ";
    *rString += "const uint64_t* = "; // TEQ
    if (pStruct->pValues == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pValues.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pValues = {false, false, false, nullptr};
        arrayToString<const uint64_t*>(rString, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pStructIn.pValues.GetPointer()), "pValues", pStruct->semaphoreCount,  vinfo_pValues);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkSemaphoreSignalInfoKHR>(std::string* rString, const Decoded_VkSemaphoreSignalInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSemaphoreSignalInfoKHR *pStruct = (const VkSemaphoreSignalInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSemaphore semaphore // SMB
    indentSpaces(rString, indent);
    *rString += "semaphore:                      ";
    *rString += "VkSemaphore = "; // TEQ
    addrToString(rString, pStructIn.semaphore); // PAQ  
    *rString += "\n"; // GDS

    // uint64_t value // SMB
    indentSpaces(rString, indent);
    *rString += "value:                          ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->value);
}

void VulkanAsciiConsumer::Process_vkGetSemaphoreCounterValueKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            semaphore,
    const PointerDecoder<uint64_t>&             pValue)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetSemaphoreCounterValueKHR(device, semaphore, pValue)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSemaphore semaphore // ARG
    fprintf(GetFile(), "%s%-32sVkSemaphore = ", indentString.c_str(), "semaphore:"); // TRP
    tmpString = "";
    addrToString(&tmpString, semaphore);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pValue // ARG
    if (pValue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indentString.c_str(), "pValue:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indentString.c_str(), "pValue:", static_cast<uint64_t>(*pValue.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkWaitSemaphoresKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreWaitInfoKHR>& pWaitInfo,
    uint64_t                                    timeout)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkWaitSemaphoresKHR(device, pWaitInfo, timeout)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreWaitInfoKHR* pWaitInfo // ARG
    if (pWaitInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreWaitInfoKHR* = NULL", indentString.c_str(), "pWaitInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreWaitInfoKHR* = ", indentString.c_str(), "pWaitInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pWaitInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSemaphoreWaitInfoKHR>(&tmpString, *pWaitInfo.GetMetaStructPointer(), 2, pWaitInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t timeout // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indentString.c_str(), "timeout:", timeout); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkSignalSemaphoreKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkSemaphoreSignalInfoKHR>& pSignalInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkSignalSemaphoreKHR(device, pSignalInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSemaphoreSignalInfoKHR* pSignalInfo // ARG
    if (pSignalInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreSignalInfoKHR* = NULL", indentString.c_str(), "pSignalInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSemaphoreSignalInfoKHR* = ", indentString.c_str(), "pSignalInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSignalInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSemaphoreSignalInfoKHR>(&tmpString, *pSignalInfo.GetMetaStructPointer(), 2, pSignalInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkPipelineExecutableStatisticFormatKHR(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineExecutableStatisticFormatKHR enumValue = static_cast<VkPipelineExecutableStatisticFormatKHR>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR:
            *rString += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR");
            return;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR:
            *rString += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR");
            return;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR:
            *rString += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR");
            return;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR:
            *rString += std::string("VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(std::string* rString, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineInfoKHR>(std::string* rString, const Decoded_VkPipelineInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineExecutablePropertiesKHR>(std::string* rString, const Decoded_VkPipelineExecutablePropertiesKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineExecutableInfoKHR>(std::string* rString, const Decoded_VkPipelineExecutableInfoKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(std::string* rString, const Decoded_VkPipelineExecutableStatisticValueKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineExecutableStatisticKHR>(std::string* rString, const Decoded_VkPipelineExecutableStatisticKHR &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(std::string* rString, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(std::string* rString, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *pStruct = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 pipelineExecutableInfo // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineExecutableInfo:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->pipelineExecutableInfo);
}

template <>
void structureToString<Decoded_VkPipelineInfoKHR>(std::string* rString, const Decoded_VkPipelineInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineInfoKHR *pStruct = (const VkPipelineInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipeline pipeline // SMB
    indentSpaces(rString, indent);
    *rString += "pipeline:                       ";
    *rString += "VkPipeline = "; // TEQ
    addrToString(rString, pStructIn.pipeline); // PAQ  
}

template <>
void structureToString<Decoded_VkPipelineExecutablePropertiesKHR>(std::string* rString, const Decoded_VkPipelineExecutablePropertiesKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineExecutablePropertiesKHR *pStruct = (const VkPipelineExecutablePropertiesKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkShaderStageFlags stages // SMB
    indentSpaces(rString, indent);
    *rString += "stages:                         ";
    *rString += "VkShaderStageFlags = "; // TEQ
    flagsToString(rString, pStruct->stages, enumToString_VkShaderStageFlagBits); // URW
    *rString += "\n"; // GDS

    // char name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_name = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *rString += "\n"; // GDS

    // char description // SMB
    indentSpaces(rString, indent);
    *rString += "description:                    ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *rString += "\n"; // GDS

    // uint32_t subgroupSize // SMB
    indentSpaces(rString, indent);
    *rString += "subgroupSize:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subgroupSize);
}

template <>
void structureToString<Decoded_VkPipelineExecutableInfoKHR>(std::string* rString, const Decoded_VkPipelineExecutableInfoKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineExecutableInfoKHR *pStruct = (const VkPipelineExecutableInfoKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipeline pipeline // SMB
    indentSpaces(rString, indent);
    *rString += "pipeline:                       ";
    *rString += "VkPipeline = "; // TEQ
    addrToString(rString, pStructIn.pipeline); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t executableIndex // SMB
    indentSpaces(rString, indent);
    *rString += "executableIndex:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->executableIndex);
}

template <>
void structureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(std::string* rString, const Decoded_VkPipelineExecutableStatisticValueKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineExecutableStatisticValueKHR *pStruct = (const VkPipelineExecutableStatisticValueKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkBool32 b32 // SMB
    indentSpaces(rString, indent);
    *rString += "b32:                            ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->b32);
    *rString += "\n"; // GDS

    // int64_t i64 // SMB
    indentSpaces(rString, indent);
    *rString += "i64:                            ";
    *rString += "int64_t = "; // TEQ
    signedDecimalToString(rString, pStruct->i64);
    *rString += "\n"; // GDS

    // uint64_t u64 // SMB
    indentSpaces(rString, indent);
    *rString += "u64:                            ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->u64);
    *rString += "\n"; // GDS

    // double f64 // SMB
    indentSpaces(rString, indent);
    *rString += "f64:                            ";
    *rString += "double = "; // TEQ
    doubleToString(rString, pStruct->f64);
}

template <>
void structureToString<Decoded_VkPipelineExecutableStatisticKHR>(std::string* rString, const Decoded_VkPipelineExecutableStatisticKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineExecutableStatisticKHR *pStruct = (const VkPipelineExecutableStatisticKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // char name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_name = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *rString += "\n"; // GDS

    // char description // SMB
    indentSpaces(rString, indent);
    *rString += "description:                    ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *rString += "\n"; // GDS

    // VkPipelineExecutableStatisticFormatKHR format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkPipelineExecutableStatisticFormatKHR = "; // TEQ
    enumToString_VkPipelineExecutableStatisticFormatKHR(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkPipelineExecutableStatisticValueKHR value // SMB
    indentSpaces(rString, indent);
    *rString += "value:                          ";
    *rString += "VkPipelineExecutableStatisticValueKHR = "; // TEQ
    *rString += "(Union):"; // RGT
    structureToString<Decoded_VkPipelineExecutableStatisticValueKHR>(rString, *pStructIn.value, indent+1,  baseAddr + offsetof(VkPipelineExecutableStatisticKHR, value)); // AZJ
}

template <>
void structureToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(std::string* rString, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineExecutableInternalRepresentationKHR *pStruct = (const VkPipelineExecutableInternalRepresentationKHR *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // char name // SMB
    indentSpaces(rString, indent);
    *rString += "name:                           ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_name = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->name), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // JPA
    *rString += "\n"; // GDS

    // char description // SMB
    indentSpaces(rString, indent);
    *rString += "description:                    ";
    *rString += "char = "; // TEQ
    ValueToStringStruct vinfo_description = {false, false, false, nullptr};
    arrayToString<char*>(rString, indent, 0, "char", const_cast<char*>(pStruct->description), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // JPA
    *rString += "\n"; // GDS

    // VkBool32 isText // SMB
    indentSpaces(rString, indent);
    *rString += "isText:                         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->isText);
    *rString += "\n"; // GDS

    // size_t dataSize // SMB
    indentSpaces(rString, indent);
    *rString += "dataSize:                       ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dataSize);
    *rString += "\n"; // GDS

    // void* pData // SMB
    indentSpaces(rString, indent);
    *rString += "pData:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pData.GetAddress()); // AHW
    }
}

void VulkanAsciiConsumer::Process_vkGetPipelineExecutablePropertiesKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineInfoKHR>& pPipelineInfo,
    const PointerDecoder<uint32_t>&             pExecutableCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutablePropertiesKHR>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineInfoKHR* pPipelineInfo // ARG
    if (pPipelineInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineInfoKHR* = NULL", indentString.c_str(), "pPipelineInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineInfoKHR* = ", indentString.c_str(), "pPipelineInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pPipelineInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPipelineInfoKHR>(&tmpString, *pPipelineInfo.GetMetaStructPointer(), 2, pPipelineInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pExecutableCount // ARG
    if (pExecutableCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pExecutableCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pExecutableCount:", static_cast<uint64_t>(*pExecutableCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineExecutablePropertiesKHR* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutablePropertiesKHR* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutablePropertiesKHR* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkPipelineExecutablePropertiesKHR>(&tmpString, 2, 1, "VkPipelineExecutablePropertiesKHR",
            pProperties.GetMetaStructPointer(), "pProperties", *pExecutableCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineExecutableStatisticsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>& pExecutableInfo,
    const PointerDecoder<uint32_t>&             pStatisticCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutableStatisticKHR>& pStatistics)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineExecutableInfoKHR* pExecutableInfo // ARG
    if (pExecutableInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = NULL", indentString.c_str(), "pExecutableInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = ", indentString.c_str(), "pExecutableInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExecutableInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPipelineExecutableInfoKHR>(&tmpString, *pExecutableInfo.GetMetaStructPointer(), 2, pExecutableInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pStatisticCount // ARG
    if (pStatisticCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pStatisticCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pStatisticCount:", static_cast<uint64_t>(*pStatisticCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineExecutableStatisticKHR* pStatistics // ARG
    if (pStatistics.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableStatisticKHR* = NULL", indentString.c_str(), "pStatistics:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableStatisticKHR* = ", indentString.c_str(), "pStatistics:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pStatistics.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkPipelineExecutableStatisticKHR>(&tmpString, 2, 1, "VkPipelineExecutableStatisticKHR",
            pStatistics.GetMetaStructPointer(), "pStatistics", *pStatisticCount.GetPointer(), false, pStatistics.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPipelineExecutableInternalRepresentationsKHR(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>& pExecutableInfo,
    const PointerDecoder<uint32_t>&             pInternalRepresentationCount,
    const StructPointerDecoder<Decoded_VkPipelineExecutableInternalRepresentationKHR>& pInternalRepresentations)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPipelineExecutableInfoKHR* pExecutableInfo // ARG
    if (pExecutableInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = NULL", indentString.c_str(), "pExecutableInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPipelineExecutableInfoKHR* = ", indentString.c_str(), "pExecutableInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExecutableInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPipelineExecutableInfoKHR>(&tmpString, *pExecutableInfo.GetMetaStructPointer(), 2, pExecutableInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pInternalRepresentationCount // ARG
    if (pInternalRepresentationCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pInternalRepresentationCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pInternalRepresentationCount:", static_cast<uint64_t>(*pInternalRepresentationCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations // ARG
    if (pInternalRepresentations.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableInternalRepresentationKHR* = NULL", indentString.c_str(), "pInternalRepresentations:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipelineExecutableInternalRepresentationKHR* = ", indentString.c_str(), "pInternalRepresentations:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pInternalRepresentations.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkPipelineExecutableInternalRepresentationKHR>(&tmpString, 2, 1, "VkPipelineExecutableInternalRepresentationKHR",
            pInternalRepresentations.GetMetaStructPointer(), "pInternalRepresentations", *pInternalRepresentationCount.GetPointer(), false, pInternalRepresentations.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDebugReportObjectTypeEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDebugReportObjectTypeEXT enumValue = static_cast<VkDebugReportObjectTypeEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT");
            return;
        case VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT:
            *rString += std::string("VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDebugReportFlagBitsEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDebugReportFlagBitsEXT enumValue = static_cast<VkDebugReportFlagBitsEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEBUG_REPORT_ERROR_BIT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_ERROR_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_DEBUG_BIT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_DEBUG_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_INFORMATION_BIT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_INFORMATION_BIT_EXT");
            return;
        case VK_DEBUG_REPORT_WARNING_BIT_EXT:
            *rString += std::string("VK_DEBUG_REPORT_WARNING_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(std::string* rString, const Decoded_VkDebugReportCallbackCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(std::string* rString, const Decoded_VkDebugReportCallbackCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugReportCallbackCreateInfoEXT *pStruct = (const VkDebugReportCallbackCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDebugReportFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDebugReportFlagsEXT = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkDebugReportFlagBitsEXT); // URW
    *rString += "\n"; // GDS

    // PFN_vkDebugReportCallbackEXT pfnCallback // SMB
    indentSpaces(rString, indent);
    *rString += "pfnCallback:                    ";
    *rString += "PFN_vkDebugReportCallbackEXT = "; // TEQ
    addrToString(rString, reinterpret_cast<uint64_t>(pStruct->pfnCallback)); // WRX
    *rString += "\n"; // GDS

    // void* pUserData // SMB
    indentSpaces(rString, indent);
    *rString += "pUserData:                      ";
    *rString += "void* = "; // TEQ
    if (pStruct->pUserData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pUserData); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateDebugReportCallbackEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDebugReportCallbackCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDebugReportCallbackEXT>& pCallback)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugReportCallbackCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugReportCallbackCreateInfoEXT* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugReportCallbackCreateInfoEXT* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugReportCallbackCreateInfoEXT>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportCallbackEXT* pCallback // ARG
    if (pCallback.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDebugReportCallbackEXT* = NULL", indentString.c_str(), "pCallback:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDebugReportCallbackEXT* = ", indentString.c_str(), "pCallback:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pCallback.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDebugReportCallbackEXT(
    format::HandleId                            instance,
    format::HandleId                            callback,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportCallbackEXT callback // ARG
    fprintf(GetFile(), "%s%-32sVkDebugReportCallbackEXT = ", indentString.c_str(), "callback:"); // TRP
    tmpString = "";
    addrToString(&tmpString, callback);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDebugReportMessageEXT(
    format::HandleId                            instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const StringDecoder&                        pLayerPrefix,
    const StringDecoder&                        pMessage)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportFlagsEXT flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkDebugReportFlagBitsEXT);
    fprintf(GetFile(), "%s%-32sVkDebugReportFlagsEXT = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugReportObjectTypeEXT objectType // ARG
    tmpString = "";
    enumToString_VkDebugReportObjectTypeEXT(&tmpString,objectType); // EPW
    fprintf(GetFile(), "%s%-32sVkDebugReportObjectTypeEXT = %s", indentString.c_str(), "objectType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t object // ARG
    fprintf(GetFile(), "%s%-32suint64_t = %" PRIu64 "", indentString.c_str(), "object:", object); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // size_t location // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indentString.c_str(), "location:", location); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // int32_t messageCode // ARG
    fprintf(GetFile(), "%s%-32sint32_t = %d", indentString.c_str(), "messageCode:", messageCode); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const char* pLayerPrefix // ARG
    if (pLayerPrefix.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst char* = NULL", indentString.c_str(), "pLayerPrefix:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst char* = %" PRId64 "", indentString.c_str(), "pLayerPrefix:", static_cast<uint64_t>(*pLayerPrefix.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const char* pMessage // ARG
    if (pMessage.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst char* = NULL", indentString.c_str(), "pMessage:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst char* = %" PRId64 "", indentString.c_str(), "pMessage:", static_cast<uint64_t>(*pMessage.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkRasterizationOrderAMD(std::string* rString, uint32_t enumValueInt32)
{
    VkRasterizationOrderAMD enumValue = static_cast<VkRasterizationOrderAMD>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_RASTERIZATION_ORDER_RELAXED_AMD:
            *rString += std::string("VK_RASTERIZATION_ORDER_RELAXED_AMD");
            return;
        case VK_RASTERIZATION_ORDER_STRICT_AMD:
            *rString += std::string("VK_RASTERIZATION_ORDER_STRICT_AMD");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(std::string* rString, const Decoded_VkDebugMarkerObjectNameInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(std::string* rString, const Decoded_VkDebugMarkerObjectTagInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(std::string* rString, const Decoded_VkDebugMarkerMarkerInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(std::string* rString, const Decoded_VkDebugMarkerObjectNameInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugMarkerObjectNameInfoEXT *pStruct = (const VkDebugMarkerObjectNameInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDebugReportObjectTypeEXT objectType // SMB
    indentSpaces(rString, indent);
    *rString += "objectType:                     ";
    *rString += "VkDebugReportObjectTypeEXT = "; // TEQ
    enumToString_VkDebugReportObjectTypeEXT(rString, pStruct->objectType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->objectType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint64_t object // SMB
    indentSpaces(rString, indent);
    *rString += "object:                         ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->object);
    *rString += "\n"; // GDS

    // const char* pObjectName // SMB
    indentSpaces(rString, indent);
    *rString += "pObjectName:                    ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pObjectName); // TGH
}

template <>
void structureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(std::string* rString, const Decoded_VkDebugMarkerObjectTagInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugMarkerObjectTagInfoEXT *pStruct = (const VkDebugMarkerObjectTagInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDebugReportObjectTypeEXT objectType // SMB
    indentSpaces(rString, indent);
    *rString += "objectType:                     ";
    *rString += "VkDebugReportObjectTypeEXT = "; // TEQ
    enumToString_VkDebugReportObjectTypeEXT(rString, pStruct->objectType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->objectType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint64_t object // SMB
    indentSpaces(rString, indent);
    *rString += "object:                         ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->object);
    *rString += "\n"; // GDS

    // uint64_t tagName // SMB
    indentSpaces(rString, indent);
    *rString += "tagName:                        ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->tagName);
    *rString += "\n"; // GDS

    // size_t tagSize // SMB
    indentSpaces(rString, indent);
    *rString += "tagSize:                        ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->tagSize);
    *rString += "\n"; // GDS

    // const void* pTag // SMB
    indentSpaces(rString, indent);
    *rString += "pTag:                           ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pTag == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pTag.GetAddress()); // AHW
    }
}

template <>
void structureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(std::string* rString, const Decoded_VkDebugMarkerMarkerInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugMarkerMarkerInfoEXT *pStruct = (const VkDebugMarkerMarkerInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // const char* pMarkerName // SMB
    indentSpaces(rString, indent);
    *rString += "pMarkerName:                    ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pMarkerName); // TGH
    *rString += "\n"; // GDS

    // float color // SMB
    indentSpaces(rString, indent);
    *rString += "color:                          ";
    *rString += "float[";
    *rString += "4";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkDebugMarkerMarkerInfoEXT, color)); // IYY
    ValueToStringStruct vinfo_color = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->color), "color", 4, vinfo_color); // JPA
}

void VulkanAsciiConsumer::Process_vkDebugMarkerSetObjectTagEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugMarkerObjectTagInfoEXT>& pTagInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDebugMarkerSetObjectTagEXT(device, pTagInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerObjectTagInfoEXT* pTagInfo // ARG
    if (pTagInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectTagInfoEXT* = NULL", indentString.c_str(), "pTagInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectTagInfoEXT* = ", indentString.c_str(), "pTagInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pTagInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugMarkerObjectTagInfoEXT>(&tmpString, *pTagInfo.GetMetaStructPointer(), 2, pTagInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDebugMarkerSetObjectNameEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugMarkerObjectNameInfoEXT>& pNameInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDebugMarkerSetObjectNameEXT(device, pNameInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerObjectNameInfoEXT* pNameInfo // ARG
    if (pNameInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectNameInfoEXT* = NULL", indentString.c_str(), "pNameInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerObjectNameInfoEXT* = ", indentString.c_str(), "pNameInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pNameInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugMarkerObjectNameInfoEXT>(&tmpString, *pNameInfo.GetMetaStructPointer(), 2, pNameInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerBeginEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>& pMarkerInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerMarkerInfoEXT* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = NULL", indentString.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = ", indentString.c_str(), "pMarkerInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(&tmpString, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerEndEXT(
    format::HandleId                            commandBuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDebugMarkerEndEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDebugMarkerInsertEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>& pMarkerInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugMarkerMarkerInfoEXT* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = NULL", indentString.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugMarkerMarkerInfoEXT* = ", indentString.c_str(), "pMarkerInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugMarkerMarkerInfoEXT>(&tmpString, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT *pStruct = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 transformFeedback // SMB
    indentSpaces(rString, indent);
    *rString += "transformFeedback:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->transformFeedback);
    *rString += "\n"; // GDS

    // VkBool32 geometryStreams // SMB
    indentSpaces(rString, indent);
    *rString += "geometryStreams:                ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->geometryStreams);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT *pStruct = (const VkPhysicalDeviceTransformFeedbackPropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t maxTransformFeedbackStreams // SMB
    indentSpaces(rString, indent);
    *rString += "maxTransformFeedbackStreams:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTransformFeedbackStreams);
    *rString += "\n"; // GDS

    // uint32_t maxTransformFeedbackBuffers // SMB
    indentSpaces(rString, indent);
    *rString += "maxTransformFeedbackBuffers:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTransformFeedbackBuffers);
    *rString += "\n"; // GDS

    // VkDeviceSize maxTransformFeedbackBufferSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxTransformFeedbackBufferSize: ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->maxTransformFeedbackBufferSize);
    *rString += "\n"; // GDS

    // uint32_t maxTransformFeedbackStreamDataSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxTransformFeedbackStreamDataSize: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTransformFeedbackStreamDataSize);
    *rString += "\n"; // GDS

    // uint32_t maxTransformFeedbackBufferDataSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxTransformFeedbackBufferDataSize: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTransformFeedbackBufferDataSize);
    *rString += "\n"; // GDS

    // uint32_t maxTransformFeedbackBufferDataStride // SMB
    indentSpaces(rString, indent);
    *rString += "maxTransformFeedbackBufferDataStride: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTransformFeedbackBufferDataStride);
    *rString += "\n"; // GDS

    // VkBool32 transformFeedbackQueries // SMB
    indentSpaces(rString, indent);
    *rString += "transformFeedbackQueries:       ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->transformFeedbackQueries);
    *rString += "\n"; // GDS

    // VkBool32 transformFeedbackStreamsLinesTriangles // SMB
    indentSpaces(rString, indent);
    *rString += "transformFeedbackStreamsLinesTriangles: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->transformFeedbackStreamsLinesTriangles);
    *rString += "\n"; // GDS

    // VkBool32 transformFeedbackRasterizationStreamSelect // SMB
    indentSpaces(rString, indent);
    *rString += "transformFeedbackRasterizationStreamSelect: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->transformFeedbackRasterizationStreamSelect);
    *rString += "\n"; // GDS

    // VkBool32 transformFeedbackDraw // SMB
    indentSpaces(rString, indent);
    *rString += "transformFeedbackDraw:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->transformFeedbackDraw);
}

template <>
void structureToString<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineRasterizationStateStreamCreateInfoEXT *pStruct = (const VkPipelineRasterizationStateStreamCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineRasterizationStateStreamCreateFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineRasterizationStateStreamCreateFlagsEXT = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t rasterizationStream // SMB
    indentSpaces(rString, indent);
    *rString += "rasterizationStream:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->rasterizationStream);
}

void VulkanAsciiConsumer::Process_vkCmdBindTransformFeedbackBuffersEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const HandlePointerDecoder<VkBuffer>&       pBuffers,
    const PointerDecoder<VkDeviceSize>&         pOffsets,
    const PointerDecoder<VkDeviceSize>&         pSizes)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstBinding // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstBinding:", firstBinding); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindingCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindingCount:", bindingCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pBuffers // ARG
    if (pBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indentString.c_str(), "pBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indentString.c_str(), "pBuffers:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pBuffers = {true, false, false, nullptr};
        arrayToString<const VkBuffer*>(&tmpString, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pBuffers.GetPointer()), "pBuffers", bindingCount, vinfo_pBuffers); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pOffsets // ARG
    if (pOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indentString.c_str(), "pOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indentString.c_str(), "pOffsets:", static_cast<uint64_t>(*pOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pSizes // ARG
    if (pSizes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indentString.c_str(), "pSizes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indentString.c_str(), "pSizes:", static_cast<uint64_t>(*pSizes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginTransformFeedbackEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const HandlePointerDecoder<VkBuffer>&       pCounterBuffers,
    const PointerDecoder<VkDeviceSize>&         pCounterBufferOffsets)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstCounterBuffer // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstCounterBuffer:", firstCounterBuffer); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t counterBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "counterBufferCount:", counterBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pCounterBuffers // ARG
    if (pCounterBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indentString.c_str(), "pCounterBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indentString.c_str(), "pCounterBuffers:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pCounterBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pCounterBuffers = {true, false, false, nullptr};
        arrayToString<const VkBuffer*>(&tmpString, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pCounterBuffers.GetPointer()), "pCounterBuffers", counterBufferCount, vinfo_pCounterBuffers); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pCounterBufferOffsets // ARG
    if (pCounterBufferOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indentString.c_str(), "pCounterBufferOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indentString.c_str(), "pCounterBufferOffsets:", static_cast<uint64_t>(*pCounterBufferOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndTransformFeedbackEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const HandlePointerDecoder<VkBuffer>&       pCounterBuffers,
    const PointerDecoder<VkDeviceSize>&         pCounterBufferOffsets)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstCounterBuffer // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstCounterBuffer:", firstCounterBuffer); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t counterBufferCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "counterBufferCount:", counterBufferCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBuffer* pCounterBuffers // ARG
    if (pCounterBuffers.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = NULL", indentString.c_str(), "pCounterBuffers:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBuffer* = ", indentString.c_str(), "pCounterBuffers:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pCounterBuffers.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pCounterBuffers = {true, false, false, nullptr};
        arrayToString<const VkBuffer*>(&tmpString, 1, 1, "const VkBuffer*", reinterpret_cast<const VkBuffer*>(pCounterBuffers.GetPointer()), "pCounterBuffers", counterBufferCount, vinfo_pCounterBuffers); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceSize* pCounterBufferOffsets // ARG
    if (pCounterBufferOffsets.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = NULL", indentString.c_str(), "pCounterBufferOffsets:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceSize* = %" PRId64 "", indentString.c_str(), "pCounterBufferOffsets:", static_cast<uint64_t>(*pCounterBufferOffsets.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginQueryIndexedEXT(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags,
    uint32_t                                    index)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryControlFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkQueryControlFlagBits);
    fprintf(GetFile(), "%s%-32sVkQueryControlFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t index // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "index:", index); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndQueryIndexedEXT(
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    uint32_t                                    index)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t query // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "query:", query); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t index // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "index:", index); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndirectByteCountEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    format::HandleId                            counterBuffer,
    VkDeviceSize                                counterBufferOffset,
    uint32_t                                    counterOffset,
    uint32_t                                    vertexStride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t instanceCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "instanceCount:", instanceCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstInstance // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstInstance:", firstInstance); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer counterBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "counterBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, counterBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize counterBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "counterBufferOffset:", counterBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t counterOffset // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "counterOffset:", counterOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t vertexStride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "vertexStride:", vertexStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkImageViewHandleInfoNVX>(std::string* rString, const Decoded_VkImageViewHandleInfoNVX &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImageViewHandleInfoNVX>(std::string* rString, const Decoded_VkImageViewHandleInfoNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageViewHandleInfoNVX *pStruct = (const VkImageViewHandleInfoNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImageView imageView // SMB
    indentSpaces(rString, indent);
    *rString += "imageView:                      ";
    *rString += "VkImageView = "; // TEQ
    addrToString(rString, pStructIn.imageView); // PAQ  
    *rString += "\n"; // GDS

    // VkDescriptorType descriptorType // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorType:                 ";
    *rString += "VkDescriptorType = "; // TEQ
    enumToString_VkDescriptorType(rString, pStruct->descriptorType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->descriptorType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSampler sampler // SMB
    indentSpaces(rString, indent);
    *rString += "sampler:                        ";
    *rString += "VkSampler = "; // TEQ
    addrToString(rString, pStructIn.sampler); // PAQ  
}

void VulkanAsciiConsumer::Process_vkGetImageViewHandleNVX(
    uint32_t                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkImageViewHandleInfoNVX>& pInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageViewHandleNVX(device, pInfo)");
    fprintf(GetFile(), " returns %u:\n", returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImageViewHandleInfoNVX* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewHandleInfoNVX* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImageViewHandleInfoNVX* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageViewHandleInfoNVX>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdDrawIndirectCountAMD(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "countBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, countBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawIndexedIndirectCountAMD(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "countBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, countBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkShaderInfoTypeAMD(std::string* rString, uint32_t enumValueInt32)
{
    VkShaderInfoTypeAMD enumValue = static_cast<VkShaderInfoTypeAMD>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SHADER_INFO_TYPE_BINARY_AMD:
            *rString += std::string("VK_SHADER_INFO_TYPE_BINARY_AMD");
            return;
        case VK_SHADER_INFO_TYPE_STATISTICS_AMD:
            *rString += std::string("VK_SHADER_INFO_TYPE_STATISTICS_AMD");
            return;
        case VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD:
            *rString += std::string("VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkShaderResourceUsageAMD>(std::string* rString, const Decoded_VkShaderResourceUsageAMD &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkShaderStatisticsInfoAMD>(std::string* rString, const Decoded_VkShaderStatisticsInfoAMD &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkShaderResourceUsageAMD>(std::string* rString, const Decoded_VkShaderResourceUsageAMD &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkShaderResourceUsageAMD *pStruct = (const VkShaderResourceUsageAMD *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t numUsedVgprs // SMB
    indentSpaces(rString, indent);
    *rString += "numUsedVgprs:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->numUsedVgprs);
    *rString += "\n"; // GDS

    // uint32_t numUsedSgprs // SMB
    indentSpaces(rString, indent);
    *rString += "numUsedSgprs:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->numUsedSgprs);
    *rString += "\n"; // GDS

    // uint32_t ldsSizePerLocalWorkGroup // SMB
    indentSpaces(rString, indent);
    *rString += "ldsSizePerLocalWorkGroup:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->ldsSizePerLocalWorkGroup);
    *rString += "\n"; // GDS

    // size_t ldsUsageSizeInBytes // SMB
    indentSpaces(rString, indent);
    *rString += "ldsUsageSizeInBytes:            ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->ldsUsageSizeInBytes);
    *rString += "\n"; // GDS

    // size_t scratchMemUsageInBytes // SMB
    indentSpaces(rString, indent);
    *rString += "scratchMemUsageInBytes:         ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->scratchMemUsageInBytes);
}

template <>
void structureToString<Decoded_VkShaderStatisticsInfoAMD>(std::string* rString, const Decoded_VkShaderStatisticsInfoAMD &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkShaderStatisticsInfoAMD *pStruct = (const VkShaderStatisticsInfoAMD *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkShaderStageFlags shaderStageMask // SMB
    indentSpaces(rString, indent);
    *rString += "shaderStageMask:                ";
    *rString += "VkShaderStageFlags = "; // TEQ
    flagsToString(rString, pStruct->shaderStageMask, enumToString_VkShaderStageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkShaderResourceUsageAMD resourceUsage // SMB
    indentSpaces(rString, indent);
    *rString += "resourceUsage:                  ";
    *rString += "VkShaderResourceUsageAMD = "; // TEQ
    structureToString<Decoded_VkShaderResourceUsageAMD>(rString, *pStructIn.resourceUsage, indent+1,  baseAddr + offsetof(VkShaderStatisticsInfoAMD, resourceUsage)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t numPhysicalVgprs // SMB
    indentSpaces(rString, indent);
    *rString += "numPhysicalVgprs:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->numPhysicalVgprs);
    *rString += "\n"; // GDS

    // uint32_t numPhysicalSgprs // SMB
    indentSpaces(rString, indent);
    *rString += "numPhysicalSgprs:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->numPhysicalSgprs);
    *rString += "\n"; // GDS

    // uint32_t numAvailableVgprs // SMB
    indentSpaces(rString, indent);
    *rString += "numAvailableVgprs:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->numAvailableVgprs);
    *rString += "\n"; // GDS

    // uint32_t numAvailableSgprs // SMB
    indentSpaces(rString, indent);
    *rString += "numAvailableSgprs:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->numAvailableSgprs);
    *rString += "\n"; // GDS

    // uint32_t computeWorkGroupSize // SMB
    indentSpaces(rString, indent);
    *rString += "computeWorkGroupSize:           ";
    *rString += "uint32_t[";
    *rString += "3";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkShaderStatisticsInfoAMD, computeWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_computeWorkGroupSize = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->computeWorkGroupSize), "computeWorkGroupSize", 3, vinfo_computeWorkGroupSize); // JPA
}

void VulkanAsciiConsumer::Process_vkGetShaderInfoAMD(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    const PointerDecoder<size_t>&               pInfoSize,
    const PointerDecoder<uint8_t>&              pInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indentString.c_str(), "pipeline:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipeline);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderStageFlagBits shaderStage // ARG
    tmpString = "";
    enumToString_VkShaderStageFlagBits(&tmpString,shaderStage); // EPW
    fprintf(GetFile(), "%s%-32sVkShaderStageFlagBits = %s", indentString.c_str(), "shaderStage:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkShaderInfoTypeAMD infoType // ARG
    tmpString = "";
    enumToString_VkShaderInfoTypeAMD(&tmpString,infoType); // EPW
    fprintf(GetFile(), "%s%-32sVkShaderInfoTypeAMD = %s", indentString.c_str(), "infoType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // size_t* pInfoSize // ARG
    if (pInfoSize.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32ssize_t* = NULL", indentString.c_str(), "pInfoSize:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32ssize_t* = %" PRId64 "", indentString.c_str(), "pInfoSize:", static_cast<uint64_t>(*pInfoSize.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // void* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indentString.c_str(), "pInfo:"); // UYD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indentString.c_str(), "pInfo:");  // RYA
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress()); // YYX
        if (printShaderCode)
        {
            ValueToStringStruct vinfo_pInfo = {false, false, false, nullptr};
            arrayToString<const uint32_t*>(&tmpString, 2, 1, "void*", reinterpret_cast<const uint32_t*>(pInfo.GetPointer()), "pInfo", static_cast<size_t>(*pInfoSize.GetPointer()) / 4, vinfo_pInfo);  // CRG
        }
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEU
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(std::string* rString, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(std::string* rString, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkStreamDescriptorSurfaceCreateInfoGGP *pStruct = (const VkStreamDescriptorSurfaceCreateInfoGGP *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkStreamDescriptorSurfaceCreateFlagsGGP flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkStreamDescriptorSurfaceCreateFlagsGGP = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint64_t streamDescriptor // SMB
    indentSpaces(rString, indent);
    *rString += "streamDescriptor:               ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->streamDescriptor);
}

void VulkanAsciiConsumer::Process_vkCreateStreamDescriptorSurfaceGGP(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkStreamDescriptorSurfaceCreateInfoGGP* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkStreamDescriptorSurfaceCreateInfoGGP* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkExternalMemoryFeatureFlagBitsNV(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalMemoryFeatureFlagBitsNV enumValue = static_cast<VkExternalMemoryFeatureFlagBitsNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV:
            *rString += std::string("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV:
            *rString += std::string("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV:
            *rString += std::string("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkExternalMemoryHandleTypeFlagBitsNV(std::string* rString, uint32_t enumValueInt32)
{
    VkExternalMemoryHandleTypeFlagBitsNV enumValue = static_cast<VkExternalMemoryHandleTypeFlagBitsNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV");
            return;
        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV:
            *rString += std::string("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkExternalImageFormatPropertiesNV>(std::string* rString, const Decoded_VkExternalImageFormatPropertiesNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkExternalImageFormatPropertiesNV>(std::string* rString, const Decoded_VkExternalImageFormatPropertiesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalImageFormatPropertiesNV *pStruct = (const VkExternalImageFormatPropertiesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkImageFormatProperties imageFormatProperties // SMB
    indentSpaces(rString, indent);
    *rString += "imageFormatProperties:          ";
    *rString += "VkImageFormatProperties = "; // TEQ
    structureToString<Decoded_VkImageFormatProperties>(rString, *pStructIn.imageFormatProperties, indent+1,  baseAddr + offsetof(VkExternalImageFormatPropertiesNV, imageFormatProperties)); // AZJ
    *rString += "\n"; // GDS

    // VkExternalMemoryFeatureFlagsNV externalMemoryFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "externalMemoryFeatures:         ";
    *rString += "VkExternalMemoryFeatureFlagsNV = "; // TEQ
    flagsToString(rString, pStruct->externalMemoryFeatures, enumToString_VkExternalMemoryFeatureFlagBitsNV); // URW
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "exportFromImportedHandleTypes:  ";
    *rString += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    flagsToString(rString, pStruct->exportFromImportedHandleTypes, enumToString_VkExternalMemoryHandleTypeFlagBitsNV); // URW
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes // SMB
    indentSpaces(rString, indent);
    *rString += "compatibleHandleTypes:          ";
    *rString += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    flagsToString(rString, pStruct->compatibleHandleTypes, enumToString_VkExternalMemoryHandleTypeFlagBitsNV); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    const StructPointerDecoder<Decoded_VkExternalImageFormatPropertiesNV>& pExternalImageFormatProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkFormat format // ARG
    tmpString = "";
    enumToString_VkFormat(&tmpString,format); // EPW
    fprintf(GetFile(), "%s%-32sVkFormat = %s", indentString.c_str(), "format:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageType type // ARG
    tmpString = "";
    enumToString_VkImageType(&tmpString,type); // EPW
    fprintf(GetFile(), "%s%-32sVkImageType = %s", indentString.c_str(), "type:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageTiling tiling // ARG
    tmpString = "";
    enumToString_VkImageTiling(&tmpString,tiling); // EPW
    fprintf(GetFile(), "%s%-32sVkImageTiling = %s", indentString.c_str(), "tiling:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkImageUsageFlags usage // ARG
    tmpString = "";
    flagsToString(&tmpString, usage, enumToString_VkImageUsageFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageUsageFlags = %s", indentString.c_str(), "usage:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkImageCreateFlags flags // ARG
    tmpString = "";
    flagsToString(&tmpString, flags, enumToString_VkImageCreateFlagBits);
    fprintf(GetFile(), "%s%-32sVkImageCreateFlags = %s", indentString.c_str(), "flags:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagsNV externalHandleType // ARG
    tmpString = "";
    flagsToString(&tmpString, externalHandleType, enumToString_VkExternalMemoryHandleTypeFlagBitsNV);
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagsNV = %s", indentString.c_str(), "externalHandleType:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties // ARG
    if (pExternalImageFormatProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkExternalImageFormatPropertiesNV* = NULL", indentString.c_str(), "pExternalImageFormatProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkExternalImageFormatPropertiesNV* = ", indentString.c_str(), "pExternalImageFormatProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pExternalImageFormatProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkExternalImageFormatPropertiesNV>(&tmpString, *pExternalImageFormatProperties.GetMetaStructPointer(), 2, pExternalImageFormatProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkImportMemoryWin32HandleInfoNV>(std::string* rString, const Decoded_VkImportMemoryWin32HandleInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExportMemoryWin32HandleInfoNV>(std::string* rString, const Decoded_VkExportMemoryWin32HandleInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportMemoryWin32HandleInfoNV>(std::string* rString, const Decoded_VkImportMemoryWin32HandleInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportMemoryWin32HandleInfoNV *pStruct = (const VkImportMemoryWin32HandleInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagsNV handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagsNV = "; // TEQ
    flagsToString(rString, pStruct->handleType, enumToString_VkExternalMemoryHandleTypeFlagBitsNV); // URW
    *rString += "\n"; // GDS

    // void* handle // SMB
    indentSpaces(rString, indent);
    *rString += "handle:                         ";
    *rString += "void* = "; // TEQ
    if (pStruct->handle == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.handle); // PWR
    }
}

template <>
void structureToString<Decoded_VkExportMemoryWin32HandleInfoNV>(std::string* rString, const Decoded_VkExportMemoryWin32HandleInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExportMemoryWin32HandleInfoNV *pStruct = (const VkExportMemoryWin32HandleInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // const SECURITY_ATTRIBUTES* pAttributes // SMB
    indentSpaces(rString, indent);
    *rString += "pAttributes:                    ";
    *rString += "const SECURITY_ATTRIBUTES* = "; // TEQ
    if (pStruct->pAttributes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttributes->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t dwAccess // SMB
    indentSpaces(rString, indent);
    *rString += "dwAccess:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dwAccess);
}

void VulkanAsciiConsumer::Process_vkGetMemoryWin32HandleNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    const PointerDecoder<uint64_t>&             pHandle)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceMemory memory // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceMemory = ", indentString.c_str(), "memory:"); // TRP
    tmpString = "";
    addrToString(&tmpString, memory);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagsNV handleType // ARG
    tmpString = "";
    flagsToString(&tmpString, handleType, enumToString_VkExternalMemoryHandleTypeFlagBitsNV);
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagsNV = %s", indentString.c_str(), "handleType:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // void** pHandle // ARG
    if (pHandle.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid** = NULL", indentString.c_str(), "pHandle:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid** = ", indentString.c_str(), "pHandle:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pHandle.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkValidationCheckEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkValidationCheckEXT enumValue = static_cast<VkValidationCheckEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_VALIDATION_CHECK_ALL_EXT:
            *rString += std::string("VK_VALIDATION_CHECK_ALL_EXT");
            return;
        case VK_VALIDATION_CHECK_SHADERS_EXT:
            *rString += std::string("VK_VALIDATION_CHECK_SHADERS_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkViSurfaceCreateInfoNN>(std::string* rString, const Decoded_VkViSurfaceCreateInfoNN &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkViSurfaceCreateInfoNN>(std::string* rString, const Decoded_VkViSurfaceCreateInfoNN &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkViSurfaceCreateInfoNN *pStruct = (const VkViSurfaceCreateInfoNN *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkViSurfaceCreateFlagsNN flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkViSurfaceCreateFlagsNN = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // void* window // SMB
    indentSpaces(rString, indent);
    *rString += "window:                         ";
    *rString += "void* = "; // TEQ
    if (pStruct->window == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.window); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateViSurfaceNN(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkViSurfaceCreateInfoNN>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkViSurfaceCreateInfoNN* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkViSurfaceCreateInfoNN* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkViSurfaceCreateInfoNN* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkViSurfaceCreateInfoNN>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkConditionalRenderingFlagBitsEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkConditionalRenderingFlagBitsEXT enumValue = static_cast<VkConditionalRenderingFlagBitsEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT:
            *rString += std::string("VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(std::string* rString, const Decoded_VkConditionalRenderingBeginInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(std::string* rString, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(std::string* rString, const Decoded_VkConditionalRenderingBeginInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkConditionalRenderingBeginInfoEXT *pStruct = (const VkConditionalRenderingBeginInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
    *rString += "\n"; // GDS

    // VkConditionalRenderingFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkConditionalRenderingFlagsEXT = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkConditionalRenderingFlagBitsEXT); // URW
}

template <>
void structureToString<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT *pStruct = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 conditionalRendering // SMB
    indentSpaces(rString, indent);
    *rString += "conditionalRendering:           ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->conditionalRendering);
    *rString += "\n"; // GDS

    // VkBool32 inheritedConditionalRendering // SMB
    indentSpaces(rString, indent);
    *rString += "inheritedConditionalRendering:  ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->inheritedConditionalRendering);
}

template <>
void structureToString<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(std::string* rString, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT *pStruct = (const VkCommandBufferInheritanceConditionalRenderingInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 conditionalRenderingEnable // SMB
    indentSpaces(rString, indent);
    *rString += "conditionalRenderingEnable:     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->conditionalRenderingEnable);
}

void VulkanAsciiConsumer::Process_vkCmdBeginConditionalRenderingEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkConditionalRenderingBeginInfoEXT>& pConditionalRenderingBegin)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin // ARG
    if (pConditionalRenderingBegin.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkConditionalRenderingBeginInfoEXT* = NULL", indentString.c_str(), "pConditionalRenderingBegin:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkConditionalRenderingBeginInfoEXT* = ", indentString.c_str(), "pConditionalRenderingBegin:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pConditionalRenderingBegin.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkConditionalRenderingBeginInfoEXT>(&tmpString, *pConditionalRenderingBegin.GetMetaStructPointer(), 2, pConditionalRenderingBegin.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndConditionalRenderingEXT(
    format::HandleId                            commandBuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdEndConditionalRenderingEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkObjectEntryUsageFlagBitsNVX(std::string* rString, uint32_t enumValueInt32)
{
    VkObjectEntryUsageFlagBitsNVX enumValue = static_cast<VkObjectEntryUsageFlagBitsNVX>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX:
            *rString += std::string("VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX");
            return;
        case VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX:
            *rString += std::string("VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkIndirectCommandsLayoutUsageFlagBitsNVX(std::string* rString, uint32_t enumValueInt32)
{
    VkIndirectCommandsLayoutUsageFlagBitsNVX enumValue = static_cast<VkIndirectCommandsLayoutUsageFlagBitsNVX>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkIndirectCommandsTokenTypeNVX(std::string* rString, uint32_t enumValueInt32)
{
    VkIndirectCommandsTokenTypeNVX enumValue = static_cast<VkIndirectCommandsTokenTypeNVX>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX");
            return;
        case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX:
            *rString += std::string("VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkObjectEntryTypeNVX(std::string* rString, uint32_t enumValueInt32)
{
    VkObjectEntryTypeNVX enumValue = static_cast<VkObjectEntryTypeNVX>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX:
            *rString += std::string("VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX:
            *rString += std::string("VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX:
            *rString += std::string("VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX:
            *rString += std::string("VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX");
            return;
        case VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX:
            *rString += std::string("VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(std::string* rString, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(std::string* rString, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkIndirectCommandsTokenNVX>(std::string* rString, const Decoded_VkIndirectCommandsTokenNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(std::string* rString, const Decoded_VkIndirectCommandsLayoutTokenNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(std::string* rString, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCmdProcessCommandsInfoNVX>(std::string* rString, const Decoded_VkCmdProcessCommandsInfoNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(std::string* rString, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkObjectTableCreateInfoNVX>(std::string* rString, const Decoded_VkObjectTableCreateInfoNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkObjectTableEntryNVX>(std::string* rString, const Decoded_VkObjectTableEntryNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkObjectTablePipelineEntryNVX>(std::string* rString, const Decoded_VkObjectTablePipelineEntryNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkObjectTableDescriptorSetEntryNVX>(std::string* rString, const Decoded_VkObjectTableDescriptorSetEntryNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkObjectTableVertexBufferEntryNVX>(std::string* rString, const Decoded_VkObjectTableVertexBufferEntryNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkObjectTableIndexBufferEntryNVX>(std::string* rString, const Decoded_VkObjectTableIndexBufferEntryNVX &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkObjectTablePushConstantEntryNVX>(std::string* rString, const Decoded_VkObjectTablePushConstantEntryNVX &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(std::string* rString, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGeneratedCommandsFeaturesNVX *pStruct = (const VkDeviceGeneratedCommandsFeaturesNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 computeBindingPointSupport // SMB
    indentSpaces(rString, indent);
    *rString += "computeBindingPointSupport:     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->computeBindingPointSupport);
}

template <>
void structureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(std::string* rString, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceGeneratedCommandsLimitsNVX *pStruct = (const VkDeviceGeneratedCommandsLimitsNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t maxIndirectCommandsLayoutTokenCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxIndirectCommandsLayoutTokenCount: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxIndirectCommandsLayoutTokenCount);
    *rString += "\n"; // GDS

    // uint32_t maxObjectEntryCounts // SMB
    indentSpaces(rString, indent);
    *rString += "maxObjectEntryCounts:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxObjectEntryCounts);
    *rString += "\n"; // GDS

    // uint32_t minSequenceCountBufferOffsetAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minSequenceCountBufferOffsetAlignment: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->minSequenceCountBufferOffsetAlignment);
    *rString += "\n"; // GDS

    // uint32_t minSequenceIndexBufferOffsetAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minSequenceIndexBufferOffsetAlignment: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->minSequenceIndexBufferOffsetAlignment);
    *rString += "\n"; // GDS

    // uint32_t minCommandsTokenBufferOffsetAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minCommandsTokenBufferOffsetAlignment: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->minCommandsTokenBufferOffsetAlignment);
}

template <>
void structureToString<Decoded_VkIndirectCommandsTokenNVX>(std::string* rString, const Decoded_VkIndirectCommandsTokenNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkIndirectCommandsTokenNVX *pStruct = (const VkIndirectCommandsTokenNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkIndirectCommandsTokenTypeNVX tokenType // SMB
    indentSpaces(rString, indent);
    *rString += "tokenType:                      ";
    *rString += "VkIndirectCommandsTokenTypeNVX = "; // TEQ
    enumToString_VkIndirectCommandsTokenTypeNVX(rString, pStruct->tokenType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->tokenType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
}

template <>
void structureToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(std::string* rString, const Decoded_VkIndirectCommandsLayoutTokenNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkIndirectCommandsLayoutTokenNVX *pStruct = (const VkIndirectCommandsLayoutTokenNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkIndirectCommandsTokenTypeNVX tokenType // SMB
    indentSpaces(rString, indent);
    *rString += "tokenType:                      ";
    *rString += "VkIndirectCommandsTokenTypeNVX = "; // TEQ
    enumToString_VkIndirectCommandsTokenTypeNVX(rString, pStruct->tokenType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->tokenType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t bindingUnit // SMB
    indentSpaces(rString, indent);
    *rString += "bindingUnit:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->bindingUnit);
    *rString += "\n"; // GDS

    // uint32_t dynamicCount // SMB
    indentSpaces(rString, indent);
    *rString += "dynamicCount:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->dynamicCount);
    *rString += "\n"; // GDS

    // uint32_t divisor // SMB
    indentSpaces(rString, indent);
    *rString += "divisor:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->divisor);
}

template <>
void structureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(std::string* rString, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkIndirectCommandsLayoutCreateInfoNVX *pStruct = (const VkIndirectCommandsLayoutCreateInfoNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineBindPoint pipelineBindPoint // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineBindPoint:              ";
    *rString += "VkPipelineBindPoint = "; // TEQ
    enumToString_VkPipelineBindPoint(rString, pStruct->pipelineBindPoint);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->pipelineBindPoint);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkIndirectCommandsLayoutUsageFlagsNVX flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkIndirectCommandsLayoutUsageFlagsNVX = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkIndirectCommandsLayoutUsageFlagBitsNVX); // URW
    *rString += "\n"; // GDS

    // uint32_t tokenCount // SMB
    indentSpaces(rString, indent);
    *rString += "tokenCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->tokenCount);
    *rString += "\n"; // GDS

    // const VkIndirectCommandsLayoutTokenNVX* pTokens // SMB
    indentSpaces(rString, indent);
    *rString += "pTokens:                        ";
    *rString += "const VkIndirectCommandsLayoutTokenNVX* = "; // TEQ
    if (pStruct->pTokens == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pTokens->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkIndirectCommandsLayoutTokenNVX>(rString, indent+1, 1, "VkIndirectCommandsLayoutTokenNVX", pStructIn.pTokens->GetMetaStructPointer(), "pTokens", pStruct->tokenCount, false, pStructIn.pTokens->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkCmdProcessCommandsInfoNVX>(std::string* rString, const Decoded_VkCmdProcessCommandsInfoNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCmdProcessCommandsInfoNVX *pStruct = (const VkCmdProcessCommandsInfoNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkObjectTableNVX objectTable // SMB
    indentSpaces(rString, indent);
    *rString += "objectTable:                    ";
    *rString += "VkObjectTableNVX = "; // TEQ
    addrToString(rString, pStructIn.objectTable); // PAQ  
    *rString += "\n"; // GDS

    // VkIndirectCommandsLayoutNVX indirectCommandsLayout // SMB
    indentSpaces(rString, indent);
    *rString += "indirectCommandsLayout:         ";
    *rString += "VkIndirectCommandsLayoutNVX = "; // TEQ
    addrToString(rString, pStructIn.indirectCommandsLayout); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t indirectCommandsTokenCount // SMB
    indentSpaces(rString, indent);
    *rString += "indirectCommandsTokenCount:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->indirectCommandsTokenCount);
    *rString += "\n"; // GDS

    // const VkIndirectCommandsTokenNVX* pIndirectCommandsTokens // SMB
    indentSpaces(rString, indent);
    *rString += "pIndirectCommandsTokens:        ";
    *rString += "const VkIndirectCommandsTokenNVX* = "; // TEQ
    if (pStruct->pIndirectCommandsTokens == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pIndirectCommandsTokens->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkIndirectCommandsTokenNVX>(rString, indent+1, 1, "VkIndirectCommandsTokenNVX", pStructIn.pIndirectCommandsTokens->GetMetaStructPointer(), "pIndirectCommandsTokens", pStruct->indirectCommandsTokenCount, false, pStructIn.pIndirectCommandsTokens->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t maxSequencesCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxSequencesCount:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxSequencesCount);
    *rString += "\n"; // GDS

    // VkCommandBuffer targetCommandBuffer // SMB
    indentSpaces(rString, indent);
    *rString += "targetCommandBuffer:            ";
    *rString += "VkCommandBuffer = "; // TEQ
    addrToString(rString, pStructIn.targetCommandBuffer); // PAQ  
    *rString += "\n"; // GDS

    // VkBuffer sequencesCountBuffer // SMB
    indentSpaces(rString, indent);
    *rString += "sequencesCountBuffer:           ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.sequencesCountBuffer); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize sequencesCountOffset // SMB
    indentSpaces(rString, indent);
    *rString += "sequencesCountOffset:           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->sequencesCountOffset);
    *rString += "\n"; // GDS

    // VkBuffer sequencesIndexBuffer // SMB
    indentSpaces(rString, indent);
    *rString += "sequencesIndexBuffer:           ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.sequencesIndexBuffer); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize sequencesIndexOffset // SMB
    indentSpaces(rString, indent);
    *rString += "sequencesIndexOffset:           ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->sequencesIndexOffset);
}

template <>
void structureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(std::string* rString, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCmdReserveSpaceForCommandsInfoNVX *pStruct = (const VkCmdReserveSpaceForCommandsInfoNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkObjectTableNVX objectTable // SMB
    indentSpaces(rString, indent);
    *rString += "objectTable:                    ";
    *rString += "VkObjectTableNVX = "; // TEQ
    addrToString(rString, pStructIn.objectTable); // PAQ  
    *rString += "\n"; // GDS

    // VkIndirectCommandsLayoutNVX indirectCommandsLayout // SMB
    indentSpaces(rString, indent);
    *rString += "indirectCommandsLayout:         ";
    *rString += "VkIndirectCommandsLayoutNVX = "; // TEQ
    addrToString(rString, pStructIn.indirectCommandsLayout); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t maxSequencesCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxSequencesCount:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxSequencesCount);
}

template <>
void structureToString<Decoded_VkObjectTableCreateInfoNVX>(std::string* rString, const Decoded_VkObjectTableCreateInfoNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkObjectTableCreateInfoNVX *pStruct = (const VkObjectTableCreateInfoNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t objectCount // SMB
    indentSpaces(rString, indent);
    *rString += "objectCount:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->objectCount);
    *rString += "\n"; // GDS

    // const VkObjectEntryTypeNVX* pObjectEntryTypes // SMB
    indentSpaces(rString, indent);
    *rString += "pObjectEntryTypes:              ";
    *rString += "const VkObjectEntryTypeNVX* = "; // TEQ
    if (pStruct->pObjectEntryTypes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pObjectEntryTypes.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pObjectEntryTypes = {false, true, false, enumToString_VkObjectEntryTypeNVX};
        arrayToString<const VkObjectEntryTypeNVX*>(rString, indent, 1, "const VkObjectEntryTypeNVX*", reinterpret_cast<const VkObjectEntryTypeNVX*>(pStructIn.pObjectEntryTypes.GetPointer()), "pObjectEntryTypes", pStruct->objectCount,  vinfo_pObjectEntryTypes);  // CCQ
    }
    *rString += "\n"; // GDS

    // const uint32_t* pObjectEntryCounts // SMB
    indentSpaces(rString, indent);
    *rString += "pObjectEntryCounts:             ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pObjectEntryCounts == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pObjectEntryCounts.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pObjectEntryCounts = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pObjectEntryCounts.GetPointer()), "pObjectEntryCounts", pStruct->objectCount,  vinfo_pObjectEntryCounts);  // CCQ
    }
    *rString += "\n"; // GDS

    // const VkObjectEntryUsageFlagsNVX* pObjectEntryUsageFlags // SMB
    indentSpaces(rString, indent);
    *rString += "pObjectEntryUsageFlags:         ";
    *rString += "const VkObjectEntryUsageFlagsNVX* = "; // TEQ
    if (pStruct->pObjectEntryUsageFlags == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pObjectEntryUsageFlags.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pObjectEntryUsageFlags = {false, false, true, enumToString_VkObjectEntryUsageFlagBitsNVX};
        arrayToString<const VkObjectEntryUsageFlagsNVX*>(rString, indent, 1, "const VkObjectEntryUsageFlagsNVX*", reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(pStructIn.pObjectEntryUsageFlags.GetPointer()), "pObjectEntryUsageFlags", pStruct->objectCount,  vinfo_pObjectEntryUsageFlags);  // CCR
    }
    *rString += "\n"; // GDS

    // uint32_t maxUniformBuffersPerDescriptor // SMB
    indentSpaces(rString, indent);
    *rString += "maxUniformBuffersPerDescriptor: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxUniformBuffersPerDescriptor);
    *rString += "\n"; // GDS

    // uint32_t maxStorageBuffersPerDescriptor // SMB
    indentSpaces(rString, indent);
    *rString += "maxStorageBuffersPerDescriptor: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxStorageBuffersPerDescriptor);
    *rString += "\n"; // GDS

    // uint32_t maxStorageImagesPerDescriptor // SMB
    indentSpaces(rString, indent);
    *rString += "maxStorageImagesPerDescriptor:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxStorageImagesPerDescriptor);
    *rString += "\n"; // GDS

    // uint32_t maxSampledImagesPerDescriptor // SMB
    indentSpaces(rString, indent);
    *rString += "maxSampledImagesPerDescriptor:  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxSampledImagesPerDescriptor);
    *rString += "\n"; // GDS

    // uint32_t maxPipelineLayouts // SMB
    indentSpaces(rString, indent);
    *rString += "maxPipelineLayouts:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxPipelineLayouts);
}

template <>
void structureToString<Decoded_VkObjectTableEntryNVX>(std::string* rString, const Decoded_VkObjectTableEntryNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkObjectTableEntryNVX *pStruct = (const VkObjectTableEntryNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkObjectEntryTypeNVX = "; // TEQ
    enumToString_VkObjectEntryTypeNVX(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkObjectEntryUsageFlagBitsNVX); // URW
}

template <>
void structureToString<Decoded_VkObjectTablePipelineEntryNVX>(std::string* rString, const Decoded_VkObjectTablePipelineEntryNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkObjectTablePipelineEntryNVX *pStruct = (const VkObjectTablePipelineEntryNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkObjectEntryTypeNVX = "; // TEQ
    enumToString_VkObjectEntryTypeNVX(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkObjectEntryUsageFlagBitsNVX); // URW
    *rString += "\n"; // GDS

    // VkPipeline pipeline // SMB
    indentSpaces(rString, indent);
    *rString += "pipeline:                       ";
    *rString += "VkPipeline = "; // TEQ
    addrToString(rString, pStructIn.pipeline); // PAQ  
}

template <>
void structureToString<Decoded_VkObjectTableDescriptorSetEntryNVX>(std::string* rString, const Decoded_VkObjectTableDescriptorSetEntryNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkObjectTableDescriptorSetEntryNVX *pStruct = (const VkObjectTableDescriptorSetEntryNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkObjectEntryTypeNVX = "; // TEQ
    enumToString_VkObjectEntryTypeNVX(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkObjectEntryUsageFlagBitsNVX); // URW
    *rString += "\n"; // GDS

    // VkPipelineLayout pipelineLayout // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineLayout:                 ";
    *rString += "VkPipelineLayout = "; // TEQ
    addrToString(rString, pStructIn.pipelineLayout); // PAQ  
    *rString += "\n"; // GDS

    // VkDescriptorSet descriptorSet // SMB
    indentSpaces(rString, indent);
    *rString += "descriptorSet:                  ";
    *rString += "VkDescriptorSet = "; // TEQ
    addrToString(rString, pStructIn.descriptorSet); // PAQ  
}

template <>
void structureToString<Decoded_VkObjectTableVertexBufferEntryNVX>(std::string* rString, const Decoded_VkObjectTableVertexBufferEntryNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkObjectTableVertexBufferEntryNVX *pStruct = (const VkObjectTableVertexBufferEntryNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkObjectEntryTypeNVX = "; // TEQ
    enumToString_VkObjectEntryTypeNVX(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkObjectEntryUsageFlagBitsNVX); // URW
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
}

template <>
void structureToString<Decoded_VkObjectTableIndexBufferEntryNVX>(std::string* rString, const Decoded_VkObjectTableIndexBufferEntryNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkObjectTableIndexBufferEntryNVX *pStruct = (const VkObjectTableIndexBufferEntryNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkObjectEntryTypeNVX = "; // TEQ
    enumToString_VkObjectEntryTypeNVX(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkObjectEntryUsageFlagBitsNVX); // URW
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
    *rString += "\n"; // GDS

    // VkIndexType indexType // SMB
    indentSpaces(rString, indent);
    *rString += "indexType:                      ";
    *rString += "VkIndexType = "; // TEQ
    enumToString_VkIndexType(rString, pStruct->indexType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->indexType);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkObjectTablePushConstantEntryNVX>(std::string* rString, const Decoded_VkObjectTablePushConstantEntryNVX &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkObjectTablePushConstantEntryNVX *pStruct = (const VkObjectTablePushConstantEntryNVX *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkObjectEntryTypeNVX type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkObjectEntryTypeNVX = "; // TEQ
    enumToString_VkObjectEntryTypeNVX(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkObjectEntryUsageFlagsNVX flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkObjectEntryUsageFlagsNVX = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkObjectEntryUsageFlagBitsNVX); // URW
    *rString += "\n"; // GDS

    // VkPipelineLayout pipelineLayout // SMB
    indentSpaces(rString, indent);
    *rString += "pipelineLayout:                 ";
    *rString += "VkPipelineLayout = "; // TEQ
    addrToString(rString, pStructIn.pipelineLayout); // PAQ  
    *rString += "\n"; // GDS

    // VkShaderStageFlags stageFlags // SMB
    indentSpaces(rString, indent);
    *rString += "stageFlags:                     ";
    *rString += "VkShaderStageFlags = "; // TEQ
    flagsToString(rString, pStruct->stageFlags, enumToString_VkShaderStageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkCmdProcessCommandsNVX(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCmdProcessCommandsInfoNVX>& pProcessCommandsInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo // ARG
    if (pProcessCommandsInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdProcessCommandsInfoNVX* = NULL", indentString.c_str(), "pProcessCommandsInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdProcessCommandsInfoNVX* = ", indentString.c_str(), "pProcessCommandsInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pProcessCommandsInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkCmdProcessCommandsInfoNVX>(&tmpString, *pProcessCommandsInfo.GetMetaStructPointer(), 2, pProcessCommandsInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdReserveSpaceForCommandsNVX(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>& pReserveSpaceInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo // ARG
    if (pReserveSpaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdReserveSpaceForCommandsInfoNVX* = NULL", indentString.c_str(), "pReserveSpaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCmdReserveSpaceForCommandsInfoNVX* = ", indentString.c_str(), "pReserveSpaceInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pReserveSpaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkCmdReserveSpaceForCommandsInfoNVX>(&tmpString, *pReserveSpaceInfo.GetMetaStructPointer(), 2, pReserveSpaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateIndirectCommandsLayoutNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkIndirectCommandsLayoutNVX>& pIndirectCommandsLayout)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, pIndirectCommandsLayout)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkIndirectCommandsLayoutCreateInfoNVX* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkIndirectCommandsLayoutCreateInfoNVX* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkIndirectCommandsLayoutCreateInfoNVX>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout // ARG
    if (pIndirectCommandsLayout.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkIndirectCommandsLayoutNVX* = NULL", indentString.c_str(), "pIndirectCommandsLayout:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkIndirectCommandsLayoutNVX* = ", indentString.c_str(), "pIndirectCommandsLayout:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pIndirectCommandsLayout.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyIndirectCommandsLayoutNVX(
    format::HandleId                            device,
    format::HandleId                            indirectCommandsLayout,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkIndirectCommandsLayoutNVX indirectCommandsLayout // ARG
    fprintf(GetFile(), "%s%-32sVkIndirectCommandsLayoutNVX = ", indentString.c_str(), "indirectCommandsLayout:"); // TRP
    tmpString = "";
    addrToString(&tmpString, indirectCommandsLayout);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateObjectTableNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkObjectTableCreateInfoNVX>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkObjectTableNVX>& pObjectTable)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateObjectTableNVX(device, pCreateInfo, pAllocator, pObjectTable)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkObjectTableCreateInfoNVX* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectTableCreateInfoNVX* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectTableCreateInfoNVX* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkObjectTableCreateInfoNVX>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkObjectTableNVX* pObjectTable // ARG
    if (pObjectTable.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkObjectTableNVX* = NULL", indentString.c_str(), "pObjectTable:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkObjectTableNVX* = ", indentString.c_str(), "pObjectTable:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pObjectTable.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyObjectTableNVX(
    format::HandleId                            device,
    format::HandleId                            objectTable,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyObjectTableNVX(device, objectTable, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkObjectTableNVX objectTable // ARG
    fprintf(GetFile(), "%s%-32sVkObjectTableNVX = ", indentString.c_str(), "objectTable:"); // TRP
    tmpString = "";
    addrToString(&tmpString, objectTable);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkUnregisterObjectsNVX(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            objectTable,
    uint32_t                                    objectCount,
    const PointerDecoder<VkObjectEntryTypeNVX>& pObjectEntryTypes,
    const PointerDecoder<uint32_t>&             pObjectIndices)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkUnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkObjectTableNVX objectTable // ARG
    fprintf(GetFile(), "%s%-32sVkObjectTableNVX = ", indentString.c_str(), "objectTable:"); // TRP
    tmpString = "";
    addrToString(&tmpString, objectTable);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t objectCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "objectCount:", objectCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkObjectEntryTypeNVX* pObjectEntryTypes // ARG
    if (pObjectEntryTypes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectEntryTypeNVX* = NULL", indentString.c_str(), "pObjectEntryTypes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkObjectEntryTypeNVX* = %" PRId64 "", indentString.c_str(), "pObjectEntryTypes:", static_cast<uint64_t>(*pObjectEntryTypes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const uint32_t* pObjectIndices // ARG
    if (pObjectIndices.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = NULL", indentString.c_str(), "pObjectIndices:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst uint32_t* = %" PRId64 "", indentString.c_str(), "pObjectIndices:", static_cast<uint64_t>(*pObjectIndices.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>& pFeatures,
    const StructPointerDecoder<Decoded_VkDeviceGeneratedCommandsLimitsNVX>& pLimits)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, pLimits)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGeneratedCommandsFeaturesNVX* pFeatures // ARG
    if (pFeatures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsFeaturesNVX* = NULL", indentString.c_str(), "pFeatures:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsFeaturesNVX* = ", indentString.c_str(), "pFeatures:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pFeatures.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDeviceGeneratedCommandsFeaturesNVX>(&tmpString, *pFeatures.GetMetaStructPointer(), 2, pFeatures.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGeneratedCommandsLimitsNVX* pLimits // ARG
    if (pLimits.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsLimitsNVX* = NULL", indentString.c_str(), "pLimits:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDeviceGeneratedCommandsLimitsNVX* = ", indentString.c_str(), "pLimits:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pLimits.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDeviceGeneratedCommandsLimitsNVX>(&tmpString, *pLimits.GetMetaStructPointer(), 2, pLimits.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkViewportWScalingNV>(std::string* rString, const Decoded_VkViewportWScalingNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkViewportWScalingNV>(std::string* rString, const Decoded_VkViewportWScalingNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkViewportWScalingNV *pStruct = (const VkViewportWScalingNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // float xcoeff // SMB
    indentSpaces(rString, indent);
    *rString += "xcoeff:                         ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->xcoeff);
    *rString += "\n"; // GDS

    // float ycoeff // SMB
    indentSpaces(rString, indent);
    *rString += "ycoeff:                         ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->ycoeff);
}

template <>
void structureToString<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineViewportWScalingStateCreateInfoNV *pStruct = (const VkPipelineViewportWScalingStateCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 viewportWScalingEnable // SMB
    indentSpaces(rString, indent);
    *rString += "viewportWScalingEnable:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->viewportWScalingEnable);
    *rString += "\n"; // GDS

    // uint32_t viewportCount // SMB
    indentSpaces(rString, indent);
    *rString += "viewportCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->viewportCount);
    *rString += "\n"; // GDS

    // const VkViewportWScalingNV* pViewportWScalings // SMB
    indentSpaces(rString, indent);
    *rString += "pViewportWScalings:             ";
    *rString += "const VkViewportWScalingNV* = "; // TEQ
    if (pStruct->pViewportWScalings == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pViewportWScalings->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkViewportWScalingNV>(rString, indent+1, 1, "VkViewportWScalingNV", pStructIn.pViewportWScalings->GetMetaStructPointer(), "pViewportWScalings", pStruct->viewportCount, false, pStructIn.pViewportWScalings->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetViewportWScalingNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkViewportWScalingNV>& pViewportWScalings)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstViewport // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstViewport:", firstViewport); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t viewportCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "viewportCount:", viewportCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkViewportWScalingNV* pViewportWScalings // ARG
    if (pViewportWScalings.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkViewportWScalingNV* = NULL", indentString.c_str(), "pViewportWScalings:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkViewportWScalingNV* = ", indentString.c_str(), "pViewportWScalings:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pViewportWScalings.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkViewportWScalingNV>(&tmpString, 2, 1, "VkViewportWScalingNV",
            pViewportWScalings.GetMetaStructPointer(), "pViewportWScalings", viewportCount, false, pViewportWScalings.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkReleaseDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkReleaseDisplayEXT(physicalDevice, display)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indentString.c_str(), "display:"); // TRP
    tmpString = "";
    addrToString(&tmpString, display);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkAcquireXlibDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    format::HandleId                            display)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAcquireXlibDisplayEXT(physicalDevice, dpy, display)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // void* dpy // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indentString.c_str(), "dpy:", dpy); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indentString.c_str(), "display:"); // TRP
    tmpString = "";
    addrToString(&tmpString, display);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRandROutputDisplayEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    size_t                                      rrOutput,
    const HandlePointerDecoder<VkDisplayKHR>&   pDisplay)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // void* dpy // ARG
    fprintf(GetFile(), "%s%-32svoid* = 0x%" PRIx64 "", indentString.c_str(), "dpy:", dpy); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // size_t rrOutput // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indentString.c_str(), "rrOutput:", rrOutput); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR* pDisplay // ARG
    if (pDisplay.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = NULL", indentString.c_str(), "pDisplay:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDisplayKHR* = ", indentString.c_str(), "pDisplay:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pDisplay.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkSurfaceCounterFlagBitsEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkSurfaceCounterFlagBitsEXT enumValue = static_cast<VkSurfaceCounterFlagBitsEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SURFACE_COUNTER_VBLANK_EXT:
            *rString += std::string("VK_SURFACE_COUNTER_VBLANK_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkSurfaceCapabilities2EXT>(std::string* rString, const Decoded_VkSurfaceCapabilities2EXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkSurfaceCapabilities2EXT>(std::string* rString, const Decoded_VkSurfaceCapabilities2EXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceCapabilities2EXT *pStruct = (const VkSurfaceCapabilities2EXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t minImageCount // SMB
    indentSpaces(rString, indent);
    *rString += "minImageCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->minImageCount);
    *rString += "\n"; // GDS

    // uint32_t maxImageCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageCount);
    *rString += "\n"; // GDS

    // VkExtent2D currentExtent // SMB
    indentSpaces(rString, indent);
    *rString += "currentExtent:                  ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.currentExtent, indent+1,  baseAddr + offsetof(VkSurfaceCapabilities2EXT, currentExtent)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D minImageExtent // SMB
    indentSpaces(rString, indent);
    *rString += "minImageExtent:                 ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.minImageExtent, indent+1,  baseAddr + offsetof(VkSurfaceCapabilities2EXT, minImageExtent)); // AZJ
    *rString += "\n"; // GDS

    // VkExtent2D maxImageExtent // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageExtent:                 ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.maxImageExtent, indent+1,  baseAddr + offsetof(VkSurfaceCapabilities2EXT, maxImageExtent)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t maxImageArrayLayers // SMB
    indentSpaces(rString, indent);
    *rString += "maxImageArrayLayers:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxImageArrayLayers);
    *rString += "\n"; // GDS

    // VkSurfaceTransformFlagsKHR supportedTransforms // SMB
    indentSpaces(rString, indent);
    *rString += "supportedTransforms:            ";
    *rString += "VkSurfaceTransformFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->supportedTransforms, enumToString_VkSurfaceTransformFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // VkSurfaceTransformFlagBitsKHR currentTransform // SMB
    indentSpaces(rString, indent);
    *rString += "currentTransform:               ";
    *rString += "VkSurfaceTransformFlagBitsKHR = "; // TEQ
    enumToString_VkSurfaceTransformFlagBitsKHR(rString, pStruct->currentTransform);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->currentTransform);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkCompositeAlphaFlagsKHR supportedCompositeAlpha // SMB
    indentSpaces(rString, indent);
    *rString += "supportedCompositeAlpha:        ";
    *rString += "VkCompositeAlphaFlagsKHR = "; // TEQ
    flagsToString(rString, pStruct->supportedCompositeAlpha, enumToString_VkCompositeAlphaFlagBitsKHR); // URW
    *rString += "\n"; // GDS

    // VkImageUsageFlags supportedUsageFlags // SMB
    indentSpaces(rString, indent);
    *rString += "supportedUsageFlags:            ";
    *rString += "VkImageUsageFlags = "; // TEQ
    flagsToString(rString, pStruct->supportedUsageFlags, enumToString_VkImageUsageFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSurfaceCounterFlagsEXT supportedSurfaceCounters // SMB
    indentSpaces(rString, indent);
    *rString += "supportedSurfaceCounters:       ";
    *rString += "VkSurfaceCounterFlagsEXT = "; // TEQ
    flagsToString(rString, pStruct->supportedSurfaceCounters, enumToString_VkSurfaceCounterFlagBitsEXT); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    const StructPointerDecoder<Decoded_VkSurfaceCapabilities2EXT>& pSurfaceCapabilities)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR surface // ARG
    fprintf(GetFile(), "%s%-32sVkSurfaceKHR = ", indentString.c_str(), "surface:"); // TRP
    tmpString = "";
    addrToString(&tmpString, surface);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCapabilities2EXT* pSurfaceCapabilities // ARG
    if (pSurfaceCapabilities.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2EXT* = NULL", indentString.c_str(), "pSurfaceCapabilities:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceCapabilities2EXT* = ", indentString.c_str(), "pSurfaceCapabilities:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSurfaceCapabilities.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSurfaceCapabilities2EXT>(&tmpString, *pSurfaceCapabilities.GetMetaStructPointer(), 2, pSurfaceCapabilities.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDisplayPowerStateEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDisplayPowerStateEXT enumValue = static_cast<VkDisplayPowerStateEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DISPLAY_POWER_STATE_OFF_EXT:
            *rString += std::string("VK_DISPLAY_POWER_STATE_OFF_EXT");
            return;
        case VK_DISPLAY_POWER_STATE_SUSPEND_EXT:
            *rString += std::string("VK_DISPLAY_POWER_STATE_SUSPEND_EXT");
            return;
        case VK_DISPLAY_POWER_STATE_ON_EXT:
            *rString += std::string("VK_DISPLAY_POWER_STATE_ON_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDeviceEventTypeEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDeviceEventTypeEXT enumValue = static_cast<VkDeviceEventTypeEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT:
            *rString += std::string("VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDisplayEventTypeEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDisplayEventTypeEXT enumValue = static_cast<VkDisplayEventTypeEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT:
            *rString += std::string("VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkDisplayPowerInfoEXT>(std::string* rString, const Decoded_VkDisplayPowerInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDeviceEventInfoEXT>(std::string* rString, const Decoded_VkDeviceEventInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDisplayEventInfoEXT>(std::string* rString, const Decoded_VkDisplayEventInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSwapchainCounterCreateInfoEXT>(std::string* rString, const Decoded_VkSwapchainCounterCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDisplayPowerInfoEXT>(std::string* rString, const Decoded_VkDisplayPowerInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayPowerInfoEXT *pStruct = (const VkDisplayPowerInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayPowerStateEXT powerState // SMB
    indentSpaces(rString, indent);
    *rString += "powerState:                     ";
    *rString += "VkDisplayPowerStateEXT = "; // TEQ
    enumToString_VkDisplayPowerStateEXT(rString, pStruct->powerState);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->powerState);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkDeviceEventInfoEXT>(std::string* rString, const Decoded_VkDeviceEventInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDeviceEventInfoEXT *pStruct = (const VkDeviceEventInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceEventTypeEXT deviceEvent // SMB
    indentSpaces(rString, indent);
    *rString += "deviceEvent:                    ";
    *rString += "VkDeviceEventTypeEXT = "; // TEQ
    enumToString_VkDeviceEventTypeEXT(rString, pStruct->deviceEvent);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->deviceEvent);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkDisplayEventInfoEXT>(std::string* rString, const Decoded_VkDisplayEventInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayEventInfoEXT *pStruct = (const VkDisplayEventInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDisplayEventTypeEXT displayEvent // SMB
    indentSpaces(rString, indent);
    *rString += "displayEvent:                   ";
    *rString += "VkDisplayEventTypeEXT = "; // TEQ
    enumToString_VkDisplayEventTypeEXT(rString, pStruct->displayEvent);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->displayEvent);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkSwapchainCounterCreateInfoEXT>(std::string* rString, const Decoded_VkSwapchainCounterCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSwapchainCounterCreateInfoEXT *pStruct = (const VkSwapchainCounterCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSurfaceCounterFlagsEXT surfaceCounters // SMB
    indentSpaces(rString, indent);
    *rString += "surfaceCounters:                ";
    *rString += "VkSurfaceCounterFlagsEXT = "; // TEQ
    flagsToString(rString, pStruct->surfaceCounters, enumToString_VkSurfaceCounterFlagBitsEXT); // URW
}

void VulkanAsciiConsumer::Process_vkDisplayPowerControlEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayPowerInfoEXT>& pDisplayPowerInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indentString.c_str(), "display:"); // TRP
    tmpString = "";
    addrToString(&tmpString, display);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayPowerInfoEXT* pDisplayPowerInfo // ARG
    if (pDisplayPowerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPowerInfoEXT* = NULL", indentString.c_str(), "pDisplayPowerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayPowerInfoEXT* = ", indentString.c_str(), "pDisplayPowerInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pDisplayPowerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDisplayPowerInfoEXT>(&tmpString, *pDisplayPowerInfo.GetMetaStructPointer(), 2, pDisplayPowerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkRegisterDeviceEventEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDeviceEventInfoEXT>& pDeviceEventInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDeviceEventInfoEXT* pDeviceEventInfo // ARG
    if (pDeviceEventInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceEventInfoEXT* = NULL", indentString.c_str(), "pDeviceEventInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDeviceEventInfoEXT* = ", indentString.c_str(), "pDeviceEventInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pDeviceEventInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDeviceEventInfoEXT>(&tmpString, *pDeviceEventInfo.GetMetaStructPointer(), 2, pDeviceEventInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence* pFence // ARG
    if (pFence.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFence* = NULL", indentString.c_str(), "pFence:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFence* = ", indentString.c_str(), "pFence:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pFence.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkRegisterDisplayEventEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    const StructPointerDecoder<Decoded_VkDisplayEventInfoEXT>& pDisplayEventInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkFence>&        pFence)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDisplayKHR display // ARG
    fprintf(GetFile(), "%s%-32sVkDisplayKHR = ", indentString.c_str(), "display:"); // TRP
    tmpString = "";
    addrToString(&tmpString, display);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDisplayEventInfoEXT* pDisplayEventInfo // ARG
    if (pDisplayEventInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayEventInfoEXT* = NULL", indentString.c_str(), "pDisplayEventInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDisplayEventInfoEXT* = ", indentString.c_str(), "pDisplayEventInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pDisplayEventInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDisplayEventInfoEXT>(&tmpString, *pDisplayEventInfo.GetMetaStructPointer(), 2, pDisplayEventInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFence* pFence // ARG
    if (pFence.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFence* = NULL", indentString.c_str(), "pFence:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFence* = ", indentString.c_str(), "pFence:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pFence.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetSwapchainCounterEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    const PointerDecoder<uint64_t>&             pCounterValue)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceCounterFlagBitsEXT counter // ARG
    tmpString = "";
    enumToString_VkSurfaceCounterFlagBitsEXT(&tmpString,counter); // EPW
    fprintf(GetFile(), "%s%-32sVkSurfaceCounterFlagBitsEXT = %s", indentString.c_str(), "counter:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pCounterValue // ARG
    if (pCounterValue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indentString.c_str(), "pCounterValue:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indentString.c_str(), "pCounterValue:", static_cast<uint64_t>(*pCounterValue.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkRefreshCycleDurationGOOGLE>(std::string* rString, const Decoded_VkRefreshCycleDurationGOOGLE &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPastPresentationTimingGOOGLE>(std::string* rString, const Decoded_VkPastPresentationTimingGOOGLE &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPresentTimeGOOGLE>(std::string* rString, const Decoded_VkPresentTimeGOOGLE &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPresentTimesInfoGOOGLE>(std::string* rString, const Decoded_VkPresentTimesInfoGOOGLE &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkRefreshCycleDurationGOOGLE>(std::string* rString, const Decoded_VkRefreshCycleDurationGOOGLE &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRefreshCycleDurationGOOGLE *pStruct = (const VkRefreshCycleDurationGOOGLE *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint64_t refreshDuration // SMB
    indentSpaces(rString, indent);
    *rString += "refreshDuration:                ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->refreshDuration);
}

template <>
void structureToString<Decoded_VkPastPresentationTimingGOOGLE>(std::string* rString, const Decoded_VkPastPresentationTimingGOOGLE &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPastPresentationTimingGOOGLE *pStruct = (const VkPastPresentationTimingGOOGLE *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t presentID // SMB
    indentSpaces(rString, indent);
    *rString += "presentID:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->presentID);
    *rString += "\n"; // GDS

    // uint64_t desiredPresentTime // SMB
    indentSpaces(rString, indent);
    *rString += "desiredPresentTime:             ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->desiredPresentTime);
    *rString += "\n"; // GDS

    // uint64_t actualPresentTime // SMB
    indentSpaces(rString, indent);
    *rString += "actualPresentTime:              ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->actualPresentTime);
    *rString += "\n"; // GDS

    // uint64_t earliestPresentTime // SMB
    indentSpaces(rString, indent);
    *rString += "earliestPresentTime:            ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->earliestPresentTime);
    *rString += "\n"; // GDS

    // uint64_t presentMargin // SMB
    indentSpaces(rString, indent);
    *rString += "presentMargin:                  ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->presentMargin);
}

template <>
void structureToString<Decoded_VkPresentTimeGOOGLE>(std::string* rString, const Decoded_VkPresentTimeGOOGLE &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPresentTimeGOOGLE *pStruct = (const VkPresentTimeGOOGLE *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t presentID // SMB
    indentSpaces(rString, indent);
    *rString += "presentID:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->presentID);
    *rString += "\n"; // GDS

    // uint64_t desiredPresentTime // SMB
    indentSpaces(rString, indent);
    *rString += "desiredPresentTime:             ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->desiredPresentTime);
}

template <>
void structureToString<Decoded_VkPresentTimesInfoGOOGLE>(std::string* rString, const Decoded_VkPresentTimesInfoGOOGLE &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPresentTimesInfoGOOGLE *pStruct = (const VkPresentTimesInfoGOOGLE *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t swapchainCount // SMB
    indentSpaces(rString, indent);
    *rString += "swapchainCount:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->swapchainCount);
    *rString += "\n"; // GDS

    // const VkPresentTimeGOOGLE* pTimes // SMB
    indentSpaces(rString, indent);
    *rString += "pTimes:                         ";
    *rString += "const VkPresentTimeGOOGLE* = "; // TEQ
    if (pStruct->pTimes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pTimes->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkPresentTimeGOOGLE>(rString, indent+1, 1, "VkPresentTimeGOOGLE", pStructIn.pTimes->GetMetaStructPointer(), "pTimes", pStruct->swapchainCount, false, pStructIn.pTimes->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkGetRefreshCycleDurationGOOGLE(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const StructPointerDecoder<Decoded_VkRefreshCycleDurationGOOGLE>& pDisplayTimingProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties // ARG
    if (pDisplayTimingProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkRefreshCycleDurationGOOGLE* = NULL", indentString.c_str(), "pDisplayTimingProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkRefreshCycleDurationGOOGLE* = ", indentString.c_str(), "pDisplayTimingProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pDisplayTimingProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkRefreshCycleDurationGOOGLE>(&tmpString, *pDisplayTimingProperties.GetMetaStructPointer(), 2, pDisplayTimingProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPastPresentationTimingGOOGLE(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    const PointerDecoder<uint32_t>&             pPresentationTimingCount,
    const StructPointerDecoder<Decoded_VkPastPresentationTimingGOOGLE>& pPresentationTimings)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPresentationTimingCount // ARG
    if (pPresentationTimingCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPresentationTimingCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPresentationTimingCount:", static_cast<uint64_t>(*pPresentationTimingCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPastPresentationTimingGOOGLE* pPresentationTimings // ARG
    if (pPresentationTimings.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPastPresentationTimingGOOGLE* = NULL", indentString.c_str(), "pPresentationTimings:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPastPresentationTimingGOOGLE* = ", indentString.c_str(), "pPresentationTimings:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pPresentationTimings.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkPastPresentationTimingGOOGLE>(&tmpString, 2, 1, "VkPastPresentationTimingGOOGLE",
            pPresentationTimings.GetMetaStructPointer(), "pPresentationTimings", *pPresentationTimingCount.GetPointer(), false, pPresentationTimings.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDiscardRectangleModeEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDiscardRectangleModeEXT enumValue = static_cast<VkDiscardRectangleModeEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT:
            *rString += std::string("VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT");
            return;
        case VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT:
            *rString += std::string("VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkViewportCoordinateSwizzleNV(std::string* rString, uint32_t enumValueInt32)
{
    VkViewportCoordinateSwizzleNV enumValue = static_cast<VkViewportCoordinateSwizzleNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV");
            return;
        case VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV:
            *rString += std::string("VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT *pStruct = (const VkPhysicalDeviceDiscardRectanglePropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t maxDiscardRectangles // SMB
    indentSpaces(rString, indent);
    *rString += "maxDiscardRectangles:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDiscardRectangles);
}

template <>
void structureToString<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineDiscardRectangleStateCreateInfoEXT *pStruct = (const VkPipelineDiscardRectangleStateCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineDiscardRectangleStateCreateFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineDiscardRectangleStateCreateFlagsEXT = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkDiscardRectangleModeEXT discardRectangleMode // SMB
    indentSpaces(rString, indent);
    *rString += "discardRectangleMode:           ";
    *rString += "VkDiscardRectangleModeEXT = "; // TEQ
    enumToString_VkDiscardRectangleModeEXT(rString, pStruct->discardRectangleMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->discardRectangleMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t discardRectangleCount // SMB
    indentSpaces(rString, indent);
    *rString += "discardRectangleCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->discardRectangleCount);
    *rString += "\n"; // GDS

    // const VkRect2D* pDiscardRectangles // SMB
    indentSpaces(rString, indent);
    *rString += "pDiscardRectangles:             ";
    *rString += "const VkRect2D* = "; // TEQ
    if (pStruct->pDiscardRectangles == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDiscardRectangles->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkRect2D>(rString, indent+1, 1, "VkRect2D", pStructIn.pDiscardRectangles->GetMetaStructPointer(), "pDiscardRectangles", pStruct->discardRectangleCount, false, pStructIn.pDiscardRectangles->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetDiscardRectangleEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pDiscardRectangles)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstDiscardRectangle // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstDiscardRectangle:", firstDiscardRectangle); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t discardRectangleCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "discardRectangleCount:", discardRectangleCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRect2D* pDiscardRectangles // ARG
    if (pDiscardRectangles.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = NULL", indentString.c_str(), "pDiscardRectangles:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = ", indentString.c_str(), "pDiscardRectangles:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pDiscardRectangles.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkRect2D>(&tmpString, 2, 1, "VkRect2D",
            pDiscardRectangles.GetMetaStructPointer(), "pDiscardRectangles", discardRectangleCount, false, pDiscardRectangles.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkConservativeRasterizationModeEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkConservativeRasterizationModeEXT enumValue = static_cast<VkConservativeRasterizationModeEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT:
            *rString += std::string("VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT");
            return;
        case VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT:
            *rString += std::string("VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT");
            return;
        case VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT:
            *rString += std::string("VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkXYColorEXT>(std::string* rString, const Decoded_VkXYColorEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkHdrMetadataEXT>(std::string* rString, const Decoded_VkHdrMetadataEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkXYColorEXT>(std::string* rString, const Decoded_VkXYColorEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkXYColorEXT *pStruct = (const VkXYColorEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // float x // SMB
    indentSpaces(rString, indent);
    *rString += "x:                              ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->x);
    *rString += "\n"; // GDS

    // float y // SMB
    indentSpaces(rString, indent);
    *rString += "y:                              ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->y);
}

template <>
void structureToString<Decoded_VkHdrMetadataEXT>(std::string* rString, const Decoded_VkHdrMetadataEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkHdrMetadataEXT *pStruct = (const VkHdrMetadataEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkXYColorEXT displayPrimaryRed // SMB
    indentSpaces(rString, indent);
    *rString += "displayPrimaryRed:              ";
    *rString += "VkXYColorEXT = "; // TEQ
    structureToString<Decoded_VkXYColorEXT>(rString, *pStructIn.displayPrimaryRed, indent+1,  baseAddr + offsetof(VkHdrMetadataEXT, displayPrimaryRed)); // AZJ
    *rString += "\n"; // GDS

    // VkXYColorEXT displayPrimaryGreen // SMB
    indentSpaces(rString, indent);
    *rString += "displayPrimaryGreen:            ";
    *rString += "VkXYColorEXT = "; // TEQ
    structureToString<Decoded_VkXYColorEXT>(rString, *pStructIn.displayPrimaryGreen, indent+1,  baseAddr + offsetof(VkHdrMetadataEXT, displayPrimaryGreen)); // AZJ
    *rString += "\n"; // GDS

    // VkXYColorEXT displayPrimaryBlue // SMB
    indentSpaces(rString, indent);
    *rString += "displayPrimaryBlue:             ";
    *rString += "VkXYColorEXT = "; // TEQ
    structureToString<Decoded_VkXYColorEXT>(rString, *pStructIn.displayPrimaryBlue, indent+1,  baseAddr + offsetof(VkHdrMetadataEXT, displayPrimaryBlue)); // AZJ
    *rString += "\n"; // GDS

    // VkXYColorEXT whitePoint // SMB
    indentSpaces(rString, indent);
    *rString += "whitePoint:                     ";
    *rString += "VkXYColorEXT = "; // TEQ
    structureToString<Decoded_VkXYColorEXT>(rString, *pStructIn.whitePoint, indent+1,  baseAddr + offsetof(VkHdrMetadataEXT, whitePoint)); // AZJ
    *rString += "\n"; // GDS

    // float maxLuminance // SMB
    indentSpaces(rString, indent);
    *rString += "maxLuminance:                   ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxLuminance);
    *rString += "\n"; // GDS

    // float minLuminance // SMB
    indentSpaces(rString, indent);
    *rString += "minLuminance:                   ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->minLuminance);
    *rString += "\n"; // GDS

    // float maxContentLightLevel // SMB
    indentSpaces(rString, indent);
    *rString += "maxContentLightLevel:           ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxContentLightLevel);
    *rString += "\n"; // GDS

    // float maxFrameAverageLightLevel // SMB
    indentSpaces(rString, indent);
    *rString += "maxFrameAverageLightLevel:      ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->maxFrameAverageLightLevel);
}

void VulkanAsciiConsumer::Process_vkSetHdrMetadataEXT(
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    const HandlePointerDecoder<VkSwapchainKHR>& pSwapchains,
    const StructPointerDecoder<Decoded_VkHdrMetadataEXT>& pMetadata)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t swapchainCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "swapchainCount:", swapchainCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkSwapchainKHR* pSwapchains // ARG
    if (pSwapchains.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainKHR* = NULL", indentString.c_str(), "pSwapchains:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSwapchainKHR* = ", indentString.c_str(), "pSwapchains:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pSwapchains.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pSwapchains = {true, false, false, nullptr};
        arrayToString<const VkSwapchainKHR*>(&tmpString, 1, 1, "const VkSwapchainKHR*", reinterpret_cast<const VkSwapchainKHR*>(pSwapchains.GetPointer()), "pSwapchains", swapchainCount, vinfo_pSwapchains); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkHdrMetadataEXT* pMetadata // ARG
    if (pMetadata.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkHdrMetadataEXT* = NULL", indentString.c_str(), "pMetadata:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkHdrMetadataEXT* = ", indentString.c_str(), "pMetadata:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pMetadata.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkHdrMetadataEXT>(&tmpString, 2, 1, "VkHdrMetadataEXT",
            pMetadata.GetMetaStructPointer(), "pMetadata", swapchainCount, false, pMetadata.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(std::string* rString, const Decoded_VkIOSSurfaceCreateInfoMVK &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(std::string* rString, const Decoded_VkIOSSurfaceCreateInfoMVK &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkIOSSurfaceCreateInfoMVK *pStruct = (const VkIOSSurfaceCreateInfoMVK *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkIOSSurfaceCreateFlagsMVK flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkIOSSurfaceCreateFlagsMVK = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // const void* pView // SMB
    indentSpaces(rString, indent);
    *rString += "pView:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pView == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pView); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateIOSSurfaceMVK(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkIOSSurfaceCreateInfoMVK>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkIOSSurfaceCreateInfoMVK* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkIOSSurfaceCreateInfoMVK* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkIOSSurfaceCreateInfoMVK* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkIOSSurfaceCreateInfoMVK>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(std::string* rString, const Decoded_VkMacOSSurfaceCreateInfoMVK &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(std::string* rString, const Decoded_VkMacOSSurfaceCreateInfoMVK &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMacOSSurfaceCreateInfoMVK *pStruct = (const VkMacOSSurfaceCreateInfoMVK *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkMacOSSurfaceCreateFlagsMVK flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkMacOSSurfaceCreateFlagsMVK = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // const void* pView // SMB
    indentSpaces(rString, indent);
    *rString += "pView:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pView == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pView); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateMacOSSurfaceMVK(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkMacOSSurfaceCreateInfoMVK>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMacOSSurfaceCreateInfoMVK* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMacOSSurfaceCreateInfoMVK* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMacOSSurfaceCreateInfoMVK* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMacOSSurfaceCreateInfoMVK>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDebugUtilsMessageTypeFlagBitsEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDebugUtilsMessageTypeFlagBitsEXT enumValue = static_cast<VkDebugUtilsMessageTypeFlagBitsEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT:
            *rString += std::string("VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT:
            *rString += std::string("VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT:
            *rString += std::string("VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkDebugUtilsMessageSeverityFlagBitsEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDebugUtilsMessageSeverityFlagBitsEXT enumValue = static_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:
            *rString += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:
            *rString += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:
            *rString += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT");
            return;
        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:
            *rString += std::string("VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(std::string* rString, const Decoded_VkDebugUtilsObjectNameInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(std::string* rString, const Decoded_VkDebugUtilsObjectTagInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDebugUtilsLabelEXT>(std::string* rString, const Decoded_VkDebugUtilsLabelEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(std::string* rString, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(std::string* rString, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(std::string* rString, const Decoded_VkDebugUtilsObjectNameInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugUtilsObjectNameInfoEXT *pStruct = (const VkDebugUtilsObjectNameInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkObjectType objectType // SMB
    indentSpaces(rString, indent);
    *rString += "objectType:                     ";
    *rString += "VkObjectType = "; // TEQ
    enumToString_VkObjectType(rString, pStruct->objectType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->objectType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint64_t objectHandle // SMB
    indentSpaces(rString, indent);
    *rString += "objectHandle:                   ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->objectHandle);
    *rString += "\n"; // GDS

    // const char* pObjectName // SMB
    indentSpaces(rString, indent);
    *rString += "pObjectName:                    ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pObjectName); // TGH
}

template <>
void structureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(std::string* rString, const Decoded_VkDebugUtilsObjectTagInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugUtilsObjectTagInfoEXT *pStruct = (const VkDebugUtilsObjectTagInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkObjectType objectType // SMB
    indentSpaces(rString, indent);
    *rString += "objectType:                     ";
    *rString += "VkObjectType = "; // TEQ
    enumToString_VkObjectType(rString, pStruct->objectType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->objectType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint64_t objectHandle // SMB
    indentSpaces(rString, indent);
    *rString += "objectHandle:                   ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->objectHandle);
    *rString += "\n"; // GDS

    // uint64_t tagName // SMB
    indentSpaces(rString, indent);
    *rString += "tagName:                        ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->tagName);
    *rString += "\n"; // GDS

    // size_t tagSize // SMB
    indentSpaces(rString, indent);
    *rString += "tagSize:                        ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->tagSize);
    *rString += "\n"; // GDS

    // const void* pTag // SMB
    indentSpaces(rString, indent);
    *rString += "pTag:                           ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pTag == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pTag.GetAddress()); // AHW
    }
}

template <>
void structureToString<Decoded_VkDebugUtilsLabelEXT>(std::string* rString, const Decoded_VkDebugUtilsLabelEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugUtilsLabelEXT *pStruct = (const VkDebugUtilsLabelEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // const char* pLabelName // SMB
    indentSpaces(rString, indent);
    *rString += "pLabelName:                     ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pLabelName); // TGH
    *rString += "\n"; // GDS

    // float color // SMB
    indentSpaces(rString, indent);
    *rString += "color:                          ";
    *rString += "float[";
    *rString += "4";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkDebugUtilsLabelEXT, color)); // IYY
    ValueToStringStruct vinfo_color = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->color), "color", 4, vinfo_color); // JPA
}

template <>
void structureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(std::string* rString, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugUtilsMessengerCallbackDataEXT *pStruct = (const VkDebugUtilsMessengerCallbackDataEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDebugUtilsMessengerCallbackDataFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDebugUtilsMessengerCallbackDataFlagsEXT = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // const char* pMessageIdName // SMB
    indentSpaces(rString, indent);
    *rString += "pMessageIdName:                 ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pMessageIdName); // TGH
    *rString += "\n"; // GDS

    // int32_t messageIdNumber // SMB
    indentSpaces(rString, indent);
    *rString += "messageIdNumber:                ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->messageIdNumber);
    *rString += "\n"; // GDS

    // const char* pMessage // SMB
    indentSpaces(rString, indent);
    *rString += "pMessage:                       ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->pMessage); // TGH
    *rString += "\n"; // GDS

    // uint32_t queueLabelCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueLabelCount:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueLabelCount);
    *rString += "\n"; // GDS

    // const VkDebugUtilsLabelEXT* pQueueLabels // SMB
    indentSpaces(rString, indent);
    *rString += "pQueueLabels:                   ";
    *rString += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pStruct->pQueueLabels == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pQueueLabels->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(rString, indent+1, 1, "VkDebugUtilsLabelEXT", pStructIn.pQueueLabels->GetMetaStructPointer(), "pQueueLabels", pStruct->queueLabelCount, false, pStructIn.pQueueLabels->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t cmdBufLabelCount // SMB
    indentSpaces(rString, indent);
    *rString += "cmdBufLabelCount:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->cmdBufLabelCount);
    *rString += "\n"; // GDS

    // const VkDebugUtilsLabelEXT* pCmdBufLabels // SMB
    indentSpaces(rString, indent);
    *rString += "pCmdBufLabels:                  ";
    *rString += "const VkDebugUtilsLabelEXT* = "; // TEQ
    if (pStruct->pCmdBufLabels == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCmdBufLabels->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDebugUtilsLabelEXT>(rString, indent+1, 1, "VkDebugUtilsLabelEXT", pStructIn.pCmdBufLabels->GetMetaStructPointer(), "pCmdBufLabels", pStruct->cmdBufLabelCount, false, pStructIn.pCmdBufLabels->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t objectCount // SMB
    indentSpaces(rString, indent);
    *rString += "objectCount:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->objectCount);
    *rString += "\n"; // GDS

    // const VkDebugUtilsObjectNameInfoEXT* pObjects // SMB
    indentSpaces(rString, indent);
    *rString += "pObjects:                       ";
    *rString += "const VkDebugUtilsObjectNameInfoEXT* = "; // TEQ
    if (pStruct->pObjects == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pObjects->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(rString, indent+1, 1, "VkDebugUtilsObjectNameInfoEXT", pStructIn.pObjects->GetMetaStructPointer(), "pObjects", pStruct->objectCount, false, pStructIn.pObjects->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(std::string* rString, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDebugUtilsMessengerCreateInfoEXT *pStruct = (const VkDebugUtilsMessengerCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDebugUtilsMessengerCreateFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkDebugUtilsMessengerCreateFlagsEXT = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkDebugUtilsMessageSeverityFlagsEXT messageSeverity // SMB
    indentSpaces(rString, indent);
    *rString += "messageSeverity:                ";
    *rString += "VkDebugUtilsMessageSeverityFlagsEXT = "; // TEQ
    flagsToString(rString, pStruct->messageSeverity, enumToString_VkDebugUtilsMessageSeverityFlagBitsEXT); // URW
    *rString += "\n"; // GDS

    // VkDebugUtilsMessageTypeFlagsEXT messageType // SMB
    indentSpaces(rString, indent);
    *rString += "messageType:                    ";
    *rString += "VkDebugUtilsMessageTypeFlagsEXT = "; // TEQ
    flagsToString(rString, pStruct->messageType, enumToString_VkDebugUtilsMessageTypeFlagBitsEXT); // URW
    *rString += "\n"; // GDS

    // PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback // SMB
    indentSpaces(rString, indent);
    *rString += "pfnUserCallback:                ";
    *rString += "PFN_vkDebugUtilsMessengerCallbackEXT = "; // TEQ
    addrToString(rString, reinterpret_cast<uint64_t>(pStruct->pfnUserCallback)); // WRX
    *rString += "\n"; // GDS

    // void* pUserData // SMB
    indentSpaces(rString, indent);
    *rString += "pUserData:                      ";
    *rString += "void* = "; // TEQ
    if (pStruct->pUserData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pUserData); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkSetDebugUtilsObjectNameEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugUtilsObjectNameInfoEXT>& pNameInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkSetDebugUtilsObjectNameEXT(device, pNameInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsObjectNameInfoEXT* pNameInfo // ARG
    if (pNameInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectNameInfoEXT* = NULL", indentString.c_str(), "pNameInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectNameInfoEXT* = ", indentString.c_str(), "pNameInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pNameInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsObjectNameInfoEXT>(&tmpString, *pNameInfo.GetMetaStructPointer(), 2, pNameInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkSetDebugUtilsObjectTagEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkDebugUtilsObjectTagInfoEXT>& pTagInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkSetDebugUtilsObjectTagEXT(device, pTagInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsObjectTagInfoEXT* pTagInfo // ARG
    if (pTagInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectTagInfoEXT* = NULL", indentString.c_str(), "pTagInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsObjectTagInfoEXT* = ", indentString.c_str(), "pTagInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pTagInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsObjectTagInfoEXT>(&tmpString, *pTagInfo.GetMetaStructPointer(), 2, pTagInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueBeginDebugUtilsLabelEXT(
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indentString.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indentString.c_str(), "pLabelInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsLabelEXT>(&tmpString, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueEndDebugUtilsLabelEXT(
    format::HandleId                            queue)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueueEndDebugUtilsLabelEXT(queue)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueInsertDebugUtilsLabelEXT(
    format::HandleId                            queue,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indentString.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indentString.c_str(), "pLabelInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsLabelEXT>(&tmpString, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBeginDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indentString.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indentString.c_str(), "pLabelInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsLabelEXT>(&tmpString, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdEndDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdEndDebugUtilsLabelEXT(commandBuffer)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdInsertDebugUtilsLabelEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>& pLabelInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsLabelEXT* pLabelInfo // ARG
    if (pLabelInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = NULL", indentString.c_str(), "pLabelInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsLabelEXT* = ", indentString.c_str(), "pLabelInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pLabelInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsLabelEXT>(&tmpString, *pLabelInfo.GetMetaStructPointer(), 2, pLabelInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateDebugUtilsMessengerEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkDebugUtilsMessengerCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkDebugUtilsMessengerEXT>& pMessenger)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCreateInfoEXT* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCreateInfoEXT* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsMessengerCreateInfoEXT>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessengerEXT* pMessenger // ARG
    if (pMessenger.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkDebugUtilsMessengerEXT* = NULL", indentString.c_str(), "pMessenger:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkDebugUtilsMessengerEXT* = ", indentString.c_str(), "pMessenger:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pMessenger.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyDebugUtilsMessengerEXT(
    format::HandleId                            instance,
    format::HandleId                            messenger,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessengerEXT messenger // ARG
    fprintf(GetFile(), "%s%-32sVkDebugUtilsMessengerEXT = ", indentString.c_str(), "messenger:"); // TRP
    tmpString = "";
    addrToString(&tmpString, messenger);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkSubmitDebugUtilsMessageEXT(
    format::HandleId                            instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT             messageTypes,
    const StructPointerDecoder<Decoded_VkDebugUtilsMessengerCallbackDataEXT>& pCallbackData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData)");
    fprintf(GetFile(), " returns void:\n");

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity // ARG
    tmpString = "";
    enumToString_VkDebugUtilsMessageSeverityFlagBitsEXT(&tmpString,messageSeverity); // EPW
    fprintf(GetFile(), "%s%-32sVkDebugUtilsMessageSeverityFlagBitsEXT = %s", indentString.c_str(), "messageSeverity:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkDebugUtilsMessageTypeFlagsEXT messageTypes // ARG
    tmpString = "";
    flagsToString(&tmpString, messageTypes, enumToString_VkDebugUtilsMessageTypeFlagBitsEXT);
    fprintf(GetFile(), "%s%-32sVkDebugUtilsMessageTypeFlagsEXT = %s", indentString.c_str(), "messageTypes:", tmpString.c_str()); // XZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData // ARG
    if (pCallbackData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCallbackDataEXT* = NULL", indentString.c_str(), "pCallbackData:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkDebugUtilsMessengerCallbackDataEXT* = ", indentString.c_str(), "pCallbackData:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCallbackData.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkDebugUtilsMessengerCallbackDataEXT>(&tmpString, *pCallbackData.GetMetaStructPointer(), 2, pCallbackData.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkAndroidHardwareBufferUsageANDROID>(std::string* rString, const Decoded_VkAndroidHardwareBufferUsageANDROID &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(std::string* rString, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>(std::string* rString, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImportAndroidHardwareBufferInfoANDROID>(std::string* rString, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(std::string* rString, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkExternalFormatANDROID>(std::string* rString, const Decoded_VkExternalFormatANDROID &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkAndroidHardwareBufferUsageANDROID>(std::string* rString, const Decoded_VkAndroidHardwareBufferUsageANDROID &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAndroidHardwareBufferUsageANDROID *pStruct = (const VkAndroidHardwareBufferUsageANDROID *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint64_t androidHardwareBufferUsage // SMB
    indentSpaces(rString, indent);
    *rString += "androidHardwareBufferUsage:     ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->androidHardwareBufferUsage);
}

template <>
void structureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(std::string* rString, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAndroidHardwareBufferPropertiesANDROID *pStruct = (const VkAndroidHardwareBufferPropertiesANDROID *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceSize allocationSize // SMB
    indentSpaces(rString, indent);
    *rString += "allocationSize:                 ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->allocationSize);
    *rString += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypeBits:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryTypeBits);
}

template <>
void structureToString<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>(std::string* rString, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAndroidHardwareBufferFormatPropertiesANDROID *pStruct = (const VkAndroidHardwareBufferFormatPropertiesANDROID *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFormat format // SMB
    indentSpaces(rString, indent);
    *rString += "format:                         ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->format);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->format);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint64_t externalFormat // SMB
    indentSpaces(rString, indent);
    *rString += "externalFormat:                 ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->externalFormat);
    *rString += "\n"; // GDS

    // VkFormatFeatureFlags formatFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "formatFeatures:                 ";
    *rString += "VkFormatFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->formatFeatures, enumToString_VkFormatFeatureFlagBits); // URW
    *rString += "\n"; // GDS

    // VkComponentMapping samplerYcbcrConversionComponents // SMB
    indentSpaces(rString, indent);
    *rString += "samplerYcbcrConversionComponents: ";
    *rString += "VkComponentMapping = "; // TEQ
    structureToString<Decoded_VkComponentMapping>(rString, *pStructIn.samplerYcbcrConversionComponents, indent+1,  baseAddr + offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents)); // AZJ
    *rString += "\n"; // GDS

    // VkSamplerYcbcrModelConversion suggestedYcbcrModel // SMB
    indentSpaces(rString, indent);
    *rString += "suggestedYcbcrModel:            ";
    *rString += "VkSamplerYcbcrModelConversion = "; // TEQ
    enumToString_VkSamplerYcbcrModelConversion(rString, pStruct->suggestedYcbcrModel);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->suggestedYcbcrModel);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSamplerYcbcrRange suggestedYcbcrRange // SMB
    indentSpaces(rString, indent);
    *rString += "suggestedYcbcrRange:            ";
    *rString += "VkSamplerYcbcrRange = "; // TEQ
    enumToString_VkSamplerYcbcrRange(rString, pStruct->suggestedYcbcrRange);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->suggestedYcbcrRange);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkChromaLocation suggestedXChromaOffset // SMB
    indentSpaces(rString, indent);
    *rString += "suggestedXChromaOffset:         ";
    *rString += "VkChromaLocation = "; // TEQ
    enumToString_VkChromaLocation(rString, pStruct->suggestedXChromaOffset);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->suggestedXChromaOffset);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkChromaLocation suggestedYChromaOffset // SMB
    indentSpaces(rString, indent);
    *rString += "suggestedYChromaOffset:         ";
    *rString += "VkChromaLocation = "; // TEQ
    enumToString_VkChromaLocation(rString, pStruct->suggestedYChromaOffset);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->suggestedYChromaOffset);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkImportAndroidHardwareBufferInfoANDROID>(std::string* rString, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportAndroidHardwareBufferInfoANDROID *pStruct = (const VkImportAndroidHardwareBufferInfoANDROID *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // struct void* buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "struct void* = "; // TEQ
    if (pStruct->buffer == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.buffer); // PWR
    }
}

template <>
void structureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(std::string* rString, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryGetAndroidHardwareBufferInfoANDROID *pStruct = (const VkMemoryGetAndroidHardwareBufferInfoANDROID *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
}

template <>
void structureToString<Decoded_VkExternalFormatANDROID>(std::string* rString, const Decoded_VkExternalFormatANDROID &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkExternalFormatANDROID *pStruct = (const VkExternalFormatANDROID *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint64_t externalFormat // SMB
    indentSpaces(rString, indent);
    *rString += "externalFormat:                 ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->externalFormat);
}

void VulkanAsciiConsumer::Process_vkGetAndroidHardwareBufferPropertiesANDROID(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint64_t                                    buffer,
    const StructPointerDecoder<Decoded_VkAndroidHardwareBufferPropertiesANDROID>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const struct void* buffer // ARG
    fprintf(GetFile(), "%s%-32sconst struct void* = 0x%" PRIx64 "", indentString.c_str(), "buffer:", buffer); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkAndroidHardwareBufferPropertiesANDROID* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkAndroidHardwareBufferPropertiesANDROID* = NULL", indentString.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkAndroidHardwareBufferPropertiesANDROID* = ", indentString.c_str(), "pProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAndroidHardwareBufferPropertiesANDROID>(&tmpString, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetMemoryAndroidHardwareBufferANDROID(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>& pInfo,
    const PointerDecoder<uint64_t>&             pBuffer)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetAndroidHardwareBufferInfoANDROID* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMemoryGetAndroidHardwareBufferInfoANDROID* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // struct void** pBuffer // ARG
    if (pBuffer.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sstruct void** = NULL", indentString.c_str(), "pBuffer:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sstruct void** = ", indentString.c_str(), "pBuffer:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pBuffer.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkSamplerReductionModeEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkSamplerReductionModeEXT enumValue = static_cast<VkSamplerReductionModeEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SAMPLER_REDUCTION_MODE_MAX_EXT:
            *rString += std::string("VK_SAMPLER_REDUCTION_MODE_MAX_EXT");
            return;
        case VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT:
            *rString += std::string("VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT");
            return;
        case VK_SAMPLER_REDUCTION_MODE_MIN_EXT:
            *rString += std::string("VK_SAMPLER_REDUCTION_MODE_MIN_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkSampleLocationEXT>(std::string* rString, const Decoded_VkSampleLocationEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSampleLocationsInfoEXT>(std::string* rString, const Decoded_VkSampleLocationsInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAttachmentSampleLocationsEXT>(std::string* rString, const Decoded_VkAttachmentSampleLocationsEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSubpassSampleLocationsEXT>(std::string* rString, const Decoded_VkSubpassSampleLocationsEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>(std::string* rString, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMultisamplePropertiesEXT>(std::string* rString, const Decoded_VkMultisamplePropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkSampleLocationEXT>(std::string* rString, const Decoded_VkSampleLocationEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSampleLocationEXT *pStruct = (const VkSampleLocationEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // float x // SMB
    indentSpaces(rString, indent);
    *rString += "x:                              ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->x);
    *rString += "\n"; // GDS

    // float y // SMB
    indentSpaces(rString, indent);
    *rString += "y:                              ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->y);
}

template <>
void structureToString<Decoded_VkSampleLocationsInfoEXT>(std::string* rString, const Decoded_VkSampleLocationsInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSampleLocationsInfoEXT *pStruct = (const VkSampleLocationsInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSampleCountFlagBits sampleLocationsPerPixel // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationsPerPixel:        ";
    *rString += "VkSampleCountFlagBits = "; // TEQ
    enumToString_VkSampleCountFlagBits(rString, pStruct->sampleLocationsPerPixel);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sampleLocationsPerPixel);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkExtent2D sampleLocationGridSize // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationGridSize:         ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.sampleLocationGridSize, indent+1,  baseAddr + offsetof(VkSampleLocationsInfoEXT, sampleLocationGridSize)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t sampleLocationsCount // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationsCount:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->sampleLocationsCount);
    *rString += "\n"; // GDS

    // const VkSampleLocationEXT* pSampleLocations // SMB
    indentSpaces(rString, indent);
    *rString += "pSampleLocations:               ";
    *rString += "const VkSampleLocationEXT* = "; // TEQ
    if (pStruct->pSampleLocations == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSampleLocations->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSampleLocationEXT>(rString, indent+1, 1, "VkSampleLocationEXT", pStructIn.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pStruct->sampleLocationsCount, false, pStructIn.pSampleLocations->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkAttachmentSampleLocationsEXT>(std::string* rString, const Decoded_VkAttachmentSampleLocationsEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAttachmentSampleLocationsEXT *pStruct = (const VkAttachmentSampleLocationsEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t attachmentIndex // SMB
    indentSpaces(rString, indent);
    *rString += "attachmentIndex:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachmentIndex);
    *rString += "\n"; // GDS

    // VkSampleLocationsInfoEXT sampleLocationsInfo // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationsInfo:            ";
    *rString += "VkSampleLocationsInfoEXT = "; // TEQ
    structureToString<Decoded_VkSampleLocationsInfoEXT>(rString, *pStructIn.sampleLocationsInfo, indent+1,  baseAddr + offsetof(VkAttachmentSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

template <>
void structureToString<Decoded_VkSubpassSampleLocationsEXT>(std::string* rString, const Decoded_VkSubpassSampleLocationsEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSubpassSampleLocationsEXT *pStruct = (const VkSubpassSampleLocationsEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t subpassIndex // SMB
    indentSpaces(rString, indent);
    *rString += "subpassIndex:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->subpassIndex);
    *rString += "\n"; // GDS

    // VkSampleLocationsInfoEXT sampleLocationsInfo // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationsInfo:            ";
    *rString += "VkSampleLocationsInfoEXT = "; // TEQ
    structureToString<Decoded_VkSampleLocationsInfoEXT>(rString, *pStructIn.sampleLocationsInfo, indent+1,  baseAddr + offsetof(VkSubpassSampleLocationsEXT, sampleLocationsInfo)); // AZJ
}

template <>
void structureToString<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>(std::string* rString, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRenderPassSampleLocationsBeginInfoEXT *pStruct = (const VkRenderPassSampleLocationsBeginInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t attachmentInitialSampleLocationsCount // SMB
    indentSpaces(rString, indent);
    *rString += "attachmentInitialSampleLocationsCount: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->attachmentInitialSampleLocationsCount);
    *rString += "\n"; // GDS

    // const VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations // SMB
    indentSpaces(rString, indent);
    *rString += "pAttachmentInitialSampleLocations: ";
    *rString += "const VkAttachmentSampleLocationsEXT* = "; // TEQ
    if (pStruct->pAttachmentInitialSampleLocations == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAttachmentInitialSampleLocations->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkAttachmentSampleLocationsEXT>(rString, indent+1, 1, "VkAttachmentSampleLocationsEXT", pStructIn.pAttachmentInitialSampleLocations->GetMetaStructPointer(), "pAttachmentInitialSampleLocations", pStruct->attachmentInitialSampleLocationsCount, false, pStructIn.pAttachmentInitialSampleLocations->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t postSubpassSampleLocationsCount // SMB
    indentSpaces(rString, indent);
    *rString += "postSubpassSampleLocationsCount: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->postSubpassSampleLocationsCount);
    *rString += "\n"; // GDS

    // const VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations // SMB
    indentSpaces(rString, indent);
    *rString += "pPostSubpassSampleLocations:    ";
    *rString += "const VkSubpassSampleLocationsEXT* = "; // TEQ
    if (pStruct->pPostSubpassSampleLocations == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pPostSubpassSampleLocations->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSubpassSampleLocationsEXT>(rString, indent+1, 1, "VkSubpassSampleLocationsEXT", pStructIn.pPostSubpassSampleLocations->GetMetaStructPointer(), "pPostSubpassSampleLocations", pStruct->postSubpassSampleLocationsCount, false, pStructIn.pPostSubpassSampleLocations->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineSampleLocationsStateCreateInfoEXT *pStruct = (const VkPipelineSampleLocationsStateCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 sampleLocationsEnable // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationsEnable:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->sampleLocationsEnable);
    *rString += "\n"; // GDS

    // VkSampleLocationsInfoEXT sampleLocationsInfo // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationsInfo:            ";
    *rString += "VkSampleLocationsInfoEXT = "; // TEQ
    structureToString<Decoded_VkSampleLocationsInfoEXT>(rString, *pStructIn.sampleLocationsInfo, indent+1,  baseAddr + offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo)); // AZJ
}

template <>
void structureToString<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceSampleLocationsPropertiesEXT *pStruct = (const VkPhysicalDeviceSampleLocationsPropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkSampleCountFlags sampleLocationSampleCounts // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationSampleCounts:     ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->sampleLocationSampleCounts, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkExtent2D maxSampleLocationGridSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxSampleLocationGridSize:      ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.maxSampleLocationGridSize, indent+1,  baseAddr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize)); // AZJ
    *rString += "\n"; // GDS

    // float sampleLocationCoordinateRange // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationCoordinateRange:  ";
    *rString += "float[";
    *rString += "2";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationCoordinateRange)); // IYY
    ValueToStringStruct vinfo_sampleLocationCoordinateRange = {false, false, false, nullptr};
    arrayToString<float*>(rString, indent, 0, "float", const_cast<float*>(pStruct->sampleLocationCoordinateRange), "sampleLocationCoordinateRange", 2, vinfo_sampleLocationCoordinateRange); // JPA
    *rString += "\n"; // GDS

    // uint32_t sampleLocationSubPixelBits // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationSubPixelBits:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->sampleLocationSubPixelBits);
    *rString += "\n"; // GDS

    // VkBool32 variableSampleLocations // SMB
    indentSpaces(rString, indent);
    *rString += "variableSampleLocations:        ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->variableSampleLocations);
}

template <>
void structureToString<Decoded_VkMultisamplePropertiesEXT>(std::string* rString, const Decoded_VkMultisamplePropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMultisamplePropertiesEXT *pStruct = (const VkMultisamplePropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExtent2D maxSampleLocationGridSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxSampleLocationGridSize:      ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.maxSampleLocationGridSize, indent+1,  baseAddr + offsetof(VkMultisamplePropertiesEXT, maxSampleLocationGridSize)); // AZJ
}

void VulkanAsciiConsumer::Process_vkCmdSetSampleLocationsEXT(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkSampleLocationsInfoEXT>& pSampleLocationsInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkSampleLocationsInfoEXT* pSampleLocationsInfo // ARG
    if (pSampleLocationsInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkSampleLocationsInfoEXT* = NULL", indentString.c_str(), "pSampleLocationsInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkSampleLocationsInfoEXT* = ", indentString.c_str(), "pSampleLocationsInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSampleLocationsInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkSampleLocationsInfoEXT>(&tmpString, *pSampleLocationsInfo.GetMetaStructPointer(), 2, pSampleLocationsInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceMultisamplePropertiesEXT(
    format::HandleId                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    const StructPointerDecoder<Decoded_VkMultisamplePropertiesEXT>& pMultisampleProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties)");
    fprintf(GetFile(), " returns void:\n");

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSampleCountFlagBits samples // ARG
    tmpString = "";
    enumToString_VkSampleCountFlagBits(&tmpString,samples); // EPW
    fprintf(GetFile(), "%s%-32sVkSampleCountFlagBits = %s", indentString.c_str(), "samples:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkMultisamplePropertiesEXT* pMultisampleProperties // ARG
    if (pMultisampleProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMultisamplePropertiesEXT* = NULL", indentString.c_str(), "pMultisampleProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMultisamplePropertiesEXT* = ", indentString.c_str(), "pMultisampleProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMultisampleProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMultisamplePropertiesEXT>(&tmpString, *pMultisampleProperties.GetMetaStructPointer(), 2, pMultisampleProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkBlendOverlapEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkBlendOverlapEXT enumValue = static_cast<VkBlendOverlapEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_BLEND_OVERLAP_CONJOINT_EXT:
            *rString += std::string("VK_BLEND_OVERLAP_CONJOINT_EXT");
            return;
        case VK_BLEND_OVERLAP_DISJOINT_EXT:
            *rString += std::string("VK_BLEND_OVERLAP_DISJOINT_EXT");
            return;
        case VK_BLEND_OVERLAP_UNCORRELATED_EXT:
            *rString += std::string("VK_BLEND_OVERLAP_UNCORRELATED_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCoverageModulationModeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkCoverageModulationModeNV enumValue = static_cast<VkCoverageModulationModeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COVERAGE_MODULATION_MODE_RGBA_NV:
            *rString += std::string("VK_COVERAGE_MODULATION_MODE_RGBA_NV");
            return;
        case VK_COVERAGE_MODULATION_MODE_ALPHA_NV:
            *rString += std::string("VK_COVERAGE_MODULATION_MODE_ALPHA_NV");
            return;
        case VK_COVERAGE_MODULATION_MODE_RGB_NV:
            *rString += std::string("VK_COVERAGE_MODULATION_MODE_RGB_NV");
            return;
        case VK_COVERAGE_MODULATION_MODE_NONE_NV:
            *rString += std::string("VK_COVERAGE_MODULATION_MODE_NONE_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkDrmFormatModifierPropertiesEXT>(std::string* rString, const Decoded_VkDrmFormatModifierPropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDrmFormatModifierPropertiesListEXT>(std::string* rString, const Decoded_VkDrmFormatModifierPropertiesListEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(std::string* rString, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>(std::string* rString, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>(std::string* rString, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(std::string* rString, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDrmFormatModifierPropertiesEXT>(std::string* rString, const Decoded_VkDrmFormatModifierPropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDrmFormatModifierPropertiesEXT *pStruct = (const VkDrmFormatModifierPropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint64_t drmFormatModifier // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifier:              ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifier);
    *rString += "\n"; // GDS

    // uint32_t drmFormatModifierPlaneCount // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifierPlaneCount:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifierPlaneCount);
    *rString += "\n"; // GDS

    // VkFormatFeatureFlags drmFormatModifierTilingFeatures // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifierTilingFeatures: ";
    *rString += "VkFormatFeatureFlags = "; // TEQ
    flagsToString(rString, pStruct->drmFormatModifierTilingFeatures, enumToString_VkFormatFeatureFlagBits); // URW
}

template <>
void structureToString<Decoded_VkDrmFormatModifierPropertiesListEXT>(std::string* rString, const Decoded_VkDrmFormatModifierPropertiesListEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDrmFormatModifierPropertiesListEXT *pStruct = (const VkDrmFormatModifierPropertiesListEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t drmFormatModifierCount // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifierCount:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifierCount);
    *rString += "\n"; // GDS

    // VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties // SMB
    indentSpaces(rString, indent);
    *rString += "pDrmFormatModifierProperties:   ";
    *rString += "VkDrmFormatModifierPropertiesEXT* = "; // TEQ
    if (pStruct->pDrmFormatModifierProperties == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDrmFormatModifierProperties->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkDrmFormatModifierPropertiesEXT>(rString, indent+1, 1, "VkDrmFormatModifierPropertiesEXT", pStructIn.pDrmFormatModifierProperties->GetMetaStructPointer(), "pDrmFormatModifierProperties", pStruct->drmFormatModifierCount, false, pStructIn.pDrmFormatModifierProperties->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(std::string* rString, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *pStruct = (const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint64_t drmFormatModifier // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifier:              ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifier);
    *rString += "\n"; // GDS

    // VkSharingMode sharingMode // SMB
    indentSpaces(rString, indent);
    *rString += "sharingMode:                    ";
    *rString += "VkSharingMode = "; // TEQ
    enumToString_VkSharingMode(rString, pStruct->sharingMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sharingMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t queueFamilyIndexCount // SMB
    indentSpaces(rString, indent);
    *rString += "queueFamilyIndexCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->queueFamilyIndexCount);
    *rString += "\n"; // GDS

    // const uint32_t* pQueueFamilyIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pQueueFamilyIndices:            ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pQueueFamilyIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pQueueFamilyIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pQueueFamilyIndices.GetPointer()), "pQueueFamilyIndices", pStruct->queueFamilyIndexCount,  vinfo_pQueueFamilyIndices);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>(std::string* rString, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageDrmFormatModifierListCreateInfoEXT *pStruct = (const VkImageDrmFormatModifierListCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t drmFormatModifierCount // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifierCount:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifierCount);
    *rString += "\n"; // GDS

    // const uint64_t* pDrmFormatModifiers // SMB
    indentSpaces(rString, indent);
    *rString += "pDrmFormatModifiers:            ";
    *rString += "const uint64_t* = "; // TEQ
    if (pStruct->pDrmFormatModifiers == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDrmFormatModifiers.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDrmFormatModifiers = {false, false, false, nullptr};
        arrayToString<const uint64_t*>(rString, indent, 1, "const uint64_t*", reinterpret_cast<const uint64_t*>(pStructIn.pDrmFormatModifiers.GetPointer()), "pDrmFormatModifiers", pStruct->drmFormatModifierCount,  vinfo_pDrmFormatModifiers);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>(std::string* rString, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageDrmFormatModifierExplicitCreateInfoEXT *pStruct = (const VkImageDrmFormatModifierExplicitCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint64_t drmFormatModifier // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifier:              ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifier);
    *rString += "\n"; // GDS

    // uint32_t drmFormatModifierPlaneCount // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifierPlaneCount:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifierPlaneCount);
    *rString += "\n"; // GDS

    // const VkSubresourceLayout* pPlaneLayouts // SMB
    indentSpaces(rString, indent);
    *rString += "pPlaneLayouts:                  ";
    *rString += "const VkSubresourceLayout* = "; // TEQ
    if (pStruct->pPlaneLayouts == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pPlaneLayouts->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkSubresourceLayout>(rString, indent+1, 1, "VkSubresourceLayout", pStructIn.pPlaneLayouts->GetMetaStructPointer(), "pPlaneLayouts", pStruct->drmFormatModifierPlaneCount, false, pStructIn.pPlaneLayouts->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(std::string* rString, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImageDrmFormatModifierPropertiesEXT *pStruct = (const VkImageDrmFormatModifierPropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint64_t drmFormatModifier // SMB
    indentSpaces(rString, indent);
    *rString += "drmFormatModifier:              ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->drmFormatModifier);
}

void VulkanAsciiConsumer::Process_vkGetImageDrmFormatModifierPropertiesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    const StructPointerDecoder<Decoded_VkImageDrmFormatModifierPropertiesEXT>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImage image // ARG
    fprintf(GetFile(), "%s%-32sVkImage = ", indentString.c_str(), "image:"); // TRP
    tmpString = "";
    addrToString(&tmpString, image);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageDrmFormatModifierPropertiesEXT* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkImageDrmFormatModifierPropertiesEXT* = NULL", indentString.c_str(), "pProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkImageDrmFormatModifierPropertiesEXT* = ", indentString.c_str(), "pProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImageDrmFormatModifierPropertiesEXT>(&tmpString, *pProperties.GetMetaStructPointer(), 2, pProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkValidationCacheHeaderVersionEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkValidationCacheHeaderVersionEXT enumValue = static_cast<VkValidationCacheHeaderVersionEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT:
            *rString += std::string("VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkValidationCacheCreateInfoEXT>(std::string* rString, const Decoded_VkValidationCacheCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>(std::string* rString, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkValidationCacheCreateInfoEXT>(std::string* rString, const Decoded_VkValidationCacheCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkValidationCacheCreateInfoEXT *pStruct = (const VkValidationCacheCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkValidationCacheCreateFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkValidationCacheCreateFlagsEXT = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // size_t initialDataSize // SMB
    indentSpaces(rString, indent);
    *rString += "initialDataSize:                ";
    *rString += "size_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->initialDataSize);
    *rString += "\n"; // GDS

    // const void* pInitialData // SMB
    indentSpaces(rString, indent);
    *rString += "pInitialData:                   ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pInitialData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pInitialData.GetAddress()); // AHW
    }
}

template <>
void structureToString<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>(std::string* rString, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkShaderModuleValidationCacheCreateInfoEXT *pStruct = (const VkShaderModuleValidationCacheCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkValidationCacheEXT validationCache // SMB
    indentSpaces(rString, indent);
    *rString += "validationCache:                ";
    *rString += "VkValidationCacheEXT = "; // TEQ
    addrToString(rString, pStructIn.validationCache); // PAQ  
}

void VulkanAsciiConsumer::Process_vkCreateValidationCacheEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkValidationCacheCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkValidationCacheEXT>& pValidationCache)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkValidationCacheCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheCreateInfoEXT* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheCreateInfoEXT* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkValidationCacheCreateInfoEXT>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT* pValidationCache // ARG
    if (pValidationCache.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkValidationCacheEXT* = NULL", indentString.c_str(), "pValidationCache:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkValidationCacheEXT* = ", indentString.c_str(), "pValidationCache:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pValidationCache.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyValidationCacheEXT(
    format::HandleId                            device,
    format::HandleId                            validationCache,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyValidationCacheEXT(device, validationCache, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT validationCache // ARG
    fprintf(GetFile(), "%s%-32sVkValidationCacheEXT = ", indentString.c_str(), "validationCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, validationCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkMergeValidationCachesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    const HandlePointerDecoder<VkValidationCacheEXT>& pSrcCaches)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT dstCache // ARG
    fprintf(GetFile(), "%s%-32sVkValidationCacheEXT = ", indentString.c_str(), "dstCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t srcCacheCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "srcCacheCount:", srcCacheCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkValidationCacheEXT* pSrcCaches // ARG
    if (pSrcCaches.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheEXT* = NULL", indentString.c_str(), "pSrcCaches:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkValidationCacheEXT* = ", indentString.c_str(), "pSrcCaches:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pSrcCaches.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pSrcCaches = {true, false, false, nullptr};
        arrayToString<const VkValidationCacheEXT*>(&tmpString, 1, 1, "const VkValidationCacheEXT*", reinterpret_cast<const VkValidationCacheEXT*>(pSrcCaches.GetPointer()), "pSrcCaches", srcCacheCount, vinfo_pSrcCaches); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetValidationCacheDataEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            validationCache,
    const PointerDecoder<size_t>&               pDataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkValidationCacheEXT validationCache // ARG
    fprintf(GetFile(), "%s%-32sVkValidationCacheEXT = ", indentString.c_str(), "validationCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, validationCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // size_t* pDataSize // ARG
    if (pDataSize.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32ssize_t* = NULL", indentString.c_str(), "pDataSize:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32ssize_t* = %" PRId64 "", indentString.c_str(), "pDataSize:", static_cast<uint64_t>(*pDataSize.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indentString.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indentString.c_str(), "pData:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkDescriptorBindingFlagBitsEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkDescriptorBindingFlagBitsEXT enumValue = static_cast<VkDescriptorBindingFlagBitsEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT:
            *rString += std::string("VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT");
            return;
        case VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT:
            *rString += std::string("VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT");
            return;
        case VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT:
            *rString += std::string("VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT");
            return;
        case VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT:
            *rString += std::string("VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkShadingRatePaletteEntryNV(std::string* rString, uint32_t enumValueInt32)
{
    VkShadingRatePaletteEntryNV enumValue = static_cast<VkShadingRatePaletteEntryNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV");
            return;
        case VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV:
            *rString += std::string("VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCoarseSampleOrderTypeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkCoarseSampleOrderTypeNV enumValue = static_cast<VkCoarseSampleOrderTypeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV:
            *rString += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV");
            return;
        case VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV:
            *rString += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV");
            return;
        case VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV:
            *rString += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV");
            return;
        case VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV:
            *rString += std::string("VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkShadingRatePaletteNV>(std::string* rString, const Decoded_VkShadingRatePaletteNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCoarseSampleLocationNV>(std::string* rString, const Decoded_VkCoarseSampleLocationNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCoarseSampleOrderCustomNV>(std::string* rString, const Decoded_VkCoarseSampleOrderCustomNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkShadingRatePaletteNV>(std::string* rString, const Decoded_VkShadingRatePaletteNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkShadingRatePaletteNV *pStruct = (const VkShadingRatePaletteNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t shadingRatePaletteEntryCount // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRatePaletteEntryCount:   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->shadingRatePaletteEntryCount);
    *rString += "\n"; // GDS

    // const VkShadingRatePaletteEntryNV* pShadingRatePaletteEntries // SMB
    indentSpaces(rString, indent);
    *rString += "pShadingRatePaletteEntries:     ";
    *rString += "const VkShadingRatePaletteEntryNV* = "; // TEQ
    if (pStruct->pShadingRatePaletteEntries == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pShadingRatePaletteEntries.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pShadingRatePaletteEntries = {false, true, false, enumToString_VkShadingRatePaletteEntryNV};
        arrayToString<const VkShadingRatePaletteEntryNV*>(rString, indent, 1, "const VkShadingRatePaletteEntryNV*", reinterpret_cast<const VkShadingRatePaletteEntryNV*>(pStructIn.pShadingRatePaletteEntries.GetPointer()), "pShadingRatePaletteEntries", pStruct->shadingRatePaletteEntryCount,  vinfo_pShadingRatePaletteEntries);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineViewportShadingRateImageStateCreateInfoNV *pStruct = (const VkPipelineViewportShadingRateImageStateCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 shadingRateImageEnable // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRateImageEnable:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shadingRateImageEnable);
    *rString += "\n"; // GDS

    // uint32_t viewportCount // SMB
    indentSpaces(rString, indent);
    *rString += "viewportCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->viewportCount);
    *rString += "\n"; // GDS

    // const VkShadingRatePaletteNV* pShadingRatePalettes // SMB
    indentSpaces(rString, indent);
    *rString += "pShadingRatePalettes:           ";
    *rString += "const VkShadingRatePaletteNV* = "; // TEQ
    if (pStruct->pShadingRatePalettes == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pShadingRatePalettes->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkShadingRatePaletteNV>(rString, indent+1, 1, "VkShadingRatePaletteNV", pStructIn.pShadingRatePalettes->GetMetaStructPointer(), "pShadingRatePalettes", pStruct->viewportCount, false, pStructIn.pShadingRatePalettes->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceShadingRateImageFeaturesNV *pStruct = (const VkPhysicalDeviceShadingRateImageFeaturesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 shadingRateImage // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRateImage:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shadingRateImage);
    *rString += "\n"; // GDS

    // VkBool32 shadingRateCoarseSampleOrder // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRateCoarseSampleOrder:   ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->shadingRateCoarseSampleOrder);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceShadingRateImagePropertiesNV *pStruct = (const VkPhysicalDeviceShadingRateImagePropertiesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExtent2D shadingRateTexelSize // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRateTexelSize:           ";
    *rString += "VkExtent2D = "; // TEQ
    structureToString<Decoded_VkExtent2D>(rString, *pStructIn.shadingRateTexelSize, indent+1,  baseAddr + offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize)); // AZJ
    *rString += "\n"; // GDS

    // uint32_t shadingRatePaletteSize // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRatePaletteSize:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->shadingRatePaletteSize);
    *rString += "\n"; // GDS

    // uint32_t shadingRateMaxCoarseSamples // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRateMaxCoarseSamples:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->shadingRateMaxCoarseSamples);
}

template <>
void structureToString<Decoded_VkCoarseSampleLocationNV>(std::string* rString, const Decoded_VkCoarseSampleLocationNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCoarseSampleLocationNV *pStruct = (const VkCoarseSampleLocationNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t pixelX // SMB
    indentSpaces(rString, indent);
    *rString += "pixelX:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->pixelX);
    *rString += "\n"; // GDS

    // uint32_t pixelY // SMB
    indentSpaces(rString, indent);
    *rString += "pixelY:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->pixelY);
    *rString += "\n"; // GDS

    // uint32_t sample // SMB
    indentSpaces(rString, indent);
    *rString += "sample:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->sample);
}

template <>
void structureToString<Decoded_VkCoarseSampleOrderCustomNV>(std::string* rString, const Decoded_VkCoarseSampleOrderCustomNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCoarseSampleOrderCustomNV *pStruct = (const VkCoarseSampleOrderCustomNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkShadingRatePaletteEntryNV shadingRate // SMB
    indentSpaces(rString, indent);
    *rString += "shadingRate:                    ";
    *rString += "VkShadingRatePaletteEntryNV = "; // TEQ
    enumToString_VkShadingRatePaletteEntryNV(rString, pStruct->shadingRate);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->shadingRate);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t sampleCount // SMB
    indentSpaces(rString, indent);
    *rString += "sampleCount:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->sampleCount);
    *rString += "\n"; // GDS

    // uint32_t sampleLocationCount // SMB
    indentSpaces(rString, indent);
    *rString += "sampleLocationCount:            ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->sampleLocationCount);
    *rString += "\n"; // GDS

    // const VkCoarseSampleLocationNV* pSampleLocations // SMB
    indentSpaces(rString, indent);
    *rString += "pSampleLocations:               ";
    *rString += "const VkCoarseSampleLocationNV* = "; // TEQ
    if (pStruct->pSampleLocations == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pSampleLocations->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkCoarseSampleLocationNV>(rString, indent+1, 1, "VkCoarseSampleLocationNV", pStructIn.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pStruct->sampleLocationCount, false, pStructIn.pSampleLocations->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *pStruct = (const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkCoarseSampleOrderTypeNV sampleOrderType // SMB
    indentSpaces(rString, indent);
    *rString += "sampleOrderType:                ";
    *rString += "VkCoarseSampleOrderTypeNV = "; // TEQ
    enumToString_VkCoarseSampleOrderTypeNV(rString, pStruct->sampleOrderType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sampleOrderType);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t customSampleOrderCount // SMB
    indentSpaces(rString, indent);
    *rString += "customSampleOrderCount:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->customSampleOrderCount);
    *rString += "\n"; // GDS

    // const VkCoarseSampleOrderCustomNV* pCustomSampleOrders // SMB
    indentSpaces(rString, indent);
    *rString += "pCustomSampleOrders:            ";
    *rString += "const VkCoarseSampleOrderCustomNV* = "; // TEQ
    if (pStruct->pCustomSampleOrders == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCustomSampleOrders->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkCoarseSampleOrderCustomNV>(rString, indent+1, 1, "VkCoarseSampleOrderCustomNV", pStructIn.pCustomSampleOrders->GetMetaStructPointer(), "pCustomSampleOrders", pStruct->customSampleOrderCount, false, pStructIn.pCustomSampleOrders->GetAddress());  // CCP
    }
}

void VulkanAsciiConsumer::Process_vkCmdBindShadingRateImageNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            imageView,
    VkImageLayout                               imageLayout)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageView imageView // ARG
    fprintf(GetFile(), "%s%-32sVkImageView = ", indentString.c_str(), "imageView:"); // TRP
    tmpString = "";
    addrToString(&tmpString, imageView);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkImageLayout imageLayout // ARG
    tmpString = "";
    enumToString_VkImageLayout(&tmpString,imageLayout); // EPW
    fprintf(GetFile(), "%s%-32sVkImageLayout = %s", indentString.c_str(), "imageLayout:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetViewportShadingRatePaletteNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const StructPointerDecoder<Decoded_VkShadingRatePaletteNV>& pShadingRatePalettes)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstViewport // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstViewport:", firstViewport); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t viewportCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "viewportCount:", viewportCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkShadingRatePaletteNV* pShadingRatePalettes // ARG
    if (pShadingRatePalettes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkShadingRatePaletteNV* = NULL", indentString.c_str(), "pShadingRatePalettes:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkShadingRatePaletteNV* = ", indentString.c_str(), "pShadingRatePalettes:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pShadingRatePalettes.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkShadingRatePaletteNV>(&tmpString, 2, 1, "VkShadingRatePaletteNV",
            pShadingRatePalettes.GetMetaStructPointer(), "pShadingRatePalettes", viewportCount, false, pShadingRatePalettes.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetCoarseSampleOrderNV(
    format::HandleId                            commandBuffer,
    VkCoarseSampleOrderTypeNV                   sampleOrderType,
    uint32_t                                    customSampleOrderCount,
    const StructPointerDecoder<Decoded_VkCoarseSampleOrderCustomNV>& pCustomSampleOrders)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCoarseSampleOrderTypeNV sampleOrderType // ARG
    tmpString = "";
    enumToString_VkCoarseSampleOrderTypeNV(&tmpString,sampleOrderType); // EPW
    fprintf(GetFile(), "%s%-32sVkCoarseSampleOrderTypeNV = %s", indentString.c_str(), "sampleOrderType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t customSampleOrderCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "customSampleOrderCount:", customSampleOrderCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCoarseSampleOrderCustomNV* pCustomSampleOrders // ARG
    if (pCustomSampleOrders.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCoarseSampleOrderCustomNV* = NULL", indentString.c_str(), "pCustomSampleOrders:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCoarseSampleOrderCustomNV* = ", indentString.c_str(), "pCustomSampleOrders:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pCustomSampleOrders.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkCoarseSampleOrderCustomNV>(&tmpString, 2, 1, "VkCoarseSampleOrderCustomNV",
            pCustomSampleOrders.GetMetaStructPointer(), "pCustomSampleOrders", customSampleOrderCount, false, pCustomSampleOrders.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkRayTracingShaderGroupTypeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkRayTracingShaderGroupTypeNV enumValue = static_cast<VkRayTracingShaderGroupTypeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV:
            *rString += std::string("VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV");
            return;
        case VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV:
            *rString += std::string("VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV");
            return;
        case VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV:
            *rString += std::string("VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkAccelerationStructureTypeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkAccelerationStructureTypeNV enumValue = static_cast<VkAccelerationStructureTypeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV:
            *rString += std::string("VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV");
            return;
        case VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV:
            *rString += std::string("VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkBuildAccelerationStructureFlagBitsNV(std::string* rString, uint32_t enumValueInt32)
{
    VkBuildAccelerationStructureFlagBitsNV enumValue = static_cast<VkBuildAccelerationStructureFlagBitsNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV:
            *rString += std::string("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV:
            *rString += std::string("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV:
            *rString += std::string("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV:
            *rString += std::string("VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV");
            return;
        case VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV:
            *rString += std::string("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkAccelerationStructureMemoryRequirementsTypeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkAccelerationStructureMemoryRequirementsTypeNV enumValue = static_cast<VkAccelerationStructureMemoryRequirementsTypeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV:
            *rString += std::string("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV");
            return;
        case VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV:
            *rString += std::string("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV");
            return;
        case VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV:
            *rString += std::string("VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkGeometryFlagBitsNV(std::string* rString, uint32_t enumValueInt32)
{
    VkGeometryFlagBitsNV enumValue = static_cast<VkGeometryFlagBitsNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV:
            *rString += std::string("VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV");
            return;
        case VK_GEOMETRY_OPAQUE_BIT_NV:
            *rString += std::string("VK_GEOMETRY_OPAQUE_BIT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkCopyAccelerationStructureModeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkCopyAccelerationStructureModeNV enumValue = static_cast<VkCopyAccelerationStructureModeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV:
            *rString += std::string("VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV");
            return;
        case VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV:
            *rString += std::string("VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkGeometryInstanceFlagBitsNV(std::string* rString, uint32_t enumValueInt32)
{
    VkGeometryInstanceFlagBitsNV enumValue = static_cast<VkGeometryInstanceFlagBitsNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV:
            *rString += std::string("VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV");
            return;
        case VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV:
            *rString += std::string("VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV");
            return;
        case VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV:
            *rString += std::string("VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV");
            return;
        case VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV:
            *rString += std::string("VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkGeometryTypeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkGeometryTypeNV enumValue = static_cast<VkGeometryTypeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_GEOMETRY_TYPE_TRIANGLES_NV:
            *rString += std::string("VK_GEOMETRY_TYPE_TRIANGLES_NV");
            return;
        case VK_GEOMETRY_TYPE_AABBS_NV:
            *rString += std::string("VK_GEOMETRY_TYPE_AABBS_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(std::string* rString, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkRayTracingPipelineCreateInfoNV>(std::string* rString, const Decoded_VkRayTracingPipelineCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkGeometryTrianglesNV>(std::string* rString, const Decoded_VkGeometryTrianglesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkGeometryAABBNV>(std::string* rString, const Decoded_VkGeometryAABBNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkGeometryDataNV>(std::string* rString, const Decoded_VkGeometryDataNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkGeometryNV>(std::string* rString, const Decoded_VkGeometryNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAccelerationStructureInfoNV>(std::string* rString, const Decoded_VkAccelerationStructureInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAccelerationStructureCreateInfoNV>(std::string* rString, const Decoded_VkAccelerationStructureCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(std::string* rString, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkWriteDescriptorSetAccelerationStructureNV>(std::string* rString, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(std::string* rString, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(std::string* rString, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRayTracingShaderGroupCreateInfoNV *pStruct = (const VkRayTracingShaderGroupCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkRayTracingShaderGroupTypeNV type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkRayTracingShaderGroupTypeNV = "; // TEQ
    enumToString_VkRayTracingShaderGroupTypeNV(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // uint32_t generalShader // SMB
    indentSpaces(rString, indent);
    *rString += "generalShader:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->generalShader);
    *rString += "\n"; // GDS

    // uint32_t closestHitShader // SMB
    indentSpaces(rString, indent);
    *rString += "closestHitShader:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->closestHitShader);
    *rString += "\n"; // GDS

    // uint32_t anyHitShader // SMB
    indentSpaces(rString, indent);
    *rString += "anyHitShader:                   ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->anyHitShader);
    *rString += "\n"; // GDS

    // uint32_t intersectionShader // SMB
    indentSpaces(rString, indent);
    *rString += "intersectionShader:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->intersectionShader);
}

template <>
void structureToString<Decoded_VkRayTracingPipelineCreateInfoNV>(std::string* rString, const Decoded_VkRayTracingPipelineCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkRayTracingPipelineCreateInfoNV *pStruct = (const VkRayTracingPipelineCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineCreateFlags flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineCreateFlags = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkPipelineCreateFlagBits); // URW
    *rString += "\n"; // GDS

    // uint32_t stageCount // SMB
    indentSpaces(rString, indent);
    *rString += "stageCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->stageCount);
    *rString += "\n"; // GDS

    // const VkPipelineShaderStageCreateInfo* pStages // SMB
    indentSpaces(rString, indent);
    *rString += "pStages:                        ";
    *rString += "const VkPipelineShaderStageCreateInfo* = "; // TEQ
    if (pStruct->pStages == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pStages->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkPipelineShaderStageCreateInfo>(rString, indent+1, 1, "VkPipelineShaderStageCreateInfo", pStructIn.pStages->GetMetaStructPointer(), "pStages", pStruct->stageCount, false, pStructIn.pStages->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t groupCount // SMB
    indentSpaces(rString, indent);
    *rString += "groupCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->groupCount);
    *rString += "\n"; // GDS

    // const VkRayTracingShaderGroupCreateInfoNV* pGroups // SMB
    indentSpaces(rString, indent);
    *rString += "pGroups:                        ";
    *rString += "const VkRayTracingShaderGroupCreateInfoNV* = "; // TEQ
    if (pStruct->pGroups == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pGroups->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkRayTracingShaderGroupCreateInfoNV>(rString, indent+1, 1, "VkRayTracingShaderGroupCreateInfoNV", pStructIn.pGroups->GetMetaStructPointer(), "pGroups", pStruct->groupCount, false, pStructIn.pGroups->GetAddress());  // CCP
    }
    *rString += "\n"; // GDS

    // uint32_t maxRecursionDepth // SMB
    indentSpaces(rString, indent);
    *rString += "maxRecursionDepth:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxRecursionDepth);
    *rString += "\n"; // GDS

    // VkPipelineLayout layout // SMB
    indentSpaces(rString, indent);
    *rString += "layout:                         ";
    *rString += "VkPipelineLayout = "; // TEQ
    addrToString(rString, pStructIn.layout); // PAQ  
    *rString += "\n"; // GDS

    // VkPipeline basePipelineHandle // SMB
    indentSpaces(rString, indent);
    *rString += "basePipelineHandle:             ";
    *rString += "VkPipeline = "; // TEQ
    addrToString(rString, pStructIn.basePipelineHandle); // PAQ  
    *rString += "\n"; // GDS

    // int32_t basePipelineIndex // SMB
    indentSpaces(rString, indent);
    *rString += "basePipelineIndex:              ";
    *rString += "int32_t = "; // TEQ
    signedDecimalToString(rString, pStruct->basePipelineIndex);
}

template <>
void structureToString<Decoded_VkGeometryTrianglesNV>(std::string* rString, const Decoded_VkGeometryTrianglesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkGeometryTrianglesNV *pStruct = (const VkGeometryTrianglesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBuffer vertexData // SMB
    indentSpaces(rString, indent);
    *rString += "vertexData:                     ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.vertexData); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize vertexOffset // SMB
    indentSpaces(rString, indent);
    *rString += "vertexOffset:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->vertexOffset);
    *rString += "\n"; // GDS

    // uint32_t vertexCount // SMB
    indentSpaces(rString, indent);
    *rString += "vertexCount:                    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->vertexCount);
    *rString += "\n"; // GDS

    // VkDeviceSize vertexStride // SMB
    indentSpaces(rString, indent);
    *rString += "vertexStride:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->vertexStride);
    *rString += "\n"; // GDS

    // VkFormat vertexFormat // SMB
    indentSpaces(rString, indent);
    *rString += "vertexFormat:                   ";
    *rString += "VkFormat = "; // TEQ
    enumToString_VkFormat(rString, pStruct->vertexFormat);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->vertexFormat);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBuffer indexData // SMB
    indentSpaces(rString, indent);
    *rString += "indexData:                      ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.indexData); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize indexOffset // SMB
    indentSpaces(rString, indent);
    *rString += "indexOffset:                    ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->indexOffset);
    *rString += "\n"; // GDS

    // uint32_t indexCount // SMB
    indentSpaces(rString, indent);
    *rString += "indexCount:                     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->indexCount);
    *rString += "\n"; // GDS

    // VkIndexType indexType // SMB
    indentSpaces(rString, indent);
    *rString += "indexType:                      ";
    *rString += "VkIndexType = "; // TEQ
    enumToString_VkIndexType(rString, pStruct->indexType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->indexType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBuffer transformData // SMB
    indentSpaces(rString, indent);
    *rString += "transformData:                  ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.transformData); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize transformOffset // SMB
    indentSpaces(rString, indent);
    *rString += "transformOffset:                ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->transformOffset);
}

template <>
void structureToString<Decoded_VkGeometryAABBNV>(std::string* rString, const Decoded_VkGeometryAABBNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkGeometryAABBNV *pStruct = (const VkGeometryAABBNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBuffer aabbData // SMB
    indentSpaces(rString, indent);
    *rString += "aabbData:                       ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.aabbData); // PAQ  
    *rString += "\n"; // GDS

    // uint32_t numAABBs // SMB
    indentSpaces(rString, indent);
    *rString += "numAABBs:                       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->numAABBs);
    *rString += "\n"; // GDS

    // uint32_t stride // SMB
    indentSpaces(rString, indent);
    *rString += "stride:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->stride);
    *rString += "\n"; // GDS

    // VkDeviceSize offset // SMB
    indentSpaces(rString, indent);
    *rString += "offset:                         ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->offset);
}

template <>
void structureToString<Decoded_VkGeometryDataNV>(std::string* rString, const Decoded_VkGeometryDataNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkGeometryDataNV *pStruct = (const VkGeometryDataNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkGeometryTrianglesNV triangles // SMB
    indentSpaces(rString, indent);
    *rString += "triangles:                      ";
    *rString += "VkGeometryTrianglesNV = "; // TEQ
    structureToString<Decoded_VkGeometryTrianglesNV>(rString, *pStructIn.triangles, indent+1,  baseAddr + offsetof(VkGeometryDataNV, triangles)); // AZJ
    *rString += "\n"; // GDS

    // VkGeometryAABBNV aabbs // SMB
    indentSpaces(rString, indent);
    *rString += "aabbs:                          ";
    *rString += "VkGeometryAABBNV = "; // TEQ
    structureToString<Decoded_VkGeometryAABBNV>(rString, *pStructIn.aabbs, indent+1,  baseAddr + offsetof(VkGeometryDataNV, aabbs)); // AZJ
}

template <>
void structureToString<Decoded_VkGeometryNV>(std::string* rString, const Decoded_VkGeometryNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkGeometryNV *pStruct = (const VkGeometryNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkGeometryTypeNV geometryType // SMB
    indentSpaces(rString, indent);
    *rString += "geometryType:                   ";
    *rString += "VkGeometryTypeNV = "; // TEQ
    enumToString_VkGeometryTypeNV(rString, pStruct->geometryType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->geometryType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkGeometryDataNV geometry // SMB
    indentSpaces(rString, indent);
    *rString += "geometry:                       ";
    *rString += "VkGeometryDataNV = "; // TEQ
    structureToString<Decoded_VkGeometryDataNV>(rString, *pStructIn.geometry, indent+1,  baseAddr + offsetof(VkGeometryNV, geometry)); // AZJ
    *rString += "\n"; // GDS

    // VkGeometryFlagsNV flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkGeometryFlagsNV = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkGeometryFlagBitsNV); // URW
}

template <>
void structureToString<Decoded_VkAccelerationStructureInfoNV>(std::string* rString, const Decoded_VkAccelerationStructureInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAccelerationStructureInfoNV *pStruct = (const VkAccelerationStructureInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAccelerationStructureTypeNV type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkAccelerationStructureTypeNV = "; // TEQ
    enumToString_VkAccelerationStructureTypeNV(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBuildAccelerationStructureFlagsNV flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkBuildAccelerationStructureFlagsNV = "; // TEQ
    flagsToString(rString, pStruct->flags, enumToString_VkBuildAccelerationStructureFlagBitsNV); // URW
    *rString += "\n"; // GDS

    // uint32_t instanceCount // SMB
    indentSpaces(rString, indent);
    *rString += "instanceCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->instanceCount);
    *rString += "\n"; // GDS

    // uint32_t geometryCount // SMB
    indentSpaces(rString, indent);
    *rString += "geometryCount:                  ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->geometryCount);
    *rString += "\n"; // GDS

    // const VkGeometryNV* pGeometries // SMB
    indentSpaces(rString, indent);
    *rString += "pGeometries:                    ";
    *rString += "const VkGeometryNV* = "; // TEQ
    if (pStruct->pGeometries == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pGeometries->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkGeometryNV>(rString, indent+1, 1, "VkGeometryNV", pStructIn.pGeometries->GetMetaStructPointer(), "pGeometries", pStruct->geometryCount, false, pStructIn.pGeometries->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkAccelerationStructureCreateInfoNV>(std::string* rString, const Decoded_VkAccelerationStructureCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAccelerationStructureCreateInfoNV *pStruct = (const VkAccelerationStructureCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceSize compactedSize // SMB
    indentSpaces(rString, indent);
    *rString += "compactedSize:                  ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->compactedSize);
    *rString += "\n"; // GDS

    // VkAccelerationStructureInfoNV info // SMB
    indentSpaces(rString, indent);
    *rString += "info:                           ";
    *rString += "VkAccelerationStructureInfoNV = "; // TEQ
    structureToString<Decoded_VkAccelerationStructureInfoNV>(rString, *pStructIn.info, indent+1,  baseAddr + offsetof(VkAccelerationStructureCreateInfoNV, info)); // AZJ
}

template <>
void structureToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(std::string* rString, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBindAccelerationStructureMemoryInfoNV *pStruct = (const VkBindAccelerationStructureMemoryInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAccelerationStructureNV accelerationStructure // SMB
    indentSpaces(rString, indent);
    *rString += "accelerationStructure:          ";
    *rString += "VkAccelerationStructureNV = "; // TEQ
    addrToString(rString, pStructIn.accelerationStructure); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceMemory memory // SMB
    indentSpaces(rString, indent);
    *rString += "memory:                         ";
    *rString += "VkDeviceMemory = "; // TEQ
    addrToString(rString, pStructIn.memory); // PAQ  
    *rString += "\n"; // GDS

    // VkDeviceSize memoryOffset // SMB
    indentSpaces(rString, indent);
    *rString += "memoryOffset:                   ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->memoryOffset);
    *rString += "\n"; // GDS

    // uint32_t deviceIndexCount // SMB
    indentSpaces(rString, indent);
    *rString += "deviceIndexCount:               ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceIndexCount);
    *rString += "\n"; // GDS

    // const uint32_t* pDeviceIndices // SMB
    indentSpaces(rString, indent);
    *rString += "pDeviceIndices:                 ";
    *rString += "const uint32_t* = "; // TEQ
    if (pStruct->pDeviceIndices == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pDeviceIndices.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pDeviceIndices = {false, false, false, nullptr};
        arrayToString<const uint32_t*>(rString, indent, 1, "const uint32_t*", reinterpret_cast<const uint32_t*>(pStructIn.pDeviceIndices.GetPointer()), "pDeviceIndices", pStruct->deviceIndexCount,  vinfo_pDeviceIndices);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkWriteDescriptorSetAccelerationStructureNV>(std::string* rString, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkWriteDescriptorSetAccelerationStructureNV *pStruct = (const VkWriteDescriptorSetAccelerationStructureNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t accelerationStructureCount // SMB
    indentSpaces(rString, indent);
    *rString += "accelerationStructureCount:     ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->accelerationStructureCount);
    *rString += "\n"; // GDS

    // const VkAccelerationStructureNV* pAccelerationStructures // SMB
    indentSpaces(rString, indent);
    *rString += "pAccelerationStructures:        ";
    *rString += "const VkAccelerationStructureNV* = "; // TEQ
    if (pStruct->pAccelerationStructures == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pAccelerationStructures.GetAddress()); // PAZ
        ValueToStringStruct vinfo_pAccelerationStructures = {true, false, false, nullptr};
        arrayToString<const VkAccelerationStructureNV*>(rString, indent, 1, "const VkAccelerationStructureNV*", reinterpret_cast<const VkAccelerationStructureNV*>(pStructIn.pAccelerationStructures.GetPointer()), "pAccelerationStructures", pStruct->accelerationStructureCount,  vinfo_pAccelerationStructures);  // CCQ
    }
}

template <>
void structureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(std::string* rString, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkAccelerationStructureMemoryRequirementsInfoNV *pStruct = (const VkAccelerationStructureMemoryRequirementsInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkAccelerationStructureMemoryRequirementsTypeNV type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkAccelerationStructureMemoryRequirementsTypeNV = "; // TEQ
    enumToString_VkAccelerationStructureMemoryRequirementsTypeNV(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkAccelerationStructureNV accelerationStructure // SMB
    indentSpaces(rString, indent);
    *rString += "accelerationStructure:          ";
    *rString += "VkAccelerationStructureNV = "; // TEQ
    addrToString(rString, pStructIn.accelerationStructure); // PAQ  
}

template <>
void structureToString<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceRayTracingPropertiesNV *pStruct = (const VkPhysicalDeviceRayTracingPropertiesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t shaderGroupHandleSize // SMB
    indentSpaces(rString, indent);
    *rString += "shaderGroupHandleSize:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->shaderGroupHandleSize);
    *rString += "\n"; // GDS

    // uint32_t maxRecursionDepth // SMB
    indentSpaces(rString, indent);
    *rString += "maxRecursionDepth:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxRecursionDepth);
    *rString += "\n"; // GDS

    // uint32_t maxShaderGroupStride // SMB
    indentSpaces(rString, indent);
    *rString += "maxShaderGroupStride:           ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxShaderGroupStride);
    *rString += "\n"; // GDS

    // uint32_t shaderGroupBaseAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "shaderGroupBaseAlignment:       ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->shaderGroupBaseAlignment);
    *rString += "\n"; // GDS

    // uint64_t maxGeometryCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxGeometryCount:               ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxGeometryCount);
    *rString += "\n"; // GDS

    // uint64_t maxInstanceCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxInstanceCount:               ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxInstanceCount);
    *rString += "\n"; // GDS

    // uint64_t maxTriangleCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxTriangleCount:               ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTriangleCount);
    *rString += "\n"; // GDS

    // uint32_t maxDescriptorSetAccelerationStructures // SMB
    indentSpaces(rString, indent);
    *rString += "maxDescriptorSetAccelerationStructures: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDescriptorSetAccelerationStructures);
}

void VulkanAsciiConsumer::Process_vkCreateAccelerationStructureNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAccelerationStructureCreateInfoNV>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkAccelerationStructureNV>& pAccelerationStructure)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureCreateInfoNV* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureCreateInfoNV* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureCreateInfoNV* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAccelerationStructureCreateInfoNV>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV* pAccelerationStructure // ARG
    if (pAccelerationStructure.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV* = NULL", indentString.c_str(), "pAccelerationStructure:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV* = ", indentString.c_str(), "pAccelerationStructure:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pAccelerationStructure.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkDestroyAccelerationStructureNV(
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV accelerationStructure // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indentString.c_str(), "accelerationStructure:"); // TRP
    tmpString = "";
    addrToString(&tmpString, accelerationStructure);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetAccelerationStructureMemoryRequirementsNV(
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>& pInfo,
    const StructPointerDecoder<Decoded_VkMemoryRequirements2KHR>& pMemoryRequirements)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureMemoryRequirementsInfoNV* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureMemoryRequirementsInfoNV* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryRequirements2KHR* pMemoryRequirements // ARG
    if (pMemoryRequirements.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2KHR* = NULL", indentString.c_str(), "pMemoryRequirements:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryRequirements2KHR* = ", indentString.c_str(), "pMemoryRequirements:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryRequirements.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryRequirements2KHR>(&tmpString, *pMemoryRequirements.GetMetaStructPointer(), 2, pMemoryRequirements.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkBindAccelerationStructureMemoryNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    const StructPointerDecoder<Decoded_VkBindAccelerationStructureMemoryInfoNV>& pBindInfos)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t bindInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "bindInfoCount:", bindInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkBindAccelerationStructureMemoryInfoNV* pBindInfos // ARG
    if (pBindInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBindAccelerationStructureMemoryInfoNV* = NULL", indentString.c_str(), "pBindInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBindAccelerationStructureMemoryInfoNV* = ", indentString.c_str(), "pBindInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pBindInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkBindAccelerationStructureMemoryInfoNV>(&tmpString, 2, 1, "VkBindAccelerationStructureMemoryInfoNV",
            pBindInfos.GetMetaStructPointer(), "pBindInfos", bindInfoCount, false, pBindInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdBuildAccelerationStructureNV(
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkAccelerationStructureInfoNV>& pInfo,
    format::HandleId                            instanceData,
    VkDeviceSize                                instanceOffset,
    VkBool32                                    update,
    format::HandleId                            dst,
    format::HandleId                            src,
    format::HandleId                            scratch,
    VkDeviceSize                                scratchOffset)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureInfoNV* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureInfoNV* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureInfoNV* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAccelerationStructureInfoNV>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer instanceData // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "instanceData:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instanceData);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize instanceOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "instanceOffset:", instanceOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32 update // ARG
    fprintf(GetFile(), "%s%-32sVkBool32 = %u", indentString.c_str(), "update:", update); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV dst // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indentString.c_str(), "dst:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dst);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV src // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indentString.c_str(), "src:"); // TRP
    tmpString = "";
    addrToString(&tmpString, src);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer scratch // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "scratch:"); // TRP
    tmpString = "";
    addrToString(&tmpString, scratch);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize scratchOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "scratchOffset:", scratchOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdCopyAccelerationStructureNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            dst,
    format::HandleId                            src,
    VkCopyAccelerationStructureModeNV           mode)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV dst // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indentString.c_str(), "dst:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dst);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV src // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indentString.c_str(), "src:"); // TRP
    tmpString = "";
    addrToString(&tmpString, src);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkCopyAccelerationStructureModeNV mode // ARG
    tmpString = "";
    enumToString_VkCopyAccelerationStructureModeNV(&tmpString,mode); // EPW
    fprintf(GetFile(), "%s%-32sVkCopyAccelerationStructureModeNV = %s", indentString.c_str(), "mode:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdTraceRaysNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    format::HandleId                            missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    format::HandleId                            hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    format::HandleId                            callableShaderBindingTableBuffer,
    VkDeviceSize                                callableShaderBindingOffset,
    VkDeviceSize                                callableShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer raygenShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "raygenShaderBindingTableBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, raygenShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize raygenShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "raygenShaderBindingOffset:", raygenShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer missShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "missShaderBindingTableBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, missShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize missShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "missShaderBindingOffset:", missShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize missShaderBindingStride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "missShaderBindingStride:", missShaderBindingStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer hitShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "hitShaderBindingTableBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, hitShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize hitShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "hitShaderBindingOffset:", hitShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize hitShaderBindingStride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "hitShaderBindingStride:", hitShaderBindingStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer callableShaderBindingTableBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "callableShaderBindingTableBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, callableShaderBindingTableBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize callableShaderBindingOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "callableShaderBindingOffset:", callableShaderBindingOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize callableShaderBindingStride // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "callableShaderBindingStride:", callableShaderBindingStride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t width // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "width:", width); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t height // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "height:", height); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t depth // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "depth:", depth); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCreateRayTracingPipelinesNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    const StructPointerDecoder<Decoded_VkRayTracingPipelineCreateInfoNV>& pCreateInfos,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkPipeline>&     pPipelines)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineCache pipelineCache // ARG
    fprintf(GetFile(), "%s%-32sVkPipelineCache = ", indentString.c_str(), "pipelineCache:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipelineCache);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t createInfoCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "createInfoCount:", createInfoCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRayTracingPipelineCreateInfoNV* pCreateInfos // ARG
    if (pCreateInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRayTracingPipelineCreateInfoNV* = NULL", indentString.c_str(), "pCreateInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRayTracingPipelineCreateInfoNV* = ", indentString.c_str(), "pCreateInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pCreateInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkRayTracingPipelineCreateInfoNV>(&tmpString, 2, 1, "VkRayTracingPipelineCreateInfoNV",
            pCreateInfos.GetMetaStructPointer(), "pCreateInfos", createInfoCount, false, pCreateInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline* pPipelines // ARG
    if (pPipelines.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = NULL", indentString.c_str(), "pPipelines:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPipeline* = ", indentString.c_str(), "pPipelines:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pPipelines.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pPipelines = {true, false, false, nullptr};
        arrayToString<VkPipeline*>(&tmpString, 1, 1, "VkPipeline*", reinterpret_cast<VkPipeline*>(pPipelines.GetPointer()), "pPipelines", createInfoCount, vinfo_pPipelines); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetRayTracingShaderGroupHandlesNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indentString.c_str(), "pipeline:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipeline);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstGroup // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstGroup:", firstGroup); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t groupCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "groupCount:", groupCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // size_t dataSize // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indentString.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indentString.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indentString.c_str(), "pData:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetAccelerationStructureHandleNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    size_t                                      dataSize,
    const PointerDecoder<uint8_t>&              pData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkAccelerationStructureNV accelerationStructure // ARG
    fprintf(GetFile(), "%s%-32sVkAccelerationStructureNV = ", indentString.c_str(), "accelerationStructure:"); // TRP
    tmpString = "";
    addrToString(&tmpString, accelerationStructure);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // size_t dataSize // ARG
    fprintf(GetFile(), "%s%-32ssize_t = %zu", indentString.c_str(), "dataSize:", dataSize); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // void* pData // ARG
    if (pData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32svoid* = NULL", indentString.c_str(), "pData:"); // GZD
    }
    else
    {
        fprintf(GetFile(), "%s%-32svoid* = ", indentString.c_str(), "pData:");  // SSA
        tmpString = "";
        addrToString(&tmpString, *(reinterpret_cast<uint64_t*>(pData.GetPointer()))); // CWS
        fprintf(GetFile(), "%s", tmpString.c_str()); // YWW
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdWriteAccelerationStructuresPropertiesNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    accelerationStructureCount,
    const HandlePointerDecoder<VkAccelerationStructureNV>& pAccelerationStructures,
    VkQueryType                                 queryType,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t accelerationStructureCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "accelerationStructureCount:", accelerationStructureCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkAccelerationStructureNV* pAccelerationStructures // ARG
    if (pAccelerationStructures.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureNV* = NULL", indentString.c_str(), "pAccelerationStructures:"); // GHD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAccelerationStructureNV* = ", indentString.c_str(), "pAccelerationStructures:");  // SXB
        tmpString = "";
        addrToString(&tmpString, pAccelerationStructures.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // YEF
        tmpString = "";
        ValueToStringStruct vinfo_pAccelerationStructures = {true, false, false, nullptr};
        arrayToString<const VkAccelerationStructureNV*>(&tmpString, 1, 1, "const VkAccelerationStructureNV*", reinterpret_cast<const VkAccelerationStructureNV*>(pAccelerationStructures.GetPointer()), "pAccelerationStructures", accelerationStructureCount, vinfo_pAccelerationStructures); // SFX
        fprintf(GetFile(), "%s", tmpString.c_str());  // AFL
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryType queryType // ARG
    tmpString = "";
    enumToString_VkQueryType(&tmpString,queryType); // EPW
    fprintf(GetFile(), "%s%-32sVkQueryType = %s", indentString.c_str(), "queryType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCompileDeferredNV(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    shader)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCompileDeferredNV(device, pipeline, shader)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipeline pipeline // ARG
    fprintf(GetFile(), "%s%-32sVkPipeline = ", indentString.c_str(), "pipeline:"); // TRP
    tmpString = "";
    addrToString(&tmpString, pipeline);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t shader // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "shader:", shader); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkQueueGlobalPriorityEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkQueueGlobalPriorityEXT enumValue = static_cast<VkQueueGlobalPriorityEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT:
            *rString += std::string("VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT");
            return;
        case VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT:
            *rString += std::string("VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT");
            return;
        case VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT:
            *rString += std::string("VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT");
            return;
        case VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT:
            *rString += std::string("VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkImportMemoryHostPointerInfoEXT>(std::string* rString, const Decoded_VkImportMemoryHostPointerInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(std::string* rString, const Decoded_VkMemoryHostPointerPropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImportMemoryHostPointerInfoEXT>(std::string* rString, const Decoded_VkImportMemoryHostPointerInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImportMemoryHostPointerInfoEXT *pStruct = (const VkImportMemoryHostPointerInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkExternalMemoryHandleTypeFlagBits handleType // SMB
    indentSpaces(rString, indent);
    *rString += "handleType:                     ";
    *rString += "VkExternalMemoryHandleTypeFlagBits = "; // TEQ
    enumToString_VkExternalMemoryHandleTypeFlagBits(rString, pStruct->handleType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->handleType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pHostPointer // SMB
    indentSpaces(rString, indent);
    *rString += "pHostPointer:                   ";
    *rString += "void* = "; // TEQ
    if (pStruct->pHostPointer == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pHostPointer); // PWR
    }
}

template <>
void structureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(std::string* rString, const Decoded_VkMemoryHostPointerPropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMemoryHostPointerPropertiesEXT *pStruct = (const VkMemoryHostPointerPropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t memoryTypeBits // SMB
    indentSpaces(rString, indent);
    *rString += "memoryTypeBits:                 ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->memoryTypeBits);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *pStruct = (const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceSize minImportedHostPointerAlignment // SMB
    indentSpaces(rString, indent);
    *rString += "minImportedHostPointerAlignment: ";
    *rString += "VkDeviceSize = "; // TEQ
    signedDecimalToString(rString, pStruct->minImportedHostPointerAlignment);
}

void VulkanAsciiConsumer::Process_vkGetMemoryHostPointerPropertiesEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    pHostPointer,
    const StructPointerDecoder<Decoded_VkMemoryHostPointerPropertiesEXT>& pMemoryHostPointerProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkExternalMemoryHandleTypeFlagBits handleType // ARG
    tmpString = "";
    enumToString_VkExternalMemoryHandleTypeFlagBits(&tmpString,handleType); // EPW
    fprintf(GetFile(), "%s%-32sVkExternalMemoryHandleTypeFlagBits = %s", indentString.c_str(), "handleType:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // const void* pHostPointer // ARG
    fprintf(GetFile(), "%s%-32sconst void* = 0x%" PRIx64 "", indentString.c_str(), "pHostPointer:", pHostPointer); // YQA
    fprintf(GetFile(), "\n"); // YWN

    // VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties // ARG
    if (pMemoryHostPointerProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkMemoryHostPointerPropertiesEXT* = NULL", indentString.c_str(), "pMemoryHostPointerProperties:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkMemoryHostPointerPropertiesEXT* = ", indentString.c_str(), "pMemoryHostPointerProperties:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMemoryHostPointerProperties.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMemoryHostPointerPropertiesEXT>(&tmpString, *pMemoryHostPointerProperties.GetMetaStructPointer(), 2, pMemoryHostPointerProperties.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void VulkanAsciiConsumer::Process_vkCmdWriteBufferMarkerAMD(
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPipelineStageFlagBits pipelineStage // ARG
    tmpString = "";
    enumToString_VkPipelineStageFlagBits(&tmpString,pipelineStage); // EPW
    fprintf(GetFile(), "%s%-32sVkPipelineStageFlagBits = %s", indentString.c_str(), "pipelineStage:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer dstBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "dstBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, dstBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize dstOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "dstOffset:", dstOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t marker // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "marker:", marker); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkPipelineCompilerControlFlagBitsAMD(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineCompilerControlFlagBitsAMD enumValue = static_cast<VkPipelineCompilerControlFlagBitsAMD>(enumValueInt32);
    assert(rString != nullptr);
    *rString += std::string("UNKNOWN");
};


void enumToString_VkTimeDomainEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkTimeDomainEXT enumValue = static_cast<VkTimeDomainEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT:
            *rString += std::string("VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT");
            return;
        case VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT:
            *rString += std::string("VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT");
            return;
        case VK_TIME_DOMAIN_DEVICE_EXT:
            *rString += std::string("VK_TIME_DOMAIN_DEVICE_EXT");
            return;
        case VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT:
            *rString += std::string("VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkCalibratedTimestampInfoEXT>(std::string* rString, const Decoded_VkCalibratedTimestampInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkCalibratedTimestampInfoEXT>(std::string* rString, const Decoded_VkCalibratedTimestampInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCalibratedTimestampInfoEXT *pStruct = (const VkCalibratedTimestampInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkTimeDomainEXT timeDomain // SMB
    indentSpaces(rString, indent);
    *rString += "timeDomain:                     ";
    *rString += "VkTimeDomainEXT = "; // TEQ
    enumToString_VkTimeDomainEXT(rString, pStruct->timeDomain);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->timeDomain);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pTimeDomainCount,
    const PointerDecoder<VkTimeDomainEXT>&      pTimeDomains)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pTimeDomainCount // ARG
    if (pTimeDomainCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pTimeDomainCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pTimeDomainCount:", static_cast<uint64_t>(*pTimeDomainCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkTimeDomainEXT* pTimeDomains // ARG
    if (pTimeDomains.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkTimeDomainEXT* = NULL", indentString.c_str(), "pTimeDomains:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkTimeDomainEXT* = %" PRId64 "", indentString.c_str(), "pTimeDomains:", static_cast<uint64_t>(*pTimeDomains.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetCalibratedTimestampsEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    timestampCount,
    const StructPointerDecoder<Decoded_VkCalibratedTimestampInfoEXT>& pTimestampInfos,
    const PointerDecoder<uint64_t>&             pTimestamps,
    const PointerDecoder<uint64_t>&             pMaxDeviation)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t timestampCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "timestampCount:", timestampCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkCalibratedTimestampInfoEXT* pTimestampInfos // ARG
    if (pTimestampInfos.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkCalibratedTimestampInfoEXT* = NULL", indentString.c_str(), "pTimestampInfos:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkCalibratedTimestampInfoEXT* = ", indentString.c_str(), "pTimestampInfos:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pTimestampInfos.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkCalibratedTimestampInfoEXT>(&tmpString, 2, 1, "VkCalibratedTimestampInfoEXT",
            pTimestampInfos.GetMetaStructPointer(), "pTimestampInfos", timestampCount, false, pTimestampInfos.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pTimestamps // ARG
    if (pTimestamps.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indentString.c_str(), "pTimestamps:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indentString.c_str(), "pTimestamps:", static_cast<uint64_t>(*pTimestamps.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint64_t* pMaxDeviation // ARG
    if (pMaxDeviation.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint64_t* = NULL", indentString.c_str(), "pMaxDeviation:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint64_t* = %" PRId64 "", indentString.c_str(), "pMaxDeviation:", static_cast<uint64_t>(*pMaxDeviation.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkMemoryOverallocationBehaviorAMD(std::string* rString, uint32_t enumValueInt32)
{
    VkMemoryOverallocationBehaviorAMD enumValue = static_cast<VkMemoryOverallocationBehaviorAMD>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD:
            *rString += std::string("VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD");
            return;
        case VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD:
            *rString += std::string("VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD");
            return;
        case VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD:
            *rString += std::string("VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPipelineCreationFeedbackFlagBitsEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkPipelineCreationFeedbackFlagBitsEXT enumValue = static_cast<VkPipelineCreationFeedbackFlagBitsEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT:
            *rString += std::string("VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT");
            return;
        case VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT:
            *rString += std::string("VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT");
            return;
        case VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT:
            *rString += std::string("VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkDrawMeshTasksIndirectCommandNV>(std::string* rString, const Decoded_VkDrawMeshTasksIndirectCommandNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceMeshShaderFeaturesNV *pStruct = (const VkPhysicalDeviceMeshShaderFeaturesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 taskShader // SMB
    indentSpaces(rString, indent);
    *rString += "taskShader:                     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->taskShader);
    *rString += "\n"; // GDS

    // VkBool32 meshShader // SMB
    indentSpaces(rString, indent);
    *rString += "meshShader:                     ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->meshShader);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceMeshShaderPropertiesNV *pStruct = (const VkPhysicalDeviceMeshShaderPropertiesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t maxDrawMeshTasksCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxDrawMeshTasksCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxDrawMeshTasksCount);
    *rString += "\n"; // GDS

    // uint32_t maxTaskWorkGroupInvocations // SMB
    indentSpaces(rString, indent);
    *rString += "maxTaskWorkGroupInvocations:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTaskWorkGroupInvocations);
    *rString += "\n"; // GDS

    // uint32_t maxTaskWorkGroupSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxTaskWorkGroupSize:           ";
    *rString += "uint32_t[";
    *rString += "3";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_maxTaskWorkGroupSize = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->maxTaskWorkGroupSize), "maxTaskWorkGroupSize", 3, vinfo_maxTaskWorkGroupSize); // JPA
    *rString += "\n"; // GDS

    // uint32_t maxTaskTotalMemorySize // SMB
    indentSpaces(rString, indent);
    *rString += "maxTaskTotalMemorySize:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTaskTotalMemorySize);
    *rString += "\n"; // GDS

    // uint32_t maxTaskOutputCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxTaskOutputCount:             ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxTaskOutputCount);
    *rString += "\n"; // GDS

    // uint32_t maxMeshWorkGroupInvocations // SMB
    indentSpaces(rString, indent);
    *rString += "maxMeshWorkGroupInvocations:    ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMeshWorkGroupInvocations);
    *rString += "\n"; // GDS

    // uint32_t maxMeshWorkGroupSize // SMB
    indentSpaces(rString, indent);
    *rString += "maxMeshWorkGroupSize:           ";
    *rString += "uint32_t[";
    *rString += "3";
    *rString += "] = ";
    addrToString(rString, baseAddr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupSize)); // IYY
    ValueToStringStruct vinfo_maxMeshWorkGroupSize = {false, false, false, nullptr};
    arrayToString<uint32_t*>(rString, indent, 0, "uint32_t", const_cast<uint32_t*>(pStruct->maxMeshWorkGroupSize), "maxMeshWorkGroupSize", 3, vinfo_maxMeshWorkGroupSize); // JPA
    *rString += "\n"; // GDS

    // uint32_t maxMeshTotalMemorySize // SMB
    indentSpaces(rString, indent);
    *rString += "maxMeshTotalMemorySize:         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMeshTotalMemorySize);
    *rString += "\n"; // GDS

    // uint32_t maxMeshOutputVertices // SMB
    indentSpaces(rString, indent);
    *rString += "maxMeshOutputVertices:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMeshOutputVertices);
    *rString += "\n"; // GDS

    // uint32_t maxMeshOutputPrimitives // SMB
    indentSpaces(rString, indent);
    *rString += "maxMeshOutputPrimitives:        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMeshOutputPrimitives);
    *rString += "\n"; // GDS

    // uint32_t maxMeshMultiviewViewCount // SMB
    indentSpaces(rString, indent);
    *rString += "maxMeshMultiviewViewCount:      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->maxMeshMultiviewViewCount);
    *rString += "\n"; // GDS

    // uint32_t meshOutputPerVertexGranularity // SMB
    indentSpaces(rString, indent);
    *rString += "meshOutputPerVertexGranularity: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->meshOutputPerVertexGranularity);
    *rString += "\n"; // GDS

    // uint32_t meshOutputPerPrimitiveGranularity // SMB
    indentSpaces(rString, indent);
    *rString += "meshOutputPerPrimitiveGranularity: ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->meshOutputPerPrimitiveGranularity);
}

template <>
void structureToString<Decoded_VkDrawMeshTasksIndirectCommandNV>(std::string* rString, const Decoded_VkDrawMeshTasksIndirectCommandNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDrawMeshTasksIndirectCommandNV *pStruct = (const VkDrawMeshTasksIndirectCommandNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t taskCount // SMB
    indentSpaces(rString, indent);
    *rString += "taskCount:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->taskCount);
    *rString += "\n"; // GDS

    // uint32_t firstTask // SMB
    indentSpaces(rString, indent);
    *rString += "firstTask:                      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->firstTask);
}

void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    taskCount,
    uint32_t                                    firstTask)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t taskCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "taskCount:", taskCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstTask // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstTask:", firstTask); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksIndirectNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t drawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "drawCount:", drawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdDrawMeshTasksIndirectCountNV(
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer buffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "buffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, buffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize offset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "offset:", offset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // VkBuffer countBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkBuffer = ", indentString.c_str(), "countBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, countBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceSize countBufferOffset // ARG
    fprintf(GetFile(), "%s%-32sVkDeviceSize = %" PRIu64 "", indentString.c_str(), "countBufferOffset:", countBufferOffset); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t maxDrawCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "maxDrawCount:", maxDrawCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t stride // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "stride:", stride); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV *pStruct = (const VkPipelineViewportExclusiveScissorStateCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t exclusiveScissorCount // SMB
    indentSpaces(rString, indent);
    *rString += "exclusiveScissorCount:          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->exclusiveScissorCount);
    *rString += "\n"; // GDS

    // const VkRect2D* pExclusiveScissors // SMB
    indentSpaces(rString, indent);
    *rString += "pExclusiveScissors:             ";
    *rString += "const VkRect2D* = "; // TEQ
    if (pStruct->pExclusiveScissors == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pExclusiveScissors->GetAddress()); // WUS
        arrayOfStructsToString<Decoded_VkRect2D>(rString, indent+1, 1, "VkRect2D", pStructIn.pExclusiveScissors->GetMetaStructPointer(), "pExclusiveScissors", pStruct->exclusiveScissorCount, false, pStructIn.pExclusiveScissors->GetAddress());  // CCP
    }
}

template <>
void structureToString<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceExclusiveScissorFeaturesNV *pStruct = (const VkPhysicalDeviceExclusiveScissorFeaturesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 exclusiveScissor // SMB
    indentSpaces(rString, indent);
    *rString += "exclusiveScissor:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->exclusiveScissor);
}

void VulkanAsciiConsumer::Process_vkCmdSetExclusiveScissorNV(
    format::HandleId                            commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    const StructPointerDecoder<Decoded_VkRect2D>& pExclusiveScissors)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstExclusiveScissor // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstExclusiveScissor:", firstExclusiveScissor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t exclusiveScissorCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "exclusiveScissorCount:", exclusiveScissorCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // const VkRect2D* pExclusiveScissors // ARG
    if (pExclusiveScissors.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = NULL", indentString.c_str(), "pExclusiveScissors:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkRect2D* = ", indentString.c_str(), "pExclusiveScissors:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pExclusiveScissors.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkRect2D>(&tmpString, 2, 1, "VkRect2D",
            pExclusiveScissors.GetMetaStructPointer(), "pExclusiveScissors", exclusiveScissorCount, false, pExclusiveScissors.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkQueueFamilyCheckpointPropertiesNV>(std::string* rString, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkCheckpointDataNV>(std::string* rString, const Decoded_VkCheckpointDataNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkQueueFamilyCheckpointPropertiesNV>(std::string* rString, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkQueueFamilyCheckpointPropertiesNV *pStruct = (const VkQueueFamilyCheckpointPropertiesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineStageFlags checkpointExecutionStageMask // SMB
    indentSpaces(rString, indent);
    *rString += "checkpointExecutionStageMask:   ";
    *rString += "VkPipelineStageFlags = "; // TEQ
    flagsToString(rString, pStruct->checkpointExecutionStageMask, enumToString_VkPipelineStageFlagBits); // URW
}

template <>
void structureToString<Decoded_VkCheckpointDataNV>(std::string* rString, const Decoded_VkCheckpointDataNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCheckpointDataNV *pStruct = (const VkCheckpointDataNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineStageFlagBits stage // SMB
    indentSpaces(rString, indent);
    *rString += "stage:                          ";
    *rString += "VkPipelineStageFlagBits = "; // TEQ
    enumToString_VkPipelineStageFlagBits(rString, pStruct->stage);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->stage);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pCheckpointMarker // SMB
    indentSpaces(rString, indent);
    *rString += "pCheckpointMarker:              ";
    *rString += "void* = "; // TEQ
    if (pStruct->pCheckpointMarker == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pCheckpointMarker); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCmdSetCheckpointNV(
    format::HandleId                            commandBuffer,
    uint64_t                                    pCheckpointMarker)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const void* pCheckpointMarker // ARG
    fprintf(GetFile(), "%s%-32sconst void* = 0x%" PRIx64 "", indentString.c_str(), "pCheckpointMarker:", pCheckpointMarker); // YQA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetQueueCheckpointDataNV(
    format::HandleId                            queue,
    const PointerDecoder<uint32_t>&             pCheckpointDataCount,
    const StructPointerDecoder<Decoded_VkCheckpointDataNV>& pCheckpointData)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData)");
    fprintf(GetFile(), " returns void:\n");

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pCheckpointDataCount // ARG
    if (pCheckpointDataCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pCheckpointDataCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pCheckpointDataCount:", static_cast<uint64_t>(*pCheckpointDataCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCheckpointDataNV* pCheckpointData // ARG
    if (pCheckpointData.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCheckpointDataNV* = NULL", indentString.c_str(), "pCheckpointData:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCheckpointDataNV* = ", indentString.c_str(), "pCheckpointData:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pCheckpointData.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkCheckpointDataNV>(&tmpString, 2, 1, "VkCheckpointDataNV",
            pCheckpointData.GetMetaStructPointer(), "pCheckpointData", *pCheckpointDataCount.GetPointer(), false, pCheckpointData.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkPerformanceValueTypeINTEL(std::string* rString, uint32_t enumValueInt32)
{
    VkPerformanceValueTypeINTEL enumValue = static_cast<VkPerformanceValueTypeINTEL>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL:
            *rString += std::string("VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL:
            *rString += std::string("VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL:
            *rString += std::string("VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL:
            *rString += std::string("VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL");
            return;
        case VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL:
            *rString += std::string("VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkQueryPoolSamplingModeINTEL(std::string* rString, uint32_t enumValueInt32)
{
    VkQueryPoolSamplingModeINTEL enumValue = static_cast<VkQueryPoolSamplingModeINTEL>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL:
            *rString += std::string("VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPerformanceOverrideTypeINTEL(std::string* rString, uint32_t enumValueInt32)
{
    VkPerformanceOverrideTypeINTEL enumValue = static_cast<VkPerformanceOverrideTypeINTEL>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL:
            *rString += std::string("VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL");
            return;
        case VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL:
            *rString += std::string("VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPerformanceParameterTypeINTEL(std::string* rString, uint32_t enumValueInt32)
{
    VkPerformanceParameterTypeINTEL enumValue = static_cast<VkPerformanceParameterTypeINTEL>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL:
            *rString += std::string("VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL");
            return;
        case VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL:
            *rString += std::string("VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkPerformanceConfigurationTypeINTEL(std::string* rString, uint32_t enumValueInt32)
{
    VkPerformanceConfigurationTypeINTEL enumValue = static_cast<VkPerformanceConfigurationTypeINTEL>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL:
            *rString += std::string("VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPerformanceValueDataINTEL>(std::string* rString, const Decoded_VkPerformanceValueDataINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPerformanceValueINTEL>(std::string* rString, const Decoded_VkPerformanceValueINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(std::string* rString, const Decoded_VkInitializePerformanceApiInfoINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkQueryPoolCreateInfoINTEL>(std::string* rString, const Decoded_VkQueryPoolCreateInfoINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPerformanceMarkerInfoINTEL>(std::string* rString, const Decoded_VkPerformanceMarkerInfoINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(std::string* rString, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPerformanceOverrideInfoINTEL>(std::string* rString, const Decoded_VkPerformanceOverrideInfoINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(std::string* rString, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPerformanceValueDataINTEL>(std::string* rString, const Decoded_VkPerformanceValueDataINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPerformanceValueDataINTEL *pStruct = (const VkPerformanceValueDataINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // uint32_t value32 // SMB
    indentSpaces(rString, indent);
    *rString += "value32:                        ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->value32);
    *rString += "\n"; // GDS

    // uint64_t value64 // SMB
    indentSpaces(rString, indent);
    *rString += "value64:                        ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->value64);
    *rString += "\n"; // GDS

    // float valueFloat // SMB
    indentSpaces(rString, indent);
    *rString += "valueFloat:                     ";
    *rString += "float = "; // TEQ
    doubleToString(rString, pStruct->valueFloat);
    *rString += "\n"; // GDS

    // VkBool32 valueBool // SMB
    indentSpaces(rString, indent);
    *rString += "valueBool:                      ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->valueBool);
    *rString += "\n"; // GDS

    // const char* valueString // SMB
    indentSpaces(rString, indent);
    *rString += "valueString:                    ";
    *rString += "const char* = "; // TEQ
    stringToQuotedString(rString, pStruct->valueString); // TGH
}

template <>
void structureToString<Decoded_VkPerformanceValueINTEL>(std::string* rString, const Decoded_VkPerformanceValueINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPerformanceValueINTEL *pStruct = (const VkPerformanceValueINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkPerformanceValueTypeINTEL type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkPerformanceValueTypeINTEL = "; // TEQ
    enumToString_VkPerformanceValueTypeINTEL(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkPerformanceValueDataINTEL data // SMB
    indentSpaces(rString, indent);
    *rString += "data:                           ";
    *rString += "VkPerformanceValueDataINTEL = "; // TEQ
    *rString += "(Union):"; // RGT
    structureToString<Decoded_VkPerformanceValueDataINTEL>(rString, *pStructIn.data, indent+1,  baseAddr + offsetof(VkPerformanceValueINTEL, data)); // AZJ
}

template <>
void structureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(std::string* rString, const Decoded_VkInitializePerformanceApiInfoINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkInitializePerformanceApiInfoINTEL *pStruct = (const VkInitializePerformanceApiInfoINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // void* pUserData // SMB
    indentSpaces(rString, indent);
    *rString += "pUserData:                      ";
    *rString += "void* = "; // TEQ
    if (pStruct->pUserData == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pUserData); // PWR
    }
}

template <>
void structureToString<Decoded_VkQueryPoolCreateInfoINTEL>(std::string* rString, const Decoded_VkQueryPoolCreateInfoINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkQueryPoolCreateInfoINTEL *pStruct = (const VkQueryPoolCreateInfoINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkQueryPoolSamplingModeINTEL performanceCountersSampling // SMB
    indentSpaces(rString, indent);
    *rString += "performanceCountersSampling:    ";
    *rString += "VkQueryPoolSamplingModeINTEL = "; // TEQ
    enumToString_VkQueryPoolSamplingModeINTEL(rString, pStruct->performanceCountersSampling);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->performanceCountersSampling);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkPerformanceMarkerInfoINTEL>(std::string* rString, const Decoded_VkPerformanceMarkerInfoINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPerformanceMarkerInfoINTEL *pStruct = (const VkPerformanceMarkerInfoINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint64_t marker // SMB
    indentSpaces(rString, indent);
    *rString += "marker:                         ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->marker);
}

template <>
void structureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(std::string* rString, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPerformanceStreamMarkerInfoINTEL *pStruct = (const VkPerformanceStreamMarkerInfoINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t marker // SMB
    indentSpaces(rString, indent);
    *rString += "marker:                         ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->marker);
}

template <>
void structureToString<Decoded_VkPerformanceOverrideInfoINTEL>(std::string* rString, const Decoded_VkPerformanceOverrideInfoINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPerformanceOverrideInfoINTEL *pStruct = (const VkPerformanceOverrideInfoINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPerformanceOverrideTypeINTEL type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkPerformanceOverrideTypeINTEL = "; // TEQ
    enumToString_VkPerformanceOverrideTypeINTEL(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 enable // SMB
    indentSpaces(rString, indent);
    *rString += "enable:                         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->enable);
    *rString += "\n"; // GDS

    // uint64_t parameter // SMB
    indentSpaces(rString, indent);
    *rString += "parameter:                      ";
    *rString += "uint64_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->parameter);
}

template <>
void structureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(std::string* rString, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPerformanceConfigurationAcquireInfoINTEL *pStruct = (const VkPerformanceConfigurationAcquireInfoINTEL *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPerformanceConfigurationTypeINTEL type // SMB
    indentSpaces(rString, indent);
    *rString += "type:                           ";
    *rString += "VkPerformanceConfigurationTypeINTEL = "; // TEQ
    enumToString_VkPerformanceConfigurationTypeINTEL(rString, pStruct->type);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->type);
    *rString += ")";
}

void VulkanAsciiConsumer::Process_vkInitializePerformanceApiINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkInitializePerformanceApiInfoINTEL>& pInitializeInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkInitializePerformanceApiINTEL(device, pInitializeInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkInitializePerformanceApiInfoINTEL* pInitializeInfo // ARG
    if (pInitializeInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkInitializePerformanceApiInfoINTEL* = NULL", indentString.c_str(), "pInitializeInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkInitializePerformanceApiInfoINTEL* = ", indentString.c_str(), "pInitializeInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInitializeInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkInitializePerformanceApiInfoINTEL>(&tmpString, *pInitializeInfo.GetMetaStructPointer(), 2, pInitializeInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkUninitializePerformanceApiINTEL(
    format::HandleId                            device)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkUninitializePerformanceApiINTEL(device)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceMarkerINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceMarkerInfoINTEL>& pMarkerInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceMarkerInfoINTEL* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceMarkerInfoINTEL* = NULL", indentString.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceMarkerInfoINTEL* = ", indentString.c_str(), "pMarkerInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPerformanceMarkerInfoINTEL>(&tmpString, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceStreamMarkerINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceStreamMarkerInfoINTEL>& pMarkerInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo // ARG
    if (pMarkerInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceStreamMarkerInfoINTEL* = NULL", indentString.c_str(), "pMarkerInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceStreamMarkerInfoINTEL* = ", indentString.c_str(), "pMarkerInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pMarkerInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPerformanceStreamMarkerInfoINTEL>(&tmpString, *pMarkerInfo.GetMetaStructPointer(), 2, pMarkerInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkCmdSetPerformanceOverrideINTEL(
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    const StructPointerDecoder<Decoded_VkPerformanceOverrideInfoINTEL>& pOverrideInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceOverrideInfoINTEL* pOverrideInfo // ARG
    if (pOverrideInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceOverrideInfoINTEL* = NULL", indentString.c_str(), "pOverrideInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceOverrideInfoINTEL* = ", indentString.c_str(), "pOverrideInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pOverrideInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPerformanceOverrideInfoINTEL>(&tmpString, *pOverrideInfo.GetMetaStructPointer(), 2, pOverrideInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquirePerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>& pAcquireInfo,
    const HandlePointerDecoder<VkPerformanceConfigurationINTEL>& pConfiguration)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo // ARG
    if (pAcquireInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceConfigurationAcquireInfoINTEL* = NULL", indentString.c_str(), "pAcquireInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPerformanceConfigurationAcquireInfoINTEL* = ", indentString.c_str(), "pAcquireInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAcquireInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>(&tmpString, *pAcquireInfo.GetMetaStructPointer(), 2, pAcquireInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceConfigurationINTEL* pConfiguration // ARG
    if (pConfiguration.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL* = NULL", indentString.c_str(), "pConfiguration:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL* = ", indentString.c_str(), "pConfiguration:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pConfiguration.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkReleasePerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            configuration)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkReleasePerformanceConfigurationINTEL(device, configuration)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceConfigurationINTEL configuration // ARG
    fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL = ", indentString.c_str(), "configuration:"); // TRP
    tmpString = "";
    addrToString(&tmpString, configuration);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkQueueSetPerformanceConfigurationINTEL(
    VkResult                                    returnValue,
    format::HandleId                            queue,
    format::HandleId                            configuration)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkQueueSetPerformanceConfigurationINTEL(queue, configuration)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkQueue queue // ARG
    fprintf(GetFile(), "%s%-32sVkQueue = ", indentString.c_str(), "queue:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queue);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceConfigurationINTEL configuration // ARG
    fprintf(GetFile(), "%s%-32sVkPerformanceConfigurationINTEL = ", indentString.c_str(), "configuration:"); // TRP
    tmpString = "";
    addrToString(&tmpString, configuration);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetPerformanceParameterINTEL(
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkPerformanceParameterTypeINTEL             parameter,
    const StructPointerDecoder<Decoded_VkPerformanceValueINTEL>& pValue)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPerformanceParameterINTEL(device, parameter, pValue)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceParameterTypeINTEL parameter // ARG
    tmpString = "";
    enumToString_VkPerformanceParameterTypeINTEL(&tmpString,parameter); // EPW
    fprintf(GetFile(), "%s%-32sVkPerformanceParameterTypeINTEL = %s", indentString.c_str(), "parameter:", tmpString.c_str()); // KHW
    fprintf(GetFile(), "\n"); // YWN

    // VkPerformanceValueINTEL* pValue // ARG
    if (pValue.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceValueINTEL* = NULL", indentString.c_str(), "pValue:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPerformanceValueINTEL* = ", indentString.c_str(), "pValue:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pValue.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPerformanceValueINTEL>(&tmpString, *pValue.GetMetaStructPointer(), 2, pValue.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>(std::string* rString, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>(std::string* rString, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>(std::string* rString, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD *pStruct = (const VkDisplayNativeHdrSurfaceCapabilitiesAMD *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 localDimmingSupport // SMB
    indentSpaces(rString, indent);
    *rString += "localDimmingSupport:            ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->localDimmingSupport);
}

template <>
void structureToString<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>(std::string* rString, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSwapchainDisplayNativeHdrCreateInfoAMD *pStruct = (const VkSwapchainDisplayNativeHdrCreateInfoAMD *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 localDimmingEnable // SMB
    indentSpaces(rString, indent);
    *rString += "localDimmingEnable:             ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->localDimmingEnable);
}

void VulkanAsciiConsumer::Process_vkSetLocalDimmingAMD(
    format::HandleId                            device,
    format::HandleId                            swapChain,
    VkBool32                                    localDimmingEnable)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapChain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapChain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapChain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkBool32 localDimmingEnable // ARG
    fprintf(GetFile(), "%s%-32sVkBool32 = %u", indentString.c_str(), "localDimmingEnable:", localDimmingEnable); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(std::string* rString, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(std::string* rString, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkImagePipeSurfaceCreateInfoFUCHSIA *pStruct = (const VkImagePipeSurfaceCreateInfoFUCHSIA *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkImagePipeSurfaceCreateFlagsFUCHSIA flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkImagePipeSurfaceCreateFlagsFUCHSIA = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // uint32_t imagePipeHandle // SMB
    indentSpaces(rString, indent);
    *rString += "imagePipeHandle:                ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->imagePipeHandle);
}

void VulkanAsciiConsumer::Process_vkCreateImagePipeSurfaceFUCHSIA(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkImagePipeSurfaceCreateInfoFUCHSIA* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkImagePipeSurfaceCreateInfoFUCHSIA* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(std::string* rString, const Decoded_VkMetalSurfaceCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(std::string* rString, const Decoded_VkMetalSurfaceCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkMetalSurfaceCreateInfoEXT *pStruct = (const VkMetalSurfaceCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkMetalSurfaceCreateFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkMetalSurfaceCreateFlagsEXT = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // const void* pLayer // SMB
    indentSpaces(rString, indent);
    *rString += "pLayer:                         ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pLayer == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pLayer); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkCreateMetalSurfaceEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkMetalSurfaceCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkMetalSurfaceCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkMetalSurfaceCreateInfoEXT* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkMetalSurfaceCreateInfoEXT* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkMetalSurfaceCreateInfoEXT>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkShaderCorePropertiesFlagBitsAMD(std::string* rString, uint32_t enumValueInt32)
{
    VkShaderCorePropertiesFlagBitsAMD enumValue = static_cast<VkShaderCorePropertiesFlagBitsAMD>(enumValueInt32);
    assert(rString != nullptr);
    *rString += std::string("UNKNOWN");
};

template <> void structureToString<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferDeviceAddressInfoEXT>(std::string* rString, const Decoded_VkBufferDeviceAddressInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkBufferDeviceAddressCreateInfoEXT>(std::string* rString, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *pStruct = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 bufferDeviceAddress // SMB
    indentSpaces(rString, indent);
    *rString += "bufferDeviceAddress:            ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->bufferDeviceAddress);
    *rString += "\n"; // GDS

    // VkBool32 bufferDeviceAddressCaptureReplay // SMB
    indentSpaces(rString, indent);
    *rString += "bufferDeviceAddressCaptureReplay: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->bufferDeviceAddressCaptureReplay);
    *rString += "\n"; // GDS

    // VkBool32 bufferDeviceAddressMultiDevice // SMB
    indentSpaces(rString, indent);
    *rString += "bufferDeviceAddressMultiDevice: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->bufferDeviceAddressMultiDevice);
}

template <>
void structureToString<Decoded_VkBufferDeviceAddressInfoEXT>(std::string* rString, const Decoded_VkBufferDeviceAddressInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferDeviceAddressInfoEXT *pStruct = (const VkBufferDeviceAddressInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBuffer buffer // SMB
    indentSpaces(rString, indent);
    *rString += "buffer:                         ";
    *rString += "VkBuffer = "; // TEQ
    addrToString(rString, pStructIn.buffer); // PAQ  
}

template <>
void structureToString<Decoded_VkBufferDeviceAddressCreateInfoEXT>(std::string* rString, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkBufferDeviceAddressCreateInfoEXT *pStruct = (const VkBufferDeviceAddressCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkDeviceAddress deviceAddress // SMB
    indentSpaces(rString, indent);
    *rString += "deviceAddress:                  ";
    *rString += "VkDeviceAddress = "; // TEQ
    unsignedDecimalToString(rString, pStruct->deviceAddress);
}

void VulkanAsciiConsumer::Process_vkGetBufferDeviceAddressEXT(
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkBufferDeviceAddressInfoEXT>& pInfo)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetBufferDeviceAddressEXT(device, pInfo)");
    fprintf(GetFile(), " returns 0x%" PRIx64 ":\n", returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkBufferDeviceAddressInfoEXT* pInfo // ARG
    if (pInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferDeviceAddressInfoEXT* = NULL", indentString.c_str(), "pInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkBufferDeviceAddressInfoEXT* = ", indentString.c_str(), "pInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkBufferDeviceAddressInfoEXT>(&tmpString, *pInfo.GetMetaStructPointer(), 2, pInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkValidationFeatureEnableEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkValidationFeatureEnableEXT enumValue = static_cast<VkValidationFeatureEnableEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT");
            return;
        case VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT");
            return;
        case VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkValidationFeatureDisableEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkValidationFeatureDisableEXT enumValue = static_cast<VkValidationFeatureDisableEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_ALL_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_DISABLE_ALL_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT");
            return;
        case VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT:
            *rString += std::string("VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkComponentTypeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkComponentTypeNV enumValue = static_cast<VkComponentTypeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COMPONENT_TYPE_SINT8_NV:
            *rString += std::string("VK_COMPONENT_TYPE_SINT8_NV");
            return;
        case VK_COMPONENT_TYPE_SINT16_NV:
            *rString += std::string("VK_COMPONENT_TYPE_SINT16_NV");
            return;
        case VK_COMPONENT_TYPE_FLOAT32_NV:
            *rString += std::string("VK_COMPONENT_TYPE_FLOAT32_NV");
            return;
        case VK_COMPONENT_TYPE_UINT64_NV:
            *rString += std::string("VK_COMPONENT_TYPE_UINT64_NV");
            return;
        case VK_COMPONENT_TYPE_SINT32_NV:
            *rString += std::string("VK_COMPONENT_TYPE_SINT32_NV");
            return;
        case VK_COMPONENT_TYPE_UINT32_NV:
            *rString += std::string("VK_COMPONENT_TYPE_UINT32_NV");
            return;
        case VK_COMPONENT_TYPE_UINT8_NV:
            *rString += std::string("VK_COMPONENT_TYPE_UINT8_NV");
            return;
        case VK_COMPONENT_TYPE_FLOAT16_NV:
            *rString += std::string("VK_COMPONENT_TYPE_FLOAT16_NV");
            return;
        case VK_COMPONENT_TYPE_UINT16_NV:
            *rString += std::string("VK_COMPONENT_TYPE_UINT16_NV");
            return;
        case VK_COMPONENT_TYPE_SINT64_NV:
            *rString += std::string("VK_COMPONENT_TYPE_SINT64_NV");
            return;
        case VK_COMPONENT_TYPE_FLOAT64_NV:
            *rString += std::string("VK_COMPONENT_TYPE_FLOAT64_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};


void enumToString_VkScopeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkScopeNV enumValue = static_cast<VkScopeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_SCOPE_QUEUE_FAMILY_NV:
            *rString += std::string("VK_SCOPE_QUEUE_FAMILY_NV");
            return;
        case VK_SCOPE_WORKGROUP_NV:
            *rString += std::string("VK_SCOPE_WORKGROUP_NV");
            return;
        case VK_SCOPE_SUBGROUP_NV:
            *rString += std::string("VK_SCOPE_SUBGROUP_NV");
            return;
        case VK_SCOPE_DEVICE_NV:
            *rString += std::string("VK_SCOPE_DEVICE_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkCooperativeMatrixPropertiesNV>(std::string* rString, const Decoded_VkCooperativeMatrixPropertiesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkCooperativeMatrixPropertiesNV>(std::string* rString, const Decoded_VkCooperativeMatrixPropertiesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkCooperativeMatrixPropertiesNV *pStruct = (const VkCooperativeMatrixPropertiesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t MSize // SMB
    indentSpaces(rString, indent);
    *rString += "MSize:                          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->MSize);
    *rString += "\n"; // GDS

    // uint32_t NSize // SMB
    indentSpaces(rString, indent);
    *rString += "NSize:                          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->NSize);
    *rString += "\n"; // GDS

    // uint32_t KSize // SMB
    indentSpaces(rString, indent);
    *rString += "KSize:                          ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->KSize);
    *rString += "\n"; // GDS

    // VkComponentTypeNV AType // SMB
    indentSpaces(rString, indent);
    *rString += "AType:                          ";
    *rString += "VkComponentTypeNV = "; // TEQ
    enumToString_VkComponentTypeNV(rString, pStruct->AType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->AType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentTypeNV BType // SMB
    indentSpaces(rString, indent);
    *rString += "BType:                          ";
    *rString += "VkComponentTypeNV = "; // TEQ
    enumToString_VkComponentTypeNV(rString, pStruct->BType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->BType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentTypeNV CType // SMB
    indentSpaces(rString, indent);
    *rString += "CType:                          ";
    *rString += "VkComponentTypeNV = "; // TEQ
    enumToString_VkComponentTypeNV(rString, pStruct->CType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->CType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkComponentTypeNV DType // SMB
    indentSpaces(rString, indent);
    *rString += "DType:                          ";
    *rString += "VkComponentTypeNV = "; // TEQ
    enumToString_VkComponentTypeNV(rString, pStruct->DType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->DType);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkScopeNV scope // SMB
    indentSpaces(rString, indent);
    *rString += "scope:                          ";
    *rString += "VkScopeNV = "; // TEQ
    enumToString_VkScopeNV(rString, pStruct->scope);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->scope);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV *pStruct = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 cooperativeMatrix // SMB
    indentSpaces(rString, indent);
    *rString += "cooperativeMatrix:              ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->cooperativeMatrix);
    *rString += "\n"; // GDS

    // VkBool32 cooperativeMatrixRobustBufferAccess // SMB
    indentSpaces(rString, indent);
    *rString += "cooperativeMatrixRobustBufferAccess: ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->cooperativeMatrixRobustBufferAccess);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>(std::string* rString, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV *pStruct = (const VkPhysicalDeviceCooperativeMatrixPropertiesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkShaderStageFlags cooperativeMatrixSupportedStages // SMB
    indentSpaces(rString, indent);
    *rString += "cooperativeMatrixSupportedStages: ";
    *rString += "VkShaderStageFlags = "; // TEQ
    flagsToString(rString, pStruct->cooperativeMatrixSupportedStages, enumToString_VkShaderStageFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pPropertyCount,
    const StructPointerDecoder<Decoded_VkCooperativeMatrixPropertiesNV>& pProperties)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPropertyCount // ARG
    if (pPropertyCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPropertyCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPropertyCount:", static_cast<uint64_t>(*pPropertyCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkCooperativeMatrixPropertiesNV* pProperties // ARG
    if (pProperties.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkCooperativeMatrixPropertiesNV* = NULL", indentString.c_str(), "pProperties:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkCooperativeMatrixPropertiesNV* = ", indentString.c_str(), "pProperties:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pProperties.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkCooperativeMatrixPropertiesNV>(&tmpString, 2, 1, "VkCooperativeMatrixPropertiesNV",
            pProperties.GetMetaStructPointer(), "pProperties", *pPropertyCount.GetPointer(), false, pProperties.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkCoverageReductionModeNV(std::string* rString, uint32_t enumValueInt32)
{
    VkCoverageReductionModeNV enumValue = static_cast<VkCoverageReductionModeNV>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV:
            *rString += std::string("VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV");
            return;
        case VK_COVERAGE_REDUCTION_MODE_MERGE_NV:
            *rString += std::string("VK_COVERAGE_REDUCTION_MODE_MERGE_NV");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(std::string* rString, const Decoded_VkFramebufferMixedSamplesCombinationNV &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>(std::string* rString, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV *pStruct = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 coverageReductionMode // SMB
    indentSpaces(rString, indent);
    *rString += "coverageReductionMode:          ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->coverageReductionMode);
}

template <>
void structureToString<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>(std::string* rString, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineCoverageReductionStateCreateInfoNV *pStruct = (const VkPipelineCoverageReductionStateCreateInfoNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkPipelineCoverageReductionStateCreateFlagsNV flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkPipelineCoverageReductionStateCreateFlagsNV = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
    *rString += "\n"; // GDS

    // VkCoverageReductionModeNV coverageReductionMode // SMB
    indentSpaces(rString, indent);
    *rString += "coverageReductionMode:          ";
    *rString += "VkCoverageReductionModeNV = "; // TEQ
    enumToString_VkCoverageReductionModeNV(rString, pStruct->coverageReductionMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->coverageReductionMode);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(std::string* rString, const Decoded_VkFramebufferMixedSamplesCombinationNV &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkFramebufferMixedSamplesCombinationNV *pStruct = (const VkFramebufferMixedSamplesCombinationNV *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkCoverageReductionModeNV coverageReductionMode // SMB
    indentSpaces(rString, indent);
    *rString += "coverageReductionMode:          ";
    *rString += "VkCoverageReductionModeNV = "; // TEQ
    enumToString_VkCoverageReductionModeNV(rString, pStruct->coverageReductionMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->coverageReductionMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSampleCountFlagBits rasterizationSamples // SMB
    indentSpaces(rString, indent);
    *rString += "rasterizationSamples:           ";
    *rString += "VkSampleCountFlagBits = "; // TEQ
    enumToString_VkSampleCountFlagBits(rString, pStruct->rasterizationSamples);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->rasterizationSamples);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkSampleCountFlags depthStencilSamples // SMB
    indentSpaces(rString, indent);
    *rString += "depthStencilSamples:            ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->depthStencilSamples, enumToString_VkSampleCountFlagBits); // URW
    *rString += "\n"; // GDS

    // VkSampleCountFlags colorSamples // SMB
    indentSpaces(rString, indent);
    *rString += "colorSamples:                   ";
    *rString += "VkSampleCountFlags = "; // TEQ
    flagsToString(rString, pStruct->colorSamples, enumToString_VkSampleCountFlagBits); // URW
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const PointerDecoder<uint32_t>&             pCombinationCount,
    const StructPointerDecoder<Decoded_VkFramebufferMixedSamplesCombinationNV>& pCombinations)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pCombinationCount // ARG
    if (pCombinationCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pCombinationCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pCombinationCount:", static_cast<uint64_t>(*pCombinationCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkFramebufferMixedSamplesCombinationNV* pCombinations // ARG
    if (pCombinations.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkFramebufferMixedSamplesCombinationNV* = NULL", indentString.c_str(), "pCombinations:"); // PJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkFramebufferMixedSamplesCombinationNV* = ", indentString.c_str(), "pCombinations:"); // GRR
        tmpString = "";
        addrToString(&tmpString, pCombinations.GetAddress());
        fprintf(GetFile(), "%s", tmpString.c_str());  // SSU
        tmpString = "";
        arrayOfStructsToString<Decoded_VkFramebufferMixedSamplesCombinationNV>(&tmpString, 2, 1, "VkFramebufferMixedSamplesCombinationNV",
            pCombinations.GetMetaStructPointer(), "pCombinations", *pCombinationCount.GetPointer(), false, pCombinations.GetAddress()); // VSR
        fprintf(GetFile(), "%s", tmpString.c_str()); // WZA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkFullScreenExclusiveEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkFullScreenExclusiveEXT enumValue = static_cast<VkFullScreenExclusiveEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT:
            *rString += std::string("VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT");
            return;
        case VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT:
            *rString += std::string("VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT");
            return;
        case VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT:
            *rString += std::string("VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT");
            return;
        case VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT:
            *rString += std::string("VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>(std::string* rString, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>(std::string* rString, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>(std::string* rString, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>(std::string* rString, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceFullScreenExclusiveInfoEXT *pStruct = (const VkSurfaceFullScreenExclusiveInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkFullScreenExclusiveEXT fullScreenExclusive // SMB
    indentSpaces(rString, indent);
    *rString += "fullScreenExclusive:            ";
    *rString += "VkFullScreenExclusiveEXT = "; // TEQ
    enumToString_VkFullScreenExclusiveEXT(rString, pStruct->fullScreenExclusive);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->fullScreenExclusive);
    *rString += ")";
}

template <>
void structureToString<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>(std::string* rString, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT *pStruct = (const VkSurfaceCapabilitiesFullScreenExclusiveEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 fullScreenExclusiveSupported // SMB
    indentSpaces(rString, indent);
    *rString += "fullScreenExclusiveSupported:   ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->fullScreenExclusiveSupported);
}

template <>
void structureToString<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>(std::string* rString, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkSurfaceFullScreenExclusiveWin32InfoEXT *pStruct = (const VkSurfaceFullScreenExclusiveWin32InfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // void* hmonitor // SMB
    indentSpaces(rString, indent);
    *rString += "hmonitor:                       ";
    *rString += "void* = "; // TEQ
    if (pStruct->hmonitor == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.hmonitor); // PWR
    }
}

void VulkanAsciiConsumer::Process_vkGetPhysicalDeviceSurfacePresentModes2EXT(
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<uint32_t>&             pPresentModeCount,
    const PointerDecoder<VkPresentModeKHR>&     pPresentModes)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkPhysicalDevice physicalDevice // ARG
    fprintf(GetFile(), "%s%-32sVkPhysicalDevice = ", indentString.c_str(), "physicalDevice:"); // TRP
    tmpString = "";
    addrToString(&tmpString, physicalDevice);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indentString.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indentString.c_str(), "pSurfaceInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmpString, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t* pPresentModeCount // ARG
    if (pPresentModeCount.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32suint32_t* = NULL", indentString.c_str(), "pPresentModeCount:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32suint32_t* = %" PRId64 "", indentString.c_str(), "pPresentModeCount:", static_cast<uint64_t>(*pPresentModeCount.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkPresentModeKHR* pPresentModes // ARG
    if (pPresentModes.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = NULL", indentString.c_str(), "pPresentModes:"); // GXD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkPresentModeKHR* = %" PRId64 "", indentString.c_str(), "pPresentModes:", static_cast<uint64_t>(*pPresentModes.GetPointer()));   // JQA
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkAcquireFullScreenExclusiveModeEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkAcquireFullScreenExclusiveModeEXT(device, swapchain)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkReleaseFullScreenExclusiveModeEXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkReleaseFullScreenExclusiveModeEXT(device, swapchain)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkSwapchainKHR swapchain // ARG
    fprintf(GetFile(), "%s%-32sVkSwapchainKHR = ", indentString.c_str(), "swapchain:"); // TRP
    tmpString = "";
    addrToString(&tmpString, swapchain);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
void VulkanAsciiConsumer::Process_vkGetDeviceGroupSurfacePresentModes2EXT(
    VkResult                                    returnValue,
    format::HandleId                            device,
    const StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>& pSurfaceInfo,
    const PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>& pModes)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo // ARG
    if (pSurfaceInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = NULL", indentString.c_str(), "pSurfaceInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkPhysicalDeviceSurfaceInfo2KHR* = ", indentString.c_str(), "pSurfaceInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pSurfaceInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>(&tmpString, *pSurfaceInfo.GetMetaStructPointer(), 2, pSurfaceInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkDeviceGroupPresentModeFlagsKHR* pModes // ARG
    tmpString = "";
    flagsToString(&tmpString, *pModes.GetPointer(), enumToString_VkDeviceGroupPresentModeFlagBitsKHR);
    fprintf(GetFile(), "%s%-32sVkDeviceGroupPresentModeFlagsKHR* = %s", indentString.c_str(), "pModes:", tmpString.c_str()); // UWQ
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(std::string* rString, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(std::string* rString, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkHeadlessSurfaceCreateInfoEXT *pStruct = (const VkHeadlessSurfaceCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkHeadlessSurfaceCreateFlagsEXT flags // SMB
    indentSpaces(rString, indent);
    *rString += "flags:                          ";
    *rString += "VkHeadlessSurfaceCreateFlagsEXT = "; // TEQ
    unsignedDecimalToString(rString, pStruct->flags);
}

void VulkanAsciiConsumer::Process_vkCreateHeadlessSurfaceEXT(
    VkResult                                    returnValue,
    format::HandleId                            instance,
    const StructPointerDecoder<Decoded_VkHeadlessSurfaceCreateInfoEXT>& pCreateInfo,
    const StructPointerDecoder<Decoded_VkAllocationCallbacks>& pAllocator,
    const HandlePointerDecoder<VkSurfaceKHR>&   pSurface)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)");
    tmpString = "";
    enumToString_VkResult(&tmpString, returnValue);
    fprintf(GetFile(), " returns VkResult %s (%" PRId32 "):\n", tmpString.c_str(), returnValue);

    // VkInstance instance // ARG
    fprintf(GetFile(), "%s%-32sVkInstance = ", indentString.c_str(), "instance:"); // TRP
    tmpString = "";
    addrToString(&tmpString, instance);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo // ARG
    if (pCreateInfo.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkHeadlessSurfaceCreateInfoEXT* = NULL", indentString.c_str(), "pCreateInfo:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkHeadlessSurfaceCreateInfoEXT* = ", indentString.c_str(), "pCreateInfo:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pCreateInfo.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkHeadlessSurfaceCreateInfoEXT>(&tmpString, *pCreateInfo.GetMetaStructPointer(), 2, pCreateInfo.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // const VkAllocationCallbacks* pAllocator // ARG
    if (pAllocator.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = NULL", indentString.c_str(), "pAllocator:"); // GJK
    }
    else
    {
        fprintf(GetFile(), "%s%-32sconst VkAllocationCallbacks* = ", indentString.c_str(), "pAllocator:"); // WPO
        tmpString = "";
        addrToString(&tmpString, pAllocator.GetAddress());
        fprintf(GetFile(), "%s:", tmpString.c_str()); // WPP
        tmpString = "";
        structureToString<Decoded_VkAllocationCallbacks>(&tmpString, *pAllocator.GetMetaStructPointer(), 2, pAllocator.GetAddress()); // GGG
        fprintf(GetFile(), "%s", tmpString.c_str());   // DGP
    }
    fprintf(GetFile(), "\n"); // YWN

    // VkSurfaceKHR* pSurface // ARG
    if (pSurface.GetPointer() == nullptr)
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = NULL", indentString.c_str(), "pSurface:"); // UJD
    }
    else
    {
        fprintf(GetFile(), "%s%-32sVkSurfaceKHR* = ", indentString.c_str(), "pSurface:");  // TAZ
        tmpString = "";
        addrToString(&tmpString, *(static_cast<uint64_t*>(pSurface.GetPointer())));
        fprintf(GetFile(), "%s", tmpString.c_str());  // RAJ
    }
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}


void enumToString_VkLineRasterizationModeEXT(std::string* rString, uint32_t enumValueInt32)
{
    VkLineRasterizationModeEXT enumValue = static_cast<VkLineRasterizationModeEXT>(enumValueInt32);
    assert(rString != nullptr);
    switch (enumValue)
    {
        case VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT:
            *rString += std::string("VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT");
            return;
        case VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT:
            *rString += std::string("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT");
            return;
        case VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT:
            *rString += std::string("VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT");
            return;
        case VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT:
            *rString += std::string("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT");
            return;
        default:
            *rString += std::string("UNKNOWN");
            return;
    };
};

template <> void structureToString<Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX
template <> void structureToString<Decoded_VkPipelineRasterizationLineStateCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceLineRasterizationFeaturesEXT *pStruct = (const VkPhysicalDeviceLineRasterizationFeaturesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 rectangularLines // SMB
    indentSpaces(rString, indent);
    *rString += "rectangularLines:               ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->rectangularLines);
    *rString += "\n"; // GDS

    // VkBool32 bresenhamLines // SMB
    indentSpaces(rString, indent);
    *rString += "bresenhamLines:                 ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->bresenhamLines);
    *rString += "\n"; // GDS

    // VkBool32 smoothLines // SMB
    indentSpaces(rString, indent);
    *rString += "smoothLines:                    ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->smoothLines);
    *rString += "\n"; // GDS

    // VkBool32 stippledRectangularLines // SMB
    indentSpaces(rString, indent);
    *rString += "stippledRectangularLines:       ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->stippledRectangularLines);
    *rString += "\n"; // GDS

    // VkBool32 stippledBresenhamLines // SMB
    indentSpaces(rString, indent);
    *rString += "stippledBresenhamLines:         ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->stippledBresenhamLines);
    *rString += "\n"; // GDS

    // VkBool32 stippledSmoothLines // SMB
    indentSpaces(rString, indent);
    *rString += "stippledSmoothLines:            ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->stippledSmoothLines);
}

template <>
void structureToString<Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceLineRasterizationPropertiesEXT *pStruct = (const VkPhysicalDeviceLineRasterizationPropertiesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // uint32_t lineSubPixelPrecisionBits // SMB
    indentSpaces(rString, indent);
    *rString += "lineSubPixelPrecisionBits:      ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->lineSubPixelPrecisionBits);
}

template <>
void structureToString<Decoded_VkPipelineRasterizationLineStateCreateInfoEXT>(std::string* rString, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPipelineRasterizationLineStateCreateInfoEXT *pStruct = (const VkPipelineRasterizationLineStateCreateInfoEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // const void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "const void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkLineRasterizationModeEXT lineRasterizationMode // SMB
    indentSpaces(rString, indent);
    *rString += "lineRasterizationMode:          ";
    *rString += "VkLineRasterizationModeEXT = "; // TEQ
    enumToString_VkLineRasterizationModeEXT(rString, pStruct->lineRasterizationMode);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->lineRasterizationMode);
    *rString += ")";
    *rString += "\n"; // GDS

    // VkBool32 stippledLineEnable // SMB
    indentSpaces(rString, indent);
    *rString += "stippledLineEnable:             ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->stippledLineEnable);
    *rString += "\n"; // GDS

    // uint32_t lineStippleFactor // SMB
    indentSpaces(rString, indent);
    *rString += "lineStippleFactor:              ";
    *rString += "uint32_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->lineStippleFactor);
    *rString += "\n"; // GDS

    // uint16_t lineStipplePattern // SMB
    indentSpaces(rString, indent);
    *rString += "lineStipplePattern:             ";
    *rString += "uint16_t = "; // TEQ
    unsignedDecimalToString(rString, pStruct->lineStipplePattern);
}

void VulkanAsciiConsumer::Process_vkCmdSetLineStippleEXT(
    format::HandleId                            commandBuffer,
    uint32_t                                    lineStippleFactor,
    uint16_t                                    lineStipplePattern)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern)");
    fprintf(GetFile(), " returns void:\n");

    // VkCommandBuffer commandBuffer // ARG
    fprintf(GetFile(), "%s%-32sVkCommandBuffer = ", indentString.c_str(), "commandBuffer:"); // TRP
    tmpString = "";
    addrToString(&tmpString, commandBuffer);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t lineStippleFactor // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "lineStippleFactor:", lineStippleFactor); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint16_t lineStipplePattern // ARG
    fprintf(GetFile(), "%s%-32suint16_t = %d", indentString.c_str(), "lineStipplePattern:", lineStipplePattern); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}

template <> void structureToString<Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pStructIn, int indent, uint64_t baseAddr); // ARX

template <>
void structureToString<Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT>(std::string* rString, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pStructIn, int indent, uint64_t baseAddr) // GAA
{
    const VkPhysicalDeviceHostQueryResetFeaturesEXT *pStruct = (const VkPhysicalDeviceHostQueryResetFeaturesEXT *)pStructIn.decoded_value; // BTB
    assert(rString != nullptr);
    if (pStruct == nullptr)
    {
        return;
    }
    *rString += "\n"; // UUR

    // VkStructureType sType // SMB
    indentSpaces(rString, indent);
    *rString += "sType:                          ";
    *rString += "VkStructureType = "; // TEQ
    enumToString_VkStructureType(rString, pStruct->sType);
    *rString += " (";
    unsignedDecimalToString(rString, pStruct->sType);
    *rString += ")";
    *rString += "\n"; // GDS

    // void* pNext // SMB
    indentSpaces(rString, indent);
    *rString += "pNext:                          ";
    *rString += "void* = "; // TEQ
    if (pStruct->pNext == nullptr) // WWW
    {
        *rString += "NULL";
    }
    else
    {
        addrToString(rString, pStructIn.pNext->GetAddress()); // PWS
    }
    *rString += "\n"; // GDS

    // VkBool32 hostQueryReset // SMB
    indentSpaces(rString, indent);
    *rString += "hostQueryReset:                 ";
    *rString += "VkBool32 = "; // TEQ
    signedDecimalToString(rString, pStruct->hostQueryReset);
}

void VulkanAsciiConsumer::Process_vkResetQueryPoolEXT(
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    std::string indentString;
    std::string tmpString;
    indentSpaces(&indentString, 1);
    fprintf(GetFile(), "vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount)");
    fprintf(GetFile(), " returns void:\n");

    // VkDevice device // ARG
    fprintf(GetFile(), "%s%-32sVkDevice = ", indentString.c_str(), "device:"); // TRP
    tmpString = "";
    addrToString(&tmpString, device);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // VkQueryPool queryPool // ARG
    fprintf(GetFile(), "%s%-32sVkQueryPool = ", indentString.c_str(), "queryPool:"); // TRP
    tmpString = "";
    addrToString(&tmpString, queryPool);
    fprintf(GetFile(), "%s", tmpString.c_str()); // TRQ
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t firstQuery // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "firstQuery:", firstQuery); // YZA
    fprintf(GetFile(), "\n"); // YWN

    // uint32_t queryCount // ARG
    fprintf(GetFile(), "%s%-32suint32_t = %u", indentString.c_str(), "queryCount:", queryCount); // YZA
    fprintf(GetFile(), "\n"); // YWN

    tmpString = "\n";   // HDS
    fprintf(GetFile(), "%s", tmpString.c_str());
}
GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)
