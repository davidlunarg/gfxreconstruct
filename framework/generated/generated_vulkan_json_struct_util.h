/*
** Copyright (c) 2018-2019 Valve Corporation
** Copyright (c) 2018-2019 LunarG, Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#ifndef  GFXRECON_GENERATED_VULKAN_JSON_STRUCT_UTIL_H
#define  GFXRECON_GENERATED_VULKAN_JSON_STRUCT_UTIL_H

#include "format/platform_types.h"
#include "generated/generated_vulkan_enum_output_util.h"
#include "util/defines.h"
#include "util/json_utils.h"
#include "vulkan/vulkan.h"
#include <inttypes.h>
#include <string>
#include <unordered_map>

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

void OutputStructureJson(FILE* outputFile, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRectLayerKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentRegionKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentRegionsKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImagelessFramebufferFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferAttachmentImageInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferAttachmentsCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassAttachmentBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageFormatListCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevice8BitStorageFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkConformanceVersionKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDriverPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFloatControlsPropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDescriptionDepthStencilResolveKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthStencilResolvePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceProtectedCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDedicatedAllocationImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDedicatedAllocationBufferCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkTextureLODGatherFormatPropertiesAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkValidationFlagsEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewASTCDecodeModeEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkViewportSwizzleNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerReductionModeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkWriteDescriptorSetInlineUniformBlockEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCoverageToColorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCoverageModulationStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceQueueGlobalPriorityCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCompilerControlCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkVertexInputBindingDivisorDescriptionEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineVertexInputDivisorStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentFrameTokenGGP &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryPriorityAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkImageStencilUsageCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkValidationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &pstruct_in, int indent, uint64_t base_addr);
void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &pstruct_in, int indent, uint64_t base_addr);

template <typename T>
void OutputArrayOfStructsJson(FILE*    outputFile,
                              int          indent,
                              const char*  base_type_name,
                              T*           array,
                              const char*  array_name,
                              const size_t array_length,
                              bool         is_union,
                              uint64_t     base_addr,
                              size_t       struct_size)
{
    assert(outputFile != nullptr);
    if (array_length == 0 || array == nullptr)
    {
        OutputStringJson(outputFile, "[ ]\n");
        return;
    }
    OutputStringJson(outputFile, "\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n");
    for (uint64_t j = 0; j < array_length; j++)
    {
        indent++;
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "{\n");
        indent++;
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"type\" : \"");
        OutputStringJson(outputFile, base_type_name);
        OutputStringJson(outputFile, (is_union ? " (Union)\",\n" : "\",\n"));
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"name\" : \"[");
        std::string idx_str;
        fprintf(outputFile, "%" PRIu64, j);
        OutputStringJson(outputFile, idx_str);
        OutputStringJson(outputFile, "]\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, array[j], indent, base_addr + j * struct_size); // YGS
        indent--;
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "}");
        if (j < array_length - 1)
        {
            OutputStringJson(outputFile, ",");
        }
        OutputStringJson(outputFile, "\n");
        indent--;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n");
}

std::unordered_map<VkStructureType, std::string> sTypeToStructName = {    // WTG
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES, "VkPhysicalDeviceSubgroupProperties"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES, "VkPhysicalDevice16BitStorageFeatures"},
   {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS, "VkMemoryDedicatedRequirements"},
   {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO, "VkMemoryDedicatedAllocateInfo"},
   {VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO, "VkMemoryAllocateFlagsInfo"},
   {VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, "VkDeviceGroupRenderPassBeginInfo"},
   {VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO, "VkDeviceGroupCommandBufferBeginInfo"},
   {VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO, "VkDeviceGroupSubmitInfo"},
   {VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO, "VkDeviceGroupBindSparseInfo"},
   {VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO, "VkBindBufferMemoryDeviceGroupInfo"},
   {VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO, "VkBindImageMemoryDeviceGroupInfo"},
   {VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO, "VkDeviceGroupDeviceCreateInfo"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, "VkPhysicalDeviceFeatures2"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES, "VkPhysicalDevicePointClippingProperties"},
   {VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO, "VkRenderPassInputAttachmentAspectCreateInfo"},
   {VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO, "VkImageViewUsageCreateInfo"},
   {VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO, "VkPipelineTessellationDomainOriginStateCreateInfo"},
   {VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO, "VkRenderPassMultiviewCreateInfo"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES, "VkPhysicalDeviceMultiviewFeatures"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES, "VkPhysicalDeviceMultiviewProperties"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES, "VkPhysicalDeviceVariablePointersFeatures"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES, "VkPhysicalDeviceProtectedMemoryFeatures"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES, "VkPhysicalDeviceProtectedMemoryProperties"},
   {VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO, "VkProtectedSubmitInfo"},
   {VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO, "VkSamplerYcbcrConversionInfo"},
   {VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, "VkBindImagePlaneMemoryInfo"},
   {VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO, "VkImagePlaneMemoryRequirementsInfo"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES, "VkPhysicalDeviceSamplerYcbcrConversionFeatures"},
   {VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES, "VkSamplerYcbcrConversionImageFormatProperties"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO, "VkPhysicalDeviceExternalImageFormatInfo"},
   {VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES, "VkExternalImageFormatProperties"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES, "VkPhysicalDeviceIDProperties"},
   {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, "VkExternalMemoryImageCreateInfo"},
   {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, "VkExternalMemoryBufferCreateInfo"},
   {VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO, "VkExportMemoryAllocateInfo"},
   {VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO, "VkExportFenceCreateInfo"},
   {VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO, "VkExportSemaphoreCreateInfo"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES, "VkPhysicalDeviceMaintenance3Properties"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES, "VkPhysicalDeviceShaderDrawParametersFeatures"},
   {VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, "VkImageSwapchainCreateInfoKHR"},
   {VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR, "VkBindImageMemorySwapchainInfoKHR"},
   {VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR, "VkDeviceGroupPresentInfoKHR"},
   {VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR, "VkDeviceGroupSwapchainCreateInfoKHR"},
   {VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR, "VkDisplayPresentInfoKHR"},
   {VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR, "VkImportMemoryWin32HandleInfoKHR"},
   {VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR, "VkExportMemoryWin32HandleInfoKHR"},
   {VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR, "VkImportMemoryFdInfoKHR"},
   {VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR, "VkWin32KeyedMutexAcquireReleaseInfoKHR"},
   {VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, "VkExportSemaphoreWin32HandleInfoKHR"},
   {VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR, "VkD3D12FenceSubmitInfoKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR, "VkPhysicalDevicePushDescriptorPropertiesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR, "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"},
   {VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR, "VkPresentRegionsKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR, "VkPhysicalDeviceImagelessFramebufferFeaturesKHR"},
   {VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR, "VkFramebufferAttachmentsCreateInfoKHR"},
   {VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR, "VkRenderPassAttachmentBeginInfoKHR"},
   {VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR, "VkSharedPresentSurfaceCapabilitiesKHR"},
   {VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR, "VkExportFenceWin32HandleInfoKHR"},
   {VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR, "VkImageFormatListCreateInfoKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR, "VkPhysicalDevice8BitStorageFeaturesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR, "VkPhysicalDeviceShaderClockFeaturesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR, "VkPhysicalDeviceDriverPropertiesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR, "VkPhysicalDeviceFloatControlsPropertiesKHR"},
   {VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR, "VkSubpassDescriptionDepthStencilResolveKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR, "VkPhysicalDeviceDepthStencilResolvePropertiesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR, "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR, "VkPhysicalDeviceTimelineSemaphorePropertiesKHR"},
   {VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR, "VkSemaphoreTypeCreateInfoKHR"},
   {VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR, "VkTimelineSemaphoreSubmitInfoKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"},
   {VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR, "VkSurfaceProtectedCapabilitiesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR, "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR, "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR"},
   {VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, "VkDebugReportCallbackCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD, "VkPipelineRasterizationStateRasterizationOrderAMD"},
   {VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, "VkDedicatedAllocationImageCreateInfoNV"},
   {VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, "VkDedicatedAllocationBufferCreateInfoNV"},
   {VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV, "VkDedicatedAllocationMemoryAllocateInfoNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT, "VkPhysicalDeviceTransformFeedbackFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT, "VkPhysicalDeviceTransformFeedbackPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT, "VkPipelineRasterizationStateStreamCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD, "VkTextureLODGatherFormatPropertiesAMD"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV, "VkPhysicalDeviceCornerSampledImageFeaturesNV"},
   {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, "VkExternalMemoryImageCreateInfoNV"},
   {VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV, "VkExportMemoryAllocateInfoNV"},
   {VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV, "VkImportMemoryWin32HandleInfoNV"},
   {VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV, "VkExportMemoryWin32HandleInfoNV"},
   {VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV, "VkWin32KeyedMutexAcquireReleaseInfoNV"},
   {VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT, "VkValidationFlagsEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT, "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"},
   {VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT, "VkImageViewASTCDecodeModeEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT, "VkPhysicalDeviceASTCDecodeFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT, "VkPhysicalDeviceConditionalRenderingFeaturesEXT"},
   {VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT, "VkCommandBufferInheritanceConditionalRenderingInfoEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV, "VkPipelineViewportWScalingStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT, "VkSwapchainCounterCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE, "VkPresentTimesInfoGOOGLE"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX"},
   {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV, "VkPipelineViewportSwizzleStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT, "VkPhysicalDeviceDiscardRectanglePropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT, "VkPipelineDiscardRectangleStateCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT, "VkPipelineRasterizationConservativeStateCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT, "VkPhysicalDeviceDepthClipEnableFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT, "VkPipelineRasterizationDepthClipStateCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT, "VkDebugUtilsMessengerCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID, "VkAndroidHardwareBufferUsageANDROID"},
   {VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID, "VkAndroidHardwareBufferFormatPropertiesANDROID"},
   {VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID, "VkImportAndroidHardwareBufferInfoANDROID"},
   {VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, "VkExternalFormatANDROID"},
   {VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT, "VkSamplerReductionModeCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT, "VkPhysicalDeviceInlineUniformBlockPropertiesEXT"},
   {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT, "VkWriteDescriptorSetInlineUniformBlockEXT"},
   {VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, "VkSampleLocationsInfoEXT"},
   {VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT, "VkRenderPassSampleLocationsBeginInfoEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT, "VkPipelineSampleLocationsStateCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT, "VkPhysicalDeviceSampleLocationsPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT, "VkPipelineColorBlendAdvancedStateCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV, "VkPipelineCoverageToColorStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV, "VkPipelineCoverageModulationStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV, "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV, "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV"},
   {VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT, "VkDrmFormatModifierPropertiesListEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT"},
   {VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, "VkImageDrmFormatModifierListCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, "VkImageDrmFormatModifierExplicitCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT, "VkShaderModuleValidationCacheCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT"},
   {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"},
   {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV, "VkPipelineViewportShadingRateImageStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV, "VkPhysicalDeviceShadingRateImageFeaturesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV, "VkPhysicalDeviceShadingRateImagePropertiesNV"},
   {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV, "VkWriteDescriptorSetAccelerationStructureNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV, "VkPhysicalDeviceRayTracingPropertiesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV, "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV"},
   {VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV, "VkPipelineRepresentativeFragmentTestStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT, "VkPhysicalDeviceImageViewImageFormatInfoEXT"},
   {VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT, "VkFilterCubicImageViewImageFormatPropertiesEXT"},
   {VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT, "VkDeviceQueueGlobalPriorityCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT, "VkImportMemoryHostPointerInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD, "VkPipelineCompilerControlCreateInfoAMD"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD, "VkPhysicalDeviceShaderCorePropertiesAMD"},
   {VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD, "VkDeviceMemoryOverallocationCreateInfoAMD"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT, "VkPipelineVertexInputDivisorStateCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP, "VkPresentFrameTokenGGP"},
   {VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT, "VkPipelineCreationFeedbackCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV, "VkPhysicalDeviceMeshShaderFeaturesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV, "VkPhysicalDeviceMeshShaderPropertiesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV, "VkPhysicalDeviceShaderImageFootprintFeaturesNV"},
   {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV, "VkPipelineViewportExclusiveScissorStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV, "VkPhysicalDeviceExclusiveScissorFeaturesNV"},
   {VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV, "VkQueueFamilyCheckpointPropertiesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL, "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT, "VkPhysicalDevicePCIBusInfoPropertiesEXT"},
   {VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD, "VkDisplayNativeHdrSurfaceCapabilitiesAMD"},
   {VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD, "VkSwapchainDisplayNativeHdrCreateInfoAMD"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT, "VkPhysicalDeviceFragmentDensityMapFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT, "VkPhysicalDeviceFragmentDensityMapPropertiesEXT"},
   {VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT, "VkRenderPassFragmentDensityMapCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT, "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT, "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT, "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT, "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD, "VkPhysicalDeviceShaderCoreProperties2AMD"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD, "VkPhysicalDeviceCoherentMemoryFeaturesAMD"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT, "VkPhysicalDeviceMemoryBudgetPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT, "VkPhysicalDeviceMemoryPriorityFeaturesEXT"},
   {VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT, "VkMemoryPriorityAllocateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV, "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT, "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"},
   {VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT, "VkBufferDeviceAddressCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT, "VkImageStencilUsageCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT, "VkValidationFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV, "VkPhysicalDeviceCooperativeMatrixFeaturesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV, "VkPhysicalDeviceCooperativeMatrixPropertiesNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV, "VkPhysicalDeviceCoverageReductionModeFeaturesNV"},
   {VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV, "VkPipelineCoverageReductionStateCreateInfoNV"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT, "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT, "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"},
   {VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT, "VkSurfaceFullScreenExclusiveInfoEXT"},
   {VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT, "VkSurfaceCapabilitiesFullScreenExclusiveEXT"},
   {VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, "VkSurfaceFullScreenExclusiveWin32InfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT, "VkPhysicalDeviceLineRasterizationFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT, "VkPhysicalDeviceLineRasterizationPropertiesEXT"},
   {VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT, "VkPipelineRasterizationLineStateCreateInfoEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT, "VkPhysicalDeviceHostQueryResetFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT, "VkPhysicalDeviceIndexTypeUint8FeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT, "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT, "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT"},
   {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT, "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"},
};    // WTE

void OutputPnextStructJson(FILE* outputFile, int indent, void* pNext_struct, uint64_t base_addr)
{
    assert(outputFile != nullptr);
    switch (static_cast<Decoded_VkApplicationInfo*>(pNext_struct)->decoded_value->sType)
    {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupProperties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevice16BitStorageFeatures*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkMemoryDedicatedRequirements*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkMemoryDedicatedAllocateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkMemoryAllocateFlagsInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupRenderPassBeginInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupCommandBufferBeginInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupSubmitInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupBindSparseInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkBindBufferMemoryDeviceGroupInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkBindImageMemoryDeviceGroupInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupDeviceCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFeatures2*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePointClippingProperties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassInputAttachmentAspectCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImageViewUsageCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassMultiviewCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewFeatures*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewProperties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVariablePointersFeatures*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryFeatures*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryProperties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkProtectedSubmitInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSamplerYcbcrConversionInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkBindImagePlaneMemoryInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImagePlaneMemoryRequirementsInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSamplerYcbcrConversionImageFormatProperties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceExternalImageFormatInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExternalImageFormatProperties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceIDProperties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExternalMemoryBufferCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryAllocateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportFenceCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportSemaphoreCreateInfo*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance3Properties*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImageSwapchainCreateInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkBindImageMemorySwapchainInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupPresentInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceGroupSwapchainCreateInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDisplayPresentInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryFdInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportSemaphoreWin32HandleInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkD3D12FenceSubmitInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPresentRegionsKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceImagelessFramebufferFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkFramebufferAttachmentsCreateInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassAttachmentBeginInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSharedPresentSurfaceCapabilitiesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportFenceWin32HandleInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImageFormatListCreateInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevice8BitStorageFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDriverPropertiesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFloatControlsPropertiesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSubpassDescriptionDepthStencilResolveKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDepthStencilResolvePropertiesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSemaphoreTypeCreateInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkTimelineSemaphoreSubmitInfoKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceProtectedCapabilitiesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDebugReportCallbackCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDedicatedAllocationImageCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDedicatedAllocationBufferCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkTextureLODGatherFormatPropertiesAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryAllocateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkValidationFlagsEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImageViewASTCDecodeModeEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportWScalingStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSwapchainCounterCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPresentTimesInfoGOOGLE*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDebugUtilsMessengerCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkAndroidHardwareBufferUsageANDROID*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImportAndroidHardwareBufferInfoANDROID*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkExternalFormatANDROID*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSamplerReductionModeCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkWriteDescriptorSetInlineUniformBlockEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSampleLocationsInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassSampleLocationsBeginInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCoverageToColorStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCoverageModulationStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDrmFormatModifierPropertiesListEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImageDrmFormatModifierListCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkShaderModuleValidationCacheCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkWriteDescriptorSetAccelerationStructureNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPropertiesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceQueueGlobalPriorityCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImportMemoryHostPointerInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCompilerControlCreateInfoAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineVertexInputDivisorStateCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPresentFrameTokenGGP*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCreationFeedbackCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkQueueFamilyCheckpointPropertiesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkMemoryPriorityAllocateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkBufferDeviceAddressCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkImageStencilUsageCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkValidationFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineCoverageReductionStateCreateInfoNV*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
            OutputStructureJson(outputFile, *(reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(pNext_struct)) , indent, base_addr);
            break;
        default:
            OutputStringJson(outputFile, "\"Unknown pNext structure\"");
            break;
    }
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkApplicationInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkApplicationInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pApplicationName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pApplicationName\",\n");
    if (pstruct->pApplicationName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pApplicationName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t applicationVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"applicationVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->applicationVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pEngineName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pEngineName\",\n");
    if (pstruct->pEngineName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pEngineName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t engineVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"engineVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->engineVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t apiVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"apiVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->apiVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkInstanceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkInstanceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkInstanceCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkInstanceCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkApplicationInfo* pApplicationInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkApplicationInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pApplicationInfo\",\n");
    if (pstruct->pApplicationInfo == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pApplicationInfo->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pApplicationInfo->GetMetaStructPointer(), indent,  base_addr + offsetof(VkInstanceCreateInfo, pApplicationInfo)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t enabledLayerCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"enabledLayerCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->enabledLayerCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* const* ppEnabledLayerNames
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char* const*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ppEnabledLayerNames\",\n");
    if (pstruct->ppEnabledLayerNames == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.ppEnabledLayerNames.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRG
        OutputScalarValueStructInfo vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const char* const*", &pstruct_in.ppEnabledLayerNames, "ppEnabledLayerNames", pstruct->enabledLayerCount, vinfo_ppEnabledLayerNames); // UQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t enabledExtensionCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"enabledExtensionCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->enabledExtensionCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* const* ppEnabledExtensionNames
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char* const*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ppEnabledExtensionNames\",\n");
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.ppEnabledExtensionNames.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRG
        OutputScalarValueStructInfo vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const char* const*", &pstruct_in.ppEnabledExtensionNames, "ppEnabledExtensionNames", pstruct->enabledExtensionCount, vinfo_ppEnabledExtensionNames); // UQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAllocationCallbacks &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAllocationCallbacks *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: void* pUserData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pUserData\",\n");
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pUserData /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pUserData); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: PFN_vkAllocationFunction pfnAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"PFN_vkAllocationFunction"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pfnAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnAllocation)); // WRX
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: PFN_vkReallocationFunction pfnReallocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"PFN_vkReallocationFunction"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pfnReallocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnReallocation)); // WRX
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: PFN_vkFreeFunction pfnFree
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"PFN_vkFreeFunction"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pfnFree\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnFree)); // WRX
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: PFN_vkInternalAllocationNotification pfnInternalAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"PFN_vkInternalAllocationNotification"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pfnInternalAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnInternalAllocation)); // WRX
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: PFN_vkInternalFreeNotification pfnInternalFree
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"PFN_vkInternalFreeNotification"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pfnInternalFree\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnInternalFree)); // WRX
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkBool32 robustBufferAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"robustBufferAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->robustBufferAccess); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fullDrawIndexUint32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fullDrawIndexUint32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fullDrawIndexUint32); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 imageCubeArray
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageCubeArray\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->imageCubeArray); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 independentBlend
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"independentBlend\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->independentBlend); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 geometryShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"geometryShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->geometryShader); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 tessellationShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tessellationShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->tessellationShader); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sampleRateShading
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleRateShading\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sampleRateShading); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 dualSrcBlend
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dualSrcBlend\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->dualSrcBlend); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 logicOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"logicOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->logicOp); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 multiDrawIndirect
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"multiDrawIndirect\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->multiDrawIndirect); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 drawIndirectFirstInstance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drawIndirectFirstInstance\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->drawIndirectFirstInstance); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthClamp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthClamp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthClamp); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthBiasClamp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthBiasClamp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthBiasClamp); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fillModeNonSolid
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fillModeNonSolid\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fillModeNonSolid); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthBounds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthBounds\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthBounds); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 wideLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"wideLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->wideLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 largePoints
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"largePoints\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->largePoints); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 alphaToOne
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"alphaToOne\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->alphaToOne); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 multiViewport
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"multiViewport\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->multiViewport); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 samplerAnisotropy
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"samplerAnisotropy\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->samplerAnisotropy); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 textureCompressionETC2
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"textureCompressionETC2\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->textureCompressionETC2); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 textureCompressionASTC_LDR
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"textureCompressionASTC_LDR\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->textureCompressionASTC_LDR); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 textureCompressionBC
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"textureCompressionBC\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->textureCompressionBC); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 occlusionQueryPrecise
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"occlusionQueryPrecise\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->occlusionQueryPrecise); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 pipelineStatisticsQuery
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineStatisticsQuery\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->pipelineStatisticsQuery); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 vertexPipelineStoresAndAtomics
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexPipelineStoresAndAtomics\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vertexPipelineStoresAndAtomics); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentStoresAndAtomics
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentStoresAndAtomics\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentStoresAndAtomics); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderTessellationAndGeometryPointSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderTessellationAndGeometryPointSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderTessellationAndGeometryPointSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderImageGatherExtended
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderImageGatherExtended\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderImageGatherExtended); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageImageExtendedFormats
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageImageExtendedFormats\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageImageExtendedFormats); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageImageMultisample
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageImageMultisample\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageImageMultisample); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageImageReadWithoutFormat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageImageReadWithoutFormat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageImageReadWithoutFormat); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageImageWriteWithoutFormat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageImageWriteWithoutFormat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageImageWriteWithoutFormat); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderUniformBufferArrayDynamicIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderUniformBufferArrayDynamicIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderUniformBufferArrayDynamicIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSampledImageArrayDynamicIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSampledImageArrayDynamicIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSampledImageArrayDynamicIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageBufferArrayDynamicIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageBufferArrayDynamicIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageBufferArrayDynamicIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageImageArrayDynamicIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageImageArrayDynamicIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageImageArrayDynamicIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderClipDistance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderClipDistance\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderClipDistance); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderCullDistance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderCullDistance\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderCullDistance); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderFloat64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderFloat64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderFloat64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderInt64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderInt64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderInt64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderInt16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderInt16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderInt16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderResourceResidency
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderResourceResidency\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderResourceResidency); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderResourceMinLod
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderResourceMinLod\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderResourceMinLod); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseBinding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseBinding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseBinding); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidencyBuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidencyBuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidencyBuffer); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidencyImage2D
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidencyImage2D\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidencyImage2D); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidencyImage3D
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidencyImage3D\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidencyImage3D); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidency2Samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidency2Samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidency2Samples); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidency4Samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidency4Samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidency4Samples); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidency8Samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidency8Samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidency8Samples); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidency16Samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidency16Samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidency16Samples); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sparseResidencyAliased
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseResidencyAliased\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseResidencyAliased); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 variableMultisampleRate
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"variableMultisampleRate\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->variableMultisampleRate); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 inheritedQueries
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"inheritedQueries\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->inheritedQueries); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkFormatFeatureFlags linearTilingFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormatFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"linearTilingFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->linearTilingFeatures, OutputEnumVkFormatFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormatFeatureFlags optimalTilingFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormatFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"optimalTilingFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->optimalTilingFeatures, OutputEnumVkFormatFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormatFeatureFlags bufferFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormatFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->bufferFeatures, OutputEnumVkFormatFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExtent3D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExtent3D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t width
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"width\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->width); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t height
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"height\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->height); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t depth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->depth); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkExtent3D maxExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxExtent, indent,  base_addr + offsetof(VkImageFormatProperties, maxExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMipLevels
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMipLevels\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMipLevels); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxArrayLayers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxArrayLayers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxArrayLayers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags sampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize maxResourceSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxResourceSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->maxResourceSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceLimits &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceLimits *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t maxImageDimension1D
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageDimension1D\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageDimension1D); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageDimension2D
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageDimension2D\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageDimension2D); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageDimension3D
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageDimension3D\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageDimension3D); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageDimensionCube
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageDimensionCube\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageDimensionCube); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageArrayLayers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageArrayLayers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageArrayLayers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTexelBufferElements
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTexelBufferElements\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTexelBufferElements); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxUniformBufferRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxUniformBufferRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxUniformBufferRange); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxStorageBufferRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxStorageBufferRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxStorageBufferRange); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPushConstantsSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPushConstantsSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPushConstantsSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMemoryAllocationCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMemoryAllocationCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMemoryAllocationCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSamplerAllocationCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSamplerAllocationCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSamplerAllocationCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize bufferImageGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferImageGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->bufferImageGranularity); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize sparseAddressSpaceSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseAddressSpaceSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sparseAddressSpaceSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxBoundDescriptorSets
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxBoundDescriptorSets\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxBoundDescriptorSets); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorSamplers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorSamplers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorSamplers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUniformBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUniformBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUniformBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorStorageBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorStorageBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorStorageBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorSampledImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorSampledImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorSampledImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorStorageImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorStorageImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorStorageImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorInputAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorInputAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorInputAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageResources
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageResources\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageResources); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetSamplers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetSamplers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetSamplers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUniformBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUniformBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUniformBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUniformBuffersDynamic
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUniformBuffersDynamic\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUniformBuffersDynamic); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetStorageBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetStorageBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetStorageBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetStorageBuffersDynamic
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetStorageBuffersDynamic\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetStorageBuffersDynamic); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetSampledImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetSampledImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetSampledImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetStorageImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetStorageImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetStorageImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetInputAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetInputAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetInputAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVertexInputAttributes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVertexInputAttributes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVertexInputAttributes); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVertexInputBindings
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVertexInputBindings\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVertexInputBindings); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVertexInputAttributeOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVertexInputAttributeOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVertexInputAttributeOffset); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVertexInputBindingStride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVertexInputBindingStride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVertexInputBindingStride); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVertexOutputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVertexOutputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVertexOutputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationGenerationLevel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationGenerationLevel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationGenerationLevel); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationPatchSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationPatchSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationPatchSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationControlPerVertexInputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationControlPerVertexInputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationControlPerVertexInputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationControlPerVertexOutputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationControlPerVertexOutputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationControlPerVertexOutputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationControlPerPatchOutputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationControlPerPatchOutputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationControlPerPatchOutputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationControlTotalOutputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationControlTotalOutputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationControlTotalOutputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationEvaluationInputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationEvaluationInputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationEvaluationInputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTessellationEvaluationOutputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTessellationEvaluationOutputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTessellationEvaluationOutputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxGeometryShaderInvocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxGeometryShaderInvocations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxGeometryShaderInvocations); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxGeometryInputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxGeometryInputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxGeometryInputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxGeometryOutputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxGeometryOutputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxGeometryOutputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxGeometryOutputVertices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxGeometryOutputVertices\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxGeometryOutputVertices); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxGeometryTotalOutputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxGeometryTotalOutputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxGeometryTotalOutputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxFragmentInputComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFragmentInputComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxFragmentInputComponents); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxFragmentOutputAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFragmentOutputAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxFragmentOutputAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxFragmentDualSrcAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFragmentDualSrcAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxFragmentDualSrcAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxFragmentCombinedOutputResources
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFragmentCombinedOutputResources\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxFragmentCombinedOutputResources); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxComputeSharedMemorySize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxComputeSharedMemorySize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxComputeSharedMemorySize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxComputeWorkGroupCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "3"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxComputeWorkGroupCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupCount) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_maxComputeWorkGroupCount = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint32_t", &pstruct_in.maxComputeWorkGroupCount, "maxComputeWorkGroupCount", 3, vinfo_maxComputeWorkGroupCount); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxComputeWorkGroupInvocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxComputeWorkGroupInvocations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxComputeWorkGroupInvocations); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxComputeWorkGroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "3"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxComputeWorkGroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupSize) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_maxComputeWorkGroupSize = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint32_t", &pstruct_in.maxComputeWorkGroupSize, "maxComputeWorkGroupSize", 3, vinfo_maxComputeWorkGroupSize); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subPixelPrecisionBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subPixelPrecisionBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subPixelPrecisionBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subTexelPrecisionBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subTexelPrecisionBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subTexelPrecisionBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t mipmapPrecisionBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mipmapPrecisionBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->mipmapPrecisionBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDrawIndexedIndexValue
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDrawIndexedIndexValue\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDrawIndexedIndexValue); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDrawIndirectCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDrawIndirectCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDrawIndirectCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxSamplerLodBias
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSamplerLodBias\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxSamplerLodBias); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxSamplerAnisotropy
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSamplerAnisotropy\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxSamplerAnisotropy); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxViewports
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxViewports\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxViewports); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxViewportDimensions
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "2"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxViewportDimensions\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceLimits, maxViewportDimensions) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_maxViewportDimensions = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint32_t", &pstruct_in.maxViewportDimensions, "maxViewportDimensions", 2, vinfo_maxViewportDimensions); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float viewportBoundsRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "2"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewportBoundsRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceLimits, viewportBoundsRange) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_viewportBoundsRange = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "float", &pstruct_in.viewportBoundsRange, "viewportBoundsRange", 2, vinfo_viewportBoundsRange); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewportSubPixelBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewportSubPixelBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewportSubPixelBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t minMemoryMapAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minMemoryMapAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minMemoryMapAlignment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize minTexelBufferOffsetAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minTexelBufferOffsetAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->minTexelBufferOffsetAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize minUniformBufferOffsetAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minUniformBufferOffsetAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->minUniformBufferOffsetAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize minStorageBufferOffsetAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minStorageBufferOffsetAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->minStorageBufferOffsetAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t minTexelOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minTexelOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->minTexelOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTexelOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTexelOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTexelOffset); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t minTexelGatherOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minTexelGatherOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->minTexelGatherOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTexelGatherOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTexelGatherOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTexelGatherOffset); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float minInterpolationOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minInterpolationOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->minInterpolationOffset); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxInterpolationOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxInterpolationOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxInterpolationOffset); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subPixelInterpolationOffsetBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subPixelInterpolationOffsetBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subPixelInterpolationOffsetBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxFramebufferWidth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFramebufferWidth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxFramebufferWidth); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxFramebufferHeight
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFramebufferHeight\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxFramebufferHeight); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxFramebufferLayers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFramebufferLayers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxFramebufferLayers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags framebufferColorSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"framebufferColorSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->framebufferColorSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags framebufferDepthSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"framebufferDepthSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->framebufferDepthSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags framebufferStencilSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"framebufferStencilSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->framebufferStencilSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags framebufferNoAttachmentsSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"framebufferNoAttachmentsSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->framebufferNoAttachmentsSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxColorAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxColorAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxColorAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags sampledImageColorSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampledImageColorSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sampledImageColorSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags sampledImageIntegerSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampledImageIntegerSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sampledImageIntegerSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags sampledImageDepthSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampledImageDepthSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sampledImageDepthSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags sampledImageStencilSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampledImageStencilSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sampledImageStencilSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags storageImageSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storageImageSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->storageImageSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSampleMaskWords
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSampleMaskWords\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSampleMaskWords); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 timestampComputeAndGraphics
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"timestampComputeAndGraphics\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->timestampComputeAndGraphics); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float timestampPeriod
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"timestampPeriod\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->timestampPeriod); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxClipDistances
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxClipDistances\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxClipDistances); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxCullDistances
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxCullDistances\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxCullDistances); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxCombinedClipAndCullDistances
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxCombinedClipAndCullDistances\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxCombinedClipAndCullDistances); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t discreteQueuePriorities
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"discreteQueuePriorities\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->discreteQueuePriorities); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float pointSizeRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "2"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pointSizeRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceLimits, pointSizeRange) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_pointSizeRange = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "float", &pstruct_in.pointSizeRange, "pointSizeRange", 2, vinfo_pointSizeRange); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float lineWidthRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "2"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"lineWidthRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceLimits, lineWidthRange) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_lineWidthRange = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "float", &pstruct_in.lineWidthRange, "lineWidthRange", 2, vinfo_lineWidthRange); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float pointSizeGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pointSizeGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->pointSizeGranularity); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float lineWidthGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"lineWidthGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->lineWidthGranularity); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 strictLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"strictLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->strictLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 standardSampleLocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"standardSampleLocations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->standardSampleLocations); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize optimalBufferCopyOffsetAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"optimalBufferCopyOffsetAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->optimalBufferCopyOffsetAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize optimalBufferCopyRowPitchAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"optimalBufferCopyRowPitchAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->optimalBufferCopyRowPitchAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize nonCoherentAtomSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"nonCoherentAtomSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->nonCoherentAtomSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSparseProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkBool32 residencyStandard2DBlockShape
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"residencyStandard2DBlockShape\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->residencyStandard2DBlockShape); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 residencyStandard2DMultisampleBlockShape
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"residencyStandard2DMultisampleBlockShape\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->residencyStandard2DMultisampleBlockShape); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 residencyStandard3DBlockShape
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"residencyStandard3DBlockShape\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->residencyStandard3DBlockShape); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 residencyAlignedMipSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"residencyAlignedMipSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->residencyAlignedMipSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 residencyNonResidentStrict
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"residencyNonResidentStrict\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->residencyNonResidentStrict); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t apiVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"apiVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->apiVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t driverVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"driverVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->driverVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t vendorID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vendorID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vendorID); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceID); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPhysicalDeviceType deviceType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPhysicalDeviceType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPhysicalDeviceType(outputFile, pstruct->deviceType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char deviceName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceName\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_deviceName = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.deviceName.GetPointer(), "deviceName", VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, vinfo_deviceName); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint8_t pipelineCacheUUID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_UUID_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineCacheUUID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceProperties, pipelineCacheUUID) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_pipelineCacheUUID = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint8_t", &pstruct_in.pipelineCacheUUID, "pipelineCacheUUID", VK_UUID_SIZE, vinfo_pipelineCacheUUID); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPhysicalDeviceLimits limits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPhysicalDeviceLimits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"limits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.limits, indent,  base_addr + offsetof(VkPhysicalDeviceProperties, limits)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPhysicalDeviceSparseProperties sparseProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPhysicalDeviceSparseProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sparseProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.sparseProperties, indent,  base_addr + offsetof(VkPhysicalDeviceProperties, sparseProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkQueueFamilyProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueueFamilyProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkQueueFlags queueFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueueFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->queueFlags, OutputEnumVkQueueFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t timestampValidBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"timestampValidBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->timestampValidBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent3D minImageTransferGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minImageTransferGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minImageTransferGranularity, indent,  base_addr + offsetof(VkQueueFamilyProperties, minImageTransferGranularity)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryType &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryType *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkMemoryPropertyFlags propertyFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMemoryPropertyFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"propertyFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->propertyFlags, OutputEnumVkMemoryPropertyFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t heapIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"heapIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->heapIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryHeap &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryHeap *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMemoryHeapFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMemoryHeapFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkMemoryHeapFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t memoryTypeCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypeCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryTypeCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMemoryType memoryTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMemoryType"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_MEMORY_TYPES"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceMemoryProperties, memoryTypes) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRZ
    OutputArrayOfStructsJson(outputFile, indent, "VkMemoryType", pstruct_in.memoryTypes->GetMetaStructPointer(), "memoryTypes", pstruct->memoryTypeCount, false, pstruct_in.memoryTypes->GetAddress(), sizeof(VkMemoryType)); // CCY
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryHeapCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryHeapCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryHeapCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMemoryHeap memoryHeaps
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMemoryHeap"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_MEMORY_HEAPS"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryHeaps\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceMemoryProperties, memoryHeaps) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRZ
    OutputArrayOfStructsJson(outputFile, indent, "VkMemoryHeap", pstruct_in.memoryHeaps->GetMetaStructPointer(), "memoryHeaps", pstruct->memoryHeapCount, false, pstruct_in.memoryHeaps->GetAddress(), sizeof(VkMemoryHeap)); // CCY
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceQueueCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceQueueCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceQueueCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceQueueCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkDeviceQueueCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueFamilyIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueFamilyIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const float* pQueuePriorities
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const float*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pQueuePriorities\",\n");
    if (pstruct->pQueuePriorities == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pQueuePriorities.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pQueuePriorities = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const float*", &pstruct_in.pQueuePriorities, "pQueuePriorities", pstruct->queueCount, vinfo_pQueuePriorities); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueCreateInfoCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueCreateInfoCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueCreateInfoCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDeviceQueueCreateInfo* pQueueCreateInfos
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDeviceQueueCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pQueueCreateInfos\",\n");
    if (pstruct->pQueueCreateInfos == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pQueueCreateInfos->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDeviceQueueCreateInfo", pstruct_in.pQueueCreateInfos->GetMetaStructPointer(), "pQueueCreateInfos", pstruct->queueCreateInfoCount, false, pstruct_in.pQueueCreateInfos->GetAddress(), sizeof(VkDeviceQueueCreateInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t enabledLayerCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"enabledLayerCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->enabledLayerCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* const* ppEnabledLayerNames
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char* const*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ppEnabledLayerNames\",\n");
    if (pstruct->ppEnabledLayerNames == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.ppEnabledLayerNames.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRG
        OutputScalarValueStructInfo vinfo_ppEnabledLayerNames = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const char* const*", &pstruct_in.ppEnabledLayerNames, "ppEnabledLayerNames", pstruct->enabledLayerCount, vinfo_ppEnabledLayerNames); // UQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t enabledExtensionCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"enabledExtensionCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->enabledExtensionCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* const* ppEnabledExtensionNames
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char* const*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ppEnabledExtensionNames\",\n");
    if (pstruct->ppEnabledExtensionNames == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.ppEnabledExtensionNames.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRG
        OutputScalarValueStructInfo vinfo_ppEnabledExtensionNames = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const char* const*", &pstruct_in.ppEnabledExtensionNames, "ppEnabledExtensionNames", pstruct->enabledExtensionCount, vinfo_ppEnabledExtensionNames); // UQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPhysicalDeviceFeatures* pEnabledFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPhysicalDeviceFeatures*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pEnabledFeatures\",\n");
    if (pstruct->pEnabledFeatures == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pEnabledFeatures->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pEnabledFeatures->GetMetaStructPointer(), indent,  base_addr + offsetof(VkDeviceCreateInfo, pEnabledFeatures)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExtensionProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExtensionProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: char extensionName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_EXTENSION_NAME_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extensionName\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_extensionName = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.extensionName.GetPointer(), "extensionName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_extensionName); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t specVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"specVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->specVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkLayerProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkLayerProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: char layerName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_EXTENSION_NAME_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layerName\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_layerName = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.layerName.GetPointer(), "layerName", VK_MAX_EXTENSION_NAME_SIZE, vinfo_layerName); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t specVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"specVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->specVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t implementationVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"implementationVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->implementationVersion); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char description
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DESCRIPTION_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"description\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_description = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.description.GetPointer(), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubmitInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubmitInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t waitSemaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"waitSemaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSemaphore* pWaitSemaphores
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSemaphore*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pWaitSemaphores\",\n");
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pWaitSemaphores.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pWaitSemaphores = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSemaphore*", &pstruct_in.pWaitSemaphores, "pWaitSemaphores", pstruct->waitSemaphoreCount, vinfo_pWaitSemaphores); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineStageFlags* pWaitDstStageMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineStageFlags*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pWaitDstStageMask\",\n");
    if (pstruct->pWaitDstStageMask == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pWaitDstStageMask.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pWaitDstStageMask = {false, false, true, OutputEnumVkPipelineStageFlagBits};
        OutputArrayJson(outputFile, indent, "const VkPipelineStageFlags*", &pstruct_in.pWaitDstStageMask, "pWaitDstStageMask", pstruct->waitSemaphoreCount, vinfo_pWaitDstStageMask); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t commandBufferCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"commandBufferCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->commandBufferCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkCommandBuffer* pCommandBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkCommandBuffer*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCommandBuffers\",\n");
    if (pstruct->pCommandBuffers == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCommandBuffers.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pCommandBuffers = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkCommandBuffer*", &pstruct_in.pCommandBuffers, "pCommandBuffers", pstruct->commandBufferCount, vinfo_pCommandBuffers); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t signalSemaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"signalSemaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->signalSemaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSemaphore* pSignalSemaphores
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSemaphore*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSignalSemaphores\",\n");
    if (pstruct->pSignalSemaphores == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSignalSemaphores.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pSignalSemaphores = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSemaphore*", &pstruct_in.pSignalSemaphores, "pSignalSemaphores", pstruct->signalSemaphoreCount, vinfo_pSignalSemaphores); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize allocationSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"allocationSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->allocationSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryTypeIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypeIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryTypeIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMappedMemoryRange &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMappedMemoryRange *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryRequirements &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryRequirements *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize alignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"alignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->alignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryTypeBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypeBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryTypeBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageAspectFlags aspectMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->aspectMask, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent3D imageGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageGranularity, indent,  base_addr + offsetof(VkSparseImageFormatProperties, imageGranularity)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSparseImageFormatFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSparseImageFormatFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSparseImageFormatFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryRequirements *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkSparseImageFormatProperties formatProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSparseImageFormatProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"formatProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.formatProperties, indent,  base_addr + offsetof(VkSparseImageMemoryRequirements, formatProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t imageMipTailFirstLod
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageMipTailFirstLod\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->imageMipTailFirstLod); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize imageMipTailSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageMipTailSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->imageMipTailSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize imageMipTailOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageMipTailOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->imageMipTailOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize imageMipTailStride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageMipTailStride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->imageMipTailStride); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseMemoryBind &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseMemoryBind *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDeviceSize resourceOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"resourceOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->resourceOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize memoryOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->memoryOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSparseMemoryBindFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSparseMemoryBindFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSparseMemoryBindFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseBufferMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseBufferMemoryBindInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bindCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bindCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bindCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSparseMemoryBind* pBinds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSparseMemoryBind*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pBinds\",\n");
    if (pstruct->pBinds == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pBinds->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress(), sizeof(VkSparseMemoryBind)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageOpaqueMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageOpaqueMemoryBindInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bindCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bindCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bindCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSparseMemoryBind* pBinds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSparseMemoryBind*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pBinds\",\n");
    if (pstruct->pBinds == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pBinds->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSparseMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress(), sizeof(VkSparseMemoryBind)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSubresource &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSubresource *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageAspectFlags aspectMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->aspectMask, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t mipLevel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mipLevel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->mipLevel); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t arrayLayer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"arrayLayer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->arrayLayer); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkOffset3D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkOffset3D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: int32_t x
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"x\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->x); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t y
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"y\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->y); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t z
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"z\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->z); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryBind &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryBind *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageSubresource subresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresource"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.subresource, indent,  base_addr + offsetof(VkSparseImageMemoryBind, subresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.offset, indent,  base_addr + offsetof(VkSparseImageMemoryBind, offset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent3D extent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.extent, indent,  base_addr + offsetof(VkSparseImageMemoryBind, extent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize memoryOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->memoryOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSparseMemoryBindFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSparseMemoryBindFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSparseMemoryBindFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryBindInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryBindInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bindCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bindCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bindCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSparseImageMemoryBind* pBinds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSparseImageMemoryBind*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pBinds\",\n");
    if (pstruct->pBinds == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pBinds->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSparseImageMemoryBind", pstruct_in.pBinds->GetMetaStructPointer(), "pBinds", pstruct->bindCount, false, pstruct_in.pBinds->GetAddress(), sizeof(VkSparseImageMemoryBind)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindSparseInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindSparseInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t waitSemaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"waitSemaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSemaphore* pWaitSemaphores
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSemaphore*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pWaitSemaphores\",\n");
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pWaitSemaphores.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pWaitSemaphores = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSemaphore*", &pstruct_in.pWaitSemaphores, "pWaitSemaphores", pstruct->waitSemaphoreCount, vinfo_pWaitSemaphores); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bufferBindCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferBindCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bufferBindCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSparseBufferMemoryBindInfo* pBufferBinds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSparseBufferMemoryBindInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pBufferBinds\",\n");
    if (pstruct->pBufferBinds == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pBufferBinds->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSparseBufferMemoryBindInfo", pstruct_in.pBufferBinds->GetMetaStructPointer(), "pBufferBinds", pstruct->bufferBindCount, false, pstruct_in.pBufferBinds->GetAddress(), sizeof(VkSparseBufferMemoryBindInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t imageOpaqueBindCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageOpaqueBindCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->imageOpaqueBindCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSparseImageOpaqueMemoryBindInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pImageOpaqueBinds\",\n");
    if (pstruct->pImageOpaqueBinds == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pImageOpaqueBinds->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSparseImageOpaqueMemoryBindInfo", pstruct_in.pImageOpaqueBinds->GetMetaStructPointer(), "pImageOpaqueBinds", pstruct->imageOpaqueBindCount, false, pstruct_in.pImageOpaqueBinds->GetAddress(), sizeof(VkSparseImageOpaqueMemoryBindInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t imageBindCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageBindCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->imageBindCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSparseImageMemoryBindInfo* pImageBinds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSparseImageMemoryBindInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pImageBinds\",\n");
    if (pstruct->pImageBinds == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pImageBinds->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSparseImageMemoryBindInfo", pstruct_in.pImageBinds->GetMetaStructPointer(), "pImageBinds", pstruct->imageBindCount, false, pstruct_in.pImageBinds->GetAddress(), sizeof(VkSparseImageMemoryBindInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t signalSemaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"signalSemaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->signalSemaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSemaphore* pSignalSemaphores
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSemaphore*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSignalSemaphores\",\n");
    if (pstruct->pSignalSemaphores == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSignalSemaphores.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pSignalSemaphores = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSemaphore*", &pstruct_in.pSignalSemaphores, "pSignalSemaphores", pstruct->signalSemaphoreCount, vinfo_pSignalSemaphores); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFenceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFenceCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFenceCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkFenceCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphoreCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphoreCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkEventCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkEventCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkEventCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkEventCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkQueryPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueryPoolCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueryPoolCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueryPoolCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueryType queryType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueryType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queryType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkQueryType(outputFile, pstruct->queryType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queryCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queryCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queryCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueryPipelineStatisticFlags pipelineStatistics
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueryPipelineStatisticFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineStatistics\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->pipelineStatistics, OutputEnumVkQueryPipelineStatisticFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBufferCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBufferCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkBufferCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBufferUsageFlags usage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBufferUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"usage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->usage, OutputEnumVkBufferUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSharingMode sharingMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSharingMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sharingMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSharingMode(outputFile, pstruct->sharingMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueFamilyIndexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyIndexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pQueueFamilyIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pQueueFamilyIndices\",\n");
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pQueueFamilyIndices, "pQueueFamilyIndices", pstruct->queueFamilyIndexCount, vinfo_pQueueFamilyIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferViewCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferViewCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBufferViewCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBufferViewCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize range
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"range\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->range); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkImageCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageType imageType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageType(outputFile, pstruct->imageType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent3D extent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.extent, indent,  base_addr + offsetof(VkImageCreateInfo, extent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t mipLevels
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mipLevels\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->mipLevels); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t arrayLayers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"arrayLayers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->arrayLayers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlagBits samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->samples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageTiling tiling
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageTiling"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tiling\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageTiling(outputFile, pstruct->tiling); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags usage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"usage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->usage, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSharingMode sharingMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSharingMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sharingMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSharingMode(outputFile, pstruct->sharingMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueFamilyIndexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyIndexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pQueueFamilyIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pQueueFamilyIndices\",\n");
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pQueueFamilyIndices, "pQueueFamilyIndices", pstruct->queueFamilyIndexCount, vinfo_pQueueFamilyIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout initialLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"initialLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->initialLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubresourceLayout &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubresourceLayout *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize rowPitch
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rowPitch\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->rowPitch); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize arrayPitch
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"arrayPitch\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->arrayPitch); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize depthPitch
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthPitch\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthPitch); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkComponentMapping &pstruct_in, int indent, uint64_t base_addr)
{
    const VkComponentMapping *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkComponentSwizzle r
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentSwizzle"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"r\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentSwizzle(outputFile, pstruct->r); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentSwizzle g
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentSwizzle"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"g\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentSwizzle(outputFile, pstruct->g); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentSwizzle b
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentSwizzle"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"b\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentSwizzle(outputFile, pstruct->b); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentSwizzle a
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentSwizzle"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"a\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentSwizzle(outputFile, pstruct->a); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSubresourceRange &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSubresourceRange *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageAspectFlags aspectMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->aspectMask, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t baseMipLevel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"baseMipLevel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->baseMipLevel); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t levelCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"levelCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->levelCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t baseArrayLayer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"baseArrayLayer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->baseArrayLayer); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t layerCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layerCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->layerCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageViewCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageViewCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkImageViewCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageViewType viewType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageViewType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageViewType(outputFile, pstruct->viewType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentMapping components
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentMapping"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"components\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.components, indent,  base_addr + offsetof(VkImageViewCreateInfo, components)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageSubresourceRange subresourceRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceRange"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subresourceRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.subresourceRange, indent,  base_addr + offsetof(VkImageViewCreateInfo, subresourceRange)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderModuleCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderModuleCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderModuleCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderModuleCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkShaderModuleCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t codeSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"codeSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->codeSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pCode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCode\",\n");
    if (pstruct->pCode == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCode.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        if (kPrintShaderCode)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"elements\" :");
            OutputScalarValueStructInfo vinfo_pCode = {false, false, false, nullptr};
            OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pCode, "pCode", pstruct->codeSize / 4, vinfo_pCode); // AUX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCacheCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCacheCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCacheCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCacheCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t initialDataSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"initialDataSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->initialDataSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pInitialData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pInitialData\",\n");
    if (pstruct->pInitialData == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pInitialData.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pInitialData = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const void*", &pstruct_in.pInitialData, "pInitialData", pstruct->initialDataSize, vinfo_pInitialData); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSpecializationMapEntry &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSpecializationMapEntry *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t constantID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"constantID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->constantID); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->offset); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->size); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSpecializationInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSpecializationInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t mapEntryCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mapEntryCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->mapEntryCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSpecializationMapEntry* pMapEntries
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSpecializationMapEntry*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pMapEntries\",\n");
    if (pstruct->pMapEntries == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pMapEntries->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSpecializationMapEntry", pstruct_in.pMapEntries->GetMetaStructPointer(), "pMapEntries", pstruct->mapEntryCount, false, pstruct_in.pMapEntries->GetAddress(), sizeof(VkSpecializationMapEntry)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t dataSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dataSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dataSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pData\",\n");
    if (pstruct->pData == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pData.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pData = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const void*", &pstruct_in.pData, "pData", pstruct->dataSize, vinfo_pData); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineShaderStageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineShaderStageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineShaderStageCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineShaderStageCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkPipelineShaderStageCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderStageFlagBits stage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stage, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderModule module
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderModule"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"module\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.module); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pName\",\n");
    if (pstruct->pName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSpecializationInfo* pSpecializationInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSpecializationInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSpecializationInfo\",\n");
    if (pstruct->pSpecializationInfo == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSpecializationInfo->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pSpecializationInfo->GetMetaStructPointer(), indent,  base_addr + offsetof(VkPipelineShaderStageCreateInfo, pSpecializationInfo)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkVertexInputBindingDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkVertexInputBindingDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t binding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"binding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->binding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t stride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->stride); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkVertexInputRate inputRate
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkVertexInputRate"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"inputRate\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkVertexInputRate(outputFile, pstruct->inputRate); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkVertexInputAttributeDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkVertexInputAttributeDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t location
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"location\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->location); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t binding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"binding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->binding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->offset); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineVertexInputStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineVertexInputStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineVertexInputStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineVertexInputStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t vertexBindingDescriptionCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexBindingDescriptionCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vertexBindingDescriptionCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkVertexInputBindingDescription* pVertexBindingDescriptions
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkVertexInputBindingDescription*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pVertexBindingDescriptions\",\n");
    if (pstruct->pVertexBindingDescriptions == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pVertexBindingDescriptions->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkVertexInputBindingDescription", pstruct_in.pVertexBindingDescriptions->GetMetaStructPointer(), "pVertexBindingDescriptions", pstruct->vertexBindingDescriptionCount, false, pstruct_in.pVertexBindingDescriptions->GetAddress(), sizeof(VkVertexInputBindingDescription)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t vertexAttributeDescriptionCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexAttributeDescriptionCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vertexAttributeDescriptionCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkVertexInputAttributeDescription* pVertexAttributeDescriptions
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkVertexInputAttributeDescription*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pVertexAttributeDescriptions\",\n");
    if (pstruct->pVertexAttributeDescriptions == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pVertexAttributeDescriptions->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkVertexInputAttributeDescription", pstruct_in.pVertexAttributeDescriptions->GetMetaStructPointer(), "pVertexAttributeDescriptions", pstruct->vertexAttributeDescriptionCount, false, pstruct_in.pVertexAttributeDescriptions->GetAddress(), sizeof(VkVertexInputAttributeDescription)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineInputAssemblyStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineInputAssemblyStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineInputAssemblyStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineInputAssemblyStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPrimitiveTopology topology
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPrimitiveTopology"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"topology\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPrimitiveTopology(outputFile, pstruct->topology); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 primitiveRestartEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"primitiveRestartEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->primitiveRestartEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineTessellationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineTessellationStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineTessellationStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineTessellationStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t patchControlPoints
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"patchControlPoints\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->patchControlPoints); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkViewport &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViewport *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: float x
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"x\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->x); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float y
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"y\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->y); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float width
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"width\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->width); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float height
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"height\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->height); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float minDepth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minDepth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->minDepth); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxDepth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDepth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxDepth); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkOffset2D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkOffset2D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: int32_t x
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"x\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->x); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t y
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"y\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->y); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExtent2D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExtent2D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t width
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"width\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->width); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t height
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"height\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->height); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRect2D &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRect2D *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkOffset2D offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.offset, indent,  base_addr + offsetof(VkRect2D, offset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D extent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.extent, indent,  base_addr + offsetof(VkRect2D, extent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineViewportStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineViewportStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewportCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewportCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewportCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkViewport* pViewports
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkViewport*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewports\",\n");
    if (pstruct->pViewports == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewports->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkViewport", pstruct_in.pViewports->GetMetaStructPointer(), "pViewports", pstruct->viewportCount, false, pstruct_in.pViewports->GetAddress(), sizeof(VkViewport)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t scissorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"scissorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->scissorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkRect2D* pScissors
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkRect2D*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pScissors\",\n");
    if (pstruct->pScissors == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pScissors->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkRect2D", pstruct_in.pScissors->GetMetaStructPointer(), "pScissors", pstruct->scissorCount, false, pstruct_in.pScissors->GetAddress(), sizeof(VkRect2D)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineRasterizationStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineRasterizationStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthClampEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthClampEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthClampEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 rasterizerDiscardEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rasterizerDiscardEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->rasterizerDiscardEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPolygonMode polygonMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPolygonMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"polygonMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPolygonMode(outputFile, pstruct->polygonMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCullModeFlags cullMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCullModeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"cullMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->cullMode, OutputEnumVkCullModeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFrontFace frontFace
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFrontFace"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"frontFace\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFrontFace(outputFile, pstruct->frontFace); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthBiasEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthBiasEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthBiasEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float depthBiasConstantFactor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthBiasConstantFactor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->depthBiasConstantFactor); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float depthBiasClamp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthBiasClamp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->depthBiasClamp); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float depthBiasSlopeFactor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthBiasSlopeFactor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->depthBiasSlopeFactor); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float lineWidth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"lineWidth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->lineWidth); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineMultisampleStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineMultisampleStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineMultisampleStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineMultisampleStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlagBits rasterizationSamples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rasterizationSamples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->rasterizationSamples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sampleShadingEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleShadingEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sampleShadingEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float minSampleShading
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minSampleShading\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->minSampleShading); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSampleMask* pSampleMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSampleMask*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSampleMask\",\n");
    if (pstruct->pSampleMask == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSampleMask.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pSampleMask = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSampleMask*", &pstruct_in.pSampleMask, "pSampleMask", pstruct->rasterizationSamples, vinfo_pSampleMask); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 alphaToCoverageEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"alphaToCoverageEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->alphaToCoverageEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 alphaToOneEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"alphaToOneEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->alphaToOneEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkStencilOpState &pstruct_in, int indent, uint64_t base_addr)
{
    const VkStencilOpState *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStencilOp failOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStencilOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"failOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStencilOp(outputFile, pstruct->failOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkStencilOp passOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStencilOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"passOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStencilOp(outputFile, pstruct->passOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkStencilOp depthFailOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStencilOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthFailOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStencilOp(outputFile, pstruct->depthFailOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCompareOp compareOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCompareOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compareOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCompareOp(outputFile, pstruct->compareOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t compareMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compareMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->compareMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t writeMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"writeMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->writeMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t reference
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"reference\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->reference); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineDepthStencilStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineDepthStencilStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineDepthStencilStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineDepthStencilStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthTestEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthTestEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthTestEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthWriteEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthWriteEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthWriteEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCompareOp depthCompareOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCompareOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthCompareOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCompareOp(outputFile, pstruct->depthCompareOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthBoundsTestEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthBoundsTestEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthBoundsTestEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 stencilTestEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencilTestEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->stencilTestEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkStencilOpState front
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStencilOpState"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"front\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.front, indent,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, front)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkStencilOpState back
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStencilOpState"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"back\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.back, indent,  base_addr + offsetof(VkPipelineDepthStencilStateCreateInfo, back)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float minDepthBounds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minDepthBounds\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->minDepthBounds); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxDepthBounds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDepthBounds\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxDepthBounds); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineColorBlendAttachmentState &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineColorBlendAttachmentState *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkBool32 blendEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"blendEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->blendEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBlendFactor srcColorBlendFactor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBlendFactor"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcColorBlendFactor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBlendFactor(outputFile, pstruct->srcColorBlendFactor); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBlendFactor dstColorBlendFactor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBlendFactor"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstColorBlendFactor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBlendFactor(outputFile, pstruct->dstColorBlendFactor); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBlendOp colorBlendOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBlendOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"colorBlendOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBlendOp(outputFile, pstruct->colorBlendOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBlendFactor srcAlphaBlendFactor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBlendFactor"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcAlphaBlendFactor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBlendFactor(outputFile, pstruct->srcAlphaBlendFactor); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBlendFactor dstAlphaBlendFactor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBlendFactor"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstAlphaBlendFactor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBlendFactor(outputFile, pstruct->dstAlphaBlendFactor); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBlendOp alphaBlendOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBlendOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"alphaBlendOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBlendOp(outputFile, pstruct->alphaBlendOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkColorComponentFlags colorWriteMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkColorComponentFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"colorWriteMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->colorWriteMask, OutputEnumVkColorComponentFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineColorBlendStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineColorBlendStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineColorBlendStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineColorBlendStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 logicOpEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"logicOpEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->logicOpEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkLogicOp logicOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkLogicOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"logicOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkLogicOp(outputFile, pstruct->logicOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineColorBlendAttachmentState* pAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineColorBlendAttachmentState*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttachments\",\n");
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkPipelineColorBlendAttachmentState", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress(), sizeof(VkPipelineColorBlendAttachmentState)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float blendConstants
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "4"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"blendConstants\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPipelineColorBlendStateCreateInfo, blendConstants) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_blendConstants = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "float", &pstruct_in.blendConstants, "blendConstants", 4, vinfo_blendConstants); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineDynamicStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineDynamicStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineDynamicStateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineDynamicStateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dynamicStateCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dynamicStateCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dynamicStateCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDynamicState* pDynamicStates
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDynamicState*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDynamicStates\",\n");
    if (pstruct->pDynamicStates == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDynamicStates.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDynamicStates = {false, true, false, OutputEnumVkDynamicState};
        OutputArrayJson(outputFile, indent, "const VkDynamicState*", &pstruct_in.pDynamicStates, "pDynamicStates", pstruct->dynamicStateCount, vinfo_pDynamicStates); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkGraphicsPipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGraphicsPipelineCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkPipelineCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t stageCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stageCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->stageCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineShaderStageCreateInfo* pStages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineShaderStageCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pStages\",\n");
    if (pstruct->pStages == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pStages->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress(), sizeof(VkPipelineShaderStageCreateInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineVertexInputStateCreateInfo* pVertexInputState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineVertexInputStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pVertexInputState\",\n");
    if (pstruct->pVertexInputState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pVertexInputState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pVertexInputState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pVertexInputState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineInputAssemblyStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pInputAssemblyState\",\n");
    if (pstruct->pInputAssemblyState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pInputAssemblyState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pInputAssemblyState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pInputAssemblyState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineTessellationStateCreateInfo* pTessellationState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineTessellationStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pTessellationState\",\n");
    if (pstruct->pTessellationState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pTessellationState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pTessellationState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pTessellationState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineViewportStateCreateInfo* pViewportState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineViewportStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewportState\",\n");
    if (pstruct->pViewportState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewportState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pViewportState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pViewportState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineRasterizationStateCreateInfo* pRasterizationState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineRasterizationStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pRasterizationState\",\n");
    if (pstruct->pRasterizationState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pRasterizationState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pRasterizationState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pRasterizationState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineMultisampleStateCreateInfo* pMultisampleState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineMultisampleStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pMultisampleState\",\n");
    if (pstruct->pMultisampleState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pMultisampleState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pMultisampleState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pMultisampleState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineDepthStencilStateCreateInfo* pDepthStencilState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineDepthStencilStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDepthStencilState\",\n");
    if (pstruct->pDepthStencilState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDepthStencilState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pDepthStencilState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDepthStencilState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineColorBlendStateCreateInfo* pColorBlendState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineColorBlendStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pColorBlendState\",\n");
    if (pstruct->pColorBlendState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pColorBlendState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pColorBlendState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pColorBlendState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineDynamicStateCreateInfo* pDynamicState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineDynamicStateCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDynamicState\",\n");
    if (pstruct->pDynamicState == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDynamicState->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pDynamicState->GetMetaStructPointer(), indent,  base_addr + offsetof(VkGraphicsPipelineCreateInfo, pDynamicState)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineLayout layout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.layout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRenderPass renderPass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRenderPass"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"renderPass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.renderPass); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subpass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subpass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subpass); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipeline basePipelineHandle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipeline"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"basePipelineHandle\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.basePipelineHandle); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t basePipelineIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"basePipelineIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->basePipelineIndex); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkComputePipelineCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkComputePipelineCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkPipelineCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineShaderStageCreateInfo stage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineShaderStageCreateInfo"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.stage, indent,  base_addr + offsetof(VkComputePipelineCreateInfo, stage)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineLayout layout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.layout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipeline basePipelineHandle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipeline"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"basePipelineHandle\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.basePipelineHandle); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t basePipelineIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"basePipelineIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->basePipelineIndex); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPushConstantRange &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPushConstantRange *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkShaderStageFlags stageFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stageFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stageFlags, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->offset); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->size); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineLayoutCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineLayoutCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineLayoutCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t setLayoutCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"setLayoutCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->setLayoutCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorSetLayout* pSetLayouts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorSetLayout*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSetLayouts\",\n");
    if (pstruct->pSetLayouts == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSetLayouts.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pSetLayouts = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkDescriptorSetLayout*", &pstruct_in.pSetLayouts, "pSetLayouts", pstruct->setLayoutCount, vinfo_pSetLayouts); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t pushConstantRangeCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pushConstantRangeCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pushConstantRangeCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPushConstantRange* pPushConstantRanges
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPushConstantRange*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPushConstantRanges\",\n");
    if (pstruct->pPushConstantRanges == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPushConstantRanges->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkPushConstantRange", pstruct_in.pPushConstantRanges->GetMetaStructPointer(), "pPushConstantRanges", pstruct->pushConstantRangeCount, false, pstruct_in.pPushConstantRanges->GetAddress(), sizeof(VkPushConstantRange)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSamplerCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFilter magFilter
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFilter"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"magFilter\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFilter(outputFile, pstruct->magFilter); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFilter minFilter
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFilter"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minFilter\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFilter(outputFile, pstruct->minFilter); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerMipmapMode mipmapMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerMipmapMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mipmapMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerMipmapMode(outputFile, pstruct->mipmapMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerAddressMode addressModeU
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerAddressMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"addressModeU\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerAddressMode(outputFile, pstruct->addressModeU); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerAddressMode addressModeV
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerAddressMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"addressModeV\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerAddressMode(outputFile, pstruct->addressModeV); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerAddressMode addressModeW
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerAddressMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"addressModeW\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerAddressMode(outputFile, pstruct->addressModeW); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float mipLodBias
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mipLodBias\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->mipLodBias); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 anisotropyEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"anisotropyEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->anisotropyEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxAnisotropy
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxAnisotropy\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxAnisotropy); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 compareEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compareEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->compareEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCompareOp compareOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCompareOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compareOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCompareOp(outputFile, pstruct->compareOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float minLod
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minLod\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->minLod); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxLod
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxLod\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxLod); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBorderColor borderColor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBorderColor"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"borderColor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBorderColor(outputFile, pstruct->borderColor); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 unnormalizedCoordinates
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"unnormalizedCoordinates\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->unnormalizedCoordinates); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBinding &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutBinding *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t binding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"binding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->binding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorType descriptorType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDescriptorType(outputFile, pstruct->descriptorType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderStageFlags stageFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stageFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stageFlags, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSampler* pImmutableSamplers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSampler*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pImmutableSamplers\",\n");
    if (pstruct->pImmutableSamplers == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pImmutableSamplers.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pImmutableSamplers = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSampler*", &pstruct_in.pImmutableSamplers, "pImmutableSamplers", pstruct->descriptorCount, vinfo_pImmutableSamplers); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorSetLayoutCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorSetLayoutCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkDescriptorSetLayoutCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bindingCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bindingCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bindingCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorSetLayoutBinding* pBindings
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorSetLayoutBinding*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pBindings\",\n");
    if (pstruct->pBindings == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pBindings->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDescriptorSetLayoutBinding", pstruct_in.pBindings->GetMetaStructPointer(), "pBindings", pstruct->bindingCount, false, pstruct_in.pBindings->GetAddress(), sizeof(VkDescriptorSetLayoutBinding)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorPoolSize &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorPoolSize *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDescriptorType type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDescriptorType(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorPoolCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorPoolCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorPoolCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkDescriptorPoolCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSets
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSets\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSets); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t poolSizeCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"poolSizeCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->poolSizeCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorPoolSize* pPoolSizes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorPoolSize*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPoolSizes\",\n");
    if (pstruct->pPoolSizes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPoolSizes->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDescriptorPoolSize", pstruct_in.pPoolSizes->GetMetaStructPointer(), "pPoolSizes", pstruct->poolSizeCount, false, pstruct_in.pPoolSizes->GetAddress(), sizeof(VkDescriptorPoolSize)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorPool descriptorPool
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorPool"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorPool\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.descriptorPool); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorSetCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorSetCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorSetCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorSetLayout* pSetLayouts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorSetLayout*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSetLayouts\",\n");
    if (pstruct->pSetLayouts == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSetLayouts.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pSetLayouts = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkDescriptorSetLayout*", &pstruct_in.pSetLayouts, "pSetLayouts", pstruct->descriptorSetCount, vinfo_pSetLayouts); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorImageInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorImageInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkSampler sampler
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampler"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampler\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.sampler); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageView imageView
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageView"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageView\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.imageView); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout imageLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->imageLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorBufferInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorBufferInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize range
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"range\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->range); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkWriteDescriptorSet &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWriteDescriptorSet *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorSet dstSet
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorSet"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstSet\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.dstSet); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstBinding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstBinding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstBinding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstArrayElement
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstArrayElement\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstArrayElement); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorType descriptorType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDescriptorType(outputFile, pstruct->descriptorType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorImageInfo* pImageInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorImageInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pImageInfo\",\n");
    if (pstruct->pImageInfo == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pImageInfo->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDescriptorImageInfo", pstruct_in.pImageInfo->GetMetaStructPointer(), "pImageInfo", pstruct->descriptorCount, false, pstruct_in.pImageInfo->GetAddress(), sizeof(VkDescriptorImageInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorBufferInfo* pBufferInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorBufferInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pBufferInfo\",\n");
    if (pstruct->pBufferInfo == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pBufferInfo->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDescriptorBufferInfo", pstruct_in.pBufferInfo->GetMetaStructPointer(), "pBufferInfo", pstruct->descriptorCount, false, pstruct_in.pBufferInfo->GetAddress(), sizeof(VkDescriptorBufferInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkBufferView* pTexelBufferView
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkBufferView*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pTexelBufferView\",\n");
    if (pstruct->pTexelBufferView == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pTexelBufferView.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pTexelBufferView = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkBufferView*", &pstruct_in.pTexelBufferView, "pTexelBufferView", pstruct->descriptorCount, vinfo_pTexelBufferView); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCopyDescriptorSet &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCopyDescriptorSet *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorSet srcSet
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorSet"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcSet\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.srcSet); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t srcBinding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcBinding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->srcBinding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t srcArrayElement
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcArrayElement\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->srcArrayElement); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorSet dstSet
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorSet"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstSet\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.dstSet); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstBinding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstBinding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstBinding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstArrayElement
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstArrayElement\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstArrayElement); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFramebufferCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFramebufferCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkFramebufferCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRenderPass renderPass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRenderPass"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"renderPass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.renderPass); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkImageView* pAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkImageView*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttachments\",\n");
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttachments.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pAttachments = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkImageView*", &pstruct_in.pAttachments, "pAttachments", pstruct->attachmentCount, vinfo_pAttachments); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t width
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"width\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->width); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t height
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"height\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->height); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t layers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->layers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkAttachmentDescriptionFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentDescriptionFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkAttachmentDescriptionFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlagBits samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->samples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentLoadOp loadOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentLoadOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"loadOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentLoadOp(outputFile, pstruct->loadOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentStoreOp storeOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentStoreOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storeOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentStoreOp(outputFile, pstruct->storeOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentLoadOp stencilLoadOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentLoadOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencilLoadOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentLoadOp(outputFile, pstruct->stencilLoadOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentStoreOp stencilStoreOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentStoreOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencilStoreOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentStoreOp(outputFile, pstruct->stencilStoreOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout initialLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"initialLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->initialLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout finalLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"finalLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->finalLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentReference &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentReference *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t attachment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout layout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->layout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDescription &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDescription *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkSubpassDescriptionFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSubpassDescriptionFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSubpassDescriptionFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineBindPoint pipelineBindPoint
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineBindPoint"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineBindPoint\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t inputAttachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"inputAttachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->inputAttachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference* pInputAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pInputAttachments\",\n");
    if (pstruct->pInputAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pInputAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentReference", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress(), sizeof(VkAttachmentReference)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t colorAttachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"colorAttachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->colorAttachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference* pColorAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pColorAttachments\",\n");
    if (pstruct->pColorAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pColorAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentReference", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress(), sizeof(VkAttachmentReference)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference* pResolveAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pResolveAttachments\",\n");
    if (pstruct->pResolveAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pResolveAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentReference", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress(), sizeof(VkAttachmentReference)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference* pDepthStencilAttachment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDepthStencilAttachment\",\n");
    if (pstruct->pDepthStencilAttachment == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDepthStencilAttachment->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent,  base_addr + offsetof(VkSubpassDescription, pDepthStencilAttachment)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t preserveAttachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"preserveAttachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->preserveAttachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pPreserveAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPreserveAttachments\",\n");
    if (pstruct->pPreserveAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPreserveAttachments.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pPreserveAttachments = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pPreserveAttachments, "pPreserveAttachments", pstruct->preserveAttachmentCount, vinfo_pPreserveAttachments); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDependency &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDependency *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t srcSubpass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcSubpass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->srcSubpass); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstSubpass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstSubpass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstSubpass); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineStageFlags srcStageMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcStageMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->srcStageMask, OutputEnumVkPipelineStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineStageFlags dstStageMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstStageMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dstStageMask, OutputEnumVkPipelineStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags srcAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->srcAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags dstAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dstAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDependencyFlags dependencyFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDependencyFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dependencyFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dependencyFlags, OutputEnumVkDependencyFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRenderPassCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRenderPassCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkRenderPassCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentDescription* pAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentDescription*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttachments\",\n");
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentDescription", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress(), sizeof(VkAttachmentDescription)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subpassCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subpassCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subpassCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSubpassDescription* pSubpasses
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSubpassDescription*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSubpasses\",\n");
    if (pstruct->pSubpasses == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSubpasses->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSubpassDescription", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress(), sizeof(VkSubpassDescription)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dependencyCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dependencyCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dependencyCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSubpassDependency* pDependencies
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSubpassDependency*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDependencies\",\n");
    if (pstruct->pDependencies == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDependencies->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSubpassDependency", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress(), sizeof(VkSubpassDependency)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandPoolCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandPoolCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCommandPoolCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCommandPoolCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkCommandPoolCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueFamilyIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueFamilyIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCommandPool commandPool
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCommandPool"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"commandPool\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.commandPool); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCommandBufferLevel level
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCommandBufferLevel"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"level\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCommandBufferLevel(outputFile, pstruct->level); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t commandBufferCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"commandBufferCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->commandBufferCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferInheritanceInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferInheritanceInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRenderPass renderPass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRenderPass"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"renderPass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.renderPass); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subpass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subpass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subpass); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFramebuffer framebuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFramebuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"framebuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.framebuffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 occlusionQueryEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"occlusionQueryEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->occlusionQueryEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueryControlFlags queryFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueryControlFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queryFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->queryFlags, OutputEnumVkQueryControlFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueryPipelineStatisticFlags pipelineStatistics
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueryPipelineStatisticFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineStatistics\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->pipelineStatistics, OutputEnumVkQueryPipelineStatisticFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCommandBufferUsageFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCommandBufferUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkCommandBufferUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkCommandBufferInheritanceInfo* pInheritanceInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkCommandBufferInheritanceInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pInheritanceInfo\",\n");
    if (pstruct->pInheritanceInfo == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pInheritanceInfo->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pInheritanceInfo->GetMetaStructPointer(), indent,  base_addr + offsetof(VkCommandBufferBeginInfo, pInheritanceInfo)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferCopy &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferCopy *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDeviceSize srcOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->srcOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize dstOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->dstOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSubresourceLayers &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSubresourceLayers *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageAspectFlags aspectMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->aspectMask, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t mipLevel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mipLevel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->mipLevel); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t baseArrayLayer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"baseArrayLayer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->baseArrayLayer); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t layerCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layerCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->layerCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageCopy &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageCopy *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageSubresourceLayers srcSubresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceLayers"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcSubresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.srcSubresource, indent,  base_addr + offsetof(VkImageCopy, srcSubresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D srcOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.srcOffset, indent,  base_addr + offsetof(VkImageCopy, srcOffset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageSubresourceLayers dstSubresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceLayers"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstSubresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.dstSubresource, indent,  base_addr + offsetof(VkImageCopy, dstSubresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D dstOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.dstOffset, indent,  base_addr + offsetof(VkImageCopy, dstOffset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent3D extent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.extent, indent,  base_addr + offsetof(VkImageCopy, extent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageBlit &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageBlit *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageSubresourceLayers srcSubresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceLayers"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcSubresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.srcSubresource, indent,  base_addr + offsetof(VkImageBlit, srcSubresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D srcOffsets
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "2"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcOffsets\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkImageBlit, srcOffsets) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRZ
    OutputArrayOfStructsJson(outputFile, indent, "VkOffset3D", pstruct_in.srcOffsets->GetMetaStructPointer(), "srcOffsets", 2, false, pstruct_in.srcOffsets->GetAddress(), sizeof(VkOffset3D)); // CCY
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageSubresourceLayers dstSubresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceLayers"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstSubresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.dstSubresource, indent,  base_addr + offsetof(VkImageBlit, dstSubresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D dstOffsets
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "2"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstOffsets\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkImageBlit, dstOffsets) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRZ
    OutputArrayOfStructsJson(outputFile, indent, "VkOffset3D", pstruct_in.dstOffsets->GetMetaStructPointer(), "dstOffsets", 2, false, pstruct_in.dstOffsets->GetAddress(), sizeof(VkOffset3D)); // CCY
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferImageCopy &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferImageCopy *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDeviceSize bufferOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->bufferOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bufferRowLength
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferRowLength\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bufferRowLength); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bufferImageHeight
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferImageHeight\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bufferImageHeight); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageSubresourceLayers imageSubresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceLayers"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageSubresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageSubresource, indent,  base_addr + offsetof(VkBufferImageCopy, imageSubresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D imageOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageOffset, indent,  base_addr + offsetof(VkBufferImageCopy, imageOffset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent3D imageExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageExtent, indent,  base_addr + offsetof(VkBufferImageCopy, imageExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkClearColorValue &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearColorValue *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: float float32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "4"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"float32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkClearColorValue, float32) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRP
    OutputScalarValueStructInfo vinfo_float32 = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "float", pstruct_in.decoded_value->float32, "float32", 4, vinfo_float32); // TPA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t int32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "4"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"int32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkClearColorValue, int32) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRP
    OutputScalarValueStructInfo vinfo_int32 = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "int32_t", pstruct_in.decoded_value->int32, "int32", 4, vinfo_int32); // TPA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t uint32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "4"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"uint32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkClearColorValue, uint32) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRP
    OutputScalarValueStructInfo vinfo_uint32 = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "uint32_t", pstruct_in.decoded_value->uint32, "uint32", 4, vinfo_uint32); // TPA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkClearDepthStencilValue &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearDepthStencilValue *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: float depth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->depth); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t stencil
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencil\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->stencil); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkClearValue &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearValue *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkClearColorValue color
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkClearColorValue (Union)"); // UNN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"color\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, reinterpret_cast<const Decoded_VkClearColorValue&>(pstruct_in), indent,  base_addr + offsetof(VkClearValue, color)); // RQN
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkClearDepthStencilValue depthStencil
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkClearDepthStencilValue"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthStencil\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, reinterpret_cast<const Decoded_VkClearDepthStencilValue&>(pstruct_in), indent,  base_addr + offsetof(VkClearValue, depthStencil)); // RQN
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkClearAttachment &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearAttachment *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageAspectFlags aspectMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->aspectMask, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t colorAttachment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"colorAttachment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->colorAttachment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkClearValue clearValue
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkClearValue (Union)"); // UNN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"clearValue\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.clearValue, indent,  base_addr + offsetof(VkClearAttachment, clearValue)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkClearRect &pstruct_in, int indent, uint64_t base_addr)
{
    const VkClearRect *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkRect2D rect
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRect2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rect\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.rect, indent,  base_addr + offsetof(VkClearRect, rect)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t baseArrayLayer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"baseArrayLayer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->baseArrayLayer); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t layerCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layerCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->layerCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageResolve &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageResolve *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageSubresourceLayers srcSubresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceLayers"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcSubresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.srcSubresource, indent,  base_addr + offsetof(VkImageResolve, srcSubresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D srcOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.srcOffset, indent,  base_addr + offsetof(VkImageResolve, srcOffset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageSubresourceLayers dstSubresource
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceLayers"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstSubresource\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.dstSubresource, indent,  base_addr + offsetof(VkImageResolve, dstSubresource)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset3D dstOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.dstOffset, indent,  base_addr + offsetof(VkImageResolve, dstOffset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent3D extent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent3D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.extent, indent,  base_addr + offsetof(VkImageResolve, extent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryBarrier &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryBarrier *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags srcAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->srcAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags dstAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dstAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferMemoryBarrier &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferMemoryBarrier *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags srcAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->srcAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags dstAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dstAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t srcQueueFamilyIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcQueueFamilyIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->srcQueueFamilyIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstQueueFamilyIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstQueueFamilyIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstQueueFamilyIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize size
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"size\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->size); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageMemoryBarrier &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageMemoryBarrier *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags srcAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->srcAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags dstAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dstAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout oldLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"oldLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->oldLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout newLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"newLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->newLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t srcQueueFamilyIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcQueueFamilyIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->srcQueueFamilyIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstQueueFamilyIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstQueueFamilyIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstQueueFamilyIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageSubresourceRange subresourceRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageSubresourceRange"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subresourceRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.subresourceRange, indent,  base_addr + offsetof(VkImageMemoryBarrier, subresourceRange)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRenderPass renderPass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRenderPass"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"renderPass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.renderPass); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFramebuffer framebuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFramebuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"framebuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.framebuffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRect2D renderArea
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRect2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"renderArea\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.renderArea, indent,  base_addr + offsetof(VkRenderPassBeginInfo, renderArea)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t clearValueCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"clearValueCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->clearValueCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkClearValue* pClearValues
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkClearValue*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pClearValues\",\n");
    if (pstruct->pClearValues == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pClearValues->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkClearValue", pstruct_in.pClearValues->GetMetaStructPointer(), "pClearValues", pstruct->clearValueCount, true, pstruct_in.pClearValues->GetAddress(), sizeof(VkClearValue)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDispatchIndirectCommand &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDispatchIndirectCommand *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t x
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"x\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->x); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t y
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"y\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->y); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t z
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"z\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->z); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDrawIndexedIndirectCommand &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrawIndexedIndirectCommand *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t indexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->indexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t instanceCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"instanceCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->instanceCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t firstIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"firstIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->firstIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t vertexOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vertexOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t firstInstance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"firstInstance\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->firstInstance); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDrawIndirectCommand &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrawIndirectCommand *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t vertexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vertexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t instanceCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"instanceCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->instanceCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t firstVertex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"firstVertex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->firstVertex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t firstInstance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"firstInstance\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->firstInstance); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSubgroupProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subgroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subgroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subgroupSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderStageFlags supportedStages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedStages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedStages, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSubgroupFeatureFlags supportedOperations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSubgroupFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedOperations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedOperations, OutputEnumVkSubgroupFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 quadOperationsInAllStages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"quadOperationsInAllStages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->quadOperationsInAllStages); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindBufferMemoryInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindBufferMemoryInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize memoryOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->memoryOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImageMemoryInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImageMemoryInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize memoryOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->memoryOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevice16BitStorageFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevice16BitStorageFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 storageBuffer16BitAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storageBuffer16BitAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->storageBuffer16BitAccess); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 uniformAndStorageBuffer16BitAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"uniformAndStorageBuffer16BitAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->uniformAndStorageBuffer16BitAccess); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 storagePushConstant16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storagePushConstant16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->storagePushConstant16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 storageInputOutput16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storageInputOutput16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->storageInputOutput16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryDedicatedRequirements &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryDedicatedRequirements *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 prefersDedicatedAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"prefersDedicatedAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->prefersDedicatedAllocation); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 requiresDedicatedAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"requiresDedicatedAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->requiresDedicatedAllocation); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryDedicatedAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryDedicatedAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryAllocateFlagsInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryAllocateFlagsInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMemoryAllocateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMemoryAllocateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkMemoryAllocateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupRenderPassBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupRenderPassBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceRenderAreaCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceRenderAreaCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceRenderAreaCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkRect2D* pDeviceRenderAreas
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkRect2D*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDeviceRenderAreas\",\n");
    if (pstruct->pDeviceRenderAreas == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDeviceRenderAreas->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkRect2D", pstruct_in.pDeviceRenderAreas->GetMetaStructPointer(), "pDeviceRenderAreas", pstruct->deviceRenderAreaCount, false, pstruct_in.pDeviceRenderAreas->GetAddress(), sizeof(VkRect2D)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupCommandBufferBeginInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupCommandBufferBeginInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupSubmitInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupSubmitInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t waitSemaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"waitSemaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pWaitSemaphoreDeviceIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pWaitSemaphoreDeviceIndices\",\n");
    if (pstruct->pWaitSemaphoreDeviceIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pWaitSemaphoreDeviceIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pWaitSemaphoreDeviceIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pWaitSemaphoreDeviceIndices, "pWaitSemaphoreDeviceIndices", pstruct->waitSemaphoreCount, vinfo_pWaitSemaphoreDeviceIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t commandBufferCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"commandBufferCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->commandBufferCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pCommandBufferDeviceMasks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCommandBufferDeviceMasks\",\n");
    if (pstruct->pCommandBufferDeviceMasks == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCommandBufferDeviceMasks.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pCommandBufferDeviceMasks = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pCommandBufferDeviceMasks, "pCommandBufferDeviceMasks", pstruct->commandBufferCount, vinfo_pCommandBufferDeviceMasks); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t signalSemaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"signalSemaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->signalSemaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pSignalSemaphoreDeviceIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSignalSemaphoreDeviceIndices\",\n");
    if (pstruct->pSignalSemaphoreDeviceIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSignalSemaphoreDeviceIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pSignalSemaphoreDeviceIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pSignalSemaphoreDeviceIndices, "pSignalSemaphoreDeviceIndices", pstruct->signalSemaphoreCount, vinfo_pSignalSemaphoreDeviceIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupBindSparseInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupBindSparseInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t resourceDeviceIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"resourceDeviceIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->resourceDeviceIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryDeviceIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryDeviceIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryDeviceIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindBufferMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindBufferMemoryDeviceGroupInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceIndexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceIndexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceIndexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pDeviceIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDeviceIndices\",\n");
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDeviceIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDeviceIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pDeviceIndices, "pDeviceIndices", pstruct->deviceIndexCount, vinfo_pDeviceIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImageMemoryDeviceGroupInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImageMemoryDeviceGroupInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceIndexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceIndexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceIndexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pDeviceIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDeviceIndices\",\n");
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDeviceIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDeviceIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pDeviceIndices, "pDeviceIndices", pstruct->deviceIndexCount, vinfo_pDeviceIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t splitInstanceBindRegionCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"splitInstanceBindRegionCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->splitInstanceBindRegionCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkRect2D* pSplitInstanceBindRegions
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkRect2D*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSplitInstanceBindRegions\",\n");
    if (pstruct->pSplitInstanceBindRegions == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSplitInstanceBindRegions->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkRect2D", pstruct_in.pSplitInstanceBindRegions->GetMetaStructPointer(), "pSplitInstanceBindRegions", pstruct->splitInstanceBindRegionCount, false, pstruct_in.pSplitInstanceBindRegions->GetAddress(), sizeof(VkRect2D)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceGroupProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceGroupProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t physicalDeviceCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"physicalDeviceCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->physicalDeviceCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPhysicalDevice physicalDevices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPhysicalDevice"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DEVICE_GROUP_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"physicalDevices\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceGroupProperties, physicalDevices) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :"); // TRI
    OutputScalarValueStructInfo vinfo_physicalDevices = {true, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "VkPhysicalDevice", &pstruct_in.physicalDevices, "physicalDevices", pstruct->physicalDeviceCount, vinfo_physicalDevices); // AQA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 subsetAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subsetAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->subsetAllocation); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupDeviceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupDeviceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t physicalDeviceCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"physicalDeviceCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->physicalDeviceCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPhysicalDevice* pPhysicalDevices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPhysicalDevice*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPhysicalDevices\",\n");
    if (pstruct->pPhysicalDevices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPhysicalDevices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pPhysicalDevices = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkPhysicalDevice*", &pstruct_in.pPhysicalDevices, "pPhysicalDevices", pstruct->physicalDeviceCount, vinfo_pPhysicalDevices); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferMemoryRequirementsInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageMemoryRequirementsInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSparseMemoryRequirementsInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSparseMemoryRequirementsInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryRequirements2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMemoryRequirements memoryRequirements
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMemoryRequirements"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryRequirements\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.memoryRequirements, indent,  base_addr + offsetof(VkMemoryRequirements2, memoryRequirements)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageMemoryRequirements2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageMemoryRequirements2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSparseImageMemoryRequirements memoryRequirements
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSparseImageMemoryRequirements"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryRequirements\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.memoryRequirements, indent,  base_addr + offsetof(VkSparseImageMemoryRequirements2, memoryRequirements)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFeatures2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFeatures2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPhysicalDeviceFeatures features
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPhysicalDeviceFeatures"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"features\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.features, indent,  base_addr + offsetof(VkPhysicalDeviceFeatures2, features)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPhysicalDeviceProperties properties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPhysicalDeviceProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"properties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.properties, indent,  base_addr + offsetof(VkPhysicalDeviceProperties2, properties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFormatProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFormatProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormatProperties formatProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormatProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"formatProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.formatProperties, indent,  base_addr + offsetof(VkFormatProperties2, formatProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageFormatProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageFormatProperties imageFormatProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageFormatProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageFormatProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageFormatProperties, indent,  base_addr + offsetof(VkImageFormatProperties2, imageFormatProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImageFormatInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageType type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageType(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageTiling tiling
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageTiling"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tiling\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageTiling(outputFile, pstruct->tiling); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags usage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"usage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->usage, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkImageCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkQueueFamilyProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueueFamilyProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueueFamilyProperties queueFamilyProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueueFamilyProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.queueFamilyProperties, indent,  base_addr + offsetof(VkQueueFamilyProperties2, queueFamilyProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPhysicalDeviceMemoryProperties memoryProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPhysicalDeviceMemoryProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.memoryProperties, indent,  base_addr + offsetof(VkPhysicalDeviceMemoryProperties2, memoryProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSparseImageFormatProperties2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSparseImageFormatProperties2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSparseImageFormatProperties properties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSparseImageFormatProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"properties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.properties, indent,  base_addr + offsetof(VkSparseImageFormatProperties2, properties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSparseImageFormatInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageType type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageType(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlagBits samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->samples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags usage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"usage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->usage, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageTiling tiling
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageTiling"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tiling\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageTiling(outputFile, pstruct->tiling); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePointClippingProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePointClippingProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPointClippingBehavior pointClippingBehavior
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPointClippingBehavior"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pointClippingBehavior\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPointClippingBehavior(outputFile, pstruct->pointClippingBehavior); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkInputAttachmentAspectReference &pstruct_in, int indent, uint64_t base_addr)
{
    const VkInputAttachmentAspectReference *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t subpass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subpass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subpass); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t inputAttachmentIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"inputAttachmentIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->inputAttachmentIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageAspectFlags aspectMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->aspectMask, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassInputAttachmentAspectCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t aspectReferenceCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectReferenceCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->aspectReferenceCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkInputAttachmentAspectReference* pAspectReferences
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkInputAttachmentAspectReference*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAspectReferences\",\n");
    if (pstruct->pAspectReferences == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAspectReferences->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkInputAttachmentAspectReference", pstruct_in.pAspectReferences->GetMetaStructPointer(), "pAspectReferences", pstruct->aspectReferenceCount, false, pstruct_in.pAspectReferences->GetAddress(), sizeof(VkInputAttachmentAspectReference)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewUsageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewUsageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags usage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"usage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->usage, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineTessellationDomainOriginStateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkTessellationDomainOrigin domainOrigin
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkTessellationDomainOrigin"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"domainOrigin\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkTessellationDomainOrigin(outputFile, pstruct->domainOrigin); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassMultiviewCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassMultiviewCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subpassCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subpassCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subpassCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pViewMasks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewMasks\",\n");
    if (pstruct->pViewMasks == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewMasks.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pViewMasks = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pViewMasks, "pViewMasks", pstruct->subpassCount, vinfo_pViewMasks); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dependencyCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dependencyCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dependencyCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const int32_t* pViewOffsets
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const int32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewOffsets\",\n");
    if (pstruct->pViewOffsets == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewOffsets.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pViewOffsets = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const int32_t*", &pstruct_in.pViewOffsets, "pViewOffsets", pstruct->dependencyCount, vinfo_pViewOffsets); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t correlationMaskCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"correlationMaskCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->correlationMaskCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pCorrelationMasks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCorrelationMasks\",\n");
    if (pstruct->pCorrelationMasks == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCorrelationMasks.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pCorrelationMasks = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pCorrelationMasks, "pCorrelationMasks", pstruct->correlationMaskCount, vinfo_pCorrelationMasks); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMultiviewFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 multiview
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"multiview\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->multiview); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 multiviewGeometryShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"multiviewGeometryShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->multiviewGeometryShader); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 multiviewTessellationShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"multiviewTessellationShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->multiviewTessellationShader); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMultiviewProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMultiviewViewCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMultiviewViewCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMultiviewViewCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMultiviewInstanceIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMultiviewInstanceIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMultiviewInstanceIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVariablePointersFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVariablePointersFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 variablePointersStorageBuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"variablePointersStorageBuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->variablePointersStorageBuffer); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 variablePointers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"variablePointers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->variablePointers); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProtectedMemoryFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 protectedMemory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"protectedMemory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->protectedMemory); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceProtectedMemoryProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceProtectedMemoryProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 protectedNoFault
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"protectedNoFault\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->protectedNoFault); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceQueueInfo2 &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceQueueInfo2 *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceQueueCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceQueueCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkDeviceQueueCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueFamilyIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueFamilyIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkProtectedSubmitInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkProtectedSubmitInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 protectedSubmit
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"protectedSubmit\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->protectedSubmit); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerYcbcrConversionCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerYcbcrModelConversion ycbcrModel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerYcbcrModelConversion"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ycbcrModel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerYcbcrModelConversion(outputFile, pstruct->ycbcrModel); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerYcbcrRange ycbcrRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerYcbcrRange"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ycbcrRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerYcbcrRange(outputFile, pstruct->ycbcrRange); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentMapping components
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentMapping"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"components\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.components, indent,  base_addr + offsetof(VkSamplerYcbcrConversionCreateInfo, components)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkChromaLocation xChromaOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkChromaLocation"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"xChromaOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkChromaLocation(outputFile, pstruct->xChromaOffset); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkChromaLocation yChromaOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkChromaLocation"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"yChromaOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkChromaLocation(outputFile, pstruct->yChromaOffset); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFilter chromaFilter
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFilter"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"chromaFilter\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFilter(outputFile, pstruct->chromaFilter); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 forceExplicitReconstruction
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"forceExplicitReconstruction\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->forceExplicitReconstruction); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerYcbcrConversionInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerYcbcrConversion conversion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerYcbcrConversion"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"conversion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.conversion); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImagePlaneMemoryInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImagePlaneMemoryInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageAspectFlagBits planeAspect
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"planeAspect\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->planeAspect, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImagePlaneMemoryRequirementsInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImagePlaneMemoryRequirementsInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageAspectFlagBits planeAspect
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"planeAspect\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->planeAspect, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 samplerYcbcrConversion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"samplerYcbcrConversion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->samplerYcbcrConversion); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerYcbcrConversionImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerYcbcrConversionImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t combinedImageSamplerDescriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"combinedImageSamplerDescriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->combinedImageSamplerDescriptorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateEntry &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorUpdateTemplateEntry *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t dstBinding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstBinding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstBinding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstArrayElement
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstArrayElement\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstArrayElement); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorType descriptorType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDescriptorType(outputFile, pstruct->descriptorType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->offset); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t stride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->stride); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorUpdateTemplateCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorUpdateTemplateCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorUpdateTemplateCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorUpdateTemplateCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorUpdateEntryCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorUpdateEntryCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorUpdateEntryCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorUpdateTemplateEntry*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDescriptorUpdateEntries\",\n");
    if (pstruct->pDescriptorUpdateEntries == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDescriptorUpdateEntries->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDescriptorUpdateTemplateEntry", pstruct_in.pDescriptorUpdateEntries->GetMetaStructPointer(), "pDescriptorUpdateEntries", pstruct->descriptorUpdateEntryCount, false, pstruct_in.pDescriptorUpdateEntries->GetAddress(), sizeof(VkDescriptorUpdateTemplateEntry)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorUpdateTemplateType templateType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorUpdateTemplateType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"templateType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDescriptorUpdateTemplateType(outputFile, pstruct->templateType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorSetLayout descriptorSetLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorSetLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorSetLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.descriptorSetLayout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineBindPoint pipelineBindPoint
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineBindPoint"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineBindPoint\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineLayout pipelineLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.pipelineLayout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t set
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"set\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->set); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkExternalMemoryFeatureFlags externalMemoryFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalMemoryFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->externalMemoryFeatures, OutputEnumVkExternalMemoryFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"exportFromImportedHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->exportFromImportedHandleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlags compatibleHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compatibleHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->compatibleHandleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalImageFormatInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalImageFormatInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalImageFormatProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalImageFormatProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryProperties externalMemoryProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalMemoryProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.externalMemoryProperties, indent,  base_addr + offsetof(VkExternalImageFormatProperties, externalMemoryProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalBufferInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalBufferInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBufferCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBufferCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkBufferCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBufferUsageFlags usage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBufferUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"usage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->usage, OutputEnumVkBufferUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalBufferProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalBufferProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryProperties externalMemoryProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalMemoryProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.externalMemoryProperties, indent,  base_addr + offsetof(VkExternalBufferProperties, externalMemoryProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceIDProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceIDProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint8_t deviceUUID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_UUID_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceUUID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceIDProperties, deviceUUID) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_deviceUUID = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint8_t", &pstruct_in.deviceUUID, "deviceUUID", VK_UUID_SIZE, vinfo_deviceUUID); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint8_t driverUUID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_UUID_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"driverUUID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceIDProperties, driverUUID) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_driverUUID = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint8_t", &pstruct_in.driverUUID, "driverUUID", VK_UUID_SIZE, vinfo_driverUUID); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint8_t deviceLUID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_LUID_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceLUID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceIDProperties, deviceLUID) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_deviceLUID = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint8_t", &pstruct_in.deviceLUID, "deviceLUID", VK_LUID_SIZE, vinfo_deviceLUID); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceNodeMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceNodeMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceNodeMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 deviceLUIDValid
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceLUIDValid\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->deviceLUIDValid); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryImageCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryBufferCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryBufferCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryAllocateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlags handleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalFenceInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalFenceInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalFenceProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalFenceProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"exportFromImportedHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->exportFromImportedHandleTypes, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlags compatibleHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compatibleHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->compatibleHandleTypes, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceFeatureFlags externalFenceFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalFenceFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->externalFenceFeatures, OutputEnumVkExternalFenceFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportFenceCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportFenceCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlags handleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleTypes, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportSemaphoreCreateInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportSemaphoreCreateInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlags handleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleTypes, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalSemaphoreInfo *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalSemaphoreProperties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalSemaphoreProperties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"exportFromImportedHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->exportFromImportedHandleTypes, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compatibleHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->compatibleHandleTypes, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalSemaphoreFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->externalSemaphoreFeatures, OutputEnumVkExternalSemaphoreFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMaintenance3Properties &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMaintenance3Properties *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerSetDescriptors
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerSetDescriptors\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerSetDescriptors); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize maxMemoryAllocationSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMemoryAllocationSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->maxMemoryAllocationSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutSupport &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutSupport *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 supported
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supported\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->supported); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderDrawParametersFeatures *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDrawParameters
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDrawParameters\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDrawParameters); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t minImageCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minImageCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minImageCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D currentExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"currentExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.currentExtent, indent,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, currentExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D minImageExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minImageExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minImageExtent, indent,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, minImageExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D maxImageExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxImageExtent, indent,  base_addr + offsetof(VkSurfaceCapabilitiesKHR, maxImageExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageArrayLayers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageArrayLayers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageArrayLayers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceTransformFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedTransforms\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedTransforms, OutputEnumVkSurfaceTransformFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceTransformFlagBitsKHR currentTransform
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceTransformFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"currentTransform\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->currentTransform, OutputEnumVkSurfaceTransformFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCompositeAlphaFlagsKHR supportedCompositeAlpha
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCompositeAlphaFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedCompositeAlpha\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedCompositeAlpha, OutputEnumVkCompositeAlphaFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags supportedUsageFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedUsageFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedUsageFlags, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFormatKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFormatKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkColorSpaceKHR colorSpace
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkColorSpaceKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"colorSpace\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkColorSpaceKHR(outputFile, pstruct->colorSpace); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSwapchainCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSwapchainCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSwapchainCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSwapchainCreateFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceKHR surface
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"surface\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.surface); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minImageCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minImageCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minImageCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat imageFormat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageFormat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->imageFormat); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkColorSpaceKHR imageColorSpace
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkColorSpaceKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageColorSpace\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkColorSpaceKHR(outputFile, pstruct->imageColorSpace); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D imageExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageExtent, indent,  base_addr + offsetof(VkSwapchainCreateInfoKHR, imageExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t imageArrayLayers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageArrayLayers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->imageArrayLayers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags imageUsage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageUsage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->imageUsage, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSharingMode imageSharingMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSharingMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageSharingMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSharingMode(outputFile, pstruct->imageSharingMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueFamilyIndexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyIndexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pQueueFamilyIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pQueueFamilyIndices\",\n");
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pQueueFamilyIndices, "pQueueFamilyIndices", pstruct->queueFamilyIndexCount, vinfo_pQueueFamilyIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceTransformFlagBitsKHR preTransform
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceTransformFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"preTransform\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->preTransform, OutputEnumVkSurfaceTransformFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCompositeAlphaFlagBitsKHR compositeAlpha
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCompositeAlphaFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compositeAlpha\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->compositeAlpha, OutputEnumVkCompositeAlphaFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPresentModeKHR presentMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPresentModeKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"presentMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPresentModeKHR(outputFile, pstruct->presentMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 clipped
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"clipped\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->clipped); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSwapchainKHR oldSwapchain
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSwapchainKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"oldSwapchain\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.oldSwapchain); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t waitSemaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"waitSemaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->waitSemaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSemaphore* pWaitSemaphores
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSemaphore*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pWaitSemaphores\",\n");
    if (pstruct->pWaitSemaphores == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pWaitSemaphores.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pWaitSemaphores = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSemaphore*", &pstruct_in.pWaitSemaphores, "pWaitSemaphores", pstruct->waitSemaphoreCount, vinfo_pWaitSemaphores); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t swapchainCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"swapchainCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->swapchainCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSwapchainKHR* pSwapchains
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSwapchainKHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSwapchains\",\n");
    if (pstruct->pSwapchains == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSwapchains.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pSwapchains = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSwapchainKHR*", &pstruct_in.pSwapchains, "pSwapchains", pstruct->swapchainCount, vinfo_pSwapchains); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pImageIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pImageIndices\",\n");
    if (pstruct->pImageIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pImageIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pImageIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pImageIndices, "pImageIndices", pstruct->swapchainCount, vinfo_pImageIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkResult* pResults
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkResult*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pResults\",\n");
    if (pstruct->pResults == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pResults.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pResults = {false, true, false, OutputEnumVkResult};
        OutputArrayJson(outputFile, indent, "VkResult*", &pstruct_in.pResults, "pResults", pstruct->swapchainCount, vinfo_pResults); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageSwapchainCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSwapchainKHR swapchain
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSwapchainKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"swapchain\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.swapchain); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindImageMemorySwapchainInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindImageMemorySwapchainInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSwapchainKHR swapchain
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSwapchainKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"swapchain\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.swapchain); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t imageIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->imageIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAcquireNextImageInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAcquireNextImageInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSwapchainKHR swapchain
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSwapchainKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"swapchain\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.swapchain); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t timeout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"timeout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->timeout); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphore semaphore
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphore"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphore\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.semaphore); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFence fence
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFence"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fence\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.fence); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupPresentCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupPresentCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t presentMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DEVICE_GROUP_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"presentMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkDeviceGroupPresentCapabilitiesKHR, presentMask) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_presentMask = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint32_t", &pstruct_in.presentMask, "presentMask", VK_MAX_DEVICE_GROUP_SIZE, vinfo_presentMask); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceGroupPresentModeFlagsKHR modes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceGroupPresentModeFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"modes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->modes, OutputEnumVkDeviceGroupPresentModeFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupPresentInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t swapchainCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"swapchainCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->swapchainCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pDeviceMasks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDeviceMasks\",\n");
    if (pstruct->pDeviceMasks == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDeviceMasks.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDeviceMasks = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pDeviceMasks, "pDeviceMasks", pstruct->swapchainCount, vinfo_pDeviceMasks); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceGroupPresentModeFlagBitsKHR mode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceGroupPresentModeFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->mode, OutputEnumVkDeviceGroupPresentModeFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGroupSwapchainCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceGroupPresentModeFlagsKHR modes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceGroupPresentModeFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"modes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->modes, OutputEnumVkDeviceGroupPresentModeFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDisplayKHR display
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"display\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.display); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* displayName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayName\",\n");
    if (pstruct->displayName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->displayName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D physicalDimensions
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"physicalDimensions\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.physicalDimensions, indent,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalDimensions)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D physicalResolution
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"physicalResolution\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.physicalResolution, indent,  base_addr + offsetof(VkDisplayPropertiesKHR, physicalResolution)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceTransformFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedTransforms\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedTransforms, OutputEnumVkSurfaceTransformFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 planeReorderPossible
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"planeReorderPossible\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->planeReorderPossible); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 persistentContent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"persistentContent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->persistentContent); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModeParametersKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModeParametersKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkExtent2D visibleRegion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"visibleRegion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.visibleRegion, indent,  base_addr + offsetof(VkDisplayModeParametersKHR, visibleRegion)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t refreshRate
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"refreshRate\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->refreshRate); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDisplayModeKHR displayMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayModeKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.displayMode); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayModeParametersKHR parameters
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayModeParametersKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"parameters\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.parameters, indent,  base_addr + offsetof(VkDisplayModePropertiesKHR, parameters)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModeCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayModeCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayModeCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayModeParametersKHR parameters
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayModeParametersKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"parameters\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.parameters, indent,  base_addr + offsetof(VkDisplayModeCreateInfoKHR, parameters)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDisplayPlaneAlphaFlagsKHR supportedAlpha
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayPlaneAlphaFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedAlpha\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedAlpha, OutputEnumVkDisplayPlaneAlphaFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset2D minSrcPosition
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minSrcPosition\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minSrcPosition, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcPosition)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset2D maxSrcPosition
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSrcPosition\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxSrcPosition, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcPosition)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D minSrcExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minSrcExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minSrcExtent, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D maxSrcExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSrcExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxSrcExtent, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset2D minDstPosition
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minDstPosition\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minDstPosition, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstPosition)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkOffset2D maxDstPosition
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDstPosition\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxDstPosition, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstPosition)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D minDstExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minDstExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minDstExtent, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, minDstExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D maxDstExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDstExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxDstExtent, indent,  base_addr + offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlanePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlanePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkDisplayKHR currentDisplay
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"currentDisplay\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.currentDisplay); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t currentStackIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"currentStackIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->currentStackIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplaySurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplaySurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplaySurfaceCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplaySurfaceCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayModeKHR displayMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayModeKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.displayMode); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t planeIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"planeIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->planeIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t planeStackIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"planeStackIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->planeStackIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceTransformFlagBitsKHR transform
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceTransformFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transform\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->transform, OutputEnumVkSurfaceTransformFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float globalAlpha
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"globalAlpha\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->globalAlpha); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayPlaneAlphaFlagBitsKHR alphaMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayPlaneAlphaFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"alphaMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->alphaMode, OutputEnumVkDisplayPlaneAlphaFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D imageExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageExtent, indent,  base_addr + offsetof(VkDisplaySurfaceCreateInfoKHR, imageExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPresentInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPresentInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRect2D srcRect
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRect2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcRect\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.srcRect, indent,  base_addr + offsetof(VkDisplayPresentInfoKHR, srcRect)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRect2D dstRect
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRect2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstRect\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.dstRect, indent,  base_addr + offsetof(VkDisplayPresentInfoKHR, dstRect)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 persistent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"persistent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->persistent); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkXlibSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkXlibSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkXlibSurfaceCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkXlibSurfaceCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* dpy
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dpy\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.dpy); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t window
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"window\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->window); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkXcbSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkXcbSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkXcbSurfaceCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkXcbSurfaceCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* connection
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"connection\",\n");
    if (pstruct->connection == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.connection /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.connection); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t window
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"window\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->window); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkWaylandSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWaylandSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkWaylandSurfaceCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkWaylandSurfaceCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: struct void* display
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"struct void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"display\",\n");
    if (pstruct->display == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.display /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.display); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: struct void* surface
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"struct void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"surface\",\n");
    if (pstruct->surface == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.surface /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.surface); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidSurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidSurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAndroidSurfaceCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAndroidSurfaceCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: struct void* window
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"struct void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"window\",\n");
    if (pstruct->window == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.window /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.window); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkWin32SurfaceCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWin32SurfaceCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkWin32SurfaceCreateFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkWin32SurfaceCreateFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* hinstance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"hinstance\",\n");
    if (pstruct->hinstance == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.hinstance /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.hinstance); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* hwnd
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"hwnd\",\n");
    if (pstruct->hwnd == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.hwnd /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.hwnd); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* handle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handle\",\n");
    if (pstruct->handle == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.handle /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.handle); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const wchar_t* name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const wchar_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    if (pstruct->name == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.name.GetAddress() /* QZR */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        WideStringToQuotedStringJson(outputFile, pstruct->name); // PXQ
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const SECURITY_ATTRIBUTES*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttributes\",\n");
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttributes->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputScalarValueStructInfo vinfo_pAttributes = {false, false, false, nullptr};
        OutputScalarValueJson(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PXT
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dwAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dwAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dwAccess); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const wchar_t* name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const wchar_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    if (pstruct->name == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.name.GetAddress() /* QZR */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        WideStringToQuotedStringJson(outputFile, pstruct->name); // PXQ
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryWin32HandlePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryWin32HandlePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryTypeBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypeBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryTypeBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryGetWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int fd
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fd\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fd); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryFdPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryFdPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryTypeBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypeBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryTypeBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryGetFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWin32KeyedMutexAcquireReleaseInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t acquireCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"acquireCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->acquireCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDeviceMemory* pAcquireSyncs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDeviceMemory*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAcquireSyncs\",\n");
    if (pstruct->pAcquireSyncs == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAcquireSyncs.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pAcquireSyncs = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkDeviceMemory*", &pstruct_in.pAcquireSyncs, "pAcquireSyncs", pstruct->acquireCount, vinfo_pAcquireSyncs); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pAcquireKeys
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAcquireKeys\",\n");
    if (pstruct->pAcquireKeys == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAcquireKeys.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pAcquireKeys = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pAcquireKeys, "pAcquireKeys", pstruct->acquireCount, vinfo_pAcquireKeys); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pAcquireTimeouts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAcquireTimeouts\",\n");
    if (pstruct->pAcquireTimeouts == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAcquireTimeouts.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pAcquireTimeouts = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pAcquireTimeouts, "pAcquireTimeouts", pstruct->acquireCount, vinfo_pAcquireTimeouts); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t releaseCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"releaseCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->releaseCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDeviceMemory* pReleaseSyncs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDeviceMemory*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pReleaseSyncs\",\n");
    if (pstruct->pReleaseSyncs == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pReleaseSyncs.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pReleaseSyncs = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkDeviceMemory*", &pstruct_in.pReleaseSyncs, "pReleaseSyncs", pstruct->releaseCount, vinfo_pReleaseSyncs); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pReleaseKeys
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pReleaseKeys\",\n");
    if (pstruct->pReleaseKeys == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pReleaseKeys.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pReleaseKeys = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pReleaseKeys, "pReleaseKeys", pstruct->releaseCount, vinfo_pReleaseKeys); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportSemaphoreWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphore semaphore
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphore"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphore\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.semaphore); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphoreImportFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphoreImportFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSemaphoreImportFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* handle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handle\",\n");
    if (pstruct->handle == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.handle /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.handle); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const wchar_t* name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const wchar_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    if (pstruct->name == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.name.GetAddress() /* QZR */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        WideStringToQuotedStringJson(outputFile, pstruct->name); // PXQ
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportSemaphoreWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportSemaphoreWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const SECURITY_ATTRIBUTES*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttributes\",\n");
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttributes->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputScalarValueStructInfo vinfo_pAttributes = {false, false, false, nullptr};
        OutputScalarValueJson(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PXT
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dwAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dwAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dwAccess); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const wchar_t* name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const wchar_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    if (pstruct->name == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.name.GetAddress() /* QZR */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        WideStringToQuotedStringJson(outputFile, pstruct->name); // PXQ
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkD3D12FenceSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkD3D12FenceSubmitInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t waitSemaphoreValuesCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"waitSemaphoreValuesCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->waitSemaphoreValuesCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pWaitSemaphoreValues
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pWaitSemaphoreValues\",\n");
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pWaitSemaphoreValues.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pWaitSemaphoreValues, "pWaitSemaphoreValues", pstruct->waitSemaphoreValuesCount, vinfo_pWaitSemaphoreValues); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t signalSemaphoreValuesCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"signalSemaphoreValuesCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->signalSemaphoreValuesCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pSignalSemaphoreValues
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSignalSemaphoreValues\",\n");
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSignalSemaphoreValues.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pSignalSemaphoreValues, "pSignalSemaphoreValues", pstruct->signalSemaphoreValuesCount, vinfo_pSignalSemaphoreValues); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreGetWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphore semaphore
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphore"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphore\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.semaphore); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportSemaphoreFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportSemaphoreFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphore semaphore
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphore"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphore\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.semaphore); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphoreImportFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphoreImportFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSemaphoreImportFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int fd
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fd\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fd); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreGetFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphore semaphore
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphore"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphore\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.semaphore); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalSemaphoreHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalSemaphoreHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalSemaphoreHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePushDescriptorPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPushDescriptors
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPushDescriptors\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPushDescriptors); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderFloat16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderFloat16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderFloat16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderInt8
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderInt8\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderInt8); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRectLayerKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRectLayerKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkOffset2D offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkOffset2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.offset, indent,  base_addr + offsetof(VkRectLayerKHR, offset)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D extent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.extent, indent,  base_addr + offsetof(VkRectLayerKHR, extent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t layer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->layer); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentRegionKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentRegionKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t rectangleCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rectangleCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->rectangleCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkRectLayerKHR* pRectangles
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkRectLayerKHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pRectangles\",\n");
    if (pstruct->pRectangles == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pRectangles->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkRectLayerKHR", pstruct_in.pRectangles->GetMetaStructPointer(), "pRectangles", pstruct->rectangleCount, false, pstruct_in.pRectangles->GetAddress(), sizeof(VkRectLayerKHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentRegionsKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentRegionsKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t swapchainCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"swapchainCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->swapchainCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPresentRegionKHR* pRegions
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPresentRegionKHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pRegions\",\n");
    if (pstruct->pRegions == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pRegions->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkPresentRegionKHR", pstruct_in.pRegions->GetMetaStructPointer(), "pRegions", pstruct->swapchainCount, false, pstruct_in.pRegions->GetAddress(), sizeof(VkPresentRegionKHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImagelessFramebufferFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImagelessFramebufferFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 imagelessFramebuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imagelessFramebuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->imagelessFramebuffer); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferAttachmentImageInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferAttachmentImageInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkImageCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags usage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"usage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->usage, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t width
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"width\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->width); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t height
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"height\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->height); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t layerCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layerCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->layerCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewFormatCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewFormatCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewFormatCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkFormat* pViewFormats
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkFormat*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewFormats\",\n");
    if (pstruct->pViewFormats == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewFormats.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pViewFormats = {false, true, false, OutputEnumVkFormat};
        OutputArrayJson(outputFile, indent, "const VkFormat*", &pstruct_in.pViewFormats, "pViewFormats", pstruct->viewFormatCount, vinfo_pViewFormats); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferAttachmentsCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferAttachmentsCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachmentImageInfoCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentImageInfoCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentImageInfoCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkFramebufferAttachmentImageInfoKHR* pAttachmentImageInfos
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkFramebufferAttachmentImageInfoKHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttachmentImageInfos\",\n");
    if (pstruct->pAttachmentImageInfos == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttachmentImageInfos->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkFramebufferAttachmentImageInfoKHR", pstruct_in.pAttachmentImageInfos->GetMetaStructPointer(), "pAttachmentImageInfos", pstruct->attachmentImageInfoCount, false, pstruct_in.pAttachmentImageInfos->GetAddress(), sizeof(VkFramebufferAttachmentImageInfoKHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassAttachmentBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassAttachmentBeginInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkImageView* pAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkImageView*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttachments\",\n");
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttachments.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pAttachments = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkImageView*", &pstruct_in.pAttachments, "pAttachments", pstruct->attachmentCount, vinfo_pAttachments); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentDescription2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentDescription2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentDescriptionFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentDescriptionFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkAttachmentDescriptionFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlagBits samples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"samples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->samples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentLoadOp loadOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentLoadOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"loadOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentLoadOp(outputFile, pstruct->loadOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentStoreOp storeOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentStoreOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storeOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentStoreOp(outputFile, pstruct->storeOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentLoadOp stencilLoadOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentLoadOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencilLoadOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentLoadOp(outputFile, pstruct->stencilLoadOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentStoreOp stencilStoreOp
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentStoreOp"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencilStoreOp\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAttachmentStoreOp(outputFile, pstruct->stencilStoreOp); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout initialLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"initialLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->initialLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout finalLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"finalLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->finalLayout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentReference2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentReference2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageLayout layout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageLayout(outputFile, pstruct->layout); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageAspectFlags aspectMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageAspectFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aspectMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->aspectMask, OutputEnumVkImageAspectFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDescription2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDescription2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSubpassDescriptionFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSubpassDescriptionFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSubpassDescriptionFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineBindPoint pipelineBindPoint
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineBindPoint"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineBindPoint\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewMask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t inputAttachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"inputAttachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->inputAttachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference2KHR* pInputAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pInputAttachments\",\n");
    if (pstruct->pInputAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pInputAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentReference2KHR", pstruct_in.pInputAttachments->GetMetaStructPointer(), "pInputAttachments", pstruct->inputAttachmentCount, false, pstruct_in.pInputAttachments->GetAddress(), sizeof(VkAttachmentReference2KHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t colorAttachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"colorAttachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->colorAttachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference2KHR* pColorAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pColorAttachments\",\n");
    if (pstruct->pColorAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pColorAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentReference2KHR", pstruct_in.pColorAttachments->GetMetaStructPointer(), "pColorAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pColorAttachments->GetAddress(), sizeof(VkAttachmentReference2KHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference2KHR* pResolveAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pResolveAttachments\",\n");
    if (pstruct->pResolveAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pResolveAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentReference2KHR", pstruct_in.pResolveAttachments->GetMetaStructPointer(), "pResolveAttachments", pstruct->colorAttachmentCount, false, pstruct_in.pResolveAttachments->GetAddress(), sizeof(VkAttachmentReference2KHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference2KHR* pDepthStencilAttachment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDepthStencilAttachment\",\n");
    if (pstruct->pDepthStencilAttachment == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDepthStencilAttachment->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pDepthStencilAttachment->GetMetaStructPointer(), indent,  base_addr + offsetof(VkSubpassDescription2KHR, pDepthStencilAttachment)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t preserveAttachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"preserveAttachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->preserveAttachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pPreserveAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPreserveAttachments\",\n");
    if (pstruct->pPreserveAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPreserveAttachments.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pPreserveAttachments = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pPreserveAttachments, "pPreserveAttachments", pstruct->preserveAttachmentCount, vinfo_pPreserveAttachments); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDependency2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDependency2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t srcSubpass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcSubpass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->srcSubpass); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dstSubpass
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstSubpass\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dstSubpass); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineStageFlags srcStageMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcStageMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->srcStageMask, OutputEnumVkPipelineStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineStageFlags dstStageMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstStageMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dstStageMask, OutputEnumVkPipelineStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags srcAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->srcAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccessFlags dstAccessMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccessFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstAccessMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dstAccessMask, OutputEnumVkAccessFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDependencyFlags dependencyFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDependencyFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dependencyFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->dependencyFlags, OutputEnumVkDependencyFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t viewOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->viewOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassCreateInfo2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassCreateInfo2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRenderPassCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRenderPassCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkRenderPassCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachmentCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentDescription2KHR* pAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentDescription2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttachments\",\n");
    if (pstruct->pAttachments == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttachments->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentDescription2KHR", pstruct_in.pAttachments->GetMetaStructPointer(), "pAttachments", pstruct->attachmentCount, false, pstruct_in.pAttachments->GetAddress(), sizeof(VkAttachmentDescription2KHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subpassCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subpassCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subpassCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSubpassDescription2KHR* pSubpasses
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSubpassDescription2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSubpasses\",\n");
    if (pstruct->pSubpasses == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSubpasses->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSubpassDescription2KHR", pstruct_in.pSubpasses->GetMetaStructPointer(), "pSubpasses", pstruct->subpassCount, false, pstruct_in.pSubpasses->GetAddress(), sizeof(VkSubpassDescription2KHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dependencyCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dependencyCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dependencyCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSubpassDependency2KHR* pDependencies
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSubpassDependency2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDependencies\",\n");
    if (pstruct->pDependencies == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDependencies->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSubpassDependency2KHR", pstruct_in.pDependencies->GetMetaStructPointer(), "pDependencies", pstruct->dependencyCount, false, pstruct_in.pDependencies->GetAddress(), sizeof(VkSubpassDependency2KHR)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t correlatedViewMaskCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"correlatedViewMaskCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->correlatedViewMaskCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pCorrelatedViewMasks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCorrelatedViewMasks\",\n");
    if (pstruct->pCorrelatedViewMasks == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCorrelatedViewMasks.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pCorrelatedViewMasks = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pCorrelatedViewMasks, "pCorrelatedViewMasks", pstruct->correlatedViewMaskCount, vinfo_pCorrelatedViewMasks); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassBeginInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassBeginInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSubpassContents contents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSubpassContents"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"contents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSubpassContents(outputFile, pstruct->contents); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassEndInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassEndInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSharedPresentSurfaceCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags sharedPresentSupportedUsageFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sharedPresentSupportedUsageFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sharedPresentSupportedUsageFlags, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportFenceWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFence fence
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFence"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fence\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.fence); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFenceImportFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFenceImportFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkFenceImportFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* handle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handle\",\n");
    if (pstruct->handle == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.handle /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.handle); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const wchar_t* name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const wchar_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    if (pstruct->name == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.name.GetAddress() /* QZR */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        WideStringToQuotedStringJson(outputFile, pstruct->name); // PXQ
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportFenceWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportFenceWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const SECURITY_ATTRIBUTES*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttributes\",\n");
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttributes->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputScalarValueStructInfo vinfo_pAttributes = {false, false, false, nullptr};
        OutputScalarValueJson(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PXT
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dwAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dwAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dwAccess); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const wchar_t* name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const wchar_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    if (pstruct->name == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.name.GetAddress() /* QZR */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        WideStringToQuotedStringJson(outputFile, pstruct->name); // PXQ
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFenceGetWin32HandleInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFenceGetWin32HandleInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFence fence
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFence"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fence\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.fence); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportFenceFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportFenceFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFence fence
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFence"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fence\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.fence); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFenceImportFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFenceImportFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkFenceImportFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int fd
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fd\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fd); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFenceGetFdInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFenceGetFdInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFence fence
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFence"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fence\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.fence); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalFenceHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalFenceHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalFenceHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSurfaceInfo2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceKHR surface
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"surface\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.surface); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilities2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceCapabilitiesKHR surfaceCapabilities
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceCapabilitiesKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"surfaceCapabilities\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.surfaceCapabilities, indent,  base_addr + offsetof(VkSurfaceCapabilities2KHR, surfaceCapabilities)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFormat2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFormat2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceFormatKHR surfaceFormat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceFormatKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"surfaceFormat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.surfaceFormat, indent,  base_addr + offsetof(VkSurfaceFormat2KHR, surfaceFormat)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayProperties2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayProperties2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayPropertiesKHR displayProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayPropertiesKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.displayProperties, indent,  base_addr + offsetof(VkDisplayProperties2KHR, displayProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneProperties2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneProperties2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayPlanePropertiesKHR displayPlaneProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayPlanePropertiesKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayPlaneProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.displayPlaneProperties, indent,  base_addr + offsetof(VkDisplayPlaneProperties2KHR, displayPlaneProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayModeProperties2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayModeProperties2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayModePropertiesKHR displayModeProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayModePropertiesKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayModeProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.displayModeProperties, indent,  base_addr + offsetof(VkDisplayModeProperties2KHR, displayModeProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneInfo2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneInfo2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayModeKHR mode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayModeKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"mode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.mode); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t planeIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"planeIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->planeIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPlaneCapabilities2KHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPlaneCapabilities2KHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayPlaneCapabilitiesKHR capabilities
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayPlaneCapabilitiesKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"capabilities\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.capabilities, indent,  base_addr + offsetof(VkDisplayPlaneCapabilities2KHR, capabilities)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageFormatListCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageFormatListCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewFormatCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewFormatCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewFormatCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkFormat* pViewFormats
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkFormat*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewFormats\",\n");
    if (pstruct->pViewFormats == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewFormats.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pViewFormats = {false, true, false, OutputEnumVkFormat};
        OutputArrayJson(outputFile, indent, "const VkFormat*", &pstruct_in.pViewFormats, "pViewFormats", pstruct->viewFormatCount, vinfo_pViewFormats); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSubgroupExtendedTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSubgroupExtendedTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSubgroupExtendedTypes); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevice8BitStorageFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevice8BitStorageFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 storageBuffer8BitAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storageBuffer8BitAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->storageBuffer8BitAccess); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 uniformAndStorageBuffer8BitAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"uniformAndStorageBuffer8BitAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->uniformAndStorageBuffer8BitAccess); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 storagePushConstant8
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storagePushConstant8\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->storagePushConstant8); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderBufferInt64Atomics
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderBufferInt64Atomics\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderBufferInt64Atomics); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSharedInt64Atomics
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSharedInt64Atomics\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSharedInt64Atomics); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderClockFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSubgroupClock
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSubgroupClock\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSubgroupClock); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDeviceClock
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDeviceClock\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDeviceClock); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkConformanceVersionKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkConformanceVersionKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint8_t major
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"major\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->major); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint8_t minor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint8_t subminor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subminor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subminor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint8_t patch
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint8_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"patch\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->patch); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDriverPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDriverPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDriverIdKHR driverID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDriverIdKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"driverID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDriverIdKHR(outputFile, pstruct->driverID); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char driverName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DRIVER_NAME_SIZE_KHR"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"driverName\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_driverName = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.driverName.GetPointer(), "driverName", VK_MAX_DRIVER_NAME_SIZE_KHR, vinfo_driverName); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char driverInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DRIVER_INFO_SIZE_KHR"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"driverInfo\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_driverInfo = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.driverInfo.GetPointer(), "driverInfo", VK_MAX_DRIVER_INFO_SIZE_KHR, vinfo_driverInfo); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkConformanceVersionKHR conformanceVersion
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkConformanceVersionKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"conformanceVersion\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.conformanceVersion, indent,  base_addr + offsetof(VkPhysicalDeviceDriverPropertiesKHR, conformanceVersion)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFloatControlsPropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFloatControlsPropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderFloatControlsIndependenceKHR denormBehaviorIndependence
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderFloatControlsIndependenceKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"denormBehaviorIndependence\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkShaderFloatControlsIndependenceKHR(outputFile, pstruct->denormBehaviorIndependence); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderFloatControlsIndependenceKHR roundingModeIndependence
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderFloatControlsIndependenceKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"roundingModeIndependence\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkShaderFloatControlsIndependenceKHR(outputFile, pstruct->roundingModeIndependence); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSignedZeroInfNanPreserveFloat16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSignedZeroInfNanPreserveFloat16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSignedZeroInfNanPreserveFloat16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSignedZeroInfNanPreserveFloat32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSignedZeroInfNanPreserveFloat32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSignedZeroInfNanPreserveFloat32); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSignedZeroInfNanPreserveFloat64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSignedZeroInfNanPreserveFloat64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSignedZeroInfNanPreserveFloat64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDenormPreserveFloat16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDenormPreserveFloat16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDenormPreserveFloat16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDenormPreserveFloat32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDenormPreserveFloat32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDenormPreserveFloat32); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDenormPreserveFloat64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDenormPreserveFloat64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDenormPreserveFloat64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDenormFlushToZeroFloat16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDenormFlushToZeroFloat16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDenormFlushToZeroFloat16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDenormFlushToZeroFloat32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDenormFlushToZeroFloat32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDenormFlushToZeroFloat32); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDenormFlushToZeroFloat64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDenormFlushToZeroFloat64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDenormFlushToZeroFloat64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderRoundingModeRTEFloat16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderRoundingModeRTEFloat16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderRoundingModeRTEFloat16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderRoundingModeRTEFloat32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderRoundingModeRTEFloat32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderRoundingModeRTEFloat32); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderRoundingModeRTEFloat64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderRoundingModeRTEFloat64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderRoundingModeRTEFloat64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderRoundingModeRTZFloat16
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderRoundingModeRTZFloat16\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderRoundingModeRTZFloat16); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderRoundingModeRTZFloat32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderRoundingModeRTZFloat32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderRoundingModeRTZFloat32); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderRoundingModeRTZFloat64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderRoundingModeRTZFloat64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderRoundingModeRTZFloat64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassDescriptionDepthStencilResolveKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassDescriptionDepthStencilResolveKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkResolveModeFlagBitsKHR depthResolveMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkResolveModeFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthResolveMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->depthResolveMode, OutputEnumVkResolveModeFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkResolveModeFlagBitsKHR stencilResolveMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkResolveModeFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencilResolveMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stencilResolveMode, OutputEnumVkResolveModeFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentReference2KHR* pDepthStencilResolveAttachment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentReference2KHR*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDepthStencilResolveAttachment\",\n");
    if (pstruct->pDepthStencilResolveAttachment == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDepthStencilResolveAttachment->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pDepthStencilResolveAttachment->GetMetaStructPointer(), indent,  base_addr + offsetof(VkSubpassDescriptionDepthStencilResolveKHR, pDepthStencilResolveAttachment)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthStencilResolvePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDepthStencilResolvePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkResolveModeFlagsKHR supportedDepthResolveModes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkResolveModeFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedDepthResolveModes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedDepthResolveModes, OutputEnumVkResolveModeFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkResolveModeFlagsKHR supportedStencilResolveModes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkResolveModeFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedStencilResolveModes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedStencilResolveModes, OutputEnumVkResolveModeFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 independentResolveNone
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"independentResolveNone\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->independentResolveNone); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 independentResolve
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"independentResolve\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->independentResolve); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 timelineSemaphore
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"timelineSemaphore\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->timelineSemaphore); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTimelineSemaphorePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTimelineSemaphorePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t maxTimelineSemaphoreValueDifference
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTimelineSemaphoreValueDifference\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTimelineSemaphoreValueDifference); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreTypeCreateInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreTypeCreateInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphoreTypeKHR semaphoreType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphoreTypeKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphoreType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSemaphoreTypeKHR(outputFile, pstruct->semaphoreType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t initialValue
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"initialValue\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->initialValue); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkTimelineSemaphoreSubmitInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkTimelineSemaphoreSubmitInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t waitSemaphoreValueCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"waitSemaphoreValueCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->waitSemaphoreValueCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pWaitSemaphoreValues
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pWaitSemaphoreValues\",\n");
    if (pstruct->pWaitSemaphoreValues == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pWaitSemaphoreValues.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pWaitSemaphoreValues = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pWaitSemaphoreValues, "pWaitSemaphoreValues", pstruct->waitSemaphoreValueCount, vinfo_pWaitSemaphoreValues); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t signalSemaphoreValueCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"signalSemaphoreValueCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->signalSemaphoreValueCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pSignalSemaphoreValues
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSignalSemaphoreValues\",\n");
    if (pstruct->pSignalSemaphoreValues == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSignalSemaphoreValues.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pSignalSemaphoreValues = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pSignalSemaphoreValues, "pSignalSemaphoreValues", pstruct->signalSemaphoreValueCount, vinfo_pSignalSemaphoreValues); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreWaitInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreWaitInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphoreWaitFlagsKHR flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphoreWaitFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkSemaphoreWaitFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t semaphoreCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphoreCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->semaphoreCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSemaphore* pSemaphores
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSemaphore*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSemaphores\",\n");
    if (pstruct->pSemaphores == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSemaphores.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pSemaphores = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkSemaphore*", &pstruct_in.pSemaphores, "pSemaphores", pstruct->semaphoreCount, vinfo_pSemaphores); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pValues
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pValues\",\n");
    if (pstruct->pValues == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pValues.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pValues = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pValues, "pValues", pstruct->semaphoreCount, vinfo_pValues); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSemaphoreSignalInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSemaphoreSignalInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSemaphore semaphore
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSemaphore"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"semaphore\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.semaphore); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t value
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"value\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->value); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 vulkanMemoryModel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vulkanMemoryModel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vulkanMemoryModel); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 vulkanMemoryModelDeviceScope
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vulkanMemoryModelDeviceScope\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vulkanMemoryModelDeviceScope); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 vulkanMemoryModelAvailabilityVisibilityChains
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vulkanMemoryModelAvailabilityVisibilityChains\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vulkanMemoryModelAvailabilityVisibilityChains); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceProtectedCapabilitiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceProtectedCapabilitiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 supportsProtected
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportsProtected\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->supportsProtected); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 uniformBufferStandardLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"uniformBufferStandardLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->uniformBufferStandardLayout); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 pipelineExecutableInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineExecutableInfo\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->pipelineExecutableInfo); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipeline pipeline
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipeline"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipeline\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.pipeline); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutablePropertiesKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutablePropertiesKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderStageFlags stages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stages, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DESCRIPTION_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_name = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.name.GetPointer(), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char description
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DESCRIPTION_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"description\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_description = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.description.GetPointer(), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t subgroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subgroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subgroupSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableInfoKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableInfoKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipeline pipeline
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipeline"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipeline\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.pipeline); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t executableIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"executableIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->executableIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticValueKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableStatisticValueKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkBool32 b32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"b32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->b32); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int64_t i64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"i64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->i64); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t u64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"u64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->u64); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: double f64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"double"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"f64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->f64); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableStatisticKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableStatisticKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DESCRIPTION_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_name = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.name.GetPointer(), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char description
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DESCRIPTION_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"description\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_description = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.description.GetPointer(), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineExecutableStatisticFormatKHR format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineExecutableStatisticFormatKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPipelineExecutableStatisticFormatKHR(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineExecutableStatisticValueKHR value
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineExecutableStatisticValueKHR (Union)"); // UNN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"value\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.value, indent,  base_addr + offsetof(VkPipelineExecutableStatisticKHR, value)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineExecutableInternalRepresentationKHR &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineExecutableInternalRepresentationKHR *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char name
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DESCRIPTION_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"name\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_name = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.name.GetPointer(), "name", VK_MAX_DESCRIPTION_SIZE, vinfo_name); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: char description
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"char"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_DESCRIPTION_SIZE"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"description\",\n");
    OutputIndentJson(outputFile, indent); // UTW
    OutputStringJson(outputFile, "\"value\" : "); // TRH
    OutputScalarValueStructInfo vinfo_description = {false, false, false, nullptr};
    OutputArrayOfScalarsJson(outputFile, indent, "char", pstruct_in.description.GetPointer(), "description", VK_MAX_DESCRIPTION_SIZE, vinfo_description); // TRJ
    OutputStringJson(outputFile, "\n"); // TRX
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 isText
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"isText\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->isText); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t dataSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dataSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dataSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pData\",\n");
    if (pstruct->pData == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pData.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pData = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "void*", &pstruct_in.pData, "pData", pstruct->dataSize, vinfo_pData); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugReportCallbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugReportCallbackCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDebugReportFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDebugReportFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkDebugReportFlagBitsEXT); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: PFN_vkDebugReportCallbackEXT pfnCallback
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"PFN_vkDebugReportCallbackEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pfnCallback\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnCallback)); // WRX
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pUserData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pUserData\",\n");
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pUserData /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pUserData); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationStateRasterizationOrderAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRasterizationOrderAMD rasterizationOrder
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRasterizationOrderAMD"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rasterizationOrder\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkRasterizationOrderAMD(outputFile, pstruct->rasterizationOrder); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugMarkerObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugMarkerObjectNameInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDebugReportObjectTypeEXT objectType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDebugReportObjectTypeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDebugReportObjectTypeEXT(outputFile, pstruct->objectType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t object
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"object\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->object); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pObjectName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pObjectName\",\n");
    if (pstruct->pObjectName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pObjectName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugMarkerObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugMarkerObjectTagInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDebugReportObjectTypeEXT objectType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDebugReportObjectTypeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDebugReportObjectTypeEXT(outputFile, pstruct->objectType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t object
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"object\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->object); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t tagName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tagName\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->tagName); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t tagSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tagSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->tagSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pTag
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pTag\",\n");
    if (pstruct->pTag == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pTag.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pTag = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const void*", &pstruct_in.pTag, "pTag", pstruct->tagSize, vinfo_pTag); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugMarkerMarkerInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugMarkerMarkerInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pMarkerName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pMarkerName\",\n");
    if (pstruct->pMarkerName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pMarkerName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float color
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "4"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"color\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkDebugMarkerMarkerInfoEXT, color) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_color = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "float", &pstruct_in.color, "color", 4, vinfo_color); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDedicatedAllocationImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDedicatedAllocationImageCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 dedicatedAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dedicatedAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->dedicatedAllocation); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDedicatedAllocationBufferCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDedicatedAllocationBufferCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 dedicatedAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dedicatedAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->dedicatedAllocation); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDedicatedAllocationMemoryAllocateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImage image
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImage"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"image\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.image); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 transformFeedback
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transformFeedback\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->transformFeedback); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 geometryStreams
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"geometryStreams\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->geometryStreams); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTransformFeedbackStreams
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTransformFeedbackStreams\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTransformFeedbackStreams); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTransformFeedbackBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTransformFeedbackBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTransformFeedbackBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize maxTransformFeedbackBufferSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTransformFeedbackBufferSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->maxTransformFeedbackBufferSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTransformFeedbackStreamDataSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTransformFeedbackStreamDataSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTransformFeedbackStreamDataSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTransformFeedbackBufferDataSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTransformFeedbackBufferDataSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTransformFeedbackBufferDataSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTransformFeedbackBufferDataStride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTransformFeedbackBufferDataStride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTransformFeedbackBufferDataStride); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 transformFeedbackQueries
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transformFeedbackQueries\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->transformFeedbackQueries); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 transformFeedbackStreamsLinesTriangles
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transformFeedbackStreamsLinesTriangles\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->transformFeedbackStreamsLinesTriangles); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 transformFeedbackRasterizationStreamSelect
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transformFeedbackRasterizationStreamSelect\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->transformFeedbackRasterizationStreamSelect); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 transformFeedbackDraw
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transformFeedbackDraw\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->transformFeedbackDraw); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationStateStreamCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineRasterizationStateStreamCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineRasterizationStateStreamCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t rasterizationStream
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rasterizationStream\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->rasterizationStream); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewHandleInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewHandleInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageView imageView
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageView"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageView\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.imageView); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorType descriptorType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDescriptorType(outputFile, pstruct->descriptorType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampler sampler
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampler"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampler\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.sampler); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkTextureLODGatherFormatPropertiesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkTextureLODGatherFormatPropertiesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 supportsTextureGatherLODBiasAMD
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportsTextureGatherLODBiasAMD\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->supportsTextureGatherLODBiasAMD); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderResourceUsageAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderResourceUsageAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t numUsedVgprs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"numUsedVgprs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->numUsedVgprs); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t numUsedSgprs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"numUsedSgprs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->numUsedSgprs); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t ldsSizePerLocalWorkGroup
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ldsSizePerLocalWorkGroup\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->ldsSizePerLocalWorkGroup); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t ldsUsageSizeInBytes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ldsUsageSizeInBytes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->ldsUsageSizeInBytes); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t scratchMemUsageInBytes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"scratchMemUsageInBytes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->scratchMemUsageInBytes); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderStatisticsInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderStatisticsInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkShaderStageFlags shaderStageMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStageMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->shaderStageMask, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderResourceUsageAMD resourceUsage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderResourceUsageAMD"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"resourceUsage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.resourceUsage, indent,  base_addr + offsetof(VkShaderStatisticsInfoAMD, resourceUsage)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t numPhysicalVgprs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"numPhysicalVgprs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->numPhysicalVgprs); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t numPhysicalSgprs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"numPhysicalSgprs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->numPhysicalSgprs); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t numAvailableVgprs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"numAvailableVgprs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->numAvailableVgprs); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t numAvailableSgprs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"numAvailableSgprs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->numAvailableSgprs); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t computeWorkGroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "3"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"computeWorkGroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkShaderStatisticsInfoAMD, computeWorkGroupSize) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_computeWorkGroupSize = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint32_t", &pstruct_in.computeWorkGroupSize, "computeWorkGroupSize", 3, vinfo_computeWorkGroupSize); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP &pstruct_in, int indent, uint64_t base_addr)
{
    const VkStreamDescriptorSurfaceCreateInfoGGP *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkStreamDescriptorSurfaceCreateFlagsGGP flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStreamDescriptorSurfaceCreateFlagsGGP"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t streamDescriptor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"streamDescriptor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->streamDescriptor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCornerSampledImageFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 cornerSampledImage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"cornerSampledImage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->cornerSampledImage); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalImageFormatPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalImageFormatPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkImageFormatProperties imageFormatProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageFormatProperties"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageFormatProperties\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.imageFormatProperties, indent,  base_addr + offsetof(VkExternalImageFormatPropertiesNV, imageFormatProperties)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryFeatureFlagsNV externalMemoryFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryFeatureFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalMemoryFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->externalMemoryFeatures, OutputEnumVkExternalMemoryFeatureFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"exportFromImportedHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->exportFromImportedHandleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compatibleHandleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->compatibleHandleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalMemoryImageCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalMemoryImageCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagsNV handleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryAllocateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryAllocateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagsNV handleTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleTypes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleTypes, OutputEnumVkExternalMemoryHandleTypeFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryWin32HandleInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagsNV handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* handle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handle\",\n");
    if (pstruct->handle == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.handle /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.handle); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExportMemoryWin32HandleInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExportMemoryWin32HandleInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const SECURITY_ATTRIBUTES* pAttributes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const SECURITY_ATTRIBUTES*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttributes\",\n");
    if (pstruct->pAttributes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttributes->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputScalarValueStructInfo vinfo_pAttributes = {false, false, false, nullptr};
        OutputScalarValueJson(outputFile, pstruct_in.pAttributes->GetPointer(), vinfo_pAttributes); // PXT
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dwAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dwAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dwAccess); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWin32KeyedMutexAcquireReleaseInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t acquireCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"acquireCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->acquireCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDeviceMemory* pAcquireSyncs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDeviceMemory*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAcquireSyncs\",\n");
    if (pstruct->pAcquireSyncs == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAcquireSyncs.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pAcquireSyncs = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkDeviceMemory*", &pstruct_in.pAcquireSyncs, "pAcquireSyncs", pstruct->acquireCount, vinfo_pAcquireSyncs); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pAcquireKeys
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAcquireKeys\",\n");
    if (pstruct->pAcquireKeys == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAcquireKeys.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pAcquireKeys = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pAcquireKeys, "pAcquireKeys", pstruct->acquireCount, vinfo_pAcquireKeys); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pAcquireTimeoutMilliseconds
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAcquireTimeoutMilliseconds\",\n");
    if (pstruct->pAcquireTimeoutMilliseconds == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAcquireTimeoutMilliseconds.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pAcquireTimeoutMilliseconds = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pAcquireTimeoutMilliseconds, "pAcquireTimeoutMilliseconds", pstruct->acquireCount, vinfo_pAcquireTimeoutMilliseconds); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t releaseCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"releaseCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->releaseCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDeviceMemory* pReleaseSyncs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDeviceMemory*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pReleaseSyncs\",\n");
    if (pstruct->pReleaseSyncs == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pReleaseSyncs.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pReleaseSyncs = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkDeviceMemory*", &pstruct_in.pReleaseSyncs, "pReleaseSyncs", pstruct->releaseCount, vinfo_pReleaseSyncs); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pReleaseKeys
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pReleaseKeys\",\n");
    if (pstruct->pReleaseKeys == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pReleaseKeys.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pReleaseKeys = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pReleaseKeys, "pReleaseKeys", pstruct->releaseCount, vinfo_pReleaseKeys); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkValidationFlagsEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkValidationFlagsEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t disabledValidationCheckCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"disabledValidationCheckCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->disabledValidationCheckCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkValidationCheckEXT* pDisabledValidationChecks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkValidationCheckEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDisabledValidationChecks\",\n");
    if (pstruct->pDisabledValidationChecks == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDisabledValidationChecks.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDisabledValidationChecks = {false, true, false, OutputEnumVkValidationCheckEXT};
        OutputArrayJson(outputFile, indent, "const VkValidationCheckEXT*", &pstruct_in.pDisabledValidationChecks, "pDisabledValidationChecks", pstruct->disabledValidationCheckCount, vinfo_pDisabledValidationChecks); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkViSurfaceCreateInfoNN &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViSurfaceCreateInfoNN *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkViSurfaceCreateFlagsNN flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkViSurfaceCreateFlagsNN"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* window
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"window\",\n");
    if (pstruct->window == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.window /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.window); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 textureCompressionASTC_HDR
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"textureCompressionASTC_HDR\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->textureCompressionASTC_HDR); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageViewASTCDecodeModeEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageViewASTCDecodeModeEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat decodeMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"decodeMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->decodeMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceASTCDecodeFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 decodeModeSharedExponent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"decodeModeSharedExponent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->decodeModeSharedExponent); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkConditionalRenderingBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkConditionalRenderingBeginInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkConditionalRenderingFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkConditionalRenderingFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkConditionalRenderingFlagBitsEXT); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 conditionalRendering
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"conditionalRendering\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->conditionalRendering); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 inheritedConditionalRendering
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"inheritedConditionalRendering\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->inheritedConditionalRendering); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 conditionalRenderingEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"conditionalRenderingEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->conditionalRenderingEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsFeaturesNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGeneratedCommandsFeaturesNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 computeBindingPointSupport
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"computeBindingPointSupport\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->computeBindingPointSupport); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceGeneratedCommandsLimitsNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceGeneratedCommandsLimitsNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxIndirectCommandsLayoutTokenCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxIndirectCommandsLayoutTokenCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxIndirectCommandsLayoutTokenCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxObjectEntryCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxObjectEntryCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxObjectEntryCounts); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minSequenceCountBufferOffsetAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minSequenceCountBufferOffsetAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minSequenceCountBufferOffsetAlignment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minSequenceIndexBufferOffsetAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minSequenceIndexBufferOffsetAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minSequenceIndexBufferOffsetAlignment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minCommandsTokenBufferOffsetAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minCommandsTokenBufferOffsetAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minCommandsTokenBufferOffsetAlignment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkIndirectCommandsTokenNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIndirectCommandsTokenNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkIndirectCommandsTokenTypeNVX tokenType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIndirectCommandsTokenTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tokenType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkIndirectCommandsTokenTypeNVX(outputFile, pstruct->tokenType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutTokenNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIndirectCommandsLayoutTokenNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkIndirectCommandsTokenTypeNVX tokenType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIndirectCommandsTokenTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tokenType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkIndirectCommandsTokenTypeNVX(outputFile, pstruct->tokenType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bindingUnit
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bindingUnit\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bindingUnit); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dynamicCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dynamicCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dynamicCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t divisor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"divisor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->divisor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkIndirectCommandsLayoutCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIndirectCommandsLayoutCreateInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineBindPoint pipelineBindPoint
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineBindPoint"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineBindPoint\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPipelineBindPoint(outputFile, pstruct->pipelineBindPoint); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkIndirectCommandsLayoutUsageFlagsNVX flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIndirectCommandsLayoutUsageFlagsNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkIndirectCommandsLayoutUsageFlagBitsNVX); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t tokenCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tokenCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->tokenCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkIndirectCommandsLayoutTokenNVX* pTokens
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkIndirectCommandsLayoutTokenNVX*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pTokens\",\n");
    if (pstruct->pTokens == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pTokens->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkIndirectCommandsLayoutTokenNVX", pstruct_in.pTokens->GetMetaStructPointer(), "pTokens", pstruct->tokenCount, false, pstruct_in.pTokens->GetAddress(), sizeof(VkIndirectCommandsLayoutTokenNVX)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCmdProcessCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCmdProcessCommandsInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectTableNVX objectTable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectTableNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectTable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.objectTable); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkIndirectCommandsLayoutNVX indirectCommandsLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIndirectCommandsLayoutNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indirectCommandsLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.indirectCommandsLayout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t indirectCommandsTokenCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indirectCommandsTokenCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->indirectCommandsTokenCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkIndirectCommandsTokenNVX* pIndirectCommandsTokens
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkIndirectCommandsTokenNVX*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pIndirectCommandsTokens\",\n");
    if (pstruct->pIndirectCommandsTokens == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pIndirectCommandsTokens->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkIndirectCommandsTokenNVX", pstruct_in.pIndirectCommandsTokens->GetMetaStructPointer(), "pIndirectCommandsTokens", pstruct->indirectCommandsTokenCount, false, pstruct_in.pIndirectCommandsTokens->GetAddress(), sizeof(VkIndirectCommandsTokenNVX)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSequencesCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSequencesCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSequencesCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCommandBuffer targetCommandBuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCommandBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"targetCommandBuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.targetCommandBuffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer sequencesCountBuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sequencesCountBuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.sequencesCountBuffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize sequencesCountOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sequencesCountOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sequencesCountOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer sequencesIndexBuffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sequencesIndexBuffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.sequencesIndexBuffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize sequencesIndexOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sequencesIndexOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sequencesIndexOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCmdReserveSpaceForCommandsInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCmdReserveSpaceForCommandsInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectTableNVX objectTable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectTableNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectTable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.objectTable); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkIndirectCommandsLayoutNVX indirectCommandsLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIndirectCommandsLayoutNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indirectCommandsLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.indirectCommandsLayout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSequencesCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSequencesCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSequencesCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableCreateInfoNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableCreateInfoNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t objectCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->objectCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkObjectEntryTypeNVX* pObjectEntryTypes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkObjectEntryTypeNVX*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pObjectEntryTypes\",\n");
    if (pstruct->pObjectEntryTypes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pObjectEntryTypes.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pObjectEntryTypes = {false, true, false, OutputEnumVkObjectEntryTypeNVX};
        OutputArrayJson(outputFile, indent, "const VkObjectEntryTypeNVX*", &pstruct_in.pObjectEntryTypes, "pObjectEntryTypes", pstruct->objectCount, vinfo_pObjectEntryTypes); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pObjectEntryCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pObjectEntryCounts\",\n");
    if (pstruct->pObjectEntryCounts == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pObjectEntryCounts.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pObjectEntryCounts = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pObjectEntryCounts, "pObjectEntryCounts", pstruct->objectCount, vinfo_pObjectEntryCounts); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkObjectEntryUsageFlagsNVX* pObjectEntryUsageFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkObjectEntryUsageFlagsNVX*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pObjectEntryUsageFlags\",\n");
    if (pstruct->pObjectEntryUsageFlags == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pObjectEntryUsageFlags.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pObjectEntryUsageFlags = {false, false, true, OutputEnumVkObjectEntryUsageFlagBitsNVX};
        OutputArrayJson(outputFile, indent, "const VkObjectEntryUsageFlagsNVX*", &pstruct_in.pObjectEntryUsageFlags, "pObjectEntryUsageFlags", pstruct->objectCount, vinfo_pObjectEntryUsageFlags); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxUniformBuffersPerDescriptor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxUniformBuffersPerDescriptor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxUniformBuffersPerDescriptor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxStorageBuffersPerDescriptor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxStorageBuffersPerDescriptor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxStorageBuffersPerDescriptor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxStorageImagesPerDescriptor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxStorageImagesPerDescriptor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxStorageImagesPerDescriptor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSampledImagesPerDescriptor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSampledImagesPerDescriptor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSampledImagesPerDescriptor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPipelineLayouts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPipelineLayouts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPipelineLayouts); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkObjectEntryTypeNVX type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectEntryTypeNVX(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectEntryUsageFlagsNVX flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryUsageFlagsNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkObjectEntryUsageFlagBitsNVX); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTablePipelineEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTablePipelineEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkObjectEntryTypeNVX type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectEntryTypeNVX(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectEntryUsageFlagsNVX flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryUsageFlagsNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkObjectEntryUsageFlagBitsNVX); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipeline pipeline
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipeline"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipeline\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.pipeline); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableDescriptorSetEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableDescriptorSetEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkObjectEntryTypeNVX type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectEntryTypeNVX(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectEntryUsageFlagsNVX flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryUsageFlagsNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkObjectEntryUsageFlagBitsNVX); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineLayout pipelineLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.pipelineLayout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDescriptorSet descriptorSet
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDescriptorSet"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorSet\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.descriptorSet); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableVertexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableVertexBufferEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkObjectEntryTypeNVX type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectEntryTypeNVX(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectEntryUsageFlagsNVX flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryUsageFlagsNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkObjectEntryUsageFlagBitsNVX); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTableIndexBufferEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTableIndexBufferEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkObjectEntryTypeNVX type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectEntryTypeNVX(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectEntryUsageFlagsNVX flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryUsageFlagsNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkObjectEntryUsageFlagBitsNVX); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkIndexType indexType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIndexType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indexType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkIndexType(outputFile, pstruct->indexType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkObjectTablePushConstantEntryNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkObjectTablePushConstantEntryNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkObjectEntryTypeNVX type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryTypeNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectEntryTypeNVX(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectEntryUsageFlagsNVX flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectEntryUsageFlagsNVX"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkObjectEntryUsageFlagBitsNVX); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineLayout pipelineLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.pipelineLayout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderStageFlags stageFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stageFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stageFlags, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkViewportWScalingNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViewportWScalingNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: float xcoeff
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"xcoeff\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->xcoeff); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float ycoeff
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ycoeff\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->ycoeff); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportWScalingStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 viewportWScalingEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewportWScalingEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->viewportWScalingEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewportCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewportCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewportCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkViewportWScalingNV* pViewportWScalings
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkViewportWScalingNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewportWScalings\",\n");
    if (pstruct->pViewportWScalings == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewportWScalings->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkViewportWScalingNV", pstruct_in.pViewportWScalings->GetMetaStructPointer(), "pViewportWScalings", pstruct->viewportCount, false, pstruct_in.pViewportWScalings->GetAddress(), sizeof(VkViewportWScalingNV)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilities2EXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilities2EXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minImageCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minImageCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minImageCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D currentExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"currentExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.currentExtent, indent,  base_addr + offsetof(VkSurfaceCapabilities2EXT, currentExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D minImageExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minImageExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minImageExtent, indent,  base_addr + offsetof(VkSurfaceCapabilities2EXT, minImageExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D maxImageExtent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageExtent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxImageExtent, indent,  base_addr + offsetof(VkSurfaceCapabilities2EXT, maxImageExtent)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxImageArrayLayers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxImageArrayLayers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxImageArrayLayers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceTransformFlagsKHR supportedTransforms
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceTransformFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedTransforms\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedTransforms, OutputEnumVkSurfaceTransformFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceTransformFlagBitsKHR currentTransform
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceTransformFlagBitsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"currentTransform\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->currentTransform, OutputEnumVkSurfaceTransformFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCompositeAlphaFlagsKHR supportedCompositeAlpha
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCompositeAlphaFlagsKHR"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedCompositeAlpha\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedCompositeAlpha, OutputEnumVkCompositeAlphaFlagBitsKHR); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags supportedUsageFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedUsageFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedUsageFlags, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceCounterFlagsEXT supportedSurfaceCounters
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceCounterFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"supportedSurfaceCounters\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->supportedSurfaceCounters, OutputEnumVkSurfaceCounterFlagBitsEXT); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayPowerInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayPowerInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayPowerStateEXT powerState
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayPowerStateEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"powerState\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDisplayPowerStateEXT(outputFile, pstruct->powerState); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceEventInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceEventInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceEventTypeEXT deviceEvent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceEventTypeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceEvent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDeviceEventTypeEXT(outputFile, pstruct->deviceEvent); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayEventInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayEventInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDisplayEventTypeEXT displayEvent
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDisplayEventTypeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayEvent\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDisplayEventTypeEXT(outputFile, pstruct->displayEvent); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSwapchainCounterCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSwapchainCounterCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSurfaceCounterFlagsEXT surfaceCounters
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSurfaceCounterFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"surfaceCounters\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->surfaceCounters, OutputEnumVkSurfaceCounterFlagBitsEXT); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRefreshCycleDurationGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRefreshCycleDurationGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint64_t refreshDuration
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"refreshDuration\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->refreshDuration); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPastPresentationTimingGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPastPresentationTimingGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t presentID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"presentID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->presentID); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t desiredPresentTime
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"desiredPresentTime\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->desiredPresentTime); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t actualPresentTime
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"actualPresentTime\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->actualPresentTime); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t earliestPresentTime
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"earliestPresentTime\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->earliestPresentTime); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t presentMargin
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"presentMargin\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->presentMargin); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentTimeGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentTimeGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t presentID
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"presentID\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->presentID); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t desiredPresentTime
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"desiredPresentTime\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->desiredPresentTime); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentTimesInfoGOOGLE &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentTimesInfoGOOGLE *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t swapchainCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"swapchainCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->swapchainCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPresentTimeGOOGLE* pTimes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPresentTimeGOOGLE*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pTimes\",\n");
    if (pstruct->pTimes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pTimes->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkPresentTimeGOOGLE", pstruct_in.pTimes->GetMetaStructPointer(), "pTimes", pstruct->swapchainCount, false, pstruct_in.pTimes->GetAddress(), sizeof(VkPresentTimeGOOGLE)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 perViewPositionAllComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"perViewPositionAllComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->perViewPositionAllComponents); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkViewportSwizzleNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkViewportSwizzleNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkViewportCoordinateSwizzleNV x
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkViewportCoordinateSwizzleNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"x\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkViewportCoordinateSwizzleNV(outputFile, pstruct->x); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkViewportCoordinateSwizzleNV y
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkViewportCoordinateSwizzleNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"y\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkViewportCoordinateSwizzleNV(outputFile, pstruct->y); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkViewportCoordinateSwizzleNV z
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkViewportCoordinateSwizzleNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"z\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkViewportCoordinateSwizzleNV(outputFile, pstruct->z); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkViewportCoordinateSwizzleNV w
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkViewportCoordinateSwizzleNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"w\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkViewportCoordinateSwizzleNV(outputFile, pstruct->w); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportSwizzleStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineViewportSwizzleStateCreateFlagsNV flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineViewportSwizzleStateCreateFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewportCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewportCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewportCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkViewportSwizzleNV* pViewportSwizzles
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkViewportSwizzleNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pViewportSwizzles\",\n");
    if (pstruct->pViewportSwizzles == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pViewportSwizzles->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkViewportSwizzleNV", pstruct_in.pViewportSwizzles->GetMetaStructPointer(), "pViewportSwizzles", pstruct->viewportCount, false, pstruct_in.pViewportSwizzles->GetAddress(), sizeof(VkViewportSwizzleNV)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDiscardRectangles
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDiscardRectangles\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDiscardRectangles); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineDiscardRectangleStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineDiscardRectangleStateCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineDiscardRectangleStateCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDiscardRectangleModeEXT discardRectangleMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDiscardRectangleModeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"discardRectangleMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkDiscardRectangleModeEXT(outputFile, pstruct->discardRectangleMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t discardRectangleCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"discardRectangleCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->discardRectangleCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkRect2D* pDiscardRectangles
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkRect2D*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDiscardRectangles\",\n");
    if (pstruct->pDiscardRectangles == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDiscardRectangles->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkRect2D", pstruct_in.pDiscardRectangles->GetMetaStructPointer(), "pDiscardRectangles", pstruct->discardRectangleCount, false, pstruct_in.pDiscardRectangles->GetAddress(), sizeof(VkRect2D)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float primitiveOverestimationSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"primitiveOverestimationSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->primitiveOverestimationSize); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxExtraPrimitiveOverestimationSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxExtraPrimitiveOverestimationSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxExtraPrimitiveOverestimationSize); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float extraPrimitiveOverestimationSizeGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extraPrimitiveOverestimationSizeGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->extraPrimitiveOverestimationSizeGranularity); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 primitiveUnderestimation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"primitiveUnderestimation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->primitiveUnderestimation); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 conservativePointAndLineRasterization
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"conservativePointAndLineRasterization\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->conservativePointAndLineRasterization); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 degenerateTrianglesRasterized
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"degenerateTrianglesRasterized\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->degenerateTrianglesRasterized); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 degenerateLinesRasterized
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"degenerateLinesRasterized\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->degenerateLinesRasterized); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fullyCoveredFragmentShaderInputVariable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fullyCoveredFragmentShaderInputVariable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fullyCoveredFragmentShaderInputVariable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 conservativeRasterizationPostDepthCoverage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"conservativeRasterizationPostDepthCoverage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->conservativeRasterizationPostDepthCoverage); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationConservativeStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineRasterizationConservativeStateCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineRasterizationConservativeStateCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkConservativeRasterizationModeEXT conservativeRasterizationMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkConservativeRasterizationModeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"conservativeRasterizationMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkConservativeRasterizationModeEXT(outputFile, pstruct->conservativeRasterizationMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float extraPrimitiveOverestimationSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"extraPrimitiveOverestimationSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->extraPrimitiveOverestimationSize); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthClipEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthClipEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthClipEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineRasterizationDepthClipStateCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 depthClipEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthClipEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->depthClipEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkXYColorEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkXYColorEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: float x
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"x\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->x); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float y
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"y\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->y); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkHdrMetadataEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkHdrMetadataEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkXYColorEXT displayPrimaryRed
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkXYColorEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayPrimaryRed\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.displayPrimaryRed, indent,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryRed)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkXYColorEXT displayPrimaryGreen
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkXYColorEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayPrimaryGreen\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.displayPrimaryGreen, indent,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryGreen)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkXYColorEXT displayPrimaryBlue
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkXYColorEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"displayPrimaryBlue\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.displayPrimaryBlue, indent,  base_addr + offsetof(VkHdrMetadataEXT, displayPrimaryBlue)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkXYColorEXT whitePoint
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkXYColorEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"whitePoint\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.whitePoint, indent,  base_addr + offsetof(VkHdrMetadataEXT, whitePoint)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxLuminance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxLuminance\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxLuminance); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float minLuminance
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minLuminance\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->minLuminance); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxContentLightLevel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxContentLightLevel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxContentLightLevel); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float maxFrameAverageLightLevel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFrameAverageLightLevel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->maxFrameAverageLightLevel); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkIOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr)
{
    const VkIOSSurfaceCreateInfoMVK *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkIOSSurfaceCreateFlagsMVK flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIOSSurfaceCreateFlagsMVK"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pView
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pView\",\n");
    if (pstruct->pView == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pView /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pView); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMacOSSurfaceCreateInfoMVK &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMacOSSurfaceCreateInfoMVK *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMacOSSurfaceCreateFlagsMVK flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMacOSSurfaceCreateFlagsMVK"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pView
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pView\",\n");
    if (pstruct->pView == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pView /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pView); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsObjectNameInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsObjectNameInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectType objectType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectType(outputFile, pstruct->objectType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t objectHandle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectHandle\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->objectHandle); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pObjectName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pObjectName\",\n");
    if (pstruct->pObjectName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pObjectName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsObjectTagInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsObjectTagInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkObjectType objectType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkObjectType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkObjectType(outputFile, pstruct->objectType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t objectHandle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectHandle\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->objectHandle); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t tagName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tagName\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->tagName); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t tagSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"tagSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->tagSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pTag
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pTag\",\n");
    if (pstruct->pTag == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pTag.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pTag = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const void*", &pstruct_in.pTag, "pTag", pstruct->tagSize, vinfo_pTag); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsLabelEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsLabelEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pLabelName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pLabelName\",\n");
    if (pstruct->pLabelName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pLabelName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float color
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "4"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"color\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkDebugUtilsLabelEXT, color) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_color = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "float", &pstruct_in.color, "color", 4, vinfo_color); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCallbackDataEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsMessengerCallbackDataEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDebugUtilsMessengerCallbackDataFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDebugUtilsMessengerCallbackDataFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pMessageIdName
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pMessageIdName\",\n");
    if (pstruct->pMessageIdName == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pMessageIdName); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t messageIdNumber
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"messageIdNumber\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->messageIdNumber); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* pMessage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pMessage\",\n");
    if (pstruct->pMessage == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->pMessage); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueLabelCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueLabelCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueLabelCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDebugUtilsLabelEXT* pQueueLabels
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDebugUtilsLabelEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pQueueLabels\",\n");
    if (pstruct->pQueueLabels == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pQueueLabels->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDebugUtilsLabelEXT", pstruct_in.pQueueLabels->GetMetaStructPointer(), "pQueueLabels", pstruct->queueLabelCount, false, pstruct_in.pQueueLabels->GetAddress(), sizeof(VkDebugUtilsLabelEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t cmdBufLabelCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"cmdBufLabelCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->cmdBufLabelCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDebugUtilsLabelEXT* pCmdBufLabels
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDebugUtilsLabelEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCmdBufLabels\",\n");
    if (pstruct->pCmdBufLabels == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCmdBufLabels->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDebugUtilsLabelEXT", pstruct_in.pCmdBufLabels->GetMetaStructPointer(), "pCmdBufLabels", pstruct->cmdBufLabelCount, false, pstruct_in.pCmdBufLabels->GetAddress(), sizeof(VkDebugUtilsLabelEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t objectCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"objectCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->objectCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDebugUtilsObjectNameInfoEXT* pObjects
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDebugUtilsObjectNameInfoEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pObjects\",\n");
    if (pstruct->pObjects == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pObjects->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDebugUtilsObjectNameInfoEXT", pstruct_in.pObjects->GetMetaStructPointer(), "pObjects", pstruct->objectCount, false, pstruct_in.pObjects->GetAddress(), sizeof(VkDebugUtilsObjectNameInfoEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDebugUtilsMessengerCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDebugUtilsMessengerCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDebugUtilsMessengerCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDebugUtilsMessengerCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDebugUtilsMessageSeverityFlagsEXT messageSeverity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDebugUtilsMessageSeverityFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"messageSeverity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->messageSeverity, OutputEnumVkDebugUtilsMessageSeverityFlagBitsEXT); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDebugUtilsMessageTypeFlagsEXT messageType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDebugUtilsMessageTypeFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"messageType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->messageType, OutputEnumVkDebugUtilsMessageTypeFlagBitsEXT); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"PFN_vkDebugUtilsMessengerCallbackEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pfnUserCallback\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, reinterpret_cast<uint64_t>(pstruct->pfnUserCallback)); // WRX
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pUserData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pUserData\",\n");
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pUserData /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pUserData); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidHardwareBufferUsageANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidHardwareBufferUsageANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t androidHardwareBufferUsage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"androidHardwareBufferUsage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->androidHardwareBufferUsage); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidHardwareBufferPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidHardwareBufferPropertiesANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize allocationSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"allocationSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->allocationSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryTypeBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypeBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryTypeBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAndroidHardwareBufferFormatPropertiesANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat format
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"format\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->format); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t externalFormat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalFormat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->externalFormat); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormatFeatureFlags formatFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormatFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"formatFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->formatFeatures, OutputEnumVkFormatFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentMapping samplerYcbcrConversionComponents
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentMapping"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"samplerYcbcrConversionComponents\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.samplerYcbcrConversionComponents, indent,  base_addr + offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerYcbcrModelConversion suggestedYcbcrModel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerYcbcrModelConversion"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"suggestedYcbcrModel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerYcbcrModelConversion(outputFile, pstruct->suggestedYcbcrModel); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerYcbcrRange suggestedYcbcrRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerYcbcrRange"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"suggestedYcbcrRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerYcbcrRange(outputFile, pstruct->suggestedYcbcrRange); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkChromaLocation suggestedXChromaOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkChromaLocation"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"suggestedXChromaOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkChromaLocation(outputFile, pstruct->suggestedXChromaOffset); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkChromaLocation suggestedYChromaOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkChromaLocation"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"suggestedYChromaOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkChromaLocation(outputFile, pstruct->suggestedYChromaOffset); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportAndroidHardwareBufferInfoANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: struct void* buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"struct void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    if (pstruct->buffer == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.buffer /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.buffer); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryGetAndroidHardwareBufferInfoANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkExternalFormatANDROID &pstruct_in, int indent, uint64_t base_addr)
{
    const VkExternalFormatANDROID *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t externalFormat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"externalFormat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->externalFormat); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSamplerReductionModeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSamplerReductionModeCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSamplerReductionModeEXT reductionMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSamplerReductionModeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"reductionMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSamplerReductionModeEXT(outputFile, pstruct->reductionMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 filterMinmaxSingleComponentFormats
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"filterMinmaxSingleComponentFormats\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->filterMinmaxSingleComponentFormats); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 filterMinmaxImageComponentMapping
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"filterMinmaxImageComponentMapping\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->filterMinmaxImageComponentMapping); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceInlineUniformBlockFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 inlineUniformBlock
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"inlineUniformBlock\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->inlineUniformBlock); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingInlineUniformBlockUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingInlineUniformBlockUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceInlineUniformBlockPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceInlineUniformBlockPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxInlineUniformBlockSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxInlineUniformBlockSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxInlineUniformBlockSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorInlineUniformBlocks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorInlineUniformBlocks\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorInlineUniformBlocks); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetInlineUniformBlocks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetInlineUniformBlocks\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetInlineUniformBlocks); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindInlineUniformBlocks\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindInlineUniformBlocks); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkWriteDescriptorSetInlineUniformBlockEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWriteDescriptorSetInlineUniformBlockEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t dataSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dataSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->dataSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pData\",\n");
    if (pstruct->pData == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pData.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pData = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const void*", &pstruct_in.pData, "pData", pstruct->dataSize, vinfo_pData); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorPoolInlineUniformBlockCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxInlineUniformBlockBindings
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxInlineUniformBlockBindings\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxInlineUniformBlockBindings); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSampleLocationEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSampleLocationEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: float x
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"x\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->x); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float y
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"y\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->y); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSampleLocationsInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSampleLocationsInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlagBits sampleLocationsPerPixel
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationsPerPixel\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sampleLocationsPerPixel, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D sampleLocationGridSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationGridSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.sampleLocationGridSize, indent,  base_addr + offsetof(VkSampleLocationsInfoEXT, sampleLocationGridSize)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t sampleLocationsCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationsCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->sampleLocationsCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSampleLocationEXT* pSampleLocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSampleLocationEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSampleLocations\",\n");
    if (pstruct->pSampleLocations == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSampleLocations->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSampleLocationEXT", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationsCount, false, pstruct_in.pSampleLocations->GetAddress(), sizeof(VkSampleLocationEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAttachmentSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAttachmentSampleLocationsEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t attachmentIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleLocationsInfoEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationsInfo\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.sampleLocationsInfo, indent,  base_addr + offsetof(VkAttachmentSampleLocationsEXT, sampleLocationsInfo)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSubpassSampleLocationsEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSubpassSampleLocationsEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t subpassIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subpassIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->subpassIndex); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleLocationsInfoEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationsInfo\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.sampleLocationsInfo, indent,  base_addr + offsetof(VkSubpassSampleLocationsEXT, sampleLocationsInfo)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassSampleLocationsBeginInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t attachmentInitialSampleLocationsCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"attachmentInitialSampleLocationsCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->attachmentInitialSampleLocationsCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAttachmentSampleLocationsEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAttachmentInitialSampleLocations\",\n");
    if (pstruct->pAttachmentInitialSampleLocations == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAttachmentInitialSampleLocations->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkAttachmentSampleLocationsEXT", pstruct_in.pAttachmentInitialSampleLocations->GetMetaStructPointer(), "pAttachmentInitialSampleLocations", pstruct->attachmentInitialSampleLocationsCount, false, pstruct_in.pAttachmentInitialSampleLocations->GetAddress(), sizeof(VkAttachmentSampleLocationsEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t postSubpassSampleLocationsCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"postSubpassSampleLocationsCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->postSubpassSampleLocationsCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSubpassSampleLocationsEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPostSubpassSampleLocations\",\n");
    if (pstruct->pPostSubpassSampleLocations == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPostSubpassSampleLocations->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSubpassSampleLocationsEXT", pstruct_in.pPostSubpassSampleLocations->GetMetaStructPointer(), "pPostSubpassSampleLocations", pstruct->postSubpassSampleLocationsCount, false, pstruct_in.pPostSubpassSampleLocations->GetAddress(), sizeof(VkSubpassSampleLocationsEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineSampleLocationsStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 sampleLocationsEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationsEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->sampleLocationsEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleLocationsInfoEXT sampleLocationsInfo
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleLocationsInfoEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationsInfo\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.sampleLocationsInfo, indent,  base_addr + offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSampleLocationsPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags sampleLocationSampleCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationSampleCounts\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->sampleLocationSampleCounts, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D maxSampleLocationGridSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSampleLocationGridSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxSampleLocationGridSize, indent,  base_addr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float sampleLocationCoordinateRange
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "2"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationCoordinateRange\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationCoordinateRange) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_sampleLocationCoordinateRange = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "float", &pstruct_in.sampleLocationCoordinateRange, "sampleLocationCoordinateRange", 2, vinfo_sampleLocationCoordinateRange); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t sampleLocationSubPixelBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationSubPixelBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->sampleLocationSubPixelBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 variableSampleLocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"variableSampleLocations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->variableSampleLocations); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMultisamplePropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMultisamplePropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D maxSampleLocationGridSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSampleLocationGridSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxSampleLocationGridSize, indent,  base_addr + offsetof(VkMultisamplePropertiesEXT, maxSampleLocationGridSize)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 advancedBlendCoherentOperations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"advancedBlendCoherentOperations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->advancedBlendCoherentOperations); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t advancedBlendMaxColorAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"advancedBlendMaxColorAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->advancedBlendMaxColorAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 advancedBlendIndependentBlend
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"advancedBlendIndependentBlend\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->advancedBlendIndependentBlend); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 advancedBlendNonPremultipliedSrcColor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"advancedBlendNonPremultipliedSrcColor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->advancedBlendNonPremultipliedSrcColor); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 advancedBlendNonPremultipliedDstColor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"advancedBlendNonPremultipliedDstColor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->advancedBlendNonPremultipliedDstColor); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 advancedBlendCorrelatedOverlap
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"advancedBlendCorrelatedOverlap\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->advancedBlendCorrelatedOverlap); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 advancedBlendAllOperations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"advancedBlendAllOperations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->advancedBlendAllOperations); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 srcPremultiplied
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"srcPremultiplied\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->srcPremultiplied); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 dstPremultiplied
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dstPremultiplied\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->dstPremultiplied); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBlendOverlapEXT blendOverlap
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBlendOverlapEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"blendOverlap\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkBlendOverlapEXT(outputFile, pstruct->blendOverlap); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCoverageToColorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCoverageToColorStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCoverageToColorStateCreateFlagsNV flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCoverageToColorStateCreateFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 coverageToColorEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageToColorEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->coverageToColorEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t coverageToColorLocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageToColorLocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->coverageToColorLocation); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCoverageModulationStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCoverageModulationStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCoverageModulationStateCreateFlagsNV flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCoverageModulationStateCreateFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCoverageModulationModeNV coverageModulationMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCoverageModulationModeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageModulationMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCoverageModulationModeNV(outputFile, pstruct->coverageModulationMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 coverageModulationTableEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageModulationTableEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->coverageModulationTableEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t coverageModulationTableCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageModulationTableCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->coverageModulationTableCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const float* pCoverageModulationTable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const float*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCoverageModulationTable\",\n");
    if (pstruct->pCoverageModulationTable == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCoverageModulationTable.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pCoverageModulationTable = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const float*", &pstruct_in.pCoverageModulationTable, "pCoverageModulationTable", pstruct->coverageModulationTableCount, vinfo_pCoverageModulationTable); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shaderSMCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSMCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shaderSMCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shaderWarpsPerSM
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderWarpsPerSM\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shaderWarpsPerSM); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSMBuiltins
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSMBuiltins\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSMBuiltins); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrmFormatModifierPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint64_t drmFormatModifier
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifier\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifier); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t drmFormatModifierPlaneCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifierPlaneCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifierPlaneCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormatFeatureFlags drmFormatModifierTilingFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormatFeatureFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifierTilingFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->drmFormatModifierTilingFeatures, OutputEnumVkFormatFeatureFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDrmFormatModifierPropertiesListEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrmFormatModifierPropertiesListEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t drmFormatModifierCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifierCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifierCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDrmFormatModifierPropertiesEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDrmFormatModifierProperties\",\n");
    if (pstruct->pDrmFormatModifierProperties == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDrmFormatModifierProperties->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkDrmFormatModifierPropertiesEXT", pstruct_in.pDrmFormatModifierProperties->GetMetaStructPointer(), "pDrmFormatModifierProperties", pstruct->drmFormatModifierCount, false, pstruct_in.pDrmFormatModifierProperties->GetAddress(), sizeof(VkDrmFormatModifierPropertiesEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t drmFormatModifier
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifier\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifier); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSharingMode sharingMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSharingMode"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sharingMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkSharingMode(outputFile, pstruct->sharingMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t queueFamilyIndexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"queueFamilyIndexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->queueFamilyIndexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pQueueFamilyIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pQueueFamilyIndices\",\n");
    if (pstruct->pQueueFamilyIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pQueueFamilyIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pQueueFamilyIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pQueueFamilyIndices, "pQueueFamilyIndices", pstruct->queueFamilyIndexCount, vinfo_pQueueFamilyIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageDrmFormatModifierListCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t drmFormatModifierCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifierCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifierCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint64_t* pDrmFormatModifiers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint64_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDrmFormatModifiers\",\n");
    if (pstruct->pDrmFormatModifiers == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDrmFormatModifiers.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDrmFormatModifiers = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint64_t*", &pstruct_in.pDrmFormatModifiers, "pDrmFormatModifiers", pstruct->drmFormatModifierCount, vinfo_pDrmFormatModifiers); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageDrmFormatModifierExplicitCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t drmFormatModifier
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifier\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifier); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t drmFormatModifierPlaneCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifierPlaneCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifierPlaneCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkSubresourceLayout* pPlaneLayouts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkSubresourceLayout*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPlaneLayouts\",\n");
    if (pstruct->pPlaneLayouts == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPlaneLayouts->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkSubresourceLayout", pstruct_in.pPlaneLayouts->GetMetaStructPointer(), "pPlaneLayouts", pstruct->drmFormatModifierPlaneCount, false, pstruct_in.pPlaneLayouts->GetAddress(), sizeof(VkSubresourceLayout)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageDrmFormatModifierPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageDrmFormatModifierPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t drmFormatModifier
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"drmFormatModifier\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->drmFormatModifier); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkValidationCacheCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkValidationCacheCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkValidationCacheCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: size_t initialDataSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"size_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"initialDataSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->initialDataSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pInitialData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pInitialData\",\n");
    if (pstruct->pInitialData == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pInitialData.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pInitialData = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const void*", &pstruct_in.pInitialData, "pInitialData", pstruct->initialDataSize, vinfo_pInitialData); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShaderModuleValidationCacheCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkValidationCacheEXT validationCache
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkValidationCacheEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"validationCache\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.validationCache); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t bindingCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bindingCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->bindingCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkDescriptorBindingFlagsEXT* pBindingFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkDescriptorBindingFlagsEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pBindingFlags\",\n");
    if (pstruct->pBindingFlags == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pBindingFlags.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pBindingFlags = {false, false, true, OutputEnumVkDescriptorBindingFlagBitsEXT};
        OutputArrayJson(outputFile, indent, "const VkDescriptorBindingFlagsEXT*", &pstruct_in.pBindingFlags, "pBindingFlags", pstruct->bindingCount, vinfo_pBindingFlags); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderInputAttachmentArrayDynamicIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderInputAttachmentArrayDynamicIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderInputAttachmentArrayDynamicIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderUniformTexelBufferArrayDynamicIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderUniformTexelBufferArrayDynamicIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderUniformTexelBufferArrayDynamicIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageTexelBufferArrayDynamicIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageTexelBufferArrayDynamicIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageTexelBufferArrayDynamicIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderUniformBufferArrayNonUniformIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderUniformBufferArrayNonUniformIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderUniformBufferArrayNonUniformIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSampledImageArrayNonUniformIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSampledImageArrayNonUniformIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSampledImageArrayNonUniformIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageBufferArrayNonUniformIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageBufferArrayNonUniformIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageBufferArrayNonUniformIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageImageArrayNonUniformIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageImageArrayNonUniformIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageImageArrayNonUniformIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderInputAttachmentArrayNonUniformIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderInputAttachmentArrayNonUniformIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderInputAttachmentArrayNonUniformIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderUniformTexelBufferArrayNonUniformIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderUniformTexelBufferArrayNonUniformIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageTexelBufferArrayNonUniformIndexing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageTexelBufferArrayNonUniformIndexing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingUniformBufferUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingUniformBufferUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingUniformBufferUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingSampledImageUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingSampledImageUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingSampledImageUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingStorageImageUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingStorageImageUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingStorageImageUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingStorageBufferUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingStorageBufferUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingStorageBufferUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingUniformTexelBufferUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingUniformTexelBufferUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingStorageTexelBufferUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingStorageTexelBufferUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingUpdateUnusedWhilePending
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingUpdateUnusedWhilePending\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingUpdateUnusedWhilePending); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingPartiallyBound
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingPartiallyBound\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingPartiallyBound); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 descriptorBindingVariableDescriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorBindingVariableDescriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->descriptorBindingVariableDescriptorCount); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 runtimeDescriptorArray
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"runtimeDescriptorArray\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->runtimeDescriptorArray); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDescriptorIndexingPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxUpdateAfterBindDescriptorsInAllPools
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxUpdateAfterBindDescriptorsInAllPools\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxUpdateAfterBindDescriptorsInAllPools); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderUniformBufferArrayNonUniformIndexingNative
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderUniformBufferArrayNonUniformIndexingNative\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderUniformBufferArrayNonUniformIndexingNative); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderSampledImageArrayNonUniformIndexingNative
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderSampledImageArrayNonUniformIndexingNative\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderSampledImageArrayNonUniformIndexingNative); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageBufferArrayNonUniformIndexingNative
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageBufferArrayNonUniformIndexingNative\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageBufferArrayNonUniformIndexingNative); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderStorageImageArrayNonUniformIndexingNative
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderStorageImageArrayNonUniformIndexingNative\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderStorageImageArrayNonUniformIndexingNative); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderInputAttachmentArrayNonUniformIndexingNative\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderInputAttachmentArrayNonUniformIndexingNative); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 robustBufferAccessUpdateAfterBind
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"robustBufferAccessUpdateAfterBind\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->robustBufferAccessUpdateAfterBind); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 quadDivergentImplicitLod
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"quadDivergentImplicitLod\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->quadDivergentImplicitLod); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindSamplers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUpdateAfterBindSamplers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindSamplers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUpdateAfterBindUniformBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindUniformBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUpdateAfterBindStorageBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindStorageBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUpdateAfterBindSampledImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindSampledImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUpdateAfterBindStorageImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindStorageImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageDescriptorUpdateAfterBindInputAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageDescriptorUpdateAfterBindInputAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxPerStageUpdateAfterBindResources
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxPerStageUpdateAfterBindResources\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxPerStageUpdateAfterBindResources); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindSamplers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindSamplers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindSamplers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindUniformBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindUniformBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindUniformBuffersDynamic\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindStorageBuffers\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindStorageBuffers); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindStorageBuffersDynamic\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindSampledImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindSampledImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindSampledImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindStorageImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindStorageImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindStorageImages); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetUpdateAfterBindInputAttachments
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetUpdateAfterBindInputAttachments\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetUpdateAfterBindInputAttachments); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t descriptorSetCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"descriptorSetCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->descriptorSetCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pDescriptorCounts
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDescriptorCounts\",\n");
    if (pstruct->pDescriptorCounts == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDescriptorCounts.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDescriptorCounts = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pDescriptorCounts, "pDescriptorCounts", pstruct->descriptorSetCount, vinfo_pDescriptorCounts); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVariableDescriptorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVariableDescriptorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVariableDescriptorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkShadingRatePaletteNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkShadingRatePaletteNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t shadingRatePaletteEntryCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRatePaletteEntryCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shadingRatePaletteEntryCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkShadingRatePaletteEntryNV* pShadingRatePaletteEntries
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkShadingRatePaletteEntryNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pShadingRatePaletteEntries\",\n");
    if (pstruct->pShadingRatePaletteEntries == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pShadingRatePaletteEntries.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pShadingRatePaletteEntries = {false, true, false, OutputEnumVkShadingRatePaletteEntryNV};
        OutputArrayJson(outputFile, indent, "const VkShadingRatePaletteEntryNV*", &pstruct_in.pShadingRatePaletteEntries, "pShadingRatePaletteEntries", pstruct->shadingRatePaletteEntryCount, vinfo_pShadingRatePaletteEntries); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportShadingRateImageStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shadingRateImageEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRateImageEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shadingRateImageEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t viewportCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"viewportCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->viewportCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkShadingRatePaletteNV* pShadingRatePalettes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkShadingRatePaletteNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pShadingRatePalettes\",\n");
    if (pstruct->pShadingRatePalettes == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pShadingRatePalettes->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkShadingRatePaletteNV", pstruct_in.pShadingRatePalettes->GetMetaStructPointer(), "pShadingRatePalettes", pstruct->viewportCount, false, pstruct_in.pShadingRatePalettes->GetAddress(), sizeof(VkShadingRatePaletteNV)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShadingRateImageFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shadingRateImage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRateImage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shadingRateImage); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shadingRateCoarseSampleOrder
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRateCoarseSampleOrder\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shadingRateCoarseSampleOrder); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShadingRateImagePropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D shadingRateTexelSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRateTexelSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.shadingRateTexelSize, indent,  base_addr + offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shadingRatePaletteSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRatePaletteSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shadingRatePaletteSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shadingRateMaxCoarseSamples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRateMaxCoarseSamples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shadingRateMaxCoarseSamples); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCoarseSampleLocationNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCoarseSampleLocationNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t pixelX
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pixelX\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pixelX); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t pixelY
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pixelY\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pixelY); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t sample
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sample\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->sample); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCoarseSampleOrderCustomNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCoarseSampleOrderCustomNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkShadingRatePaletteEntryNV shadingRate
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShadingRatePaletteEntryNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shadingRate\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkShadingRatePaletteEntryNV(outputFile, pstruct->shadingRate); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t sampleCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->sampleCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t sampleLocationCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleLocationCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->sampleLocationCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkCoarseSampleLocationNV* pSampleLocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkCoarseSampleLocationNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pSampleLocations\",\n");
    if (pstruct->pSampleLocations == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pSampleLocations->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkCoarseSampleLocationNV", pstruct_in.pSampleLocations->GetMetaStructPointer(), "pSampleLocations", pstruct->sampleLocationCount, false, pstruct_in.pSampleLocations->GetAddress(), sizeof(VkCoarseSampleLocationNV)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCoarseSampleOrderTypeNV sampleOrderType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCoarseSampleOrderTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sampleOrderType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCoarseSampleOrderTypeNV(outputFile, pstruct->sampleOrderType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t customSampleOrderCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"customSampleOrderCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->customSampleOrderCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkCoarseSampleOrderCustomNV* pCustomSampleOrders
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkCoarseSampleOrderCustomNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCustomSampleOrders\",\n");
    if (pstruct->pCustomSampleOrders == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCustomSampleOrders->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkCoarseSampleOrderCustomNV", pstruct_in.pCustomSampleOrders->GetMetaStructPointer(), "pCustomSampleOrders", pstruct->customSampleOrderCount, false, pstruct_in.pCustomSampleOrders->GetAddress(), sizeof(VkCoarseSampleOrderCustomNV)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRayTracingShaderGroupCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRayTracingShaderGroupCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkRayTracingShaderGroupTypeNV type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkRayTracingShaderGroupTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkRayTracingShaderGroupTypeNV(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t generalShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"generalShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->generalShader); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t closestHitShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"closestHitShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->closestHitShader); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t anyHitShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"anyHitShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->anyHitShader); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t intersectionShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"intersectionShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->intersectionShader); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRayTracingPipelineCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRayTracingPipelineCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCreateFlags flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCreateFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkPipelineCreateFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t stageCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stageCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->stageCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkPipelineShaderStageCreateInfo* pStages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkPipelineShaderStageCreateInfo*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pStages\",\n");
    if (pstruct->pStages == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pStages->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkPipelineShaderStageCreateInfo", pstruct_in.pStages->GetMetaStructPointer(), "pStages", pstruct->stageCount, false, pstruct_in.pStages->GetAddress(), sizeof(VkPipelineShaderStageCreateInfo)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t groupCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"groupCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->groupCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkRayTracingShaderGroupCreateInfoNV* pGroups
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkRayTracingShaderGroupCreateInfoNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pGroups\",\n");
    if (pstruct->pGroups == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pGroups->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkRayTracingShaderGroupCreateInfoNV", pstruct_in.pGroups->GetMetaStructPointer(), "pGroups", pstruct->groupCount, false, pstruct_in.pGroups->GetAddress(), sizeof(VkRayTracingShaderGroupCreateInfoNV)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxRecursionDepth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxRecursionDepth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxRecursionDepth); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineLayout layout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineLayout"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"layout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.layout); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipeline basePipelineHandle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipeline"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"basePipelineHandle\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.basePipelineHandle); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: int32_t basePipelineIndex
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"int32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"basePipelineIndex\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->basePipelineIndex); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryTrianglesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryTrianglesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer vertexData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexData\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.vertexData); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize vertexOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vertexOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t vertexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vertexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize vertexStride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexStride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vertexStride); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFormat vertexFormat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFormat"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexFormat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFormat(outputFile, pstruct->vertexFormat); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer indexData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indexData\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.indexData); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize indexOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indexOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->indexOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t indexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->indexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkIndexType indexType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkIndexType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indexType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkIndexType(outputFile, pstruct->indexType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer transformData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transformData\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.transformData); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize transformOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"transformOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->transformOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryAABBNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryAABBNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer aabbData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aabbData\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.aabbData); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t numAABBs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"numAABBs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->numAABBs); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t stride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->stride); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize offset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"offset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->offset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryDataNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryDataNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkGeometryTrianglesNV triangles
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkGeometryTrianglesNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"triangles\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.triangles, indent,  base_addr + offsetof(VkGeometryDataNV, triangles)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkGeometryAABBNV aabbs
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkGeometryAABBNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"aabbs\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.aabbs, indent,  base_addr + offsetof(VkGeometryDataNV, aabbs)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkGeometryNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkGeometryNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkGeometryTypeNV geometryType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkGeometryTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"geometryType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkGeometryTypeNV(outputFile, pstruct->geometryType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkGeometryDataNV geometry
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkGeometryDataNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"geometry\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.geometry, indent,  base_addr + offsetof(VkGeometryNV, geometry)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkGeometryFlagsNV flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkGeometryFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkGeometryFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAccelerationStructureInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAccelerationStructureInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccelerationStructureTypeNV type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccelerationStructureTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAccelerationStructureTypeNV(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuildAccelerationStructureFlagsNV flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuildAccelerationStructureFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkBuildAccelerationStructureFlagBitsNV); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t instanceCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"instanceCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->instanceCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t geometryCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"geometryCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->geometryCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkGeometryNV* pGeometries
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkGeometryNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pGeometries\",\n");
    if (pstruct->pGeometries == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pGeometries->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkGeometryNV", pstruct_in.pGeometries->GetMetaStructPointer(), "pGeometries", pstruct->geometryCount, false, pstruct_in.pGeometries->GetAddress(), sizeof(VkGeometryNV)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAccelerationStructureCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAccelerationStructureCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize compactedSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compactedSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->compactedSize); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccelerationStructureInfoNV info
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccelerationStructureInfoNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"info\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.info, indent,  base_addr + offsetof(VkAccelerationStructureCreateInfoNV, info)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBindAccelerationStructureMemoryInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBindAccelerationStructureMemoryInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccelerationStructureNV accelerationStructure
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccelerationStructureNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"accelerationStructure\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.accelerationStructure); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceMemory memory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceMemory"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.memory); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize memoryOffset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryOffset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->memoryOffset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t deviceIndexCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceIndexCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceIndexCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const uint32_t* pDeviceIndices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const uint32_t*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDeviceIndices\",\n");
    if (pstruct->pDeviceIndices == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDeviceIndices.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDeviceIndices = {false, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const uint32_t*", &pstruct_in.pDeviceIndices, "pDeviceIndices", pstruct->deviceIndexCount, vinfo_pDeviceIndices); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkWriteDescriptorSetAccelerationStructureNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkWriteDescriptorSetAccelerationStructureNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t accelerationStructureCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"accelerationStructureCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->accelerationStructureCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkAccelerationStructureNV* pAccelerationStructures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkAccelerationStructureNV*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pAccelerationStructures\",\n");
    if (pstruct->pAccelerationStructures == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pAccelerationStructures.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRI
        OutputScalarValueStructInfo vinfo_pAccelerationStructures = {true, false, false, nullptr};
        OutputArrayJson(outputFile, indent, "const VkAccelerationStructureNV*", &pstruct_in.pAccelerationStructures, "pAccelerationStructures", pstruct->accelerationStructureCount, vinfo_pAccelerationStructures); // AQA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkAccelerationStructureMemoryRequirementsInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccelerationStructureMemoryRequirementsTypeNV type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccelerationStructureMemoryRequirementsTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkAccelerationStructureMemoryRequirementsTypeNV(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAccelerationStructureNV accelerationStructure
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAccelerationStructureNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"accelerationStructure\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.accelerationStructure); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceRayTracingPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shaderGroupHandleSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderGroupHandleSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shaderGroupHandleSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxRecursionDepth
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxRecursionDepth\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxRecursionDepth); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxShaderGroupStride
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxShaderGroupStride\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxShaderGroupStride); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shaderGroupBaseAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderGroupBaseAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shaderGroupBaseAlignment); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t maxGeometryCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxGeometryCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxGeometryCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t maxInstanceCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxInstanceCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxInstanceCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t maxTriangleCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTriangleCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTriangleCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDescriptorSetAccelerationStructures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDescriptorSetAccelerationStructures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDescriptorSetAccelerationStructures); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 representativeFragmentTest
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"representativeFragmentTest\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->representativeFragmentTest); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 representativeFragmentTestEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"representativeFragmentTestEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->representativeFragmentTestEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceImageViewImageFormatInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageViewType imageViewType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageViewType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageViewType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkImageViewType(outputFile, pstruct->imageViewType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFilterCubicImageViewImageFormatPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 filterCubic
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"filterCubic\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->filterCubic); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 filterCubicMinmax
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"filterCubicMinmax\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->filterCubicMinmax); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceQueueGlobalPriorityCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceQueueGlobalPriorityCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueueGlobalPriorityEXT globalPriority
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueueGlobalPriorityEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"globalPriority\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkQueueGlobalPriorityEXT(outputFile, pstruct->globalPriority); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImportMemoryHostPointerInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImportMemoryHostPointerInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExternalMemoryHandleTypeFlagBits handleType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExternalMemoryHandleTypeFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"handleType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->handleType, OutputEnumVkExternalMemoryHandleTypeFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pHostPointer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pHostPointer\",\n");
    if (pstruct->pHostPointer == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pHostPointer /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pHostPointer); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryHostPointerPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryHostPointerPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t memoryTypeBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryTypeBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->memoryTypeBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize minImportedHostPointerAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minImportedHostPointerAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->minImportedHostPointerAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCompilerControlCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCompilerControlCreateInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCompilerControlFlagsAMD compilerControlFlags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCompilerControlFlagsAMD"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"compilerControlFlags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->compilerControlFlags, OutputEnumVkPipelineCompilerControlFlagBitsAMD); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCalibratedTimestampInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCalibratedTimestampInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkTimeDomainEXT timeDomain
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkTimeDomainEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"timeDomain\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkTimeDomainEXT(outputFile, pstruct->timeDomain); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderCorePropertiesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shaderEngineCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderEngineCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shaderEngineCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t shaderArraysPerEngineCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderArraysPerEngineCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->shaderArraysPerEngineCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t computeUnitsPerShaderArray
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"computeUnitsPerShaderArray\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->computeUnitsPerShaderArray); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t simdPerComputeUnit
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"simdPerComputeUnit\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->simdPerComputeUnit); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t wavefrontsPerSimd
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"wavefrontsPerSimd\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->wavefrontsPerSimd); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t wavefrontSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"wavefrontSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->wavefrontSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t sgprsPerSimd
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sgprsPerSimd\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->sgprsPerSimd); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minSgprAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minSgprAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minSgprAllocation); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSgprAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSgprAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSgprAllocation); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t sgprAllocationGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sgprAllocationGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->sgprAllocationGranularity); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t vgprsPerSimd
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vgprsPerSimd\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vgprsPerSimd); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minVgprAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minVgprAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minVgprAllocation); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVgprAllocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVgprAllocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVgprAllocation); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t vgprAllocationGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vgprAllocationGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vgprAllocationGranularity); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDeviceMemoryOverallocationCreateInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMemoryOverallocationBehaviorAMD overallocationBehavior
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMemoryOverallocationBehaviorAMD"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"overallocationBehavior\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkMemoryOverallocationBehaviorAMD(outputFile, pstruct->overallocationBehavior); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxVertexAttribDivisor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxVertexAttribDivisor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxVertexAttribDivisor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkVertexInputBindingDivisorDescriptionEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkVertexInputBindingDivisorDescriptionEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t binding
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"binding\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->binding); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t divisor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"divisor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->divisor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineVertexInputDivisorStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineVertexInputDivisorStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t vertexBindingDivisorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexBindingDivisorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->vertexBindingDivisorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkVertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkVertexInputBindingDivisorDescriptionEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pVertexBindingDivisors\",\n");
    if (pstruct->pVertexBindingDivisors == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pVertexBindingDivisors->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkVertexInputBindingDivisorDescriptionEXT", pstruct_in.pVertexBindingDivisors->GetMetaStructPointer(), "pVertexBindingDivisors", pstruct->vertexBindingDivisorCount, false, pstruct_in.pVertexBindingDivisors->GetAddress(), sizeof(VkVertexInputBindingDivisorDescriptionEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 vertexAttributeInstanceRateDivisor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexAttributeInstanceRateDivisor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vertexAttributeInstanceRateDivisor); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 vertexAttributeInstanceRateZeroDivisor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"vertexAttributeInstanceRateZeroDivisor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->vertexAttributeInstanceRateZeroDivisor); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPresentFrameTokenGGP &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPresentFrameTokenGGP *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t frameToken
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"frameToken\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->frameToken); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCreationFeedbackEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkPipelineCreationFeedbackFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCreationFeedbackFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->flags, OutputEnumVkPipelineCreationFeedbackFlagBitsEXT); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t duration
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"duration\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->duration); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCreationFeedbackCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCreationFeedbackCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCreationFeedbackEXT* pPipelineCreationFeedback
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCreationFeedbackEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPipelineCreationFeedback\",\n");
    if (pstruct->pPipelineCreationFeedback == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPipelineCreationFeedback->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"members\" :\n");
        OutputStructureJson(outputFile, *pstruct_in.pPipelineCreationFeedback->GetMetaStructPointer(), indent,  base_addr + offsetof(VkPipelineCreationFeedbackCreateInfoEXT, pPipelineCreationFeedback)); // GLY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t pipelineStageCreationFeedbackCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pipelineStageCreationFeedbackCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pipelineStageCreationFeedbackCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCreationFeedbackEXT* pPipelineStageCreationFeedbacks
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCreationFeedbackEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pPipelineStageCreationFeedbacks\",\n");
    if (pstruct->pPipelineStageCreationFeedbacks == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pPipelineStageCreationFeedbacks->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkPipelineCreationFeedbackEXT", pstruct_in.pPipelineStageCreationFeedbacks->GetMetaStructPointer(), "pPipelineStageCreationFeedbacks", pstruct->pipelineStageCreationFeedbackCount, false, pstruct_in.pPipelineStageCreationFeedbacks->GetAddress(), sizeof(VkPipelineCreationFeedbackEXT)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 computeDerivativeGroupQuads
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"computeDerivativeGroupQuads\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->computeDerivativeGroupQuads); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 computeDerivativeGroupLinear
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"computeDerivativeGroupLinear\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->computeDerivativeGroupLinear); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMeshShaderFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 taskShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"taskShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->taskShader); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 meshShader
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"meshShader\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->meshShader); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMeshShaderPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxDrawMeshTasksCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxDrawMeshTasksCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxDrawMeshTasksCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTaskWorkGroupInvocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTaskWorkGroupInvocations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTaskWorkGroupInvocations); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTaskWorkGroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "3"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTaskWorkGroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupSize) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_maxTaskWorkGroupSize = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint32_t", &pstruct_in.maxTaskWorkGroupSize, "maxTaskWorkGroupSize", 3, vinfo_maxTaskWorkGroupSize); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTaskTotalMemorySize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTaskTotalMemorySize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTaskTotalMemorySize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxTaskOutputCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxTaskOutputCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxTaskOutputCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMeshWorkGroupInvocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMeshWorkGroupInvocations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMeshWorkGroupInvocations); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMeshWorkGroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "3"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMeshWorkGroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupSize) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_maxMeshWorkGroupSize = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "uint32_t", &pstruct_in.maxMeshWorkGroupSize, "maxMeshWorkGroupSize", 3, vinfo_maxMeshWorkGroupSize); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMeshTotalMemorySize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMeshTotalMemorySize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMeshTotalMemorySize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMeshOutputVertices
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMeshOutputVertices\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMeshOutputVertices); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMeshOutputPrimitives
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMeshOutputPrimitives\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMeshOutputPrimitives); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxMeshMultiviewViewCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxMeshMultiviewViewCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxMeshMultiviewViewCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t meshOutputPerVertexGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"meshOutputPerVertexGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->meshOutputPerVertexGranularity); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t meshOutputPerPrimitiveGranularity
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"meshOutputPerPrimitiveGranularity\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->meshOutputPerPrimitiveGranularity); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDrawMeshTasksIndirectCommandNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDrawMeshTasksIndirectCommandNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t taskCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"taskCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->taskCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t firstTask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"firstTask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->firstTask); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentShaderBarycentric
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentShaderBarycentric\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentShaderBarycentric); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 imageFootprint
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imageFootprint\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->imageFootprint); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t exclusiveScissorCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"exclusiveScissorCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->exclusiveScissorCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkRect2D* pExclusiveScissors
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkRect2D*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pExclusiveScissors\",\n");
    if (pstruct->pExclusiveScissors == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pExclusiveScissors->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :"); // TRZ
        OutputArrayOfStructsJson(outputFile, indent, "VkRect2D", pstruct_in.pExclusiveScissors->GetMetaStructPointer(), "pExclusiveScissors", pstruct->exclusiveScissorCount, false, pstruct_in.pExclusiveScissors->GetAddress(), sizeof(VkRect2D)); // CCY
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceExclusiveScissorFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 exclusiveScissor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"exclusiveScissor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->exclusiveScissor); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkQueueFamilyCheckpointPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueueFamilyCheckpointPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineStageFlags checkpointExecutionStageMask
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"checkpointExecutionStageMask\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->checkpointExecutionStageMask, OutputEnumVkPipelineStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCheckpointDataNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCheckpointDataNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineStageFlagBits stage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineStageFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stage, OutputEnumVkPipelineStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pCheckpointMarker
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pCheckpointMarker\",\n");
    if (pstruct->pCheckpointMarker == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pCheckpointMarker /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pCheckpointMarker); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderIntegerFunctions2
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderIntegerFunctions2\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderIntegerFunctions2); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceValueDataINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceValueDataINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: uint32_t value32
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"value32\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->value32); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t value64
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"value64\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->value64); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float valueFloat
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"valueFloat\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->valueFloat); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 valueBool
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"valueBool\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->valueBool); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const char* valueString
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const char*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"valueString\",\n");
    if (pstruct->valueString == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"value\" : \"\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : ");
        StringToQuotedStringJson(outputFile, pstruct->valueString); // TLK
        OutputStringJson(outputFile, "\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceValueINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceValueINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkPerformanceValueTypeINTEL type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPerformanceValueTypeINTEL"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPerformanceValueTypeINTEL(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPerformanceValueDataINTEL data
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPerformanceValueDataINTEL (Union)"); // UNN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"data\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.data, indent,  base_addr + offsetof(VkPerformanceValueINTEL, data)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkInitializePerformanceApiInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkInitializePerformanceApiInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pUserData
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pUserData\",\n");
    if (pstruct->pUserData == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pUserData /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pUserData); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkQueryPoolCreateInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkQueryPoolCreateInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkQueryPoolSamplingModeINTEL performanceCountersSampling
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkQueryPoolSamplingModeINTEL"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"performanceCountersSampling\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkQueryPoolSamplingModeINTEL(outputFile, pstruct->performanceCountersSampling); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceMarkerInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t marker
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"marker\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->marker); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceStreamMarkerInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceStreamMarkerInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t marker
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"marker\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->marker); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceOverrideInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceOverrideInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPerformanceOverrideTypeINTEL type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPerformanceOverrideTypeINTEL"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPerformanceOverrideTypeINTEL(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 enable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"enable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->enable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint64_t parameter
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint64_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"parameter\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->parameter); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPerformanceConfigurationAcquireInfoINTEL *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPerformanceConfigurationTypeINTEL type
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPerformanceConfigurationTypeINTEL"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"type\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkPerformanceConfigurationTypeINTEL(outputFile, pstruct->type); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDevicePCIBusInfoPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t pciDomain
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pciDomain\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pciDomain); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t pciBus
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pciBus\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pciBus); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t pciDevice
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pciDevice\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pciDevice); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t pciFunction
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pciFunction\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->pciFunction); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 localDimmingSupport
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"localDimmingSupport\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->localDimmingSupport); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSwapchainDisplayNativeHdrCreateInfoAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 localDimmingEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"localDimmingEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->localDimmingEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImagePipeSurfaceCreateInfoFUCHSIA *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImagePipeSurfaceCreateFlagsFUCHSIA flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImagePipeSurfaceCreateFlagsFUCHSIA"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t imagePipeHandle
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"imagePipeHandle\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->imagePipeHandle); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMetalSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMetalSurfaceCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkMetalSurfaceCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkMetalSurfaceCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pLayer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pLayer\",\n");
    if (pstruct->pLayer == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pLayer /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.pLayer); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentDensityMap
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentDensityMap\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentDensityMap); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentDensityMapDynamic
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentDensityMapDynamic\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentDensityMapDynamic); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentDensityMapNonSubsampledImages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentDensityMapNonSubsampledImages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentDensityMapNonSubsampledImages); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D minFragmentDensityTexelSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minFragmentDensityTexelSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.minFragmentDensityTexelSize, indent,  base_addr + offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, minFragmentDensityTexelSize)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkExtent2D maxFragmentDensityTexelSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkExtent2D"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxFragmentDensityTexelSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.maxFragmentDensityTexelSize, indent,  base_addr + offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, maxFragmentDensityTexelSize)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentDensityInvocations
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentDensityInvocations\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentDensityInvocations); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkRenderPassFragmentDensityMapCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkAttachmentReference fragmentDensityMapAttachment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkAttachmentReference"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentDensityMapAttachment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"members\" :\n");
    OutputStructureJson(outputFile, *pstruct_in.fragmentDensityMapAttachment, indent,  base_addr + offsetof(VkRenderPassFragmentDensityMapCreateInfoEXT, fragmentDensityMapAttachment)); // APJ
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 scalarBlockLayout
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"scalarBlockLayout\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->scalarBlockLayout); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 subgroupSizeControl
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"subgroupSizeControl\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->subgroupSizeControl); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 computeFullSubgroups
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"computeFullSubgroups\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->computeFullSubgroups); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t minSubgroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"minSubgroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->minSubgroupSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxSubgroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxSubgroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxSubgroupSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t maxComputeWorkgroupSubgroups
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"maxComputeWorkgroupSubgroups\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->maxComputeWorkgroupSubgroups); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderStageFlags requiredSubgroupSizeStages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"requiredSubgroupSizeStages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->requiredSubgroupSizeStages, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t requiredSubgroupSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"requiredSubgroupSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->requiredSubgroupSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderCoreProperties2AMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderCorePropertiesFlagsAMD shaderCoreFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderCorePropertiesFlagsAMD"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderCoreFeatures\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->shaderCoreFeatures, OutputEnumVkShaderCorePropertiesFlagBitsAMD); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t activeComputeUnitCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"activeComputeUnitCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->activeComputeUnitCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 deviceCoherentMemory
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceCoherentMemory\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->deviceCoherentMemory); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize heapBudget
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_MEMORY_HEAPS"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"heapBudget\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceMemoryBudgetPropertiesEXT, heapBudget) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_heapBudget = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "VkDeviceSize", &pstruct_in.heapBudget, "heapBudget", VK_MAX_MEMORY_HEAPS, vinfo_heapBudget); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize heapUsage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "[");
    OutputStringJson(outputFile, "VK_MAX_MEMORY_HEAPS"); // IAV
    OutputStringJson(outputFile, "]");
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"heapUsage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"address\" : \""); // EAC
    OutputAddrJson(outputFile, base_addr + offsetof(VkPhysicalDeviceMemoryBudgetPropertiesEXT, heapUsage) /* RKQ */ );
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"elements\" :");
    OutputScalarValueStructInfo vinfo_heapUsage = {false, false, false, nullptr};
    OutputArrayJson(outputFile, indent, "VkDeviceSize", &pstruct_in.heapUsage, "heapUsage", VK_MAX_MEMORY_HEAPS, vinfo_heapUsage); // AUA
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 memoryPriority
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"memoryPriority\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->memoryPriority); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkMemoryPriorityAllocateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkMemoryPriorityAllocateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: float priority
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"float"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"priority\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputDoubleJson(outputFile, pstruct->priority); // PEZ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 dedicatedAllocationImageAliasing
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"dedicatedAllocationImageAliasing\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->dedicatedAllocationImageAliasing); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 bufferDeviceAddress
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferDeviceAddress\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->bufferDeviceAddress); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 bufferDeviceAddressCaptureReplay
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferDeviceAddressCaptureReplay\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->bufferDeviceAddressCaptureReplay); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 bufferDeviceAddressMultiDevice
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bufferDeviceAddressMultiDevice\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->bufferDeviceAddressMultiDevice); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferDeviceAddressInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferDeviceAddressInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBuffer buffer
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBuffer"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"buffer\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputAddrJson(outputFile, pstruct_in.buffer); // PRQ
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkBufferDeviceAddressCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkBufferDeviceAddressCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceAddress deviceAddress
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceAddress"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"deviceAddress\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->deviceAddress); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkImageStencilUsageCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkImageStencilUsageCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkImageUsageFlags stencilUsage
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkImageUsageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stencilUsage\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->stencilUsage, OutputEnumVkImageUsageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkValidationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkValidationFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t enabledValidationFeatureCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"enabledValidationFeatureCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->enabledValidationFeatureCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkValidationFeatureEnableEXT* pEnabledValidationFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkValidationFeatureEnableEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pEnabledValidationFeatures\",\n");
    if (pstruct->pEnabledValidationFeatures == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pEnabledValidationFeatures.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pEnabledValidationFeatures = {false, true, false, OutputEnumVkValidationFeatureEnableEXT};
        OutputArrayJson(outputFile, indent, "const VkValidationFeatureEnableEXT*", &pstruct_in.pEnabledValidationFeatures, "pEnabledValidationFeatures", pstruct->enabledValidationFeatureCount, vinfo_pEnabledValidationFeatures); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t disabledValidationFeatureCount
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"disabledValidationFeatureCount\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->disabledValidationFeatureCount); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const VkValidationFeatureDisableEXT* pDisabledValidationFeatures
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"const VkValidationFeatureDisableEXT*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pDisabledValidationFeatures\",\n");
    if (pstruct->pDisabledValidationFeatures == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pDisabledValidationFeatures.GetAddress() /* RQB */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"elements\" :");
        OutputScalarValueStructInfo vinfo_pDisabledValidationFeatures = {false, true, false, OutputEnumVkValidationFeatureDisableEXT};
        OutputArrayJson(outputFile, indent, "const VkValidationFeatureDisableEXT*", &pstruct_in.pDisabledValidationFeatures, "pDisabledValidationFeatures", pstruct->disabledValidationFeatureCount, vinfo_pDisabledValidationFeatures); // AUA
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkCooperativeMatrixPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t MSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"MSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->MSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t NSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"NSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->NSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t KSize
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"KSize\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->KSize); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentTypeNV AType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"AType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentTypeNV(outputFile, pstruct->AType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentTypeNV BType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"BType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentTypeNV(outputFile, pstruct->BType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentTypeNV CType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"CType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentTypeNV(outputFile, pstruct->CType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkComponentTypeNV DType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkComponentTypeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"DType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkComponentTypeNV(outputFile, pstruct->DType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkScopeNV scope
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkScopeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"scope\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkScopeNV(outputFile, pstruct->scope); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 cooperativeMatrix
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"cooperativeMatrix\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->cooperativeMatrix); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 cooperativeMatrixRobustBufferAccess
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"cooperativeMatrixRobustBufferAccess\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->cooperativeMatrixRobustBufferAccess); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkShaderStageFlags cooperativeMatrixSupportedStages
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkShaderStageFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"cooperativeMatrixSupportedStages\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->cooperativeMatrixSupportedStages, OutputEnumVkShaderStageFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 coverageReductionMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageReductionMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->coverageReductionMode); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineCoverageReductionStateCreateInfoNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkPipelineCoverageReductionStateCreateFlagsNV flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkPipelineCoverageReductionStateCreateFlagsNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCoverageReductionModeNV coverageReductionMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCoverageReductionModeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageReductionMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCoverageReductionModeNV(outputFile, pstruct->coverageReductionMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkFramebufferMixedSamplesCombinationNV &pstruct_in, int indent, uint64_t base_addr)
{
    const VkFramebufferMixedSamplesCombinationNV *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkCoverageReductionModeNV coverageReductionMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkCoverageReductionModeNV"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"coverageReductionMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkCoverageReductionModeNV(outputFile, pstruct->coverageReductionMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlagBits rasterizationSamples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlagBits"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rasterizationSamples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->rasterizationSamples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags depthStencilSamples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"depthStencilSamples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->depthStencilSamples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkSampleCountFlags colorSamples
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkSampleCountFlags"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"colorSamples\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputFlagsJson(outputFile, pstruct->colorSamples, OutputEnumVkSampleCountFlagBits); // URG
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentShaderSampleInterlock
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentShaderSampleInterlock\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentShaderSampleInterlock); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentShaderPixelInterlock
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentShaderPixelInterlock\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentShaderPixelInterlock); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fragmentShaderShadingRateInterlock
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fragmentShaderShadingRateInterlock\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fragmentShaderShadingRateInterlock); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 ycbcrImageArrays
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"ycbcrImageArrays\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->ycbcrImageArrays); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFullScreenExclusiveInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkFullScreenExclusiveEXT fullScreenExclusive
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkFullScreenExclusiveEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fullScreenExclusive\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkFullScreenExclusiveEXT(outputFile, pstruct->fullScreenExclusive); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 fullScreenExclusiveSupported
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"fullScreenExclusiveSupported\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->fullScreenExclusiveSupported); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkSurfaceFullScreenExclusiveWin32InfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* hmonitor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"void*"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"hmonitor\",\n");
    if (pstruct->hmonitor == nullptr) // WWX
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.hmonitor /* ACF */ );
        OutputStringJson(outputFile, "\",\n");
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"value\" : \"");
        OutputAddrJson(outputFile, pstruct_in.hmonitor); // PXR
        OutputStringJson(outputFile, "\"\n");
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkHeadlessSurfaceCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkHeadlessSurfaceCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkHeadlessSurfaceCreateFlagsEXT flags
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkHeadlessSurfaceCreateFlagsEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"flags\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->flags); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceLineRasterizationFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 rectangularLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"rectangularLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->rectangularLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 bresenhamLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"bresenhamLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->bresenhamLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 smoothLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"smoothLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->smoothLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 stippledRectangularLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stippledRectangularLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->stippledRectangularLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 stippledBresenhamLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stippledBresenhamLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->stippledBresenhamLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 stippledSmoothLines
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stippledSmoothLines\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->stippledSmoothLines); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceLineRasterizationPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t lineSubPixelPrecisionBits
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"lineSubPixelPrecisionBits\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->lineSubPixelPrecisionBits); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPipelineRasterizationLineStateCreateInfoEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPipelineRasterizationLineStateCreateInfoEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: const void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "const void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkLineRasterizationModeEXT lineRasterizationMode
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkLineRasterizationModeEXT"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"lineRasterizationMode\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkLineRasterizationModeEXT(outputFile, pstruct->lineRasterizationMode); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 stippledLineEnable
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"stippledLineEnable\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->stippledLineEnable); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint32_t lineStippleFactor
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint32_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"lineStippleFactor\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->lineStippleFactor); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: uint16_t lineStipplePattern
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"uint16_t"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"lineStipplePattern\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputUnsignedDecimalJson(outputFile, pstruct->lineStipplePattern); // UYW
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceHostQueryResetFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceHostQueryResetFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 hostQueryReset
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"hostQueryReset\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->hostQueryReset); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 indexTypeUint8
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"indexTypeUint8\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->indexTypeUint8); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 shaderDemoteToHelperInvocation
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"shaderDemoteToHelperInvocation\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->shaderDemoteToHelperInvocation); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 texelBufferAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"texelBufferAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->texelBufferAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

void OutputStructureJson(FILE* outputFile, const Decoded_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &pstruct_in, int indent, uint64_t base_addr)
{
    const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *pstruct = pstruct_in.decoded_value; // BTB
    assert(outputFile != nullptr);
    if (pstruct == nullptr)
    {
        return;
    }
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "[\n"); // PXS
    indent++;

    // struct member: VkStructureType sType
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkStructureType"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"sType\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputEnumVkStructureType(outputFile, pstruct->sType); // ESA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: void* pNext
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \""); // NUX
    if (pstruct->pNext) { // NUM
        OutputStringJson(outputFile, sTypeToStructName[static_cast<Decoded_VkApplicationInfo*>(pstruct_in.pNext->GetMetaStructPointer())->decoded_value->sType] + "*");
    } else {
        OutputStringJson(outputFile, "void*");
    }
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"pNext\",\n");
    if (pstruct->pNext == nullptr) // WWZ
    {
        OutputIndentJson(outputFile, indent); // RGV
        OutputStringJson(outputFile, "\"address\" : \"NULL\"\n");
    }
    else
    { // JHD
        OutputIndentJson(outputFile, indent);
        OutputStringJson(outputFile, "\"address\" : \""); // EAC
        OutputAddrJson(outputFile, pstruct_in.pNext->GetAddress() /* KWO */ );
        OutputStringJson(outputFile, "\",\n");
        void *pNext_base_addr = reinterpret_cast<void *>(pstruct_in.pNext->GetAddress()); // PVX
        if (pNext_base_addr)
        {
            OutputIndentJson(outputFile, indent);
            OutputStringJson(outputFile, "\"members\" :\n");
            OutputPnextStructJson(outputFile, indent, pstruct_in.pNext->GetMetaStructPointer(), reinterpret_cast<uint64_t>(pNext_base_addr)); // PPX
        }
    } // HWR
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize storageTexelBufferOffsetAlignmentBytes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storageTexelBufferOffsetAlignmentBytes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->storageTexelBufferOffsetAlignmentBytes); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 storageTexelBufferOffsetSingleTexelAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"storageTexelBufferOffsetSingleTexelAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->storageTexelBufferOffsetSingleTexelAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkDeviceSize uniformTexelBufferOffsetAlignmentBytes
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkDeviceSize"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"uniformTexelBufferOffsetAlignmentBytes\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->uniformTexelBufferOffsetAlignmentBytes); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "},\n"); // UXT

    // struct member: VkBool32 uniformTexelBufferOffsetSingleTexelAlignment
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "{\n"); // UXR
    indent++;
    OutputIndentJson(outputFile, indent); // ESP
    OutputStringJson(outputFile, "\"type\" : \"VkBool32"); // NUN
    OutputStringJson(outputFile, "\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"name\" : \"uniformTexelBufferOffsetSingleTexelAlignment\",\n");
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "\"value\" : \"");
    OutputSignedDecimalJson(outputFile, pstruct->uniformTexelBufferOffsetSingleTexelAlignment); // EQA
    OutputStringJson(outputFile, "\"\n");
    indent--;
    OutputIndentJson(outputFile, indent); // UEW
    OutputStringJson(outputFile, "}\n"); // UXS
    indent--;
    OutputIndentJson(outputFile, indent);
    OutputStringJson(outputFile, "]\n"); // XXS
}

GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)

#endif
